const ve = {
  context: void 0,
  registry: void 0,
  effects: void 0,
  done: !1,
  getContextId() {
    return Hg(this.context.count);
  },
  getNextContextId() {
    return Hg(this.context.count++);
  }
};
function Hg(s) {
  const e = String(s), t = e.length - 1;
  return ve.context.id + (t ? String.fromCharCode(96 + t) : "") + e;
}
function ea(s) {
  ve.context = s;
}
const AP = !1, TP = (s, e) => s === e, va = Symbol("solid-proxy"), w0 = typeof Proxy == "function", $P = Symbol("solid-track"), Wl = {
  equals: TP
};
let S0 = T0;
const Ai = 1, wa = 2, k0 = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
}, yh = {};
var Se = null;
let ie = null, RP = null, Le = null, Tt = null, Pt = null, Ic = 0;
function gn(s, e) {
  const t = Le, i = Se, n = s.length === 0, r = e === void 0 ? i : e, a = n ? k0 : {
    owned: null,
    cleanups: null,
    context: r ? r.context : null,
    owner: r
  }, o = n ? s : () => s(() => St(() => qs(a)));
  Se = a, Le = null;
  try {
    return ei(o, !0);
  } finally {
    Le = t, Se = i;
  }
}
function re(s, e) {
  e = e ? Object.assign({}, Wl, e) : Wl;
  const t = {
    value: s,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, i = (n) => (typeof n == "function" && (ie && ie.running && ie.sources.has(t) ? n = n(t.tValue) : n = n(t.value)), A0(t, n));
  return [C0.bind(t), i];
}
function Yl(s, e, t) {
  const i = Bc(s, e, !0, Ai);
  Sr(i);
}
function Ae(s, e, t) {
  const i = Bc(s, e, !1, Ai);
  Sr(i);
}
function Jt(s, e, t) {
  S0 = zP;
  const i = Bc(s, e, !1, Ai), n = vn && Xn(vn);
  n && (i.suspense = n), i.user = !0, Pt ? Pt.push(i) : Sr(i);
}
function Ve(s, e, t) {
  t = t ? Object.assign({}, Wl, t) : Wl;
  const i = Bc(s, e, !0, 0);
  return i.observers = null, i.observerSlots = null, i.comparator = t.equals || void 0, Sr(i), C0.bind(i);
}
function EP(s) {
  return s && typeof s == "object" && "then" in s;
}
function P0(s, e, t) {
  let i, n, r;
  typeof e == "function" ? (i = s, n = e, r = {}) : (i = !0, n = s, r = e || {});
  let a = null, o = yh, l = null, c = !1, h = !1, u = "initialValue" in r, d = typeof i == "function" && Ve(i);
  const f = /* @__PURE__ */ new Set(), [p, g] = (r.storage || re)(r.initialValue), [m, O] = re(void 0), [x, b] = re(void 0, {
    equals: !1
  }), [v, y] = re(u ? "ready" : "unresolved");
  ve.context && (l = ve.getNextContextId(), r.ssrLoadFrom === "initial" ? o = r.initialValue : ve.load && ve.has(l) && (o = ve.load(l)));
  function w(C, P, $, R) {
    return a === C && (a = null, R !== void 0 && (u = !0), (C === o || P === o) && r.onHydrated && queueMicrotask(
      () => r.onHydrated(R, {
        value: P
      })
    ), o = yh, ie && C && c ? (ie.promises.delete(C), c = !1, ei(() => {
      ie.running = !0, S(P, $);
    }, !1)) : S(P, $)), P;
  }
  function S(C, P) {
    ei(() => {
      P === void 0 && g(() => C), y(P !== void 0 ? "errored" : u ? "ready" : "unresolved"), O(P);
      for (const $ of f.keys()) $.decrement();
      f.clear();
    }, !1);
  }
  function k() {
    const C = vn && Xn(vn), P = p(), $ = m();
    if ($ !== void 0 && !a) throw $;
    return Le && !Le.user && C && Yl(() => {
      x(), a && (C.resolved && ie && c ? ie.promises.add(a) : f.has(C) || (C.increment(), f.add(C)));
    }), P;
  }
  function A(C = !0) {
    if (C !== !1 && h) return;
    h = !1;
    const P = d ? d() : i;
    if (c = ie && ie.running, P == null || P === !1) {
      w(a, St(p));
      return;
    }
    ie && a && ie.promises.delete(a);
    const $ = o !== yh ? o : St(
      () => n(P, {
        value: p(),
        refetching: C
      })
    );
    return EP($) ? (a = $, "value" in $ ? ($.status === "success" ? w(a, $.value, void 0, P) : w(a, void 0, Ju($.value), P), $) : (h = !0, queueMicrotask(() => h = !1), ei(() => {
      y(u ? "refreshing" : "pending"), b();
    }, !1), $.then(
      (R) => w($, R, void 0, P),
      (R) => w($, void 0, Ju(R), P)
    ))) : (w(a, $, void 0, P), $);
  }
  Object.defineProperties(k, {
    state: {
      get: () => v()
    },
    error: {
      get: () => m()
    },
    loading: {
      get() {
        const C = v();
        return C === "pending" || C === "refreshing";
      }
    },
    latest: {
      get() {
        if (!u) return k();
        const C = m();
        if (C && !a) throw C;
        return p();
      }
    }
  });
  let T = Se;
  return d ? Yl(() => (T = Se, A(!1))) : A(!1), [
    k,
    {
      refetch: (C) => hp(T, () => A(C)),
      mutate: g
    }
  ];
}
function Q0(s) {
  return ei(s, !1);
}
function St(s) {
  if (Le === null) return s();
  const e = Le;
  Le = null;
  try {
    return s();
  } finally {
    Le = e;
  }
}
function ms(s, e, t) {
  const i = Array.isArray(s);
  let n, r = t && t.defer;
  return (a) => {
    let o;
    if (i) {
      o = Array(s.length);
      for (let c = 0; c < s.length; c++) o[c] = s[c]();
    } else o = s();
    if (r)
      return r = !1, a;
    const l = St(() => e(o, n, a));
    return n = o, l;
  };
}
function wr(s) {
  Jt(() => St(s));
}
function ii(s) {
  return Se === null || (Se.cleanups === null ? Se.cleanups = [s] : Se.cleanups.push(s)), s;
}
function qc() {
  return Se;
}
function hp(s, e) {
  const t = Se, i = Le;
  Se = s, Le = null;
  try {
    return ei(e, !0);
  } catch (n) {
    up(n);
  } finally {
    Se = t, Le = i;
  }
}
function XP(s) {
  if (ie && ie.running)
    return s(), ie.done;
  const e = Le, t = Se;
  return Promise.resolve().then(() => {
    Le = e, Se = t;
    let i;
    return vn && (i = ie || (ie = {
      sources: /* @__PURE__ */ new Set(),
      effects: [],
      promises: /* @__PURE__ */ new Set(),
      disposed: /* @__PURE__ */ new Set(),
      queue: /* @__PURE__ */ new Set(),
      running: !0
    }), i.done || (i.done = new Promise((n) => i.resolve = n)), i.running = !0), ei(s, !1), Le = Se = null, i ? i.done : void 0;
  });
}
const [AZ, Ug] = /* @__PURE__ */ re(!1);
function MP(s) {
  Pt.push.apply(Pt, s), s.length = 0;
}
function ao(s, e) {
  const t = Symbol("context");
  return {
    id: t,
    Provider: IP(t),
    defaultValue: s
  };
}
function Xn(s) {
  let e;
  return Se && Se.context && (e = Se.context[s.id]) !== void 0 ? e : s.defaultValue;
}
function Dc(s) {
  const e = Ve(s), t = Ve(() => ed(e()));
  return t.toArray = () => {
    const i = t();
    return Array.isArray(i) ? i : i != null ? [i] : [];
  }, t;
}
let vn;
function _P() {
  return vn || (vn = ao());
}
function C0() {
  const s = ie && ie.running;
  if (this.sources && (s ? this.tState : this.state))
    if ((s ? this.tState : this.state) === Ai) Sr(this);
    else {
      const e = Tt;
      Tt = null, ei(() => Nl(this), !1), Tt = e;
    }
  if (Le) {
    const e = this.observers ? this.observers.length : 0;
    Le.sources ? (Le.sources.push(this), Le.sourceSlots.push(e)) : (Le.sources = [this], Le.sourceSlots = [e]), this.observers ? (this.observers.push(Le), this.observerSlots.push(Le.sources.length - 1)) : (this.observers = [Le], this.observerSlots = [Le.sources.length - 1]);
  }
  return s && ie.sources.has(this) ? this.tValue : this.value;
}
function A0(s, e, t) {
  let i = ie && ie.running && ie.sources.has(s) ? s.tValue : s.value;
  if (!s.comparator || !s.comparator(i, e)) {
    if (ie) {
      const n = ie.running;
      (n || !t && ie.sources.has(s)) && (ie.sources.add(s), s.tValue = e), n || (s.value = e);
    } else s.value = e;
    s.observers && s.observers.length && ei(() => {
      for (let n = 0; n < s.observers.length; n += 1) {
        const r = s.observers[n], a = ie && ie.running;
        a && ie.disposed.has(r) || ((a ? !r.tState : !r.state) && (r.pure ? Tt.push(r) : Pt.push(r), r.observers && $0(r)), a ? r.tState = Ai : r.state = Ai);
      }
      if (Tt.length > 1e6)
        throw Tt = [], new Error();
    }, !1);
  }
  return e;
}
function Sr(s) {
  if (!s.fn) return;
  qs(s);
  const e = Ic;
  Gg(
    s,
    ie && ie.running && ie.sources.has(s) ? s.tValue : s.value,
    e
  ), ie && !ie.running && ie.sources.has(s) && queueMicrotask(() => {
    ei(() => {
      ie && (ie.running = !0), Le = Se = s, Gg(s, s.tValue, e), Le = Se = null;
    }, !1);
  });
}
function Gg(s, e, t) {
  let i;
  const n = Se, r = Le;
  Le = Se = s;
  try {
    i = s.fn(e);
  } catch (a) {
    return s.pure && (ie && ie.running ? (s.tState = Ai, s.tOwned && s.tOwned.forEach(qs), s.tOwned = void 0) : (s.state = Ai, s.owned && s.owned.forEach(qs), s.owned = null)), s.updatedAt = t + 1, up(a);
  } finally {
    Le = r, Se = n;
  }
  (!s.updatedAt || s.updatedAt <= t) && (s.updatedAt != null && "observers" in s ? A0(s, i, !0) : ie && ie.running && s.pure ? (ie.sources.add(s), s.tValue = i) : s.value = i, s.updatedAt = t);
}
function Bc(s, e, t, i = Ai, n) {
  const r = {
    fn: s,
    state: i,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: Se,
    context: Se ? Se.context : null,
    pure: t
  };
  return ie && ie.running && (r.state = 0, r.tState = i), Se === null || Se !== k0 && (ie && ie.running && Se.pure ? Se.tOwned ? Se.tOwned.push(r) : Se.tOwned = [r] : Se.owned ? Se.owned.push(r) : Se.owned = [r]), r;
}
function Zl(s) {
  const e = ie && ie.running;
  if ((e ? s.tState : s.state) === 0) return;
  if ((e ? s.tState : s.state) === wa) return Nl(s);
  if (s.suspense && St(s.suspense.inFallback)) return s.suspense.effects.push(s);
  const t = [s];
  for (; (s = s.owner) && (!s.updatedAt || s.updatedAt < Ic); ) {
    if (e && ie.disposed.has(s)) return;
    (e ? s.tState : s.state) && t.push(s);
  }
  for (let i = t.length - 1; i >= 0; i--) {
    if (s = t[i], e) {
      let n = s, r = t[i + 1];
      for (; (n = n.owner) && n !== r; )
        if (ie.disposed.has(n)) return;
    }
    if ((e ? s.tState : s.state) === Ai)
      Sr(s);
    else if ((e ? s.tState : s.state) === wa) {
      const n = Tt;
      Tt = null, ei(() => Nl(s, t[0]), !1), Tt = n;
    }
  }
}
function ei(s, e) {
  if (Tt) return s();
  let t = !1;
  e || (Tt = []), Pt ? t = !0 : Pt = [], Ic++;
  try {
    const i = s();
    return LP(t), i;
  } catch (i) {
    t || (Pt = null), Tt = null, up(i);
  }
}
function LP(s) {
  if (Tt && (T0(Tt), Tt = null), s) return;
  let e;
  if (ie) {
    if (!ie.promises.size && !ie.queue.size) {
      const i = ie.sources, n = ie.disposed;
      Pt.push.apply(Pt, ie.effects), e = ie.resolve;
      for (const r of Pt)
        "tState" in r && (r.state = r.tState), delete r.tState;
      ie = null, ei(() => {
        for (const r of n) qs(r);
        for (const r of i) {
          if (r.value = r.tValue, r.owned)
            for (let a = 0, o = r.owned.length; a < o; a++) qs(r.owned[a]);
          r.tOwned && (r.owned = r.tOwned), delete r.tValue, delete r.tOwned, r.tState = 0;
        }
        Ug(!1);
      }, !1);
    } else if (ie.running) {
      ie.running = !1, ie.effects.push.apply(ie.effects, Pt), Pt = null, Ug(!0);
      return;
    }
  }
  const t = Pt;
  Pt = null, t.length && ei(() => S0(t), !1), e && e();
}
function T0(s) {
  for (let e = 0; e < s.length; e++) Zl(s[e]);
}
function zP(s) {
  let e, t = 0;
  for (e = 0; e < s.length; e++) {
    const i = s[e];
    i.user ? s[t++] = i : Zl(i);
  }
  if (ve.context) {
    if (ve.count) {
      ve.effects || (ve.effects = []), ve.effects.push(...s.slice(0, t));
      return;
    }
    ea();
  }
  for (ve.effects && (ve.done || !ve.count) && (s = [...ve.effects, ...s], t += ve.effects.length, delete ve.effects), e = 0; e < t; e++) Zl(s[e]);
}
function Nl(s, e) {
  const t = ie && ie.running;
  t ? s.tState = 0 : s.state = 0;
  for (let i = 0; i < s.sources.length; i += 1) {
    const n = s.sources[i];
    if (n.sources) {
      const r = t ? n.tState : n.state;
      r === Ai ? n !== e && (!n.updatedAt || n.updatedAt < Ic) && Zl(n) : r === wa && Nl(n, e);
    }
  }
}
function $0(s) {
  const e = ie && ie.running;
  for (let t = 0; t < s.observers.length; t += 1) {
    const i = s.observers[t];
    (e ? !i.tState : !i.state) && (e ? i.tState = wa : i.state = wa, i.pure ? Tt.push(i) : Pt.push(i), i.observers && $0(i));
  }
}
function qs(s) {
  let e;
  if (s.sources)
    for (; s.sources.length; ) {
      const t = s.sources.pop(), i = s.sourceSlots.pop(), n = t.observers;
      if (n && n.length) {
        const r = n.pop(), a = t.observerSlots.pop();
        i < n.length && (r.sourceSlots[a] = i, n[i] = r, t.observerSlots[i] = a);
      }
    }
  if (s.tOwned) {
    for (e = s.tOwned.length - 1; e >= 0; e--) qs(s.tOwned[e]);
    delete s.tOwned;
  }
  if (ie && ie.running && s.pure)
    R0(s, !0);
  else if (s.owned) {
    for (e = s.owned.length - 1; e >= 0; e--) qs(s.owned[e]);
    s.owned = null;
  }
  if (s.cleanups) {
    for (e = s.cleanups.length - 1; e >= 0; e--) s.cleanups[e]();
    s.cleanups = null;
  }
  ie && ie.running ? s.tState = 0 : s.state = 0;
}
function R0(s, e) {
  if (e || (s.tState = 0, ie.disposed.add(s)), s.owned)
    for (let t = 0; t < s.owned.length; t++) R0(s.owned[t]);
}
function Ju(s) {
  return s instanceof Error ? s : new Error(typeof s == "string" ? s : "Unknown error", {
    cause: s
  });
}
function up(s, e = Se) {
  throw Ju(s);
}
function ed(s) {
  if (typeof s == "function" && !s.length) return ed(s());
  if (Array.isArray(s)) {
    const e = [];
    for (let t = 0; t < s.length; t++) {
      const i = ed(s[t]);
      Array.isArray(i) ? e.push.apply(e, i) : e.push(i);
    }
    return e;
  }
  return s;
}
function IP(s, e) {
  return function(i) {
    let n;
    return Ae(
      () => n = St(() => (Se.context = {
        ...Se.context,
        [s]: i.value
      }, Dc(() => i.children))),
      void 0
    ), n;
  };
}
const qP = Symbol("fallback");
function Kg(s) {
  for (let e = 0; e < s.length; e++) s[e]();
}
function DP(s, e, t = {}) {
  let i = [], n = [], r = [], a = 0, o = e.length > 1 ? [] : null;
  return ii(() => Kg(r)), () => {
    let l = s() || [], c = l.length, h, u;
    return l[$P], St(() => {
      let f, p, g, m, O, x, b, v, y;
      if (c === 0)
        a !== 0 && (Kg(r), r = [], i = [], n = [], a = 0, o && (o = [])), t.fallback && (i = [qP], n[0] = gn((w) => (r[0] = w, t.fallback())), a = 1);
      else if (a === 0) {
        for (n = new Array(c), u = 0; u < c; u++)
          i[u] = l[u], n[u] = gn(d);
        a = c;
      } else {
        for (g = new Array(c), m = new Array(c), o && (O = new Array(c)), x = 0, b = Math.min(a, c); x < b && i[x] === l[x]; x++) ;
        for (b = a - 1, v = c - 1; b >= x && v >= x && i[b] === l[v]; b--, v--)
          g[v] = n[b], m[v] = r[b], o && (O[v] = o[b]);
        for (f = /* @__PURE__ */ new Map(), p = new Array(v + 1), u = v; u >= x; u--)
          y = l[u], h = f.get(y), p[u] = h === void 0 ? -1 : h, f.set(y, u);
        for (h = x; h <= b; h++)
          y = i[h], u = f.get(y), u !== void 0 && u !== -1 ? (g[u] = n[h], m[u] = r[h], o && (O[u] = o[h]), u = p[u], f.set(y, u)) : r[h]();
        for (u = x; u < c; u++)
          u in g ? (n[u] = g[u], r[u] = m[u], o && (o[u] = O[u], o[u](u))) : n[u] = gn(d);
        n = n.slice(0, a = c), i = l.slice(0);
      }
      return n;
    });
    function d(f) {
      if (r[u] = f, o) {
        const [p, g] = re(u);
        return o[u] = g, e(l[u], p);
      }
      return e(l[u]);
    }
  };
}
function B(s, e) {
  return St(() => s(e || {}));
}
function Eo() {
  return !0;
}
const td = {
  get(s, e, t) {
    return e === va ? t : s.get(e);
  },
  has(s, e) {
    return e === va ? !0 : s.has(e);
  },
  set: Eo,
  deleteProperty: Eo,
  getOwnPropertyDescriptor(s, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return s.get(e);
      },
      set: Eo,
      deleteProperty: Eo
    };
  },
  ownKeys(s) {
    return s.keys();
  }
};
function vh(s) {
  return (s = typeof s == "function" ? s() : s) ? s : {};
}
function BP() {
  for (let s = 0, e = this.length; s < e; ++s) {
    const t = this[s]();
    if (t !== void 0) return t;
  }
}
function wn(...s) {
  let e = !1;
  for (let a = 0; a < s.length; a++) {
    const o = s[a];
    e = e || !!o && va in o, s[a] = typeof o == "function" ? (e = !0, Ve(o)) : o;
  }
  if (w0 && e)
    return new Proxy(
      {
        get(a) {
          for (let o = s.length - 1; o >= 0; o--) {
            const l = vh(s[o])[a];
            if (l !== void 0) return l;
          }
        },
        has(a) {
          for (let o = s.length - 1; o >= 0; o--)
            if (a in vh(s[o])) return !0;
          return !1;
        },
        keys() {
          const a = [];
          for (let o = 0; o < s.length; o++)
            a.push(...Object.keys(vh(s[o])));
          return [...new Set(a)];
        }
      },
      td
    );
  const t = {}, i = /* @__PURE__ */ Object.create(null);
  for (let a = s.length - 1; a >= 0; a--) {
    const o = s[a];
    if (!o) continue;
    const l = Object.getOwnPropertyNames(o);
    for (let c = l.length - 1; c >= 0; c--) {
      const h = l[c];
      if (h === "__proto__" || h === "constructor") continue;
      const u = Object.getOwnPropertyDescriptor(o, h);
      if (!i[h])
        i[h] = u.get ? {
          enumerable: !0,
          configurable: !0,
          get: BP.bind(t[h] = [u.get.bind(o)])
        } : u.value !== void 0 ? u : void 0;
      else {
        const d = t[h];
        d && (u.get ? d.push(u.get.bind(o)) : u.value !== void 0 && d.push(() => u.value));
      }
    }
  }
  const n = {}, r = Object.keys(i);
  for (let a = r.length - 1; a >= 0; a--) {
    const o = r[a], l = i[o];
    l && l.get ? Object.defineProperty(n, o, l) : n[o] = l ? l.value : void 0;
  }
  return n;
}
function dp(s, ...e) {
  if (w0 && va in s) {
    const n = new Set(e.length > 1 ? e.flat() : e[0]), r = e.map((a) => new Proxy(
      {
        get(o) {
          return a.includes(o) ? s[o] : void 0;
        },
        has(o) {
          return a.includes(o) && o in s;
        },
        keys() {
          return a.filter((o) => o in s);
        }
      },
      td
    ));
    return r.push(
      new Proxy(
        {
          get(a) {
            return n.has(a) ? void 0 : s[a];
          },
          has(a) {
            return n.has(a) ? !1 : a in s;
          },
          keys() {
            return Object.keys(s).filter((a) => !n.has(a));
          }
        },
        td
      )
    ), r;
  }
  const t = {}, i = e.map(() => ({}));
  for (const n of Object.getOwnPropertyNames(s)) {
    const r = Object.getOwnPropertyDescriptor(s, n), a = !r.get && !r.set && r.enumerable && r.writable && r.configurable;
    let o = !1, l = 0;
    for (const c of e)
      c.includes(n) && (o = !0, a ? i[l][n] = r.value : Object.defineProperty(i[l], n, r)), ++l;
    o || (a ? t[n] = r.value : Object.defineProperty(t, n, r));
  }
  return [...i, t];
}
let WP = 0;
function YP() {
  return ve.context ? ve.getNextContextId() : `cl-${WP++}`;
}
const ZP = (s) => `Stale read from <${s}>.`;
function Gi(s) {
  const e = "fallback" in s && {
    fallback: () => s.fallback
  };
  return Ve(DP(() => s.each, s.children, e || void 0));
}
function vi(s) {
  const e = s.keyed, t = Ve(() => s.when, void 0, void 0), i = e ? t : Ve(t, void 0, {
    equals: (n, r) => !n == !r
  });
  return Ve(
    () => {
      const n = i();
      if (n) {
        const r = s.children;
        return typeof r == "function" && r.length > 0 ? St(
          () => r(
            e ? n : () => {
              if (!St(i)) throw ZP("Show");
              return t();
            }
          )
        ) : r;
      }
      return s.fallback;
    },
    void 0,
    void 0
  );
}
const NP = /* @__PURE__ */ ao();
function VP(s) {
  let e = 0, t, i, n, r, a;
  const [o, l] = re(!1), c = _P(), h = {
    increment: () => {
      ++e === 1 && l(!0);
    },
    decrement: () => {
      --e === 0 && l(!1);
    },
    inFallback: o,
    effects: [],
    resolved: !1
  }, u = qc();
  if (ve.context && ve.load) {
    const p = ve.getContextId();
    let g = ve.load(p);
    if (g && (typeof g != "object" || g.status !== "success" ? n = g : ve.gather(p)), n && n !== "$$f") {
      const [m, O] = re(void 0, {
        equals: !1
      });
      r = m, n.then(
        () => {
          if (ve.done) return O();
          ve.gather(p), ea(i), O(), ea();
        },
        (x) => {
          a = x, O();
        }
      );
    }
  }
  const d = Xn(NP);
  d && (t = d.register(h.inFallback));
  let f;
  return ii(() => f && f()), B(c.Provider, {
    value: h,
    get children() {
      return Ve(() => {
        if (a) throw a;
        if (i = ve.context, r)
          return r(), r = void 0;
        i && n === "$$f" && ea();
        const p = Ve(() => s.children);
        return Ve((g) => {
          const m = h.inFallback(), { showContent: O = !0, showFallback: x = !0 } = t ? t() : {};
          if ((!m || n && n !== "$$f") && O)
            return h.resolved = !0, f && f(), f = i = n = void 0, MP(h.effects), p();
          if (x)
            return f ? g : gn((b) => (f = b, i && (ea({
              id: i.id + "F",
              count: 0
            }), i = void 0), s.fallback), u);
        });
      });
    }
  });
}
const FP = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
], jP = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "noValidate",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...FP
]), HP = /* @__PURE__ */ new Set([
  "innerHTML",
  "textContent",
  "innerText",
  "children"
]), UP = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
}), GP = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  novalidate: {
    $: "noValidate",
    FORM: 1
  },
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function KP(s, e) {
  const t = GP[s];
  return typeof t == "object" ? t[e] ? t.$ : void 0 : t;
}
const JP = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]), eQ = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
}, Yt = (s) => Ve(() => s());
function tQ(s, e, t) {
  let i = t.length, n = e.length, r = i, a = 0, o = 0, l = e[n - 1].nextSibling, c = null;
  for (; a < n || o < r; ) {
    if (e[a] === t[o]) {
      a++, o++;
      continue;
    }
    for (; e[n - 1] === t[r - 1]; )
      n--, r--;
    if (n === a) {
      const h = r < i ? o ? t[o - 1].nextSibling : t[r - o] : l;
      for (; o < r; ) s.insertBefore(t[o++], h);
    } else if (r === o)
      for (; a < n; )
        (!c || !c.has(e[a])) && e[a].remove(), a++;
    else if (e[a] === t[r - 1] && t[o] === e[n - 1]) {
      const h = e[--n].nextSibling;
      s.insertBefore(t[o++], e[a++].nextSibling), s.insertBefore(t[--r], h), e[n] = t[r];
    } else {
      if (!c) {
        c = /* @__PURE__ */ new Map();
        let u = o;
        for (; u < r; ) c.set(t[u], u++);
      }
      const h = c.get(e[a]);
      if (h != null)
        if (o < h && h < r) {
          let u = a, d = 1, f;
          for (; ++u < n && u < r && !((f = c.get(e[u])) == null || f !== h + d); )
            d++;
          if (d > h - o) {
            const p = e[a];
            for (; o < h; ) s.insertBefore(t[o++], p);
          } else s.replaceChild(t[o++], e[a++]);
        } else a++;
      else e[a++].remove();
    }
  }
}
const Jg = "_$DX_DELEGATE";
function iQ(s, e, t, i = {}) {
  let n;
  return gn((r) => {
    n = r, e === document ? s() : W(e, s(), e.firstChild ? null : void 0, t);
  }, i.owner), () => {
    n(), e.textContent = "";
  };
}
function K(s, e, t, i) {
  let n;
  const r = () => {
    const o = i ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
    return o.innerHTML = s, t ? o.content.firstChild.firstChild : i ? o.firstChild : o.content.firstChild;
  }, a = e ? () => St(() => document.importNode(n || (n = r()), !0)) : () => (n || (n = r())).cloneNode(!0);
  return a.cloneNode = a, a;
}
function _t(s, e = window.document) {
  const t = e[Jg] || (e[Jg] = /* @__PURE__ */ new Set());
  for (let i = 0, n = s.length; i < n; i++) {
    const r = s[i];
    t.has(r) || (t.add(r), e.addEventListener(r, lQ));
  }
}
function Fe(s, e, t) {
  kr(s) || (t == null ? s.removeAttribute(e) : s.setAttribute(e, t));
}
function sQ(s, e, t, i) {
  kr(s) || (i == null ? s.removeAttributeNS(e, t) : s.setAttributeNS(e, t, i));
}
function nQ(s, e, t) {
  kr(s) || (t ? s.setAttribute(e, "") : s.removeAttribute(e));
}
function Os(s, e) {
  kr(s) || (e == null ? s.removeAttribute("class") : s.className = e);
}
function Yn(s, e, t, i) {
  if (i)
    Array.isArray(t) ? (s[`$$${e}`] = t[0], s[`$$${e}Data`] = t[1]) : s[`$$${e}`] = t;
  else if (Array.isArray(t)) {
    const n = t[0];
    s.addEventListener(e, t[0] = (r) => n.call(s, t[1], r));
  } else s.addEventListener(e, t, typeof t != "function" && t);
}
function Vl(s, e, t = {}) {
  const i = Object.keys(e || {}), n = Object.keys(t);
  let r, a;
  for (r = 0, a = n.length; r < a; r++) {
    const o = n[r];
    !o || o === "undefined" || e[o] || (em(s, o, !1), delete t[o]);
  }
  for (r = 0, a = i.length; r < a; r++) {
    const o = i[r], l = !!e[o];
    !o || o === "undefined" || t[o] === l || !l || (em(s, o, !0), t[o] = l);
  }
  return t;
}
function rQ(s, e, t) {
  if (!e) return t ? Fe(s, "style") : e;
  const i = s.style;
  if (typeof e == "string") return i.cssText = e;
  typeof t == "string" && (i.cssText = t = void 0), t || (t = {}), e || (e = {});
  let n, r;
  for (r in t)
    e[r] == null && i.removeProperty(r), delete t[r];
  for (r in e)
    n = e[r], n !== t[r] && (i.setProperty(r, n), t[r] = n);
  return t;
}
function Wc(s, e = {}, t, i) {
  const n = {};
  return i || Ae(
    () => n.children = Sa(s, e.children, n.children)
  ), Ae(() => typeof e.ref == "function" && wi(e.ref, s)), Ae(() => aQ(s, e, t, !0, n, !0)), n;
}
function wi(s, e, t) {
  return St(() => s(e, t));
}
function W(s, e, t, i) {
  if (t !== void 0 && !i && (i = []), typeof e != "function") return Sa(s, e, i, t);
  Ae((n) => Sa(s, e(), n, t), i);
}
function aQ(s, e, t, i, n = {}, r = !1) {
  e || (e = {});
  for (const a in n)
    if (!(a in e)) {
      if (a === "children") continue;
      n[a] = tm(s, a, null, n[a], t, r, e);
    }
  for (const a in e) {
    if (a === "children")
      continue;
    const o = e[a];
    n[a] = tm(s, a, o, n[a], t, r, e);
  }
}
function kr(s) {
  return !!ve.context && !ve.done && (!s || s.isConnected);
}
function oQ(s) {
  return s.toLowerCase().replace(/-([a-z])/g, (e, t) => t.toUpperCase());
}
function em(s, e, t) {
  const i = e.trim().split(/\s+/);
  for (let n = 0, r = i.length; n < r; n++)
    s.classList.toggle(i[n], t);
}
function tm(s, e, t, i, n, r, a) {
  let o, l, c, h, u;
  if (e === "style") return rQ(s, t, i);
  if (e === "classList") return Vl(s, t, i);
  if (t === i) return i;
  if (e === "ref")
    r || t(s);
  else if (e.slice(0, 3) === "on:") {
    const d = e.slice(3);
    i && s.removeEventListener(d, i, typeof i != "function" && i), t && s.addEventListener(d, t, typeof t != "function" && t);
  } else if (e.slice(0, 10) === "oncapture:") {
    const d = e.slice(10);
    i && s.removeEventListener(d, i, !0), t && s.addEventListener(d, t, !0);
  } else if (e.slice(0, 2) === "on") {
    const d = e.slice(2).toLowerCase(), f = JP.has(d);
    if (!f && i) {
      const p = Array.isArray(i) ? i[0] : i;
      s.removeEventListener(d, p);
    }
    (f || t) && (Yn(s, d, t, f), f && _t([d]));
  } else if (e.slice(0, 5) === "attr:")
    Fe(s, e.slice(5), t);
  else if (e.slice(0, 5) === "bool:")
    nQ(s, e.slice(5), t);
  else if ((u = e.slice(0, 5) === "prop:") || (c = HP.has(e)) || !n && ((h = KP(e, s.tagName)) || (l = jP.has(e))) || (o = s.nodeName.includes("-") || "is" in a)) {
    if (u)
      e = e.slice(5), l = !0;
    else if (kr(s)) return t;
    e === "class" || e === "className" ? Os(s, t) : o && !l && !c ? s[oQ(e)] = t : s[h || e] = t;
  } else {
    const d = n && e.indexOf(":") > -1 && eQ[e.split(":")[0]];
    d ? sQ(s, d, e, t) : Fe(s, UP[e] || e, t);
  }
  return t;
}
function lQ(s) {
  if (ve.registry && ve.events && ve.events.find(([l, c]) => c === s))
    return;
  let e = s.target;
  const t = `$$${s.type}`, i = s.target, n = s.currentTarget, r = (l) => Object.defineProperty(s, "target", {
    configurable: !0,
    value: l
  }), a = () => {
    const l = e[t];
    if (l && !e.disabled) {
      const c = e[`${t}Data`];
      if (c !== void 0 ? l.call(e, c, s) : l.call(e, s), s.cancelBubble) return;
    }
    return e.host && typeof e.host != "string" && !e.host._$host && e.contains(s.target) && r(e.host), !0;
  }, o = () => {
    for (; a() && (e = e._$host || e.parentNode || e.host); ) ;
  };
  if (Object.defineProperty(s, "currentTarget", {
    configurable: !0,
    get() {
      return e || document;
    }
  }), ve.registry && !ve.done && (ve.done = _$HY.done = !0), s.composedPath) {
    const l = s.composedPath();
    r(l[0]);
    for (let c = 0; c < l.length - 2 && (e = l[c], !!a()); c++) {
      if (e._$host) {
        e = e._$host, o();
        break;
      }
      if (e.parentNode === n)
        break;
    }
  } else o();
  r(i);
}
function Sa(s, e, t, i, n) {
  const r = kr(s);
  if (r) {
    !t && (t = [...s.childNodes]);
    let l = [];
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.nodeType === 8 && h.data.slice(0, 2) === "!$" ? h.remove() : l.push(h);
    }
    t = l;
  }
  for (; typeof t == "function"; ) t = t();
  if (e === t) return t;
  const a = typeof e, o = i !== void 0;
  if (s = o && t[0] && t[0].parentNode || s, a === "string" || a === "number") {
    if (r || a === "number" && (e = e.toString(), e === t))
      return t;
    if (o) {
      let l = t[0];
      l && l.nodeType === 3 ? l.data !== e && (l.data = e) : l = document.createTextNode(e), t = Ln(s, t, i, l);
    } else
      t !== "" && typeof t == "string" ? t = s.firstChild.data = e : t = s.textContent = e;
  } else if (e == null || a === "boolean") {
    if (r) return t;
    t = Ln(s, t, i);
  } else {
    if (a === "function")
      return Ae(() => {
        let l = e();
        for (; typeof l == "function"; ) l = l();
        t = Sa(s, l, t, i);
      }), () => t;
    if (Array.isArray(e)) {
      const l = [], c = t && Array.isArray(t);
      if (id(l, e, t, n))
        return Ae(() => t = Sa(s, l, t, i, !0)), () => t;
      if (r) {
        if (!l.length) return t;
        if (i === void 0) return t = [...s.childNodes];
        let h = l[0];
        if (h.parentNode !== s) return t;
        const u = [h];
        for (; (h = h.nextSibling) !== i; ) u.push(h);
        return t = u;
      }
      if (l.length === 0) {
        if (t = Ln(s, t, i), o) return t;
      } else c ? t.length === 0 ? im(s, l, i) : tQ(s, t, l) : (t && Ln(s), im(s, l));
      t = l;
    } else if (e.nodeType) {
      if (r && e.parentNode) return t = o ? [e] : e;
      if (Array.isArray(t)) {
        if (o) return t = Ln(s, t, i, e);
        Ln(s, t, null, e);
      } else t == null || t === "" || !s.firstChild ? s.appendChild(e) : s.replaceChild(e, s.firstChild);
      t = e;
    }
  }
  return t;
}
function id(s, e, t, i) {
  let n = !1;
  for (let r = 0, a = e.length; r < a; r++) {
    let o = e[r], l = t && t[s.length], c;
    if (!(o == null || o === !0 || o === !1)) if ((c = typeof o) == "object" && o.nodeType)
      s.push(o);
    else if (Array.isArray(o))
      n = id(s, o, l) || n;
    else if (c === "function")
      if (i) {
        for (; typeof o == "function"; ) o = o();
        n = id(
          s,
          Array.isArray(o) ? o : [o],
          Array.isArray(l) ? l : [l]
        ) || n;
      } else
        s.push(o), n = !0;
    else {
      const h = String(o);
      l && l.nodeType === 3 && l.data === h ? s.push(l) : s.push(document.createTextNode(h));
    }
  }
  return n;
}
function im(s, e, t = null) {
  for (let i = 0, n = e.length; i < n; i++) s.insertBefore(e[i], t);
}
function Ln(s, e, t, i) {
  if (t === void 0) return s.textContent = "";
  const n = i || document.createTextNode("");
  if (e.length) {
    let r = !1;
    for (let a = e.length - 1; a >= 0; a--) {
      const o = e[a];
      if (n !== o) {
        const l = o.parentNode === s;
        !r && !a ? l ? s.replaceChild(n, o) : s.insertBefore(n, t) : l && o.remove();
      } else r = !0;
    }
  } else s.insertBefore(n, t);
  return [n];
}
const E0 = !1;
function X0() {
  let s = /* @__PURE__ */ new Set();
  function e(n) {
    return s.add(n), () => s.delete(n);
  }
  let t = !1;
  function i(n, r) {
    if (t)
      return !(t = !1);
    const a = {
      to: n,
      options: r,
      defaultPrevented: !1,
      preventDefault: () => a.defaultPrevented = !0
    };
    for (const o of s)
      o.listener({
        ...a,
        from: o.location,
        retry: (l) => {
          l && (t = !0), o.navigate(n, { ...r, resolve: !1 });
        }
      });
    return !a.defaultPrevented;
  }
  return {
    subscribe: e,
    confirm: i
  };
}
let sd;
function fp() {
  (!window.history.state || window.history.state._depth == null) && window.history.replaceState({ ...window.history.state, _depth: window.history.length - 1 }, ""), sd = window.history.state._depth;
}
fp();
function cQ(s) {
  return {
    ...s,
    _depth: window.history.state && window.history.state._depth
  };
}
function hQ(s, e) {
  let t = !1;
  return () => {
    const i = sd;
    fp();
    const n = i == null ? null : sd - i;
    if (t) {
      t = !1;
      return;
    }
    n && e(n) ? (t = !0, window.history.go(-n)) : s();
  };
}
const uQ = /^(?:[a-z0-9]+:)?\/\//i, dQ = /^\/+|(\/)\/+$/g, M0 = "http://sr";
function mn(s, e = !1) {
  const t = s.replace(dQ, "$1");
  return t ? e || /^[?#]/.test(t) ? t : "/" + t : "";
}
function cl(s, e, t) {
  if (uQ.test(e))
    return;
  const i = mn(s), n = t && mn(t);
  let r = "";
  return !n || e.startsWith("/") ? r = i : n.toLowerCase().indexOf(i.toLowerCase()) !== 0 ? r = i + n : r = n, (r || "/") + mn(e, !r);
}
function fQ(s, e) {
  if (s == null)
    throw new Error(e);
  return s;
}
function pQ(s, e) {
  return mn(s).replace(/\/*(\*.*)?$/g, "") + mn(e);
}
function _0(s) {
  const e = {};
  return s.searchParams.forEach((t, i) => {
    i in e ? Array.isArray(e[i]) ? e[i].push(t) : e[i] = [e[i], t] : e[i] = t;
  }), e;
}
function gQ(s, e, t) {
  const [i, n] = s.split("/*", 2), r = i.split("/").filter(Boolean), a = r.length;
  return (o) => {
    const l = o.split("/").filter(Boolean), c = l.length - a;
    if (c < 0 || c > 0 && n === void 0 && !e)
      return null;
    const h = {
      path: a ? "" : "/",
      params: {}
    }, u = (d) => t === void 0 ? void 0 : t[d];
    for (let d = 0; d < a; d++) {
      const f = r[d], p = f[0] === ":", g = p ? l[d] : l[d].toLowerCase(), m = p ? f.slice(1) : f.toLowerCase();
      if (p && wh(g, u(m)))
        h.params[m] = g;
      else if (p || !wh(g, m))
        return null;
      h.path += `/${g}`;
    }
    if (n) {
      const d = c ? l.slice(-c).join("/") : "";
      if (wh(d, u(n)))
        h.params[n] = d;
      else
        return null;
    }
    return h;
  };
}
function wh(s, e) {
  const t = (i) => i === s;
  return e === void 0 ? !0 : typeof e == "string" ? t(e) : typeof e == "function" ? e(s) : Array.isArray(e) ? e.some(t) : e instanceof RegExp ? e.test(s) : !1;
}
function mQ(s) {
  const [e, t] = s.pattern.split("/*", 2), i = e.split("/").filter(Boolean);
  return i.reduce((n, r) => n + (r.startsWith(":") ? 2 : 3), i.length - (t === void 0 ? 0 : 1));
}
function L0(s) {
  const e = /* @__PURE__ */ new Map(), t = qc();
  return new Proxy({}, {
    get(i, n) {
      return e.has(n) || hp(t, () => e.set(n, Ve(() => s()[n]))), e.get(n)();
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    },
    ownKeys() {
      return Reflect.ownKeys(s());
    }
  });
}
function z0(s) {
  let e = /(\/?\:[^\/]+)\?/.exec(s);
  if (!e)
    return [s];
  let t = s.slice(0, e.index), i = s.slice(e.index + e[0].length);
  const n = [t, t += e[1]];
  for (; e = /^(\/\:[^\/]+)\?/.exec(i); )
    n.push(t += e[1]), i = i.slice(e[0].length);
  return z0(i).reduce((r, a) => [...r, ...n.map((o) => o + a)], []);
}
const OQ = 100, I0 = ao(), pp = ao(), oo = () => fQ(Xn(I0), "<A> and 'use' router primitives can be only used inside a Route."), xQ = () => Xn(pp) || oo().base, bQ = (s) => {
  const e = xQ();
  return Ve(() => e.resolvePath(s()));
}, yQ = (s) => {
  const e = oo();
  return Ve(() => {
    const t = s();
    return t !== void 0 ? e.renderPath(t) : t;
  });
}, Mi = () => oo().navigatorFactory(), Pr = () => oo().location, lo = () => oo().params;
function vQ(s, e = "") {
  const { component: t, preload: i, load: n, children: r, info: a } = s, o = !r || Array.isArray(r) && !r.length, l = {
    key: s,
    component: t,
    preload: i || n,
    info: a
  };
  return q0(s.path).reduce((c, h) => {
    for (const u of z0(h)) {
      const d = pQ(e, u);
      let f = o ? d : d.split("/*", 1)[0];
      f = f.split("/").map((p) => p.startsWith(":") || p.startsWith("*") ? p : encodeURIComponent(p)).join("/"), c.push({
        ...l,
        originalPath: h,
        pattern: f,
        matcher: gQ(f, !o, s.matchFilters)
      });
    }
    return c;
  }, []);
}
function wQ(s, e = 0) {
  return {
    routes: s,
    score: mQ(s[s.length - 1]) * 1e4 - e,
    matcher(t) {
      const i = [];
      for (let n = s.length - 1; n >= 0; n--) {
        const r = s[n], a = r.matcher(t);
        if (!a)
          return null;
        i.unshift({
          ...a,
          route: r
        });
      }
      return i;
    }
  };
}
function q0(s) {
  return Array.isArray(s) ? s : [s];
}
function D0(s, e = "", t = [], i = []) {
  const n = q0(s);
  for (let r = 0, a = n.length; r < a; r++) {
    const o = n[r];
    if (o && typeof o == "object") {
      o.hasOwnProperty("path") || (o.path = "");
      const l = vQ(o, e);
      for (const c of l) {
        t.push(c);
        const h = Array.isArray(o.children) && o.children.length === 0;
        if (o.children && !h)
          D0(o.children, c.pattern, t, i);
        else {
          const u = wQ([...t], i.length);
          i.push(u);
        }
        t.pop();
      }
    }
  }
  return t.length ? i : i.sort((r, a) => a.score - r.score);
}
function Sh(s, e) {
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t].matcher(e);
    if (n)
      return n;
  }
  return [];
}
function SQ(s, e, t) {
  const i = new URL(M0), n = Ve((h) => {
    const u = s();
    try {
      return new URL(u, i);
    } catch {
      return console.error(`Invalid path ${u}`), h;
    }
  }, i, {
    equals: (h, u) => h.href === u.href
  }), r = Ve(() => n().pathname), a = Ve(() => n().search, !0), o = Ve(() => n().hash), l = () => "", c = ms(a, () => _0(n()));
  return {
    get pathname() {
      return r();
    },
    get search() {
      return a();
    },
    get hash() {
      return o();
    },
    get state() {
      return e();
    },
    get key() {
      return l();
    },
    query: t ? t(c) : L0(c)
  };
}
let tn;
function kQ() {
  return tn;
}
function PQ(s, e, t, i = {}) {
  const { signal: [n, r], utils: a = {} } = s, o = a.parsePath || ((R) => R), l = a.renderPath || ((R) => R), c = a.beforeLeave || X0(), h = cl("", i.base || "");
  if (h === void 0)
    throw new Error(`${h} is not a valid base path`);
  h && !n().value && r({ value: h, replace: !0, scroll: !1 });
  const [u, d] = re(!1);
  let f;
  const p = (R, X) => {
    X.value === g() && X.state === O() || (f === void 0 && d(!0), tn = R, f = X, XP(() => {
      f === X && (m(f.value), x(f.state), y[1]((M) => M.filter((z) => z.pending)));
    }).finally(() => {
      f === X && Q0(() => {
        tn = void 0, R === "navigate" && P(f), d(!1), f = void 0;
      });
    }));
  }, [g, m] = re(n().value), [O, x] = re(n().state), b = SQ(g, O, a.queryWrapper), v = [], y = re([]), w = Ve(() => typeof i.transformUrl == "function" ? Sh(e(), i.transformUrl(b.pathname)) : Sh(e(), b.pathname)), S = () => {
    const R = w(), X = {};
    for (let M = 0; M < R.length; M++)
      Object.assign(X, R[M].params);
    return X;
  }, k = a.paramsWrapper ? a.paramsWrapper(S, e) : L0(S), A = {
    pattern: h,
    path: () => h,
    outlet: () => null,
    resolvePath(R) {
      return cl(h, R);
    }
  };
  return Ae(ms(n, (R) => p("native", R), { defer: !0 })), {
    base: A,
    location: b,
    params: k,
    isRouting: u,
    renderPath: l,
    parsePath: o,
    navigatorFactory: C,
    matches: w,
    beforeLeave: c,
    preloadRoute: $,
    singleFlight: i.singleFlight === void 0 ? !0 : i.singleFlight,
    submissions: y
  };
  function T(R, X, M) {
    St(() => {
      if (typeof X == "number") {
        X && (a.go ? a.go(X) : console.warn("Router integration does not support relative routing"));
        return;
      }
      const z = !X || X[0] === "?", { replace: I, resolve: Y, scroll: V, state: N } = {
        replace: !1,
        resolve: !z,
        scroll: !0,
        ...M
      }, _ = Y ? R.resolvePath(X) : cl(z && b.pathname || "", X);
      if (_ === void 0)
        throw new Error(`Path '${X}' is not a routable path`);
      if (v.length >= OQ)
        throw new Error("Too many redirects");
      const U = g();
      (_ !== U || N !== O()) && (E0 || c.confirm(_, M) && (v.push({ value: U, replace: I, scroll: V, state: O() }), p("navigate", {
        value: _,
        state: N
      })));
    });
  }
  function C(R) {
    return R = R || Xn(pp) || A, (X, M) => T(R, X, M);
  }
  function P(R) {
    const X = v[0];
    X && (r({
      ...R,
      replace: X.replace,
      scroll: X.scroll
    }), v.length = 0);
  }
  function $(R, X) {
    const M = Sh(e(), R.pathname), z = tn;
    tn = "preload";
    for (let I in M) {
      const { route: Y, params: V } = M[I];
      Y.component && Y.component.preload && Y.component.preload();
      const { preload: N } = Y;
      X && N && hp(t(), () => N({
        params: V,
        location: {
          pathname: R.pathname,
          search: R.search,
          hash: R.hash,
          query: _0(R),
          state: null,
          key: ""
        },
        intent: "preload"
      }));
    }
    tn = z;
  }
}
function QQ(s, e, t, i) {
  const { base: n, location: r, params: a } = s, { pattern: o, component: l, preload: c } = i().route, h = Ve(() => i().path);
  l && l.preload && l.preload();
  const u = c ? c({ params: a, location: r, intent: tn || "initial" }) : void 0;
  return {
    parent: e,
    pattern: o,
    path: h,
    outlet: () => l ? B(l, {
      params: a,
      location: r,
      data: u,
      get children() {
        return t();
      }
    }) : t(),
    resolvePath(f) {
      return cl(n.path(), f, h());
    }
  };
}
const CQ = (s) => (e) => {
  const {
    base: t
  } = e, i = Dc(() => e.children), n = Ve(() => D0(i(), e.base || ""));
  let r;
  const a = PQ(s, n, () => r, {
    base: t,
    singleFlight: e.singleFlight,
    transformUrl: e.transformUrl
  });
  return s.create && s.create(a), B(I0.Provider, {
    value: a,
    get children() {
      return B(AQ, {
        routerState: a,
        get root() {
          return e.root;
        },
        get preload() {
          return e.rootPreload || e.rootLoad;
        },
        get children() {
          return [Yt(() => (r = qc()) && null), B(TQ, {
            routerState: a,
            get branches() {
              return n();
            }
          })];
        }
      });
    }
  });
};
function AQ(s) {
  const e = s.routerState.location, t = s.routerState.params, i = Ve(() => s.preload && St(() => {
    s.preload({
      params: t,
      location: e,
      intent: kQ() || "initial"
    });
  }));
  return B(vi, {
    get when() {
      return s.root;
    },
    keyed: !0,
    get fallback() {
      return s.children;
    },
    children: (n) => B(n, {
      params: t,
      location: e,
      get data() {
        return i();
      },
      get children() {
        return s.children;
      }
    })
  });
}
function TQ(s) {
  const e = [];
  let t;
  const i = Ve(ms(s.routerState.matches, (n, r, a) => {
    let o = r && n.length === r.length;
    const l = [];
    for (let c = 0, h = n.length; c < h; c++) {
      const u = r && r[c], d = n[c];
      a && u && d.route.key === u.route.key ? l[c] = a[c] : (o = !1, e[c] && e[c](), gn((f) => {
        e[c] = f, l[c] = QQ(s.routerState, l[c - 1] || s.routerState.base, sm(() => i()[c + 1]), () => s.routerState.matches()[c]);
      }));
    }
    return e.splice(n.length).forEach((c) => c()), a && o ? a : (t = l[0], l);
  }));
  return sm(() => i() && t)();
}
const sm = (s) => () => B(vi, {
  get when() {
    return s();
  },
  keyed: !0,
  children: (e) => B(pp.Provider, {
    value: e,
    get children() {
      return e.outlet();
    }
  })
}), os = (s) => {
  const e = Dc(() => s.children);
  return wn(s, {
    get children() {
      return e();
    }
  });
};
function $Q([s, e], t, i) {
  return [s, i ? (n) => e(i(n)) : e];
}
function RQ(s) {
  let e = !1;
  const t = (n) => typeof n == "string" ? { value: n } : n, i = $Q(re(t(s.get()), {
    equals: (n, r) => n.value === r.value && n.state === r.state
  }), void 0, (n) => (!e && s.set(n), ve.registry && !ve.done && (ve.done = !0), n));
  return s.init && ii(s.init((n = s.get()) => {
    e = !0, i[1](t(n)), e = !1;
  })), CQ({
    signal: i,
    create: s.create,
    utils: s.utils
  });
}
function EQ(s, e, t) {
  return s.addEventListener(e, t), () => s.removeEventListener(e, t);
}
function XQ(s, e) {
  const t = s && document.getElementById(s);
  t ? t.scrollIntoView() : e && window.scrollTo(0, 0);
}
const MQ = /* @__PURE__ */ new Map();
function _Q(s = !0, e = !1, t = "/_server", i) {
  return (n) => {
    const r = n.base.path(), a = n.navigatorFactory(n.base);
    let o, l;
    function c(g) {
      return g.namespaceURI === "http://www.w3.org/2000/svg";
    }
    function h(g) {
      if (g.defaultPrevented || g.button !== 0 || g.metaKey || g.altKey || g.ctrlKey || g.shiftKey)
        return;
      const m = g.composedPath().find((w) => w instanceof Node && w.nodeName.toUpperCase() === "A");
      if (!m || e && !m.hasAttribute("link"))
        return;
      const O = c(m), x = O ? m.href.baseVal : m.href;
      if ((O ? m.target.baseVal : m.target) || !x && !m.hasAttribute("state"))
        return;
      const v = (m.getAttribute("rel") || "").split(/\s+/);
      if (m.hasAttribute("download") || v && v.includes("external"))
        return;
      const y = O ? new URL(x, document.baseURI) : new URL(x);
      if (!(y.origin !== window.location.origin || r && y.pathname && !y.pathname.toLowerCase().startsWith(r.toLowerCase())))
        return [m, y];
    }
    function u(g) {
      const m = h(g);
      if (!m)
        return;
      const [O, x] = m, b = n.parsePath(x.pathname + x.search + x.hash), v = O.getAttribute("state");
      g.preventDefault(), a(b, {
        resolve: !1,
        replace: O.hasAttribute("replace"),
        scroll: !O.hasAttribute("noscroll"),
        state: v ? JSON.parse(v) : void 0
      });
    }
    function d(g) {
      const m = h(g);
      if (!m)
        return;
      const [O, x] = m;
      i && (x.pathname = i(x.pathname)), n.preloadRoute(x, O.getAttribute("preload") !== "false");
    }
    function f(g) {
      clearTimeout(o);
      const m = h(g);
      if (!m)
        return l = null;
      const [O, x] = m;
      l !== O && (i && (x.pathname = i(x.pathname)), o = setTimeout(() => {
        n.preloadRoute(x, O.getAttribute("preload") !== "false"), l = O;
      }, 20));
    }
    function p(g) {
      if (g.defaultPrevented)
        return;
      let m = g.submitter && g.submitter.hasAttribute("formaction") ? g.submitter.getAttribute("formaction") : g.target.getAttribute("action");
      if (!m)
        return;
      if (!m.startsWith("https://action/")) {
        const x = new URL(m, M0);
        if (m = n.parsePath(x.pathname + x.search), !m.startsWith(t))
          return;
      }
      if (g.target.method.toUpperCase() !== "POST")
        throw new Error("Only POST forms are supported for Actions");
      const O = MQ.get(m);
      if (O) {
        g.preventDefault();
        const x = new FormData(g.target, g.submitter);
        O.call({ r: n, f: g.target }, g.target.enctype === "multipart/form-data" ? x : new URLSearchParams(x));
      }
    }
    _t(["click", "submit"]), document.addEventListener("click", u), s && (document.addEventListener("mousemove", f, { passive: !0 }), document.addEventListener("focusin", d, { passive: !0 }), document.addEventListener("touchstart", d, { passive: !0 })), document.addEventListener("submit", p), ii(() => {
      document.removeEventListener("click", u), s && (document.removeEventListener("mousemove", f), document.removeEventListener("focusin", d), document.removeEventListener("touchstart", d)), document.removeEventListener("submit", p);
    });
  };
}
function LQ(s) {
  const e = () => {
    const i = window.location.pathname.replace(/^\/+/, "/") + window.location.search, n = window.history.state && window.history.state._depth && Object.keys(window.history.state).length === 1 ? void 0 : window.history.state;
    return {
      value: i + window.location.hash,
      state: n
    };
  }, t = X0();
  return RQ({
    get: e,
    set({ value: i, replace: n, scroll: r, state: a }) {
      n ? window.history.replaceState(cQ(a), "", i) : window.history.pushState(a, "", i), XQ(decodeURIComponent(window.location.hash.slice(1)), r), fp();
    },
    init: (i) => EQ(window, "popstate", hQ(i, (n) => {
      if (n && n < 0)
        return !t.confirm(n);
      {
        const r = e();
        return !t.confirm(r.value, { state: r.state });
      }
    })),
    create: _Q(s.preload, s.explicitLinks, s.actionBase, s.transformUrl),
    utils: {
      go: (i) => window.history.go(i),
      beforeLeave: t
    }
  })(s);
}
var zQ = /* @__PURE__ */ K("<a>");
function zn(s) {
  s = wn({
    inactiveClass: "inactive",
    activeClass: "active"
  }, s);
  const [, e] = dp(s, ["href", "state", "class", "activeClass", "inactiveClass", "end"]), t = bQ(() => s.href), i = yQ(t), n = Pr(), r = Ve(() => {
    const a = t();
    if (a === void 0) return [!1, !1];
    const o = mn(a.split(/[?#]/, 1)[0]).toLowerCase(), l = decodeURI(mn(n.pathname).toLowerCase());
    return [s.end ? o === l : l.startsWith(o + "/") || l === o, o === l];
  });
  return (() => {
    var a = zQ();
    return Wc(a, wn(e, {
      get href() {
        return i() || s.href;
      },
      get state() {
        return JSON.stringify(s.state);
      },
      get classList() {
        return {
          ...s.class && {
            [s.class]: !0
          },
          [s.inactiveClass]: !r()[0],
          [s.activeClass]: r()[0],
          ...e.classList
        };
      },
      link: "",
      get "aria-current"() {
        return r()[1] ? "page" : void 0;
      }
    }), !1, !1), a;
  })();
}
const IQ = Symbol("store-raw");
function qQ(s) {
  let e;
  return s != null && typeof s == "object" && (s[va] || !(e = Object.getPrototypeOf(s)) || e === Object.prototype || Array.isArray(s));
}
function Fl(s, e = /* @__PURE__ */ new Set()) {
  let t, i, n, r;
  if (t = s != null && s[IQ]) return t;
  if (!qQ(s) || e.has(s)) return s;
  if (Array.isArray(s)) {
    Object.isFrozen(s) ? s = s.slice(0) : e.add(s);
    for (let a = 0, o = s.length; a < o; a++)
      n = s[a], (i = Fl(n, e)) !== n && (s[a] = i);
  } else {
    Object.isFrozen(s) ? s = Object.assign({}, s) : e.add(s);
    const a = Object.keys(s), o = Object.getOwnPropertyDescriptors(s);
    for (let l = 0, c = a.length; l < c; l++)
      r = a[l], !o[r].get && (n = s[r], (i = Fl(n, e)) !== n && (s[r] = i));
  }
  return s;
}
const DQ = () => {
  if (typeof window < "u") {
    if (window.localStorage) {
      const e = window.localStorage.getItem("dark");
      if (typeof e == "string")
        return e === "true";
    }
    if (window.matchMedia("(prefers-color-scheme: dark)").matches)
      return !0;
  }
  return !1;
}, B0 = ao(), Sn = "http://localhost:5000/api", BQ = (s) => {
  Mi();
  const [e, t] = re(localStorage.getItem("token") || ""), [i, n] = re([]), [r, a] = re(DQ()), [o] = P0(e, async (u) => {
    const d = localStorage.getItem("user");
    if (d)
      return JSON.parse(d);
    const f = await fetch(`${Sn}/auth/me`, {
      headers: {
        "Content-Type": "application/json"
      },
      credentials: "include"
    });
    if (!f.ok)
      return f.status === 401 && (localStorage.removeItem("token"), localStorage.removeItem("user")), {
        email: "",
        name: "",
        image: ""
      };
    const p = await f.json();
    return localStorage.setItem("user", JSON.stringify(p)), p;
  }), l = async () => {
    try {
      const u = await fetch(`${Sn}/file/list?directory=./&recursive=true`, {
        headers: {
          "Content-Type": "application/json"
        },
        credentials: "include"
      });
      if (!u.ok)
        return u.status === 401 && localStorage.removeItem("token"), {};
      if (u.ok) {
        const d = await u.json();
        n(d);
      }
    } catch (u) {
      console.error("Failed to fetch files:", u);
    }
  };
  l();
  let [c, h] = re();
  return B(B0.Provider, {
    value: {
      get token() {
        return e();
      },
      set token(u) {
        t(u), localStorage.setItem("token", u);
      },
      user: o,
      tabs() {
        const u = c();
        return u ? u() : void 0;
      },
      setTabs(u) {
        h(() => u);
      },
      dark: r,
      toggleDark() {
        let u = !r();
        document.body.classList.toggle("dark", u), a(u), localStorage.setItem("dark", String(u));
      },
      files: i,
      refreshFiles: l
    },
    get children() {
      return s.children;
    }
  });
}, ss = () => Xn(B0), [WQ, nm] = re([]);
let YQ = 0;
function rm(s, e = "info", t = 3e3) {
  const i = ++YQ;
  nm((n) => [...n, { id: i, message: s, type: e }]), setTimeout(() => {
    nm((n) => n.filter((r) => r.id !== i));
  }, t);
}
var ZQ = /* @__PURE__ */ K('<div class="fixed top-4 right-4 space-y-2 z-50">'), NQ = /* @__PURE__ */ K("<div>");
function W0() {
  return (() => {
    var s = ZQ();
    return W(s, B(Gi, {
      get each() {
        return WQ();
      },
      children: (e) => (() => {
        var t = NQ();
        return W(t, () => e.message), Ae(() => Os(t, `px-4 py-3 rounded shadow text-white animate-fade-in-out
              ${e.type === "success" && "bg-green-600"}
              ${e.type === "error" && "bg-red-600"}
              ${e.type === "info" && "bg-blue-600"}`)), t;
      })()
    })), s;
  })();
}
var VQ = /* @__PURE__ */ K('<div class="flex h-screen flex-col overflow-hidden"><main class=flex-1><div class="grid grid-cols-1 grid-rows-[1fr_1px_auto_1px_auto] justify-center [--gutter-width:2.5rem] md:-mx-4 md:grid-cols-[var(--gutter-width)_minmax(0,var(--breakpoint-2xl))_var(--gutter-width)] lg:mx-0"><div class="col-start-1 row-span-full row-start-1 hidden border-x border-x-[--pattern-fg] border-neutral-200 dark:border-neutral-800 bg-[image:repeating-linear-gradient(315deg,_var(--pattern-fg)_0,_var(--pattern-fg)_1px,_transparent_0,_transparent_50%)] bg-[size:10px_10px] bg-fixed [--pattern-fg:var(--color-black)]/5 md:block dark:[--pattern-fg:var(--color-white)]/10"></div><div class></div><div class="row-span-full row-start-1 hidden border-x border-x-[--pattern-fg] border-neutral-200 dark:border-neutral-800 bg-[image:repeating-linear-gradient(315deg,_var(--pattern-fg)_0,_var(--pattern-fg)_1px,_transparent_0,_transparent_50%)] bg-[size:10px_10px] bg-fixed [--pattern-fg:var(--color-black)]/5 md:col-start-3 md:block dark:[--pattern-fg:var(--color-white)]/10">');
const In = (s) => (lo(), Mi(), Pr(), ss(), [B(W0, {}), (() => {
  var e = VQ(), t = e.firstChild, i = t.firstChild, n = i.firstChild, r = n.nextSibling;
  return W(r, () => s.children), e;
})()]), es = /* @__PURE__ */ Object.create(null);
es.open = "0";
es.close = "1";
es.ping = "2";
es.pong = "3";
es.message = "4";
es.upgrade = "5";
es.noop = "6";
const hl = /* @__PURE__ */ Object.create(null);
Object.keys(es).forEach((s) => {
  hl[es[s]] = s;
});
const nd = { type: "error", data: "parser error" }, Y0 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Z0 = typeof ArrayBuffer == "function", N0 = (s) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(s) : s && s.buffer instanceof ArrayBuffer, gp = ({ type: s, data: e }, t, i) => Y0 && e instanceof Blob ? t ? i(e) : am(e, i) : Z0 && (e instanceof ArrayBuffer || N0(e)) ? t ? i(e) : am(new Blob([e]), i) : i(es[s] + (e || "")), am = (s, e) => {
  const t = new FileReader();
  return t.onload = function() {
    const i = t.result.split(",")[1];
    e("b" + (i || ""));
  }, t.readAsDataURL(s);
};
function om(s) {
  return s instanceof Uint8Array ? s : s instanceof ArrayBuffer ? new Uint8Array(s) : new Uint8Array(s.buffer, s.byteOffset, s.byteLength);
}
let kh;
function FQ(s, e) {
  if (Y0 && s.data instanceof Blob)
    return s.data.arrayBuffer().then(om).then(e);
  if (Z0 && (s.data instanceof ArrayBuffer || N0(s.data)))
    return e(om(s.data));
  gp(s, !1, (t) => {
    kh || (kh = new TextEncoder()), e(kh.encode(t));
  });
}
const lm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ta = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let s = 0; s < lm.length; s++)
  ta[lm.charCodeAt(s)] = s;
const jQ = (s) => {
  let e = s.length * 0.75, t = s.length, i, n = 0, r, a, o, l;
  s[s.length - 1] === "=" && (e--, s[s.length - 2] === "=" && e--);
  const c = new ArrayBuffer(e), h = new Uint8Array(c);
  for (i = 0; i < t; i += 4)
    r = ta[s.charCodeAt(i)], a = ta[s.charCodeAt(i + 1)], o = ta[s.charCodeAt(i + 2)], l = ta[s.charCodeAt(i + 3)], h[n++] = r << 2 | a >> 4, h[n++] = (a & 15) << 4 | o >> 2, h[n++] = (o & 3) << 6 | l & 63;
  return c;
}, HQ = typeof ArrayBuffer == "function", mp = (s, e) => {
  if (typeof s != "string")
    return {
      type: "message",
      data: V0(s, e)
    };
  const t = s.charAt(0);
  return t === "b" ? {
    type: "message",
    data: UQ(s.substring(1), e)
  } : hl[t] ? s.length > 1 ? {
    type: hl[t],
    data: s.substring(1)
  } : {
    type: hl[t]
  } : nd;
}, UQ = (s, e) => {
  if (HQ) {
    const t = jQ(s);
    return V0(t, e);
  } else
    return { base64: !0, data: s };
}, V0 = (s, e) => {
  switch (e) {
    case "blob":
      return s instanceof Blob ? s : new Blob([s]);
    case "arraybuffer":
    default:
      return s instanceof ArrayBuffer ? s : s.buffer;
  }
}, F0 = "", GQ = (s, e) => {
  const t = s.length, i = new Array(t);
  let n = 0;
  s.forEach((r, a) => {
    gp(r, !1, (o) => {
      i[a] = o, ++n === t && e(i.join(F0));
    });
  });
}, KQ = (s, e) => {
  const t = s.split(F0), i = [];
  for (let n = 0; n < t.length; n++) {
    const r = mp(t[n], e);
    if (i.push(r), r.type === "error")
      break;
  }
  return i;
};
function JQ() {
  return new TransformStream({
    transform(s, e) {
      FQ(s, (t) => {
        const i = t.length;
        let n;
        if (i < 126)
          n = new Uint8Array(1), new DataView(n.buffer).setUint8(0, i);
        else if (i < 65536) {
          n = new Uint8Array(3);
          const r = new DataView(n.buffer);
          r.setUint8(0, 126), r.setUint16(1, i);
        } else {
          n = new Uint8Array(9);
          const r = new DataView(n.buffer);
          r.setUint8(0, 127), r.setBigUint64(1, BigInt(i));
        }
        s.data && typeof s.data != "string" && (n[0] |= 128), e.enqueue(n), e.enqueue(t);
      });
    }
  });
}
let Ph;
function Xo(s) {
  return s.reduce((e, t) => e + t.length, 0);
}
function Mo(s, e) {
  if (s[0].length === e)
    return s.shift();
  const t = new Uint8Array(e);
  let i = 0;
  for (let n = 0; n < e; n++)
    t[n] = s[0][i++], i === s[0].length && (s.shift(), i = 0);
  return s.length && i < s[0].length && (s[0] = s[0].slice(i)), t;
}
function eC(s, e) {
  Ph || (Ph = new TextDecoder());
  const t = [];
  let i = 0, n = -1, r = !1;
  return new TransformStream({
    transform(a, o) {
      for (t.push(a); ; ) {
        if (i === 0) {
          if (Xo(t) < 1)
            break;
          const l = Mo(t, 1);
          r = (l[0] & 128) === 128, n = l[0] & 127, n < 126 ? i = 3 : n === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (Xo(t) < 2)
            break;
          const l = Mo(t, 2);
          n = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (Xo(t) < 8)
            break;
          const l = Mo(t, 8), c = new DataView(l.buffer, l.byteOffset, l.length), h = c.getUint32(0);
          if (h > Math.pow(2, 21) - 1) {
            o.enqueue(nd);
            break;
          }
          n = h * Math.pow(2, 32) + c.getUint32(4), i = 3;
        } else {
          if (Xo(t) < n)
            break;
          const l = Mo(t, n);
          o.enqueue(mp(r ? l : Ph.decode(l), e)), i = 0;
        }
        if (n === 0 || n > s) {
          o.enqueue(nd);
          break;
        }
      }
    }
  });
}
const j0 = 4;
function ot(s) {
  if (s) return tC(s);
}
function tC(s) {
  for (var e in ot.prototype)
    s[e] = ot.prototype[e];
  return s;
}
ot.prototype.on = ot.prototype.addEventListener = function(s, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + s] = this._callbacks["$" + s] || []).push(e), this;
};
ot.prototype.once = function(s, e) {
  function t() {
    this.off(s, t), e.apply(this, arguments);
  }
  return t.fn = e, this.on(s, t), this;
};
ot.prototype.off = ot.prototype.removeListener = ot.prototype.removeAllListeners = ot.prototype.removeEventListener = function(s, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var t = this._callbacks["$" + s];
  if (!t) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + s], this;
  for (var i, n = 0; n < t.length; n++)
    if (i = t[n], i === e || i.fn === e) {
      t.splice(n, 1);
      break;
    }
  return t.length === 0 && delete this._callbacks["$" + s], this;
};
ot.prototype.emit = function(s) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + s], i = 1; i < arguments.length; i++)
    e[i - 1] = arguments[i];
  if (t) {
    t = t.slice(0);
    for (var i = 0, n = t.length; i < n; ++i)
      t[i].apply(this, e);
  }
  return this;
};
ot.prototype.emitReserved = ot.prototype.emit;
ot.prototype.listeners = function(s) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + s] || [];
};
ot.prototype.hasListeners = function(s) {
  return !!this.listeners(s).length;
};
const Yc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0), li = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), iC = "arraybuffer";
function H0(s, ...e) {
  return e.reduce((t, i) => (s.hasOwnProperty(i) && (t[i] = s[i]), t), {});
}
const sC = li.setTimeout, nC = li.clearTimeout;
function Zc(s, e) {
  e.useNativeTimers ? (s.setTimeoutFn = sC.bind(li), s.clearTimeoutFn = nC.bind(li)) : (s.setTimeoutFn = li.setTimeout.bind(li), s.clearTimeoutFn = li.clearTimeout.bind(li));
}
const rC = 1.33;
function aC(s) {
  return typeof s == "string" ? oC(s) : Math.ceil((s.byteLength || s.size) * rC);
}
function oC(s) {
  let e = 0, t = 0;
  for (let i = 0, n = s.length; i < n; i++)
    e = s.charCodeAt(i), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (i++, t += 4);
  return t;
}
function U0() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function lC(s) {
  let e = "";
  for (let t in s)
    s.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(s[t]));
  return e;
}
function cC(s) {
  let e = {}, t = s.split("&");
  for (let i = 0, n = t.length; i < n; i++) {
    let r = t[i].split("=");
    e[decodeURIComponent(r[0])] = decodeURIComponent(r[1]);
  }
  return e;
}
class hC extends Error {
  constructor(e, t, i) {
    super(e), this.description = t, this.context = i, this.type = "TransportError";
  }
}
class Op extends ot {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(e) {
    super(), this.writable = !1, Zc(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(e, t, i) {
    return super.emitReserved("error", new hC(e, t, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(e) {
    const t = mp(e, this.socket.binaryType);
    this.onPacket(t);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(e) {
  }
  createUri(e, t = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const t = lC(e);
    return t.length ? "?" + t : "";
  }
}
class uC extends Op {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      this.readyState = "paused", e();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || t();
      })), this.writable || (i++, this.once("drain", function() {
        --i || t();
      }));
    } else
      t();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(e) {
    const t = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    KQ(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(e) {
    this.writable = !1, GQ(e, (t) => {
      this.doWrite(t, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "https" : "http", t = this.query || {};
    return this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = U0()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t);
  }
}
let G0 = !1;
try {
  G0 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const dC = G0;
function fC() {
}
class pC extends uC {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(e) {
    if (super(e), typeof location < "u") {
      const t = location.protocol === "https:";
      let i = location.port;
      i || (i = t ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || i !== e.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(e, t) {
    const i = this.request({
      method: "POST",
      data: e
    });
    i.on("success", t), i.on("error", (n, r) => {
      this.onError("xhr post error", n, r);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (t, i) => {
      this.onError("xhr poll error", t, i);
    }), this.pollXhr = e;
  }
}
let Jn = class ul extends ot {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(e, t, i) {
    super(), this.createRequest = e, Zc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = t, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var e;
    const t = H0(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(t);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let n in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(n) && i.setRequestHeader(n, this._opts.extraHeaders[n]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var n;
        i.readyState === 3 && ((n = this._opts.cookieJar) === null || n === void 0 || n.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (n) {
      this.setTimeoutFn(() => {
        this._onError(n);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = ul.requestsCount++, ul.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(e) {
    this.emitReserved("error", e, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(e) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = fC, e)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete ul.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const e = this._xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Jn.requestsCount = 0;
Jn.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", cm);
  else if (typeof addEventListener == "function") {
    const s = "onpagehide" in li ? "pagehide" : "unload";
    addEventListener(s, cm, !1);
  }
}
function cm() {
  for (let s in Jn.requests)
    Jn.requests.hasOwnProperty(s) && Jn.requests[s].abort();
}
const gC = function() {
  const s = K0({
    xdomain: !1
  });
  return s && s.responseType !== null;
}();
class mC extends pC {
  constructor(e) {
    super(e);
    const t = e && e.forceBase64;
    this.supportsBinary = gC && !t;
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd }, this.opts), new Jn(K0, this.uri(), e);
  }
}
function K0(s) {
  const e = s.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || dC))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new li[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const J0 = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class OC extends Op {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e = this.uri(), t = this.opts.protocols, i = J0 ? {} : H0(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e, t, i);
    } catch (n) {
      return this.emitReserved("error", n);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = t === e.length - 1;
      gp(i, this.supportsBinary, (r) => {
        try {
          this.doWrite(i, r);
        } catch {
        }
        n && Yc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "wss" : "ws", t = this.query || {};
    return this.opts.timestampRequests && (t[this.opts.timestampParam] = U0()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t);
  }
}
const Qh = li.WebSocket || li.MozWebSocket;
class xC extends OC {
  createSocket(e, t, i) {
    return J0 ? new Qh(e, t, i) : t ? new Qh(e, t) : new Qh(e);
  }
  doWrite(e, t) {
    this.ws.send(t);
  }
}
class bC extends Op {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (e) {
      return this.emitReserved("error", e);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((e) => {
        const t = eC(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = e.readable.pipeThrough(t).getReader(), n = JQ();
        n.readable.pipeTo(e.writable), this._writer = n.writable.getWriter();
        const r = () => {
          i.read().then(({ done: o, value: l }) => {
            o || (this.onPacket(l), r());
          }).catch((o) => {
          });
        };
        r();
        const a = { type: "open" };
        this.query.sid && (a.data = `{"sid":"${this.query.sid}"}`), this._writer.write(a).then(() => this.onOpen());
      });
    });
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = t === e.length - 1;
      this._writer.write(i).then(() => {
        n && Yc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this._transport) === null || e === void 0 || e.close();
  }
}
const yC = {
  websocket: xC,
  webtransport: bC,
  polling: mC
}, vC = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, wC = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function rd(s) {
  if (s.length > 8e3)
    throw "URI too long";
  const e = s, t = s.indexOf("["), i = s.indexOf("]");
  t != -1 && i != -1 && (s = s.substring(0, t) + s.substring(t, i).replace(/:/g, ";") + s.substring(i, s.length));
  let n = vC.exec(s || ""), r = {}, a = 14;
  for (; a--; )
    r[wC[a]] = n[a] || "";
  return t != -1 && i != -1 && (r.source = e, r.host = r.host.substring(1, r.host.length - 1).replace(/;/g, ":"), r.authority = r.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), r.ipv6uri = !0), r.pathNames = SC(r, r.path), r.queryKey = kC(r, r.query), r;
}
function SC(s, e) {
  const t = /\/{2,9}/g, i = e.replace(t, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && i.splice(0, 1), e.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function kC(s, e) {
  const t = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, n, r) {
    n && (t[n] = r);
  }), t;
}
const ad = typeof addEventListener == "function" && typeof removeEventListener == "function", dl = [];
ad && addEventListener("offline", () => {
  dl.forEach((s) => s());
}, !1);
class Ls extends ot {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(e, t) {
    if (super(), this.binaryType = iC, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (t = e, e = null), e) {
      const i = rd(e);
      t.hostname = i.host, t.secure = i.protocol === "https" || i.protocol === "wss", t.port = i.port, i.query && (t.query = i.query);
    } else t.host && (t.hostname = rd(t.host).host);
    Zc(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, t.transports.forEach((i) => {
      const n = i.prototype.name;
      this.transports.push(n), this._transportsByName[n] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = cC(this.opts.query)), ad && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, dl.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    t.EIO = j0, t.transport = e, this.id && (t.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: t,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e]);
    return new this._transportsByName[e](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e = this.opts.rememberUpgrade && Ls.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const t = this.createTransport(e);
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (t) => this._onClose("transport close", t));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", Ls.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this._onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this._getWritablePackets();
      this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let t = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const n = this.writeBuffer[i].data;
      if (n && (t += aC(n)), i > 0 && t > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      t += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const e = Date.now() > this._pingTimeoutTime;
    return e && (this._pingTimeoutTime = 0, Yc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), e;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(e, t, i) {
    return this._sendPacket("message", e, t, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(e, t, i) {
    return this._sendPacket("message", e, t, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(e, t, i, n) {
    if (typeof t == "function" && (n = t, t = void 0), typeof i == "function" && (n = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const r = {
      type: e,
      data: t,
      options: i
    };
    this.emitReserved("packetCreate", r), this.writeBuffer.push(r), n && this.once("flush", n), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const e = () => {
      this._onClose("forced close"), this.transport.close();
    }, t = () => {
      this.off("upgrade", t), this.off("upgradeError", t), e();
    }, i = () => {
      this.once("upgrade", t), this.once("upgradeError", t);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : e();
    }) : this.upgrading ? i() : e()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(e) {
    if (Ls.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", e), this._onClose("transport error", e);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(e, t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), ad && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = dl.indexOf(this._offlineEventListener);
        i !== -1 && dl.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
Ls.protocol = j0;
class PC extends Ls {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let e = 0; e < this._upgrades.length; e++)
        this._probe(this._upgrades[e]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(e) {
    let t = this.createTransport(e), i = !1;
    Ls.priorWebsocketSuccess = !1;
    const n = () => {
      i || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", (u) => {
        if (!i)
          if (u.type === "pong" && u.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", t), !t)
              return;
            Ls.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (h(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush());
            });
          } else {
            const d = new Error("probe error");
            d.transport = t.name, this.emitReserved("upgradeError", d);
          }
      }));
    };
    function r() {
      i || (i = !0, h(), t.close(), t = null);
    }
    const a = (u) => {
      const d = new Error("probe error: " + u);
      d.transport = t.name, r(), this.emitReserved("upgradeError", d);
    };
    function o() {
      a("transport closed");
    }
    function l() {
      a("socket closed");
    }
    function c(u) {
      t && u.name !== t.name && r();
    }
    const h = () => {
      t.removeListener("open", n), t.removeListener("error", a), t.removeListener("close", o), this.off("close", l), this.off("upgrading", c);
    };
    t.once("open", n), t.once("error", a), t.once("close", o), this.once("close", l), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      i || t.open();
    }, 200) : t.open();
  }
  onHandshake(e) {
    this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(e) {
    const t = [];
    for (let i = 0; i < e.length; i++)
      ~this.transports.indexOf(e[i]) && t.push(e[i]);
    return t;
  }
}
let QC = class extends PC {
  constructor(e, t = {}) {
    const i = typeof e == "object" ? e : t;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((n) => yC[n]).filter((n) => !!n)), super(e, i);
  }
};
function CC(s, e = "", t) {
  let i = s;
  t = t || typeof location < "u" && location, s == null && (s = t.protocol + "//" + t.host), typeof s == "string" && (s.charAt(0) === "/" && (s.charAt(1) === "/" ? s = t.protocol + s : s = t.host + s), /^(https?|wss?):\/\//.test(s) || (typeof t < "u" ? s = t.protocol + "//" + s : s = "https://" + s), i = rd(s)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const r = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + r + ":" + i.port + e, i.href = i.protocol + "://" + r + (t && t.port === i.port ? "" : ":" + i.port), i;
}
const AC = typeof ArrayBuffer == "function", TC = (s) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(s) : s.buffer instanceof ArrayBuffer, ey = Object.prototype.toString, $C = typeof Blob == "function" || typeof Blob < "u" && ey.call(Blob) === "[object BlobConstructor]", RC = typeof File == "function" || typeof File < "u" && ey.call(File) === "[object FileConstructor]";
function xp(s) {
  return AC && (s instanceof ArrayBuffer || TC(s)) || $C && s instanceof Blob || RC && s instanceof File;
}
function fl(s, e) {
  if (!s || typeof s != "object")
    return !1;
  if (Array.isArray(s)) {
    for (let t = 0, i = s.length; t < i; t++)
      if (fl(s[t]))
        return !0;
    return !1;
  }
  if (xp(s))
    return !0;
  if (s.toJSON && typeof s.toJSON == "function" && arguments.length === 1)
    return fl(s.toJSON(), !0);
  for (const t in s)
    if (Object.prototype.hasOwnProperty.call(s, t) && fl(s[t]))
      return !0;
  return !1;
}
function EC(s) {
  const e = [], t = s.data, i = s;
  return i.data = od(t, e), i.attachments = e.length, { packet: i, buffers: e };
}
function od(s, e) {
  if (!s)
    return s;
  if (xp(s)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(s), t;
  } else if (Array.isArray(s)) {
    const t = new Array(s.length);
    for (let i = 0; i < s.length; i++)
      t[i] = od(s[i], e);
    return t;
  } else if (typeof s == "object" && !(s instanceof Date)) {
    const t = {};
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && (t[i] = od(s[i], e));
    return t;
  }
  return s;
}
function XC(s, e) {
  return s.data = ld(s.data, e), delete s.attachments, s;
}
function ld(s, e) {
  if (!s)
    return s;
  if (s && s._placeholder === !0) {
    if (typeof s.num == "number" && s.num >= 0 && s.num < e.length)
      return e[s.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(s))
    for (let t = 0; t < s.length; t++)
      s[t] = ld(s[t], e);
  else if (typeof s == "object")
    for (const t in s)
      Object.prototype.hasOwnProperty.call(s, t) && (s[t] = ld(s[t], e));
  return s;
}
const MC = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], _C = 5;
var ke;
(function(s) {
  s[s.CONNECT = 0] = "CONNECT", s[s.DISCONNECT = 1] = "DISCONNECT", s[s.EVENT = 2] = "EVENT", s[s.ACK = 3] = "ACK", s[s.CONNECT_ERROR = 4] = "CONNECT_ERROR", s[s.BINARY_EVENT = 5] = "BINARY_EVENT", s[s.BINARY_ACK = 6] = "BINARY_ACK";
})(ke || (ke = {}));
class LC {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(e) {
    this.replacer = e;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(e) {
    return (e.type === ke.EVENT || e.type === ke.ACK) && fl(e) ? this.encodeAsBinary({
      type: e.type === ke.EVENT ? ke.BINARY_EVENT : ke.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(e) {
    let t = "" + e.type;
    return (e.type === ke.BINARY_EVENT || e.type === ke.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(e) {
    const t = EC(e), i = this.encodeAsString(t.packet), n = t.buffers;
    return n.unshift(i), n;
  }
}
function hm(s) {
  return Object.prototype.toString.call(s) === "[object Object]";
}
class bp extends ot {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(e) {
    super(), this.reviver = e;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const i = t.type === ke.BINARY_EVENT;
      i || t.type === ke.BINARY_ACK ? (t.type = i ? ke.EVENT : ke.ACK, this.reconstructor = new zC(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
    } else if (xp(e) || e.base64)
      if (this.reconstructor)
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(e) {
    let t = 0;
    const i = {
      type: Number(e.charAt(0))
    };
    if (ke[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === ke.BINARY_EVENT || i.type === ke.BINARY_ACK) {
      const r = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; )
        ;
      const a = e.substring(r, t);
      if (a != Number(a) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(a);
    }
    if (e.charAt(t + 1) === "/") {
      const r = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); )
        ;
      i.nsp = e.substring(r, t);
    } else
      i.nsp = "/";
    const n = e.charAt(t + 1);
    if (n !== "" && Number(n) == n) {
      const r = t + 1;
      for (; ++t; ) {
        const a = e.charAt(t);
        if (a == null || Number(a) != a) {
          --t;
          break;
        }
        if (t === e.length)
          break;
      }
      i.id = Number(e.substring(r, t + 1));
    }
    if (e.charAt(++t)) {
      const r = this.tryParse(e.substr(t));
      if (bp.isPayloadValid(i.type, r))
        i.data = r;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case ke.CONNECT:
        return hm(t);
      case ke.DISCONNECT:
        return t === void 0;
      case ke.CONNECT_ERROR:
        return typeof t == "string" || hm(t);
      case ke.EVENT:
      case ke.BINARY_EVENT:
        return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && MC.indexOf(t[0]) === -1);
      case ke.ACK:
      case ke.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class zC {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const t = XC(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const IC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: bp,
  Encoder: LC,
  get PacketType() {
    return ke;
  },
  protocol: _C
}, Symbol.toStringTag, { value: "Module" }));
function yi(s, e, t) {
  return s.on(e, t), function() {
    s.off(e, t);
  };
}
const qC = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class ty extends ot {
  /**
   * `Socket` constructor.
   */
  constructor(e, t, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      yi(e, "open", this.onopen.bind(this)),
      yi(e, "packet", this.onpacket.bind(this)),
      yi(e, "error", this.onerror.bind(this)),
      yi(e, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(e, ...t) {
    var i, n, r;
    if (qC.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(t), this;
    const a = {
      type: ke.EVENT,
      data: t
    };
    if (a.options = {}, a.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") {
      const h = this.ids++, u = t.pop();
      this._registerAckCallback(h, u), a.id = h;
    }
    const o = (n = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || n === void 0 ? void 0 : n.writable, l = this.connected && !(!((r = this.io.engine) === null || r === void 0) && r._hasPingExpired());
    return this.flags.volatile && !o || (l ? (this.notifyOutgoingListeners(a), this.packet(a)) : this.sendBuffer.push(a)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(e, t) {
    var i;
    const n = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (n === void 0) {
      this.acks[e] = t;
      return;
    }
    const r = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      t.call(this, new Error("operation has timed out"));
    }, n), a = (...o) => {
      this.io.clearTimeoutFn(r), t.apply(this, o);
    };
    a.withError = !0, this.acks[e] = a;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(e, ...t) {
    return new Promise((i, n) => {
      const r = (a, o) => a ? n(a) : i(o);
      r.withError = !0, t.push(r), this.emit(e, ...t);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == "function" && (t = e.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((n, ...r) => i !== this._queue[0] ? void 0 : (n !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), t && t(n)) : (this._queue.shift(), t && t(null, ...r)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const t = this._queue[0];
    t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(e) {
    this.packet({
      type: ke.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(e, t) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((e) => {
      if (!this.sendBuffer.some((i) => String(i.id) === e)) {
        const i = this.acks[e];
        delete this.acks[e], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case ke.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case ke.EVENT:
        case ke.BINARY_EVENT:
          this.onevent(e);
          break;
        case ke.ACK:
        case ke.BINARY_ACK:
          this.onack(e);
          break;
        case ke.DISCONNECT:
          this.ondisconnect();
          break;
        case ke.CONNECT_ERROR:
          this.destroy();
          const i = new Error(e.data.message);
          i.data = e.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const i of t)
        i.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(e) {
    const t = this;
    let i = !1;
    return function(...n) {
      i || (i = !0, t.packet({
        type: ke.ACK,
        id: e,
        data: n
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" && (delete this.acks[e.id], t.withError && e.data.unshift(null), t.apply(this, e.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(e, t) {
    this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: ke.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(e) {
    return this.flags.compress = e, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const t = this._anyListeners;
      for (let i = 0; i < t.length; i++)
        if (e === t[i])
          return t.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let i = 0; i < t.length; i++)
        if (e === t[i])
          return t.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const i of t)
        i.apply(this, e.data);
    }
  }
}
function Qr(s) {
  s = s || {}, this.ms = s.min || 100, this.max = s.max || 1e4, this.factor = s.factor || 2, this.jitter = s.jitter > 0 && s.jitter <= 1 ? s.jitter : 0, this.attempts = 0;
}
Qr.prototype.duration = function() {
  var s = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), t = Math.floor(e * this.jitter * s);
    s = (Math.floor(e * 10) & 1) == 0 ? s - t : s + t;
  }
  return Math.min(s, this.max) | 0;
};
Qr.prototype.reset = function() {
  this.attempts = 0;
};
Qr.prototype.setMin = function(s) {
  this.ms = s;
};
Qr.prototype.setMax = function(s) {
  this.max = s;
};
Qr.prototype.setJitter = function(s) {
  this.jitter = s;
};
class cd extends ot {
  constructor(e, t) {
    var i;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, Zc(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((i = t.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Qr({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
    const n = t.parser || IC;
    this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new QC(this.uri, this.opts);
    const t = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const n = yi(t, "open", function() {
      i.onopen(), e && e();
    }), r = (o) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", o), e ? e(o) : this.maybeReconnectOnOpen();
    }, a = yi(t, "error", r);
    if (this._timeout !== !1) {
      const o = this._timeout, l = this.setTimeoutFn(() => {
        n(), r(new Error("timeout")), t.close();
      }, o);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(n), this.subs.push(a), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(e) {
    return this.open(e);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(
      yi(e, "ping", this.onping.bind(this)),
      yi(e, "data", this.ondata.bind(this)),
      yi(e, "error", this.onerror.bind(this)),
      yi(e, "close", this.onclose.bind(this)),
      // @ts-ignore
      yi(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose("parse error", t);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(e) {
    Yc(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(e) {
    this.emitReserved("error", e);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(e, t) {
    let i = this.nsps[e];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new ty(this, e, t), this.nsps[e] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const i of t)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let i = 0; i < t.length; i++)
      this.engine.write(t[i], e.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(e, t) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((n) => {
          n ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", n)) : e.onreconnect();
        }));
      }, t);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const qr = {};
function pl(s, e) {
  typeof s == "object" && (e = s, s = void 0), e = e || {};
  const t = CC(s, e.path || "/socket.io"), i = t.source, n = t.id, r = t.path, a = qr[n] && r in qr[n].nsps, o = e.forceNew || e["force new connection"] || e.multiplex === !1 || a;
  let l;
  return o ? l = new cd(i, e) : (qr[n] || (qr[n] = new cd(i, e)), l = qr[n]), t.query && !e.query && (e.query = t.queryKey), l.socket(t.path, e);
}
Object.assign(pl, {
  Manager: cd,
  Socket: ty,
  io: pl,
  connect: pl
});
const Pe = [], DC = (s) => {
  Pe.push(s);
}, um = (s) => {
  const e = Pe.findIndex((i) => i.uniqueId === s);
  if (e === -1)
    return;
  const t = Pe[e];
  return Pe.splice(e, 1), t;
}, iy = [
  "a[href]",
  "area[href]",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "iframe",
  "[tabindex]",
  "[contentEditable=true]"
].reduce((s, e, t) => `${s}${t ? "," : ""}${e}:not([tabindex="-1"])`, "");
let Ch = !1;
const Gt = ({ from: s, stopAtRootElement: e, ignoreElement: t = [], allowSelectors: i, direction: n = "forwards", wrap: r }) => {
  let a, o = !1;
  if (s instanceof Element)
    o = la(s), a = s;
  else {
    if (s === "activeElement") {
      const g = document.activeElement;
      o = la(g), a = dm(g);
    }
    typeof s == "object" && (s.getActiveElement && (a = dm(s.el)), o = s.isIframe);
  }
  const l = a, c = l.parentElement, h = o, u = l, d = iy + (i ? "," + i.join(",") : "");
  if (!u)
    return null;
  const f = (g, m) => {
    let O = !1;
    const x = g.children, b = x.length;
    if (Ch && (O = !0), n === "forwards")
      for (let v = 0; v < b; v++) {
        const y = x[v];
        if (O) {
          const w = jl(y, d, n, t);
          if (w)
            return w;
          continue;
        }
        if (y === e)
          return null;
        if (y === m) {
          O = !0;
          continue;
        }
      }
    else
      for (let v = b - 1; v >= 0; v--) {
        const y = x[v];
        if (O) {
          const w = jl(y, d, n, t);
          if (w)
            return w;
          continue;
        }
        if (y === e)
          return null;
        if (y === m) {
          O = !0;
          continue;
        }
      }
    if (m = g, g = g.parentElement, !g && h) {
      const v = document.activeElement;
      v && la(v) && (m = v, g = v.parentElement);
    }
    return g ? f(g, m) : null;
  };
  let p = f(c, u);
  return !p && r && e && (Ch = !0, p = Gt({
    from: e,
    allowSelectors: i,
    direction: n,
    ignoreElement: t,
    // stopAtElement,
    wrap: !1
  })), Ch = !1, p;
}, sy = (s) => {
  try {
    return s.contentWindow;
  } catch {
    return null;
  }
}, BC = (s) => {
  const e = sy(s);
  return e ? e.document : null;
}, dm = (s) => {
  if (!la(s))
    return s;
  const e = BC(s);
  return e && e.activeElement || s;
}, fm = (s, e = window) => {
  const t = (n) => n.display === "none" || n.visibility === "hidden";
  if (s.style && t(s.style) || s.hidden)
    return !0;
  const i = e.getComputedStyle(s);
  return !!(!i || t(i));
}, jl = (s, e = iy, t = "forwards", i = [], n = window, r = !0) => {
  const a = (u) => {
    if (!u.matches(e))
      return {
        el: u,
        matched: !1
      };
    const d = u.getAttribute("tabindex");
    if (la(u) && (!d || d === "-1")) {
      const f = sy(u);
      return f ? (u = f.document.documentElement, n = f, { el: u, matched: !1, windowContext: f }) : { el: u, matched: !0 };
    }
    return {
      el: u,
      matched: !0
    };
  };
  if (r) {
    if (i.some((p) => p === s) || fm(s, n))
      return null;
    const { el: u, matched: d, windowContext: f } = a(s);
    return s = u, d ? s : (n = f || n, jl(s, e, t, i, n, !1));
  }
  const o = s.shadowRoot;
  o && (s = o);
  const l = s.children, c = l.length, h = (u) => {
    if (i.some((m) => m === u) || fm(u, n))
      return {
        continue: !0
      };
    const { el: d, matched: f, windowContext: p } = a(u);
    if (u = d, n = p || n, f)
      return { returnVal: u };
    const g = jl(u, e, t, i, n, !1);
    return g ? { returnVal: g } : null;
  };
  if (t === "forwards")
    for (let u = 0; u < c; u++) {
      let d = l[u];
      const f = h(d);
      if (f) {
        if (f.continue)
          continue;
        if (f.returnVal)
          return f.returnVal;
      }
    }
  else
    for (let u = c - 1; u >= 0; u--) {
      let d = l[u];
      const f = h(d);
      if (f) {
        if (f.continue)
          continue;
        if (f.returnVal)
          return f.returnVal;
      }
    }
  return null;
}, la = (s) => s.tagName === "IFRAME", yp = (s) => s.offsetHeight === 0 && s.offsetWidth === 0, ny = (s) => Object.getPrototypeOf(s) === Object.prototype, ht = (s, { inputElement: e, type: t, subType: i }) => {
  if (e === "menuPopup")
    return s.menuPopupEl;
  if (e === "menuButton")
    return mi(s.menuBtnEls);
  if (t === "focusElementOnOpen") {
    if (ny(e))
      return ht(s, {
        inputElement: e.target,
        type: "focusElementOnOpen"
      });
    if (e === "none")
      return null;
    if (e === "firstChild")
      return Gt({
        from: s.focusSentinelBeforeEl,
        stopAtRootElement: s.containerEl
      });
    if (typeof e == "string")
      return s.containerEl?.querySelector(e);
    if (e instanceof Element)
      return e;
    if (typeof e == "object")
      return ht(s, {
        inputElement: e.target,
        type: "focusElementOnOpen"
      });
    const n = e();
    return typeof n == "string" ? s.containerEl?.querySelector(n) : n;
  }
  if (e == null && t === "menuPopup")
    return s.containerEl ? s.menuPopupEl ? s.menuPopupEl : s.containerEl.children[1] : null;
  if (typeof e == "string" && t === "menuButton" || typeof e == "string")
    return document.querySelector(e);
  if (e instanceof Element)
    return e;
  if (typeof e == "function") {
    const n = e();
    if (n instanceof Element)
      return n;
    if (t === "closeButton")
      return s.containerEl ? s.containerEl.querySelector(n) : null;
  }
  if (t === "focusElementOnClose") {
    if (!e)
      return null;
    switch (i) {
      case "tabForwards":
        return ht(s, { inputElement: e.tabForwards });
      case "tabBackwards":
        return ht(s, { inputElement: e.tabBackwards });
      case "click":
        return ht(s, { inputElement: e.click });
      case "escapeKey":
        return ht(s, { inputElement: e.escapeKey });
      case "scrolling":
        return ht(s, { inputElement: e.scrolling });
    }
  }
  if (e == null)
    return null;
  if (Array.isArray(e))
    return e.map((n) => ht(s, { inputElement: n, type: t }));
  for (const n in e) {
    const r = e[n];
    return ht(s, { inputElement: r });
  }
  return null;
}, Hl = (s) => {
  const e = (t) => {
    const i = (r) => r.visibility === "hidden";
    if (t.style && i(t.style) || t.hidden)
      return !0;
    const n = window.getComputedStyle(t);
    return !!(!n || i(n));
  };
  return yp(s) || e(s);
}, Qi = (s, e, t) => {
  for (let i = s.length - 1; i >= 0; i--) {
    const { item: n, continue: r } = e(s[i]);
    if (n && t(n), !r)
      return;
  }
}, WC = (s, e) => {
  const { timeouts: t, closeWhenMenuButtonIsClicked: i, focusedMenuBtn: n, onClickOutsideMenuButtonRef: r, setOpen: a, open: o, deadMenuButton: l, closeWhenClickingOutside: c } = s;
  s.menuBtnMouseDownFired = !1;
  const h = e.currentTarget;
  if (he.focusedMenuBtns.forEach((u) => u.el = null), !l) {
    if (s.menuBtnKeyupTabFired = !1, n.el = h, he.focusedMenuBtns.add(n), !c) {
      const u = Pe[Pe.length - 1];
      u && !u.menuBtnEls.includes(h) && !u.containerEl.contains(h) && Qi(Pe, (d) => ({ item: d, continue: !0 }), (d) => {
        const { setOpen: f } = d;
        f(!1);
      });
    }
    if (!i) {
      a(!0);
      return;
    }
    o() && (he.closedByEvents = !0), a(!o());
  }
}, YC = (s, e) => {
  const { containerEl: t, focusedMenuBtn: i, overlay: n, setOpen: r, timeouts: a, menuBtnMouseDownFired: o, closeWhenDocumentBlurs: l, closeWhenClickingOutside: c, open: h } = s, u = e.currentTarget;
  if (queueMicrotask(() => {
    ly();
  }), s.menuBtnKeyupTabFired) {
    s.menuBtnKeyupTabFired = !1;
    return;
  }
  if (o || t && t.contains(e.relatedTarget))
    return;
  if (!c && h()) {
    document.addEventListener("keydown", Vc);
    return;
  }
  const d = he.clickTarget, f = () => {
    const p = document.activeElement;
    if (!e.relatedTarget && p && p.tagName, !(t && t.contains(p)) && !(!l && !document.hasFocus()) && !he.closedBySetOpen && u.isConnected) {
      if (Hl(u)) {
        let g = !1;
        if (s.menuBtnEls?.some((m) => m === u || Hl(m) ? !1 : d && !m.contains(d) ? (g = !0, !1) : (m.focus(), !0)), !g)
          return;
      }
      s.open() && (he.closedByEvents = !0, i.el = null, r(!1));
    }
  };
  a.menuButtonBlurTimeoutId = window.setTimeout(f);
}, ZC = (s, e) => {
  const { focusMenuButtonOnMouseDown: t } = s, i = e.currentTarget;
  s.menuBtnMouseDownFired = !0, i.addEventListener("click", s.onClickMenuButtonRef), t && (i.addEventListener("blur", s.onBlurMenuButtonRef), requestAnimationFrame(() => {
    i.focus();
  }));
}, NC = (s) => {
  s.focusedMenuBtn.el = null;
}, VC = (s, e) => {
  const { containerEl: t, setOpen: i, open: n, onKeydownMenuButtonRef: r, onBlurMenuButtonRef: a, mount: o, focusSentinelBeforeEl: l, focusSentinelAfterEl: c, ignoreMenuPopupWhenTabbing: h } = s, u = e.currentTarget;
  if (e.key !== "Tab" || (he.focusedMenuBtns.forEach((f) => f.el = null), !n()))
    return;
  if (s.menuBtnKeyupTabFired = !0, e.key === "Tab" && e.shiftKey) {
    if (he.closedByEvents = !0, !o || u.nextElementSibling !== t) {
      e.preventDefault();
      let f = Gt({
        from: u,
        direction: "backwards",
        ignoreElement: [
          t,
          l,
          c
        ]
      });
      f && f.focus();
    }
    i(!1), u.removeEventListener("keydown", r), u.removeEventListener("blur", a);
    return;
  }
  if (e.preventDefault(), h) {
    const f = Gt({
      from: u,
      direction: "forwards",
      ignoreElement: [
        t,
        l,
        c
      ]
    });
    f && f.focus(), i(!1), u.removeEventListener("keydown", r), u.removeEventListener("blur", a);
    return;
  }
  let d = Gt({
    from: l,
    stopAtRootElement: t
  });
  d ? d.focus() : t.focus(), d || (i(!1), d = Gt({
    from: l
  }), d && d.focus()), u.removeEventListener("keydown", r), u.removeEventListener("blur", a);
}, FC = (s, e) => {
  const { closeWhenMenuButtonIsTabbed: t, timeouts: i, deadMenuButton: n, menuBtnEls: r, focusedMenuBtn: a } = s, o = mi(r);
  if (o.addEventListener("click", s.onClickMenuButtonRef), o.addEventListener("blur", s.onBlurMenuButtonRef), o.addEventListener("keydown", s.onKeydownMenuButtonRef), a.el = e.currentTarget, window.setTimeout(() => {
  }), n) {
    o.addEventListener("blur", s.onBlurMenuButtonRef), o.addEventListener("keydown", s.onKeydownMenuButtonRef);
    return;
  }
  t || clearTimeout(i.containerFocusTimeoutId);
}, mi = (s) => {
  if (s)
    return s.length <= 1 ? s[0] : s.find((e) => {
      if (!(!e || yp(e)))
        return e;
    });
}, jC = ({ state: s, menuButton: e, open: t }) => {
  if (Array.isArray(e) && !e.length)
    return;
  const { focusedMenuBtn: i, containerEl: n } = s, r = ht(s, {
    inputElement: e,
    type: "menuButton"
  });
  if (!r)
    return;
  s.menuBtnEls = Array.isArray(r) ? r : [r];
  const a = Pe.find((o) => o.uniqueId === s.uniqueId);
  a && (a.menuBtnEls = s.menuBtnEls), s.menuBtnEls.forEach((o, l, c) => {
    if (HC(s, o), o.addEventListener("mousedown", s.onMouseDownMenuButtonRef), o.addEventListener("focus", s.onFocusMenuButtonRef), i.el && i.el !== o && (!(c.length > 1) || !yp(o))) {
      if (i.el = o, n && n.contains(document.activeElement))
        return;
      o.focus({ preventScroll: !0 });
    }
  });
}, HC = (s, e) => {
  const { modal: t, uniqueId: i, deadMenuButton: n } = s;
  if (!n) {
    if (e.hasAttribute("type"))
      return;
    e.setAttribute("type", "button"), e.setAttribute("aria-expanded", "false");
  }
  t && (e.setAttribute("aria-controls", i), e.setAttribute("aria-haspopup", "dialog"));
}, UC = (s) => {
  const { menuBtnEls: e, deadMenuButton: t } = s;
  t && e && e.forEach((i) => {
    i.setAttribute("aria-expanded", "true");
  });
}, GC = (s) => {
  const { menuBtnEls: e, deadMenuButton: t } = s;
  t && e && e.forEach((i) => {
    i.setAttribute("aria-expanded", "false");
  });
}, KC = (s, e) => {
  !s || !s.menuBtnEls || (s.menuBtnMouseDownFired = !1, s.menuBtnEls.forEach((t) => {
    e && (t.removeEventListener("blur", s.onBlurMenuButtonRef), t.removeEventListener("keydown", s.onKeydownMenuButtonRef), t.removeEventListener("click", s.onClickMenuButtonRef), t.removeEventListener("focus", s.onFocusMenuButtonRef), t.removeEventListener("mousedown", s.onMouseDownMenuButtonRef));
  }));
}, JC = (s) => {
  if (he.thirdPartyPopupEl)
    return he.thirdPartyPopupEl = null, null;
  if (!document.hasFocus())
    return null;
  const e = he.clickTarget, i = s.map((n) => document.querySelector(n)).find((n) => n && n.contains(e)) || null;
  return he.thirdPartyPopupEl = i, i;
}, eA = (s) => {
  for (let e of s) {
    const t = document.querySelector(e);
    if (t && !Hl(t))
      return t;
  }
  return null;
}, tA = () => {
  document.addEventListener("click", ry), document.addEventListener("keydown", ay, { capture: !0 });
}, Nc = () => {
  document.removeEventListener("click", ry), document.removeEventListener("keydown", ay, { capture: !0 }), he.thirdPartyPopupEl = null, he.thirdPartyPopupElPressedEscape = !1;
}, ry = (s) => {
  const e = s.target, { thirdPartyPopupEl: t } = he;
  t && t.contains(e) || Qi(Pe, (i) => {
    const { containerEl: n } = i;
    return n.contains(e) ? { continue: !1 } : { item: i, continue: !0 };
  }, (i) => {
    const { setOpen: n } = i;
    he.closedByEvents = !0, n(!1), Nc();
  });
}, ay = (s) => {
  s.key === "Escape" && (he.thirdPartyPopupElPressedEscape = !0);
};
let Ah = !1, hd = !1, jn = null, oy = 0, ud = null, gl = null;
const he = {
  closedBySetOpen: !1,
  documentClickTimeout: null,
  closedByEvents: !1,
  focusedMenuBtns: /* @__PURE__ */ new Set(),
  cursorKeysPrevEl: null,
  clickTarget: null,
  overlayMouseDown: !1,
  thirdPartyPopupEl: null,
  thirdPartyPopupElPressedEscape: !1
};
let pm = null;
const ly = () => {
  clearTimeout(pm), pm = window.setTimeout(() => {
    he.clickTarget = null;
  });
}, vp = () => {
  document.removeEventListener("pointerup", vp);
}, cy = (s) => {
  const e = s.target;
  he.clickTarget = e, document.addEventListener("pointerup", vp);
}, hy = (s) => {
  const e = Pe[Pe.length - 1];
  setTimeout(() => {
    const i = s.timeStamp - oy;
    if (!document.hasFocus() && i < 50) {
      Qi(Pe, (n) => ({ item: n, continue: !0 }), (n) => {
        const { setOpen: r } = n;
        he.closedByEvents = !0, r(!1);
      });
      return;
    }
  });
  const t = (i) => {
    if (i.overlay || i.overlayEl || !i.closeWhenDocumentBlurs)
      return;
    mi(i.menuBtnEls).focus(), he.closedByEvents = !0, i.setOpen(!1);
  };
  e.overlay || setTimeout(() => {
    const i = document.activeElement;
    if (!i || i.tagName !== "IFRAME") {
      Qi(Pe, (n) => ({ item: n, continue: !0 }), (n) => t(n));
      return;
    }
    Qi(Pe, (n) => {
      const { containerEl: r } = n;
      return r.contains(i) ? (gl = i, py(), document.addEventListener("visibilitychange", fy), { continue: !1 }) : { item: n, continue: !0 };
    }, (n) => {
      const { setOpen: r } = n;
      he.closedByEvents = !0, r(!1);
    });
  });
}, Vc = (s) => {
  s.key === "Tab" && setTimeout(() => {
    const e = document.activeElement, t = Pe[0];
    document.removeEventListener("keydown", Vc), t && !t.menuBtnEls.some((i) => i && i.contains(e)) && Qi(Pe, (i) => ({ item: i, continue: !0 }), (i) => {
      const { setOpen: n } = i;
      n(!1);
    });
  });
}, uy = (s) => {
  const { setOpen: e, menuBtnEls: t, cursorKeys: i, closeWhenEscapeKeyIsPressed: n, focusElementOnClose: r, ignoreMenuPopupWhenTabbing: a, focusSentinelAfterEl: o, focusSentinelBeforeEl: l, mountedPopupsSafeList: c } = Pe[Pe.length - 1];
  if (s.key === "Tab") {
    if (a) {
      s.preventDefault();
      const u = s.shiftKey, d = mi(t), f = Gt({
        from: u ? l : o,
        direction: u ? "backwards" : "forwards",
        ignoreElement: d ? [d] : []
      });
      f && f.focus();
      return;
    }
    oy = s.timeStamp;
  }
  if (i && sA(s), s.key !== "Escape" || !n)
    return;
  if (he.thirdPartyPopupElPressedEscape) {
    he.thirdPartyPopupElPressedEscape = !1, Nc();
    return;
  }
  if (c && c.length) {
    const u = eA(c);
    if (u) {
      window.setTimeout(() => {
        !u.isConnected || Hl(u) || h();
      }, 100);
      return;
    }
  }
  function h() {
    const u = mi(t), d = ht({}, {
      inputElement: r,
      type: "focusElementOnClose",
      subType: "escapeKey"
    }) || u;
    d && d.focus(), he.closedByEvents = !0, e(!1);
  }
  h();
}, wp = (s) => {
  const e = s.target;
  ud !== e && Qi(Pe, (t) => {
    const { menuPopupEl: i } = t;
    return i.contains(e) ? (ud = e, { continue: !1 }) : { item: t, continue: !0 };
  }, (t) => {
    const { setOpen: i, focusElementOnClose: n, menuBtnEls: r } = t, a = mi(r);
    he.closedByEvents = !0, i(!1);
    const o = ht({}, {
      inputElement: n,
      type: "focusElementOnClose",
      subType: "scrolling"
    }) || a;
    o && o.focus();
  });
}, iA = (s) => {
  ud = null, !hd && s && (hd = !1, window.addEventListener("wheel", wp, {
    capture: !0,
    passive: !0
  }), document.body.addEventListener("touchmove", dy)), !Pe.length && (document.addEventListener("pointerdown", cy), document.addEventListener("pointerup", vp), document.addEventListener("keydown", uy), window.addEventListener("blur", hy));
}, gm = () => {
  Pe.length || (hd = !1, he.cursorKeysPrevEl = null, he.clickTarget = null, window.clearTimeout(he.documentClickTimeout), he.documentClickTimeout = null, document.removeEventListener("keydown", uy), document.removeEventListener("pointerdown", cy), document.removeEventListener("keydown", Vc), window.removeEventListener("blur", hy), window.removeEventListener("wheel", wp, {
    capture: !0
  }), document.body.removeEventListener("touchmove", dy));
}, dy = () => {
  Ah || (Ah = !0, document.body.addEventListener("touchend", () => {
    Ah = !1;
  }, { once: !0 }), window.addEventListener("scroll", wp, {
    capture: !0,
    passive: !0,
    once: !0
  }));
}, sA = (s) => {
  const e = ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], t = ["ArrowLeft", "ArrowRight"];
  if (!e.includes(s.key) || (s.preventDefault(), t.includes(s.key)))
    return;
  const { menuBtnEls: i, menuPopupEl: n, containerEl: r, focusSentinelBeforeEl: a, focusSentinelAfterEl: o, cursorKeys: l } = Pe[Pe.length - 1], c = mi(i);
  let h = he.cursorKeysPrevEl || document.activeElement, u;
  s.key === "ArrowDown" ? u = "forwards" : u = "backwards", (h === c || h === n || h === r) && (s.key === "ArrowUp" ? (u = "backwards", h = o) : (u = "forwards", h = a));
  const d = typeof l == "object", f = d && l.wrap;
  let p = Gt({
    from: h,
    direction: u,
    stopAtRootElement: n
  });
  if (!p && f) {
    const g = s.key === "ArrowDown" ? a : o;
    u = s.key === "ArrowDown" ? "forwards" : "backwards", p = Gt({
      from: g,
      direction: u,
      stopAtRootElement: r
    });
  }
  if (d && l.onKeyDown) {
    l.onKeyDown({
      currentEl: p,
      prevEl: he.cursorKeysPrevEl
    }), he.cursorKeysPrevEl = p;
    return;
  }
  p && p.focus();
}, fy = () => {
  if (document.visibilityState === "visible" && jn != null) {
    py();
    return;
  }
  clearTimeout(jn);
}, py = () => {
  const e = () => {
    const t = document.activeElement;
    if (t) {
      if (gl === t) {
        jn = window.setTimeout(e, 250);
        return;
      }
      Qi(Pe, (i) => {
        const { containerEl: n } = i;
        return t.tagName === "IFRAME" ? n && !n.contains(t) ? { item: i, continue: !0 } : (gl = t, jn = window.setTimeout(e, 250), { continue: !1 }) : n && !n.contains(t) ? { item: i, continue: !0 } : { continue: !1 };
      }, (i) => {
        const { setOpen: n } = i;
        he.closedByEvents = !0, n(!1), gl = null, jn = null, document.removeEventListener("visibilitychange", fy);
      });
    }
  };
  jn = window.setTimeout(e, 250);
}, nA = (s) => {
  const { menuPopup: e } = s;
  s.menuPopupAdded || (s.menuPopupEl = ht(s, {
    inputElement: e,
    type: "menuPopup"
  }), s.menuPopupEl && (s.menuPopupAdded = !0, s.menuPopupEl.setAttribute("tabindex", "-1")));
}, mm = (s) => {
  s.menuPopupEl && s.menuPopupAdded && (s.menuPopupEl = null, s.menuPopupAdded = !1);
}, rA = (s) => s.replace(/-./g, (e) => e.toUpperCase()[1]), dd = (s, e) => {
  const { onToggleScrollbar: t, removeScrollbar: i } = s;
  if (t) {
    if (e) {
      if (Pe.length > 1)
        return;
      t.onRemove();
    } else {
      if (Pe.length)
        return;
      t.onRestore();
    }
    return;
  }
  if (!i || Pe.length > 1)
    return;
  const n = document.scrollingElement;
  e ? n.style.overflow = "hidden" : n.style.overflow = "";
};
function aA(s) {
  requestAnimationFrame(() => {
    requestAnimationFrame(s);
  });
}
const oA = (s) => {
  let e, t = !0, i = !1, n, r = !1, a = !!s.overlay;
  const [o, l] = re(), [c, h] = re(), u = Dc(() => s.children), { onBeforeEnter: d, onEnter: f, onAfterEnter: p, onBeforeExit: g, onExit: m, onAfterExit: O, appendToElement: x, appear: b, state: v } = s, { onBeforeEnter: y, onEnter: w, onAfterEnter: S, onBeforeExit: k, onExit: A, onAfterExit: T, appendToElement: C } = s.overlay || {}, P = (q) => q === "content" ? d : y, $ = (q) => q === "content" ? f : w, R = (q) => q === "content" ? p : S, X = (q) => q === "content" ? g : k, M = (q) => q === "content" ? m : A, z = (q) => q === "content" ? O : T;
  function I(q, oe) {
    const ue = (q === "content" ? s.name : s.overlay?.name) || "s", pe = rA(oe) + "Class", Ee = (q === "content" ? s : s.overlay)[pe];
    return Ee ? Ee.split(" ") : [`${ue}-${oe}`];
  }
  const Y = (q, oe) => {
    const ae = q === "content" ? x : C;
    return ae ? ae === "menuPopup" && q !== "overlay" ? ht({ containerEl: oe }, { inputElement: null, type: "menuPopup" }) : typeof ae == "string" ? oe && oe.querySelector(ae) : ae : oe;
  };
  let V, N;
  function _(q, oe, ae) {
    if (r && (q === "content" ? V() : N()), !t || s.appear) {
      let mt = function(Ir) {
        ge && (!Ir || Ir.target === ge) && (ge.removeEventListener("transitionend", mt), ge.removeEventListener("animationend", mt), ge.classList.remove(...Vt), ge.classList.remove(...Je), Q0(() => {
          const bh = i ? n : oe;
          o() !== bh && l(bh), c() === bh && h(void 0);
        }), Ee && Ee(ge), s.mode === "inout" && U(q, ge, ae));
      };
      var ue = mt;
      const pe = $(q), be = P(q), Ee = R(q), He = I(q, "enter"), Vt = I(q, "enter-active"), Je = I(q, "enter-to"), ge = Y(q, oe);
      be && be(ge), ge.classList.add(...He), ge.classList.add(...Vt), requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          ge.classList.remove(...He), ge.classList.add(...Je);
        }), pe && pe(ge, () => mt()), requestAnimationFrame(() => {
          (!pe || pe.length < 2) && (ge.addEventListener("transitionend", mt), ge.addEventListener("animationend", mt));
        });
      });
    }
    if (q === "content") {
      const pe = i ? n : oe;
      ae && !s.mode ? h(pe) : l(pe);
    }
  }
  function U(q, oe, ae) {
    r = !0;
    const ue = M(q), pe = X(q), be = z(q), Ee = I(q, "exit"), He = I(q, "exit-active"), Vt = I(q, "exit-to"), Je = Y(q, oe), ge = Y(q, ae);
    if (!ge.parentNode)
      return mt();
    pe && pe(ge), ge.classList.add(...Ee), ge.classList.add(...He), aA(() => {
      ge.classList.remove(...Ee), ge.classList.add(...Vt);
    }), ue && ue(ge, () => mt()), (!ue || ue.length < 2) && (ge.addEventListener("transitionend", mt), ge.addEventListener("animationend", mt));
    function mt(Ir) {
      (!Ir || Ir.target === ge) && (r = !1, ge.removeEventListener("transitionend", mt), ge.removeEventListener("animationend", mt), q === "content" && (ge.classList.remove(...He), ge.classList.remove(...Vt)), q === "content" && (i && (ae.parentElement.remove(), dd(v, !1)), o() === ae && l(void 0)), be && be(ge), s.mode === "outin" && _(q, Je, ge));
    }
    q === "content" ? V = mt : N = mt;
  }
  return Yl((q) => {
    for (e = u(); typeof e == "function"; )
      e = e();
    if (e && e.nodeType === 3) {
      i = !0, n = e, n.willRemove = !1;
      const oe = e.portalContainerChild;
      if (a) {
        const ae = e.portalOverlay;
        Object.defineProperty(oe, "portalOverlay", {
          get() {
            return ae;
          },
          configurable: !0
        });
      }
      e = oe;
    }
    return St(() => (e && e !== q && (s.mode !== "outin" ? (_("content", e, q), a && _(
      "overlay",
      // @ts-ignore
      e.portalOverlay,
      // @ts-ignore
      q && q.portalOverlay
    )) : t && l(i ? n : e)), q && q !== e && s.mode !== "inout" && (U("content", e, q), a && U("overlay", e && e.portalOverlay, q.portalOverlay)), t = !1, e));
  }), [o, c];
}, Om = (s, { isCleanup: e = !1 } = {}) => {
  KC(s, e);
}, lA = (s, e) => {
  const { overlayElement: t, trapFocus: i, timeouts: n, closeWhenDocumentBlurs: r, mountedPopupsSafeList: a } = s;
  if (fd = !1, queueMicrotask(() => {
    ly();
  }), he.thirdPartyPopupEl && Nc(), he.closedBySetOpen || he.overlayMouseDown || t && i || !r && !document.hasFocus())
    return;
  const o = Pe.length;
  uA(n, () => {
    if (a && JC(a)) {
      tA();
      return;
    }
    o < Pe.length || (he.closedByEvents = !0, Qi(Pe, (l) => {
      const { containerEl: c, closeWhenClickingOutside: h } = l, u = he.clickTarget;
      return !h && u ? (document.addEventListener("keydown", Vc), { continue: !1 }) : u && c.contains(u) ? { continue: !1 } : c.contains(document.activeElement) ? { continue: !1 } : { item: l, continue: !0 };
    }, (l) => {
      const { setOpen: c } = l;
      c(!1);
    }));
  });
}, cA = (s, e) => {
  const { timeouts: t } = s;
  clearTimeout(t.containerFocusTimeoutId), clearTimeout(t.menuButtonBlurTimeoutId);
}, hA = (s) => {
  const { focusElementOnOpen: e, focusedMenuBtn: t } = s;
  if (e == null)
    return;
  const i = ht(s, {
    inputElement: e,
    type: "focusElementOnOpen"
  });
  i && setTimeout(() => {
    const n = ny(e) ? (
      // @ts-ignore
      !!e.preventScroll
    ) : i === s.menuPopupEl;
    i.focus({ preventScroll: n }), t.el = null;
  });
};
let fd = !1;
const uA = (s, e) => {
  s.containerFocusTimeoutId = window.setTimeout(() => {
    fd || (fd = !0, e());
  });
}, dA = () => {
  he.overlayMouseDown = !0;
}, fA = () => {
  he.overlayMouseDown = !1;
}, pA = (s) => {
  const { closeWhenOverlayClicked: e, menuPopupEl: t, focusElementOnClose: i, menuBtnEls: n } = s;
  if (he.overlayMouseDown = !1, !e) {
    t.focus({ preventScroll: !0 });
    return;
  }
  const r = mi(n), a = ht(s, {
    inputElement: i,
    type: "focusElementOnClose",
    subType: "click"
  }) || r;
  a && a.focus(), Qi(Pe, (o) => o.overlayElement ? { continue: !1 } : { item: o, continue: !0 }, (o) => {
    const { setOpen: l } = o;
    he.closedByEvents = !0, l(!1);
  }), he.closedByEvents = !0, s.setOpen(!1);
}, gA = ({ parent: s, matchEl: e }) => {
  if (s === e)
    return !0;
  const t = (i) => {
    if (!i)
      return !1;
    const n = i.children[0];
    return n === e ? !0 : t(n);
  };
  return t(s);
}, mA = (s) => {
  const { enableLastFocusSentinel: e, menuBtnEls: t, containerEl: i, focusSentinelAfterEl: n } = s;
  if (e) {
    n.setAttribute("tabindex", "0");
    return;
  }
  if (!t)
    return;
  const a = mi(t).nextElementSibling;
  gA({
    parent: a,
    matchEl: i
  }) || n.setAttribute("tabindex", "0");
}, xm = (s, e, t) => {
  const { uniqueId: i, containerEl: n, menuBtnEls: r, focusSentinelBeforeEl: a, trapFocus: o, focusSentinelAfterEl: l, closeWhenMenuButtonIsTabbed: c, focusElementOnClose: h, mount: u, open: d, setOpen: f } = s, p = mi(r);
  Pe.forEach((O) => window.clearTimeout(O.timeouts.containerFocusTimeoutId));
  const g = (O, x) => {
    Qi(Pe, (b) => x && mi(b.menuBtnEls) === O && !b.closeWhenMenuButtonIsTabbed ? { continue: !1 } : b.uniqueId === i || !b.containerEl.contains(O) ? { item: b, continue: !0 } : { continue: !1 }, (b) => {
      he.closedByEvents = !0, b.setOpen(!1);
    }), O && O.focus();
  };
  if (!d())
    return;
  if (p && (t === n || t === p)) {
    Gt({
      from: a,
      direction: "forwards",
      stopAtRootElement: n
    }).focus();
    return;
  }
  if (e === "before") {
    if (o) {
      Gt({
        from: l,
        direction: "backwards",
        stopAtRootElement: n
      }).focus();
      return;
    }
    if (c) {
      he.closedByEvents = !0, f(!1), p.focus();
      return;
    }
    const O = ht(s, {
      inputElement: h,
      type: "focusElementOnClose",
      subType: "tabBackwards"
    }) || p;
    if (!s.menuBtnEls) {
      O.focus();
      return;
    }
    g(O, !0);
    return;
  }
  if (o) {
    Gt({
      from: a,
      stopAtRootElement: n
    }).focus();
    return;
  }
  const m = ht(s, {
    inputElement: h,
    type: "focusElementOnClose",
    subType: "tabForwards"
  }) || Gt({
    from: p,
    ignoreElement: [n]
  });
  if (u) {
    g(m);
    return;
  }
  m && m.focus(), he.closedByEvents = !0, f(!1);
}, OA = "http://www.w3.org/2000/svg";
function xA(s, e = !1) {
  return e ? document.createElementNS(OA, s) : document.createElement(s);
}
function bA(s) {
  const {
    useShadow: e,
    isModal: t
  } = s, i = document.createTextNode(""), n = s.mount || document.body;
  function r() {
    if (ve.context) {
      const [a, o] = re(!1);
      return queueMicrotask(() => o(!0)), () => a() && s.children;
    } else return () => s.children;
  }
  if (n instanceof HTMLHeadElement) {
    const [a, o] = re(!1), l = () => o(!0);
    gn((c) => W(n, () => a() ? c() : r()(), null)), ii(() => {
      ve.context ? queueMicrotask(l) : l();
    });
  } else {
    const a = xA(s.isSVG ? "g" : "div", s.isSVG), o = e && a.attachShadow ? a.attachShadow({
      mode: "open"
    }) : a, l = {
      get() {
        return i.parentNode;
      },
      configurable: !0
    };
    Object.defineProperty(a, "host", l), Object.defineProperty(a, "_$host", l), Object.defineProperty(i, "portalContainerChild", {
      get() {
        return c ? a.children[1] : a.firstElementChild;
      },
      configurable: !0
    }), Object.defineProperty(i, "portalContainer", {
      get() {
        return a;
      },
      configurable: !0
    }), Object.defineProperty(i, "portalMount", {
      get() {
        return n;
      },
      configurable: !0
    }), i.willRemove = !0, W(o, r());
    const c = s.overlayChildren;
    c && (Object.defineProperty(i, "portalOverlay", {
      get() {
        return c;
      },
      configurable: !0
    }), a.insertAdjacentElement("afterbegin", c)), n.appendChild(a), s.ref && s.ref(a), ii(() => {
      i.willRemove && n.removeChild(a);
    });
  }
  return i;
}
var yA = /* @__PURE__ */ K("<div role=presentation>"), vA = /* @__PURE__ */ K("<div><div style=position:fixed;top:0;left:0;outline:none;pointer-events:none;width:0;height:0; aria-hidden=true></div><div style=position:fixed;top:0;left:0;outline:none;pointer-events:none;width:0;height:0; aria-hidden=true>");
const wA = (s) => {
  const e = s.modal || !1, {
    id: t,
    menuButton: i,
    menuPopup: n,
    focusElementOnClose: r,
    focusElementOnOpen: a = e ? "menuPopup" : void 0,
    focusMenuButtonOnMouseDown: o = !0,
    cursorKeys: l = !1,
    closeWhenMenuButtonIsTabbed: c = !1,
    closeWhenMenuButtonIsClicked: h = !0,
    closeWhenScrolling: u = !1,
    closeWhenDocumentBlurs: d = !1,
    closeWhenOverlayClicked: f = !0,
    closeWhenEscapeKeyIsPressed: p = !0,
    closeWhenClickingOutside: g = !0,
    overlay: m = e,
    overlayElement: O = e,
    trapFocus: x = e,
    removeScrollbar: b = e,
    enableLastFocusSentinel: v = !1,
    mount: y = e ? "body" : void 0,
    // stopComponentEventPropagation = false,
    show: w = !1,
    onToggleScrollbar: S,
    onOpen: k,
    deadMenuButton: A,
    ignoreMenuPopupWhenTabbing: T,
    mountedPopupsSafeList: C
  } = s, P = {
    mount: y,
    modal: e,
    addedFocusOutAppEvents: !1,
    closeWhenOverlayClicked: f,
    closeWhenDocumentBlurs: d,
    closeWhenEscapeKeyIsPressed: p,
    closeWhenMenuButtonIsClicked: h,
    closeWhenMenuButtonIsTabbed: c,
    closeWhenScrolling: u,
    closeWhenClickingOutside: g,
    cursorKeys: l,
    focusElementOnClose: r,
    focusMenuButtonOnMouseDown: o,
    deadMenuButton: A,
    focusElementOnOpen: a,
    ignoreMenuPopupWhenTabbing: T,
    // @ts-ignore
    id: t,
    uniqueId: YP(),
    menuBtnId: "",
    focusedMenuBtn: {
      el: null
    },
    menuBtnKeyupTabFired: !1,
    menuButton: i,
    timeouts: {
      containerFocusTimeoutId: null,
      menuButtonBlurTimeoutId: null
    },
    upperStackRemovedByFocusOut: !1,
    menuPopup: n,
    closeByDismissEvent: !1,
    menuPopupAdded: !1,
    enableLastFocusSentinel: v,
    overlay: m,
    overlayElement: O,
    onToggleScrollbar: S,
    removeScrollbar: b,
    trapFocus: x,
    hasFocusSentinels: !!r || m || !!O || x || v,
    mountedPopupsSafeList: C,
    open: s.open,
    setOpen: s.setOpen,
    onClickOutsideMenuButtonRef: () => NC(P),
    onClickOverlayRef: () => pA(P),
    onFocusInContainerRef: (_) => cA(P),
    onFocusOutContainerRef: (_) => lA(P),
    onBlurMenuButtonRef: (_) => YC(P, _),
    onClickMenuButtonRef: (_) => WC(P, _),
    onMouseDownMenuButtonRef: (_) => ZC(P, _),
    onFocusMenuButtonRef: (_) => FC(P, _),
    onKeydownMenuButtonRef: (_) => VC(P, _),
    refContainerCb: (_) => {
      if (O && (_.style.zIndex = "1000", e)) {
        _.style.pointerEvents = "none", _.style.position = "relative";
        const U = (q) => {
          q.id || (q.id = P.uniqueId), q.style.pointerEvents = "all", q.setAttribute("role", "dialog");
        };
        requestAnimationFrame(() => {
          const q = _.querySelector('[role="dialog"]');
          if (!q) {
            const oe = _.children;
            if (!oe) return;
            const ae = oe[1];
            U(ae);
            return;
          }
          U(q);
        });
      }
      s.ref && s.ref(_), P.containerEl = _;
    },
    refOverlayCb: (_) => {
      _.style.position = "fixed", _.style.top = "0", _.style.left = "0", _.style.width = "100%", _.style.height = "calc(100% + 100px)", _.style.zIndex = "1000", typeof O == "object" && O.ref && O.ref(_), P.overlayEl = _;
    }
  }, $ = !s.open(), R = () => {
    const _ = document.activeElement;
    if (_ !== document.body && P.menuBtnEls.every((pe) => _ !== pe) && !P.containerEl?.contains(_))
      return;
    const {
      menuBtnEls: U,
      focusedMenuBtn: q,
      timeouts: oe
    } = P, ae = mi(U), ue = ht(P, {
      inputElement: r,
      type: "focusElementOnClose",
      subType: "click"
    }) || ae;
    ue && ue.focus();
  }, X = () => typeof y == "string" ? document.querySelector(y) : y, M = () => {
    if (he.closedByEvents) return;
    const _ = document.activeElement;
    if (
      // activeElement !== state.menuBtnEls
      P.menuBtnEls.every((U) => _ !== U) && !P.containerEl?.contains(_)
    ) {
      setTimeout(() => {
        he.closedBySetOpen = !1;
      });
      return;
    }
    he.closedBySetOpen || (he.closedBySetOpen = !0, setTimeout(() => {
      he.closedBySetOpen = !1, R();
    }));
  };
  Yl(ms(() => !!s.open(), (_, U) => {
    _ !== U && (_ || (P.focusSentinelAfterEl && (P.focusSentinelAfterEl.tabIndex = -1), M()));
  }, {
    defer: $
  })), Jt(ms(() => typeof s.menuButton == "function" ? s.menuButton() : s.menuButton, (_) => {
    jC({
      state: P,
      menuButton: _,
      open: s.open
    }), ii(() => {
    });
  })), Jt(ms(() => !!s.open(), (_, U) => {
    _ !== U && (_ ? (he.closedByEvents = !1, nA(P), hA(P), UC(P), iA(u), DC({
      // @ts-ignore
      id: t,
      uniqueId: P.uniqueId,
      open: s.open,
      setOpen: s.setOpen,
      containerEl: P.containerEl,
      menuBtnEls: P.menuBtnEls,
      focusedMenuBtn: P.focusedMenuBtn,
      overlayEl: P.overlayEl,
      menuPopupEl: P.menuPopupEl,
      overlay: m,
      closeWhenDocumentBlurs: d,
      closeWhenEscapeKeyIsPressed: p,
      closeWhenMenuButtonIsTabbed: c,
      closeWhenClickingOutside: g,
      overlayElement: O,
      cursorKeys: l,
      focusElementOnClose: r,
      focusSentinelBeforeEl: P.focusSentinelBeforeEl,
      focusSentinelAfterEl: P.focusSentinelAfterEl,
      ignoreMenuPopupWhenTabbing: T,
      upperStackRemovedByFocusOut: !1,
      detectIfMenuButtonObscured: !1,
      queueRemoval: !1,
      mountedPopupsSafeList: P.mountedPopupsSafeList,
      timeouts: P.timeouts
    }), k && k(_, {
      uniqueId: P.uniqueId,
      dismissStack: Pe
    }), dd(P, _), mA(P)) : (GC(P), he.closedByEvents = !1, Om(P), mm(P), um(P.uniqueId), gm(), Nc(), k && k(_, {
      uniqueId: P.uniqueId,
      dismissStack: Pe
    }), s.animation || dd(P, _)));
  }, {
    defer: $
  })), ii(() => {
    Om(P, {
      isCleanup: !0
    }), mm(P), um(P.uniqueId), gm();
  });
  function z() {
    return typeof s.overlayElement == "object" && s.overlayElement.element ? s.overlayElement.element : (() => {
      var _ = yA(), U = P.refOverlayCb;
      return typeof U == "function" ? wi(U, _) : P.refOverlayCb = _, Yn(_, "mouseup", fA, !0), Yn(_, "mousedown", dA, !0), Yn(_, "click", P.onClickOverlayRef, !0), Ae((q) => {
        var oe = typeof s.overlayElement == "object" ? s.overlayElement.class : void 0, ae = typeof s.overlayElement == "object" ? s.overlayElement.classList || {} : {};
        return oe !== q.e && Os(_, q.e = oe), q.t = Vl(_, ae, q.t), q;
      }, {
        e: void 0,
        t: void 0
      }), _;
    })();
  }
  function I(_) {
    return (() => {
      var U = vA(), q = U.firstChild, oe = q.nextSibling, ae = P.refContainerCb;
      typeof ae == "function" ? wi(ae, U) : P.refContainerCb = U, Yn(U, "focusout", P.onFocusOutContainerRef, !0), Yn(U, "focusin", P.onFocusInContainerRef, !0);
      var ue = P.focusSentinelBeforeEl;
      typeof ue == "function" ? wi(ue, q) : P.focusSentinelBeforeEl = q, q.addEventListener("focus", (be) => {
        xm(P, "before", be.relatedTarget);
      }), W(U, _, oe);
      var pe = P.focusSentinelAfterEl;
      return typeof pe == "function" ? wi(pe, oe) : P.focusSentinelAfterEl = oe, oe.addEventListener("focus", () => {
        xm(P, "after");
      }), Ae((be) => {
        var Ee = P.id, He = s.class, Vt = s.classList || {}, Je = s.open() ? "0" : "-1", ge = s.open() && P.hasFocusSentinels ? "0" : "-1";
        return Ee !== be.e && Fe(U, "id", be.e = Ee), He !== be.t && Os(U, be.t = He), be.a = Vl(U, Vt, be.a), Je !== be.o && Fe(q, "tabindex", be.o = Je), ge !== be.i && Fe(oe, "tabindex", be.i = ge), be;
      }, {
        e: void 0,
        t: void 0,
        a: void 0,
        o: void 0,
        i: void 0
      }), U;
    })();
  }
  if (w) return I(s.children);
  let Y = !1;
  const V = Ve(() => s.open(), !1, {
    equals: (_, U) => Y ? _ === U : !_ == !U
  }), N = Ve(() => {
    const _ = V();
    if (_) {
      const U = s.children, q = typeof U == "function" && U.length > 0;
      return Y = q, q ? St(() => U(_)) : y ? B(bA, {
        get mount() {
          return X();
        },
        get overlayChildren() {
          return O ? z() : null;
        },
        get children() {
          return I(U);
        }
      }) : I(U);
    }
  });
  return s.animation ? B(oA, wn(() => s.animation, {
    get name() {
      return s.animation.name;
    },
    get enterClass() {
      return s.animation.enterClass;
    },
    get enterActiveClass() {
      return s.animation.enterActiveClass;
    },
    get enterToClass() {
      return s.animation.enterToClass;
    },
    get exitClass() {
      return s.animation.exitClass;
    },
    get exitActiveClass() {
      return s.animation.exitActiveClass;
    },
    get exitToClass() {
      return s.animation.exitToClass;
    },
    get appear() {
      return s.animation.appear;
    },
    get overlay() {
      return typeof s.overlayElement == "object" ? s.overlayElement.animation : void 0;
    },
    state: P,
    get children() {
      return N();
    }
  })) : N;
};
_t(["click", "mousedown", "mouseup", "focusin", "focusout"]);
var SA = /* @__PURE__ */ K("<svg>");
const ri = (s) => {
  const [e, t] = dp(s, ["path"]);
  return (() => {
    var i = SA();
    return Wc(i, wn({
      get viewBox() {
        return e.path.mini ? "0 0 20 20" : "0 0 24 24";
      },
      get fill() {
        return e.path.outline ? "none" : "currentColor";
      },
      get stroke() {
        return e.path.outline ? "currentColor" : "none";
      },
      get "stroke-width"() {
        return e.path.outline ? 1.5 : void 0;
      }
    }, t), !0, !0), W(i, () => e.path.path), i;
  })();
};
var kA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"></svg>', !1, !0, !1), PA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></svg>', !1, !0, !1), QA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M17.25 6.75L22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3l-4.5 16.5"></svg>', !1, !0, !1), CA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M4.5 12a7.5 7.5 0 0015 0m-15 0a7.5 7.5 0 1115 0m-15 0H3m16.5 0H21m-1.5 0H12m-8.457 3.077l1.41-.513m14.095-5.13l1.41-.513M5.106 17.785l1.15-.964m11.49-9.642l1.149-.964M7.501 19.795l.75-1.3m7.5-12.99l.75-1.3m-6.063 16.658l.26-1.477m2.605-14.772l.26-1.477m0 17.726l-.26-1.477M10.698 4.614l-.26-1.477M16.5 19.794l-.75-1.299M7.5 4.205L12 12m6.894 5.785l-1.149-.964M6.256 7.178l-1.15-.964m15.352 8.864l-1.41-.513M4.954 9.435l-1.41-.514M12.002 12l-3.75 6.495"></svg>', !1, !0, !1), AA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"></svg>', !1, !0, !1), TA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9"></svg>', !1, !0, !1), $A = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z"></svg>', !1, !0, !1), RA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 006.16-12.12A14.98 14.98 0 009.631 8.41m5.96 5.96a14.926 14.926 0 01-5.841 2.58m-.119-8.54a6 6 0 00-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 00-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 01-2.448-2.448 14.9 14.9 0 01.06-.312m-2.24 2.39a4.493 4.493 0 00-1.757 4.306 4.493 4.493 0 004.306-1.758M16.5 9a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z"></svg>', !1, !0, !1), EA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"></svg>', !1, !0, !1), XA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"></svg>', !1, !0, !1), MA = /* @__PURE__ */ K('<svg><path stroke-linecap=round stroke-linejoin=round d="M9.75 9.75l4.5 4.5m0-4.5l-4.5 4.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></svg>', !1, !0, !1);
const _A = {
  path: () => kA(),
  outline: !0,
  mini: !1
}, LA = {
  path: () => PA(),
  outline: !0,
  mini: !1
}, zA = {
  path: () => QA(),
  outline: !0,
  mini: !1
}, IA = {
  path: () => CA(),
  outline: !0,
  mini: !1
}, qA = {
  path: () => AA(),
  outline: !0,
  mini: !1
}, DA = {
  path: () => TA(),
  outline: !0,
  mini: !1
}, BA = {
  path: () => $A(),
  outline: !0,
  mini: !1
}, WA = {
  path: () => RA(),
  outline: !0,
  mini: !1
}, gy = {
  path: () => EA(),
  outline: !0,
  mini: !1
}, YA = {
  path: () => XA(),
  outline: !0,
  mini: !1
}, ZA = {
  path: () => MA(),
  outline: !0,
  mini: !1
};
var NA = /* @__PURE__ */ K('<button class="flex cursor-alias items-center gap-2 px-2 py-2 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 leading-0 uppercase tracking-widest">'), VA = /* @__PURE__ */ K('<img class="h-8 w-8 rounded-full"crossorigin=anonymous>'), FA = /* @__PURE__ */ K('<button class="cursor-alias hidden md:block">'), jA = /* @__PURE__ */ K('<img class="h-10 w-10 rounded-full border-`1 border-neutral-200 dark:border-neutral-600 shadow-md"crossorigin=anonymous>'), HA = /* @__PURE__ */ K('<div class="dark:bg-neutral-900 absolute right-0 flex flex-col items-left justify-center bg-neutral-100 rounded-lg w-60 border border-neutral-600 dark:text-neutral-100 shadow-lg"> <div class="flex space-x-3 px-2 py-4 border-b border-neutral-600"> <div class=text-left> <p class="text-sm font-semibold text-gray-800 dark:text-gray-100"> <br><span class="text-xs text-gray-600 dark:text-gray-400 capitalize"></span></p></div></div><button class="flex cursor-alias items-center gap-2 px-4 py-2 text-left text-neutral-100 hover:bg-neutral-800"> Settings</button><button class="flex cursor-alias items-center gap-2 px-4 py-2 text-left text-neutral-100 hover:bg-neutral-800"> API Documentation</button><button class="flex cursor-alias items-center gap-2 px-4 py-2 text-left text-neutral-100 hover:bg-neutral-800"> Logout'), UA = /* @__PURE__ */ K('<header class="dark:bg-neutral-900 border-b z-12 sticky top-0 flex items-center bg-white gap-x-4 border-slate-200 p-0 px-2 text-sm dark:border-neutral-700 mb-0 inset-1"><div class="ml-auto md:flex md:flex-row md:items-center md:space-x-2"show></div><button type=button class="visible relative ml-auto rounded px-3 py-2 opacity-80 hover:opacity-100 md:hidden"title="Mobile Menu Button"><span class=sr-only>Show menu</span></button><div class="relative h-8 cursor-pointer leading-snug">'), GA = /* @__PURE__ */ K('<button class="flex cursor-alias flex-row items-center space-x-2 rounded px-2 py-2 opacity-80 hover:opacity-100 md:px-1"><h1 class="leading-0 uppercase tracking-widest flex items-center gap-2 text-left"> <b>Project</b> Board'), KA = /* @__PURE__ */ K('<button class="flex cursor-alias items-center gap-2 px-2 py-2 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 leading-0 uppercase tracking-widest"> Dashboard'), JA = /* @__PURE__ */ K('<button class="flex cursor-alias items-center gap-2 px-2 py-2 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 leading-0 uppercase tracking-widest"> Editor'), eT = /* @__PURE__ */ K('<button class="flex cursor-alias items-center gap-2 px-2 py-2 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 leading-0 uppercase tracking-widest"> TTS'), tT = /* @__PURE__ */ K('<button class="flex cursor-alias flex-row items-center gap-2 rounded px-2 py-1 opacity-80 hover:opacity-100 md:px-1 border border-neutral-600 rounded-md "> Login'), iT = /* @__PURE__ */ K('<div class="h-8 w-8 rounded-full bg-blue-600 text-white flex items-center justify-center font-semibold uppercase">'), sT = /* @__PURE__ */ K('<div class="h-8 w-8 rounded-full bg-blue-600 text-white flex items-center justify-center font-semibold uppercase border-2 border-gray-200 dark:border-gray-600 shadow-md">');
const Mn = (s) => {
  const [e, t] = re(!1), i = ss(), [n, r] = re(!1), [a, o] = re(!1), [l, c] = re(!1), [h, u] = re("");
  let d, f;
  Mi(), window.addEventListener("resize", p), ii(() => {
    window.removeEventListener("resize", p);
  });
  function p() {
    r(!1);
  }
  function g(m) {
    window.location.href = m;
  }
  return Jt(async () => {
    i.user()?.email && (i.user()?.image && u(i.user()?.image), c(!0));
  }), (() => {
    var m = UA(), O = m.firstChild, x = O.nextSibling, b = x.firstChild, v = x.nextSibling;
    W(m, () => s.children || [(() => {
      var w = GA(), S = w.firstChild, k = S.firstChild;
      return w.$$click = () => g("/"), W(S, B(ri, {
        path: DA,
        class: "h-6"
      }), k), w;
    })(), (() => {
      var w = KA(), S = w.firstChild;
      return w.$$click = () => g("/dashboard"), W(w, B(ri, {
        path: qA,
        class: "h-6"
      }), S), w;
    })(), (() => {
      var w = JA(), S = w.firstChild;
      return w.$$click = () => g("/editor"), W(w, B(ri, {
        path: zA,
        class: "h-6"
      }), S), w;
    })(), (() => {
      var w = eT(), S = w.firstChild;
      return w.$$click = () => g("/tts"), W(w, B(ri, {
        path: gy,
        class: "h-6"
      }), S), w;
    })()], O), Fe(O, "menubutton", () => d), O.open = n, Fe(O, "setopen", r), W(O, B(vi, {
      get when() {
        return l();
      },
      get children() {
        var w = NA();
        return w.$$click = () => g("/dashboard"), W(w, B(ri, {
          path: YA,
          class: "h-6"
        })), w;
      }
    }));
    var y = d;
    return typeof y == "function" ? wi(y, x) : d = x, W(x, B(vi, {
      get when() {
        return n();
      },
      get fallback() {
        return B(ri, {
          path: LA,
          class: "h-6 w-6"
        });
      },
      get children() {
        return B(ri, {
          path: ZA,
          class: "h-[22px] w-[22px]"
        });
      }
    }), b), W(v, B(vi, {
      get when() {
        return l();
      },
      get fallback() {
        return (() => {
          var w = tT(), S = w.firstChild;
          return w.$$click = () => g("/login"), W(w, B(ri, {
            path: BA,
            class: "h-6"
          }), S), w;
        })();
      },
      get children() {
        return [(() => {
          var w = FA(), S = f;
          return typeof S == "function" ? wi(S, w) : f = w, W(w, B(vi, {
            get when() {
              return i.user()?.image;
            },
            get fallback() {
              return (() => {
                var k = iT();
                return W(k, () => i.user()?.name?.[0] || i.user()?.email?.[0] || "U"), k;
              })();
            },
            get children() {
              var k = VA();
              return Ae((A) => {
                var T = `${Sn}/file/proxy?url=${encodeURIComponent(i.user()?.image || "")}`, C = i.user()?.name;
                return T !== A.e && Fe(k, "src", A.e = T), C !== A.t && Fe(k, "alt", A.t = C), A;
              }, {
                e: void 0,
                t: void 0
              }), k;
            }
          })), w;
        })(), B(wA, {
          menuButton: () => f,
          open: a,
          setOpen: o,
          get children() {
            var w = HA(), S = w.firstChild, k = S.nextSibling, A = k.firstChild, T = A.nextSibling, C = T.firstChild, P = C.nextSibling, $ = P.firstChild, R = $.nextSibling, X = R.nextSibling, M = k.nextSibling, z = M.firstChild, I = M.nextSibling, Y = I.firstChild, V = I.nextSibling, N = V.firstChild;
            return k.$$click = () => g("/profile"), W(k, B(vi, {
              get when() {
                return i.user()?.image;
              },
              get fallback() {
                return (() => {
                  var _ = sT();
                  return W(_, () => i.user()?.name?.[0] || i.user()?.email?.[0] || "U"), _;
                })();
              },
              get children() {
                var _ = jA();
                return Ae((U) => {
                  var q = `${Sn}/file/proxy?url=${encodeURIComponent(i.user()?.image || "")}`, oe = i.user()?.name;
                  return q !== U.e && Fe(_, "src", U.e = q), oe !== U.t && Fe(_, "alt", U.t = oe), U;
                }, {
                  e: void 0,
                  t: void 0
                }), _;
              }
            }), T), W(P, () => i.user()?.name || i.user()?.email || "User", $), W(X, () => i.user()?.role || "Member"), M.$$click = () => g("/settings"), W(M, B(ri, {
              path: IA,
              class: "h-7"
            }), z), I.$$click = () => g("/api"), W(I, B(ri, {
              path: WA,
              class: "h-7"
            }), Y), V.$$click = () => g("/logout"), W(V, B(ri, {
              path: _A,
              class: "h-7"
            }), N), w;
          }
        })];
      }
    })), Ae((w) => Vl(x, {
      "border-white border": n()
    }, w)), m;
  })();
};
_t(["click"]);
var nT = /* @__PURE__ */ K('<div class="flex h-screen flex-col bg-white dark:bg-neutral-900 dark:text-white"><div class="flex-1 overflow-auto scroll-smooth px-4 py-2 text-sm "><div id=outputMessage class="my-2 px-4 py-2"><pre class="font-normal whitespace-pre-wrap"></pre></div></div><div class="relative flex items-center justify-between gap-2 pb-4"><span>$</span><input type=text autofocus>'), rT = /* @__PURE__ */ K("<pre>"), aT = /* @__PURE__ */ K('<div class="z-10 rounded-md border border-neutral-600 bg-neutral-900 text-sm text-white shadow-lg"><div class="flex flex-col text-left">'), oT = /* @__PURE__ */ K('<button class="flex items-center gap-2 px-4 py-2 text-left text-neutral-100 hover:bg-neutral-800">'), lT = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg width=24 height=24 viewBox="0 0 24 24"><path fill=#fff d="m20.713 8.128l-.246.566a.506.506 0 0 1-.934 0l-.246-.566a4.36 4.36 0 0 0-2.22-2.25l-.759-.339a.53.53 0 0 1 0-.963l.717-.319a4.37 4.37 0 0 0 2.251-2.326l.253-.611a.506.506 0 0 1 .942 0l.253.61a4.37 4.37 0 0 0 2.25 2.327l.718.32a.53.53 0 0 1 0 .962l-.76.338a4.36 4.36 0 0 0-2.219 2.251M12 4a8 8 0 1 0 7.944 7.045l1.986-.236Q22 11.396 22 12c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2c.861 0 1.699.11 2.498.315L14 4.252A8 8 0 0 0 12 4m1 7h3l-5 7v-5H8l5-7z">'), cT = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg width=24 height=24 viewBox="0 0 24 24"><path fill=none stroke=#fff d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2M7 7h10M7 12h10M7 17h6">'), hT = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg width=24 height=24 viewBox="0 0 512 512"><path fill=#fff fill-rule=evenodd d="M256 42.667C138.18 42.667 42.667 138.179 42.667 256c0 117.82 95.513 213.334 213.333 213.334c117.822 0 213.334-95.513 213.334-213.334S373.822 42.667 256 42.667m0 384c-94.105 0-170.666-76.561-170.666-170.667S161.894 85.334 256 85.334c94.107 0 170.667 76.56 170.667 170.666S350.107 426.667 256 426.667m26.714-256c0 15.468-11.262 26.667-26.497 26.667c-15.851 0-26.837-11.2-26.837-26.963c0-15.15 11.283-26.37 26.837-26.37c15.235 0 26.497 11.22 26.497 26.666m-48 64h42.666v128h-42.666z">'), uT = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg width=24 height=24 viewBox="0 0 24 24"><path fill=#fff d="M4 21h9.62a4 4 0 0 0 3.037-1.397l5.102-5.952a1 1 0 0 0-.442-1.6l-1.968-.656a3.04 3.04 0 0 0-2.823.503l-3.185 2.547l-.617-1.235A3.98 3.98 0 0 0 9.146 11H4c-1.103 0-2 .897-2 2v6c0 1.103.897 2 2 2m0-8h5.146c.763 0 1.448.423 1.789 1.105l.447.895H7v2h6.014a1 1 0 0 0 .442-.11l.003-.001l.004-.002h.003l.002-.001h.004l.001-.001c.009.003.003-.001.003-.001c.01 0 .002-.001.002-.001h.001l.002-.001l.003-.001l.002-.001l.002-.001l.003-.001l.002-.001c.003 0 .001-.001.002-.001l.003-.002l.002-.001l.002-.001l.003-.001l.002-.001h.001l.002-.001h.001l.002-.001l.002-.001c.009-.001.003-.001.003-.001l.002-.001a1 1 0 0 0 .11-.078l4.146-3.317c.262-.208.623-.273.94-.167l.557.186l-4.133 4.823a2.03 2.03 0 0 1-1.52.688H4zM16 2h-.017c-.163.002-1.006.039-1.983.705c-.951-.648-1.774-.7-1.968-.704L12.002 2h-.004c-.801 0-1.555.313-2.119.878C9.313 3.445 9 4.198 9 5s.313 1.555.861 2.104l3.414 3.586a1.006 1.006 0 0 0 1.45-.001l3.396-3.568C18.688 6.555 19 5.802 19 5s-.313-1.555-.878-2.121A2.98 2.98 0 0 0 16.002 2zm1 3c0 .267-.104.518-.311.725L14 8.55l-2.707-2.843C11.104 5.518 11 5.267 11 5s.104-.518.294-.708A.98.98 0 0 1 11.979 4c.025.001.502.032 1.067.485q.121.098.247.222l.707.707l.707-.707q.126-.124.247-.222c.529-.425.976-.478 1.052-.484a1 1 0 0 1 .701.292c.189.189.293.44.293.707">');
function dT() {
  const [s, e] = re([]), [t, i] = re(null), [n, r] = re(""), [a, o] = re("/home/your-username"), [l, c] = re(""), [h, u] = re("Disconnected"), [d, f] = re(!1), [p, g] = re({
    x: 0,
    y: 0
  }), [m, O] = re([]);
  lo(), Mi(), Pr(), ss();
  let x, b;
  b && (b.disabled = !0);
  const v = ["Switch to AI", "Documentation", "Donate", "About"], y = (C) => {
    O(v.filter((P) => P.toLowerCase().includes(C.toLowerCase().slice(1))));
  }, w = (C) => {
    const P = C.currentTarget.value;
    if (r(P), P.startsWith("/")) {
      const $ = C.currentTarget.getBoundingClientRect();
      g({
        x: $.left,
        y: $.bottom
      }), f(!0), y(P);
    } else
      f(!1);
  }, S = () => {
    x && (x.scrollTop = x.scrollHeight);
  }, k = (C, P) => {
    if (C === "outputMessage" || C === "error" && P === "Authentication required") {
      const R = document.getElementById("outputMessage");
      R && (R.innerHTML = `<pre class="${C === "error" ? "text-red-500" : "text-yellow-500"} font-light whitespace-pre-wrap">${P}</pre>`);
      return;
    }
    const $ = s()[s().length - 1];
    $ && $.content === P || (e((R) => [...R, {
      type: C,
      content: P
    }]), S());
  }, A = () => {
    n() && (k("message", "Processing..."), t()?.emit("exec", n()), r(""));
  };
  wr(() => {
    const C = pl("http://localhost:5000/terminal", {
      transports: ["websocket"],
      withCredentials: !0
    });
    i(C), C.on("connect", () => {
      u("Connected"), b && (b.disabled = !1);
    }), C.on("connect_error", (P) => {
      console.error("Connection Error:", P.message), b && (b.disabled = !0), u("Disconnected");
    }), C.on("osinfo", (P) => {
      c(P.homedir);
    }), C.on("outputMessage", (P) => {
      k("outputMessage", P);
    }), C.on("output", (P) => k("message", P)), C.on("cwdInfo", (P) => k("message", P)), C.on("error", (P) => k("error", `${P}`)), C.on("close", (P) => k("message", `
${P}
`)), C.on("prompt", ({
      cwd: P,
      command: $
    }) => {
      let R = P;
      const X = l();
      if (X && P.startsWith(X))
        R = P.replace(X, "~");
      else {
        const M = P.split("/");
        R = M[M.length - 1] || "/";
      }
      o(R), k("command", `${P} $ ${$}`);
    }), ii(() => C.disconnect());
  });
  const T = (C) => {
    r(""), f(!1), k("message", `Selected: ${C}`);
  };
  return Jt(S), (() => {
    var C = nT(), P = C.firstChild;
    P.firstChild;
    var $ = P.nextSibling, R = $.firstChild, X = R.nextSibling;
    W(C, B(Mn, {}), P);
    var M = x;
    typeof M == "function" ? wi(M, P) : x = P, P.style.setProperty("scroll-behavior", "smooth"), W(P, B(Gi, {
      get each() {
        return s();
      },
      children: (I) => (() => {
        var Y = rT();
        return W(Y, (() => {
          var V = Yt(() => I.type === "command");
          return () => V() ? `${a()} $ ${I.content.split(" $ ")[1]}` : I.content;
        })()), Ae((V) => {
          var N = I.type === "command" ? "font-bold whitespace-pre-wrap text-yellow-400" : I.type === "error" ? "whitespace-pre-wrap text-red-400" : "whitespace-pre-wrap", _ = I.type === "command" ? I.content.split(" $ ")[0] : "";
          return N !== V.e && Os(Y, V.e = N), _ !== V.t && Fe(Y, "title", V.t = _), V;
        }, {
          e: void 0,
          t: void 0
        }), Y;
      })()
    }), null), W(C, (() => {
      var I = Yt(() => !!(d() && m().length > 0));
      return () => I() && (() => {
        var Y = aT(), V = Y.firstChild;
        return Y.style.setProperty("width", "200px"), W(V, B(Gi, {
          get each() {
            return m();
          },
          children: (N) => (() => {
            var _ = oT();
            return _.$$click = () => T(N), W(_, N === "Switch to AI" ? lT() : N === "Documentation" ? cT() : N === "About" ? hT() : N === "Donate" ? uT() : null, null), W(_, N, null), _;
          })()
        })), Ae((N) => {
          var _ = `${p().x}px`, U = `${p().y + 4}px`;
          return _ !== N.e && ((N.e = _) != null ? Y.style.setProperty("left", _) : Y.style.removeProperty("left")), U !== N.t && ((N.t = U) != null ? Y.style.setProperty("top", U) : Y.style.removeProperty("top")), N;
        }, {
          e: void 0,
          t: void 0
        }), Y;
      })();
    })(), $), X.$$keydown = (I) => {
      I.key === "Enter" && (A(), f(!1));
    }, X.$$input = w;
    var z = b;
    return typeof z == "function" ? wi(z, X) : b = X, Ae((I) => {
      var Y = `ml-4 ${h() === "Connected" ? "text-green-400" : "text-red-400"}`, V = `flex-1 dark:bg-netural-950 ${h() === "Connected" ? "text-green-400" : "text-red-400"} rounded-md px-1 text-sm focus:outline-none focus:ring-0`, N = `${h() === "Connected" ? "Type a command..." : h()}`;
      return Y !== I.e && Os(R, I.e = Y), V !== I.t && Os(X, I.t = V), N !== I.a && Fe(X, "placeholder", I.a = N), I;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    }), Ae(() => X.value = n()), C;
  })();
}
_t(["input", "keydown", "click"]);
/*!
 * ApexCharts v4.7.0
 * (c) 2018-2025 ApexCharts
 * Released under the MIT License.
 */
function pd(s, e) {
  (e == null || e > s.length) && (e = s.length);
  for (var t = 0, i = Array(e); t < e; t++) i[t] = s[t];
  return i;
}
function my(s) {
  if (s === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function ee(s, e) {
  if (!(s instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function bm(s, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(s, by(i.key), i);
  }
}
function te(s, e, t) {
  return e && bm(s.prototype, e), t && bm(s, t), Object.defineProperty(s, "prototype", { writable: !1 }), s;
}
function ia(s, e) {
  var t = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
  if (!t) {
    if (Array.isArray(s) || (t = Sp(s)) || e) {
      t && (s = t);
      var i = 0, n = function() {
      };
      return { s: n, n: function() {
        return i >= s.length ? { done: !0 } : { done: !1, value: s[i++] };
      }, e: function(l) {
        throw l;
      }, f: n };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var r, a = !0, o = !1;
  return { s: function() {
    t = t.call(s);
  }, n: function() {
    var l = t.next();
    return a = l.done, l;
  }, e: function(l) {
    o = !0, r = l;
  }, f: function() {
    try {
      a || t.return == null || t.return();
    } finally {
      if (o) throw r;
    }
  } };
}
function co(s) {
  var e = Oy();
  return function() {
    var t, i = Gl(s);
    if (e) {
      var n = Gl(this).constructor;
      t = Reflect.construct(i, arguments, n);
    } else t = i.apply(this, arguments);
    return function(r, a) {
      if (a && (typeof a == "object" || typeof a == "function")) return a;
      if (a !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return my(r);
    }(this, t);
  };
}
function Ul(s, e, t) {
  return (e = by(e)) in s ? Object.defineProperty(s, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : s[e] = t, s;
}
function Gl(s) {
  return Gl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Gl(s);
}
function ho(s, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(e && e.prototype, { constructor: { value: s, writable: !0, configurable: !0 } }), Object.defineProperty(s, "prototype", { writable: !1 }), e && gd(s, e);
}
function Oy() {
  try {
    var s = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Oy = function() {
    return !!s;
  })();
}
function ym(s, e) {
  var t = Object.keys(s);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(s);
    e && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(s, n).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function F(s) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ym(Object(t), !0).forEach(function(i) {
      Ul(s, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : ym(Object(t)).forEach(function(i) {
      Object.defineProperty(s, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return s;
}
function gd(s, e) {
  return gd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, i) {
    return t.__proto__ = i, t;
  }, gd(s, e);
}
function xy(s, e) {
  return function(t) {
    if (Array.isArray(t)) return t;
  }(s) || function(t, i) {
    var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (n != null) {
      var r, a, o, l, c = [], h = !0, u = !1;
      try {
        if (o = (n = n.call(t)).next, i === 0) {
          if (Object(n) !== n) return;
          h = !1;
        } else for (; !(h = (r = o.call(n)).done) && (c.push(r.value), c.length !== i); h = !0) ;
      } catch (d) {
        u = !0, a = d;
      } finally {
        try {
          if (!h && n.return != null && (l = n.return(), Object(l) !== l)) return;
        } finally {
          if (u) throw a;
        }
      }
      return c;
    }
  }(s, e) || Sp(s, e) || function() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function dt(s) {
  return function(e) {
    if (Array.isArray(e)) return pd(e);
  }(s) || function(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }(s) || Sp(s) || function() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function by(s) {
  var e = function(t, i) {
    if (typeof t != "object" || !t) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(t, i);
      if (typeof r != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (i === "string" ? String : Number)(t);
  }(s, "string");
  return typeof e == "symbol" ? e : e + "";
}
function lr(s) {
  return lr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, lr(s);
}
function Sp(s, e) {
  if (s) {
    if (typeof s == "string") return pd(s, e);
    var t = {}.toString.call(s).slice(8, -1);
    return t === "Object" && s.constructor && (t = s.constructor.name), t === "Map" || t === "Set" ? Array.from(s) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? pd(s, e) : void 0;
  }
}
var E = function() {
  function s() {
    ee(this, s);
  }
  return te(s, [{ key: "shadeRGBColor", value: function(e, t) {
    var i = t.split(","), n = e < 0 ? 0 : 255, r = e < 0 ? -1 * e : e, a = parseInt(i[0].slice(4), 10), o = parseInt(i[1], 10), l = parseInt(i[2], 10);
    return "rgb(" + (Math.round((n - a) * r) + a) + "," + (Math.round((n - o) * r) + o) + "," + (Math.round((n - l) * r) + l) + ")";
  } }, { key: "shadeHexColor", value: function(e, t) {
    var i = parseInt(t.slice(1), 16), n = e < 0 ? 0 : 255, r = e < 0 ? -1 * e : e, a = i >> 16, o = i >> 8 & 255, l = 255 & i;
    return "#" + (16777216 + 65536 * (Math.round((n - a) * r) + a) + 256 * (Math.round((n - o) * r) + o) + (Math.round((n - l) * r) + l)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(e, t) {
    return s.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t);
  } }], [{ key: "bind", value: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  } }, { key: "isObject", value: function(e) {
    return e && lr(e) === "object" && !Array.isArray(e) && e != null;
  } }, { key: "is", value: function(e, t) {
    return Object.prototype.toString.call(t) === "[object " + e + "]";
  } }, { key: "isSafari", value: function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  } }, { key: "listToArray", value: function(e) {
    var t, i = [];
    for (t = 0; t < e.length; t++) i[t] = e[t];
    return i;
  } }, { key: "extend", value: function(e, t) {
    var i = this;
    typeof Object.assign != "function" && (Object.assign = function(r) {
      if (r == null) throw new TypeError("Cannot convert undefined or null to object");
      for (var a = Object(r), o = 1; o < arguments.length; o++) {
        var l = arguments[o];
        if (l != null) for (var c in l) l.hasOwnProperty(c) && (a[c] = l[c]);
      }
      return a;
    });
    var n = Object.assign({}, e);
    return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach(function(r) {
      i.isObject(t[r]) && r in e ? n[r] = i.extend(e[r], t[r]) : Object.assign(n, Ul({}, r, t[r]));
    }), n;
  } }, { key: "extendArray", value: function(e, t) {
    var i = [];
    return e.map(function(n) {
      i.push(s.extend(t, n));
    }), e = i;
  } }, { key: "monthMod", value: function(e) {
    return e % 12;
  } }, { key: "clone", value: function(e) {
    var t, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new WeakMap();
    if (e === null || lr(e) !== "object") return e;
    if (i.has(e)) return i.get(e);
    if (Array.isArray(e)) {
      t = [], i.set(e, t);
      for (var n = 0; n < e.length; n++) t[n] = this.clone(e[n], i);
    } else if (e instanceof Date) t = new Date(e.getTime());
    else for (var r in t = {}, i.set(e, t), e) e.hasOwnProperty(r) && (t[r] = this.clone(e[r], i));
    return t;
  } }, { key: "log10", value: function(e) {
    return Math.log(e) / Math.LN10;
  } }, { key: "roundToBase10", value: function(e) {
    return Math.pow(10, Math.floor(Math.log10(e)));
  } }, { key: "roundToBase", value: function(e, t) {
    return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)));
  } }, { key: "parseNumber", value: function(e) {
    return e === null ? e : parseFloat(e);
  } }, { key: "stripNumber", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t));
  } }, { key: "randomId", value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: "noExponents", value: function(e) {
    return e.toString().includes("e") ? Math.round(e) : e;
  } }, { key: "elementExists", value: function(e) {
    return !(!e || !e.isConnected);
  } }, { key: "getDimensions", value: function(e) {
    var t = getComputedStyle(e, null), i = e.clientHeight, n = e.clientWidth;
    return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), [n -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), i];
  } }, { key: "getBoundingClientRect", value: function(e) {
    var t = e.getBoundingClientRect();
    return { top: t.top, right: t.right, bottom: t.bottom, left: t.left, width: e.clientWidth, height: e.clientHeight, x: t.left, y: t.top };
  } }, { key: "getLargestStringFromArr", value: function(e) {
    return e.reduce(function(t, i) {
      return Array.isArray(i) && (i = i.reduce(function(n, r) {
        return n.length > r.length ? n : r;
      })), t.length > i.length ? t : i;
    }, 0);
  } }, { key: "hexToRgba", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
    e.substring(0, 1) !== "#" && (e = "#999999");
    var i = e.replace("#", "");
    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
    for (var n = 0; n < i.length; n++) i[n] = parseInt(i[n].length === 1 ? i[n] + i[n] : i[n], 16);
    return t !== void 0 && i.push(t), "rgba(" + i.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(e) {
    return parseFloat(e.replace(/^.*,(.+)\)/, "$1"));
  } }, { key: "rgb2hex", value: function(e) {
    return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && e.length === 4 ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(e) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e);
  } }, { key: "getPolygonPos", value: function(e, t) {
    for (var i = [], n = 2 * Math.PI / t, r = 0; r < t; r++) {
      var a = {};
      a.x = e * Math.sin(r * n), a.y = -e * Math.cos(r * n), i.push(a);
    }
    return i;
  } }, { key: "polarToCartesian", value: function(e, t, i, n) {
    var r = (n - 90) * Math.PI / 180;
    return { x: e + i * Math.cos(r), y: t + i * Math.sin(r) };
  } }, { key: "escapeString", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i = e.toString().slice();
    return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t);
  } }, { key: "negToZero", value: function(e) {
    return e < 0 ? 0 : e;
  } }, { key: "moveIndexInArray", value: function(e, t, i) {
    if (i >= e.length) for (var n = i - e.length + 1; n--; ) e.push(void 0);
    return e.splice(i, 0, e.splice(t, 1)[0]), e;
  } }, { key: "extractNumber", value: function(e) {
    return parseFloat(e.replace(/[^\d.]*/g, ""));
  } }, { key: "findAncestor", value: function(e, t) {
    for (; (e = e.parentElement) && !e.classList.contains(t); ) ;
    return e;
  } }, { key: "setELstyles", value: function(e, t) {
    for (var i in t) t.hasOwnProperty(i) && (e.style.key = t[i]);
  } }, { key: "preciseAddition", value: function(e, t) {
    var i = (String(e).split(".")[1] || "").length, n = (String(t).split(".")[1] || "").length, r = Math.pow(10, Math.max(i, n));
    return (Math.round(e * r) + Math.round(t * r)) / r;
  } }, { key: "isNumber", value: function(e) {
    return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10));
  } }, { key: "isFloat", value: function(e) {
    return Number(e) === e && e % 1 != 0;
  } }, { key: "isMsEdge", value: function() {
    var e = window.navigator.userAgent, t = e.indexOf("Edge/");
    return t > 0 && parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
  } }, { key: "getGCD", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7, n = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    for (e = Math.round(Math.abs(e) * n), t = Math.round(Math.abs(t) * n); t; ) {
      var r = t;
      t = e % t, e = r;
    }
    return e / n;
  } }, { key: "getPrimeFactors", value: function(e) {
    for (var t = [], i = 2; e >= 2; ) e % i == 0 ? (t.push(i), e /= i) : i++;
    return t;
  } }, { key: "mod", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7, n = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    return (e = Math.round(Math.abs(e) * n)) % (t = Math.round(Math.abs(t) * n)) / n;
  } }]), s;
}(), Cr = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "animateLine", value: function(e, t, i, n) {
    e.attr(t).animate(n).attr(i);
  } }, { key: "animateMarker", value: function(e, t, i, n) {
    e.attr({ opacity: 0 }).animate(t).attr({ opacity: 1 }).after(function() {
      n();
    });
  } }, { key: "animateRect", value: function(e, t, i, n, r) {
    e.attr(t).animate(n).attr(i).after(function() {
      return r();
    });
  } }, { key: "animatePathsGradually", value: function(e) {
    var t = e.el, i = e.realIndex, n = e.j, r = e.fill, a = e.pathFrom, o = e.pathTo, l = e.speed, c = e.delay, h = this.w, u = 0;
    h.config.chart.animations.animateGradually.enabled && (u = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && h.config.chart.type !== "bar" && (u = 0), this.morphSVG(t, i, n, h.config.chart.type !== "line" || h.globals.comboCharts ? r : "stroke", a, o, l, c * u);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach(function(e) {
      var t = e.el;
      t.classList.remove("apexcharts-element-hidden"), t.classList.add("apexcharts-hidden-element-shown");
    });
  } }, { key: "animationCompleted", value: function(e) {
    var t = this.w;
    t.globals.animationEnded || (t.globals.animationEnded = !0, this.showDelayedElements(), typeof t.config.chart.events.animationEnd == "function" && t.config.chart.events.animationEnd(this.ctx, { el: e, w: t }));
  } }, { key: "morphSVG", value: function(e, t, i, n, r, a, o, l) {
    var c = this, h = this.w;
    r || (r = e.attr("pathFrom")), a || (a = e.attr("pathTo"));
    var u = function(d) {
      return h.config.chart.type === "radar" && (o = 1), "M 0 ".concat(h.globals.gridHeight);
    };
    (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = u()), (!a.trim() || a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = u()), h.globals.shouldAnimate || (o = 1), e.plot(r).animate(1, l).plot(r).animate(o, l).plot(a).after(function() {
      E.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && c.animationCompleted(e) : n !== "none" && h.globals.shouldAnimate && (!h.globals.comboCharts && t === h.globals.series.length - 1 || h.globals.comboCharts) && c.animationCompleted(e), c.showDelayedElements();
    });
  } }]), s;
}();
const md = {}, yy = [];
function we(s, e) {
  if (Array.isArray(s)) for (const t of s) we(t, e);
  else if (typeof s != "object") vy(Object.getOwnPropertyNames(e)), md[s] = Object.assign(md[s] || {}, e);
  else for (const t in s) we(t, s[t]);
}
function zt(s) {
  return md[s] || {};
}
function vy(s) {
  yy.push(...s);
}
function kp(s, e) {
  let t;
  const i = s.length, n = [];
  for (t = 0; t < i; t++) n.push(e(s[t]));
  return n;
}
function Th(s) {
  return s % 360 * Math.PI / 180;
}
function Ar(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function Tr(s, e, t, i) {
  return e != null && t != null || (i = i || s.bbox(), e == null ? e = i.width / i.height * t : t == null && (t = i.height / i.width * e)), { width: e, height: t };
}
function Od(s, e) {
  const t = s.origin;
  let i = s.ox != null ? s.ox : s.originX != null ? s.originX : "center", n = s.oy != null ? s.oy : s.originY != null ? s.originY : "center";
  t != null && ([i, n] = Array.isArray(t) ? t : typeof t == "object" ? [t.x, t.y] : [t, t]);
  const r = typeof i == "string", a = typeof n == "string";
  if (r || a) {
    const { height: o, width: l, x: c, y: h } = e.bbox();
    r && (i = i.includes("left") ? c : i.includes("right") ? c + l : c + l / 2), a && (n = n.includes("top") ? h : n.includes("bottom") ? h + o : h + o / 2);
  }
  return [i, n];
}
const fT = /* @__PURE__ */ new Set(["desc", "metadata", "title"]), xd = (s) => fT.has(s.nodeName), wy = (s, e, t = {}) => {
  const i = { ...e };
  for (const n in i) i[n].valueOf() === t[n] && delete i[n];
  Object.keys(i).length ? s.node.setAttribute("data-svgjs", JSON.stringify(i)) : (s.node.removeAttribute("data-svgjs"), s.node.removeAttribute("svgjs:data"));
}, Pp = "http://www.w3.org/2000/svg", $h = "http://www.w3.org/2000/xmlns/", $r = "http://www.w3.org/1999/xlink", Te = { window: typeof window > "u" ? null : window, document: typeof document > "u" ? null : document };
function uo() {
  return Te.window;
}
let Qp = class {
};
const On = {}, Cp = "___SYMBOL___ROOT___";
function ka(s, e = Pp) {
  return Te.document.createElementNS(e, s);
}
function Et(s, e = !1) {
  if (s instanceof Qp) return s;
  if (typeof s == "object") return Rh(s);
  if (s == null) return new On[Cp]();
  if (typeof s == "string" && s.charAt(0) !== "<") return Rh(Te.document.querySelector(s));
  const t = e ? Te.document.createElement("div") : ka("svg");
  return t.innerHTML = s, s = Rh(t.firstChild), t.removeChild(t.firstChild), s;
}
function Be(s, e) {
  return e && (e instanceof Te.window.Node || e.ownerDocument && e instanceof e.ownerDocument.defaultView.Node) ? e : ka(s);
}
function ai(s) {
  if (!s) return null;
  if (s.instance instanceof Qp) return s.instance;
  if (s.nodeName === "#document-fragment") return new On.Fragment(s);
  let e = Ar(s.nodeName || "Dom");
  return e === "LinearGradient" || e === "RadialGradient" ? e = "Gradient" : On[e] || (e = "Dom"), new On[e](s);
}
let Rh = ai;
function Re(s, e = s.name, t = !1) {
  return On[e] = s, t && (On[Cp] = s), vy(Object.getOwnPropertyNames(s.prototype)), s;
}
let pT = 1e3;
function Sy(s) {
  return "Svgjs" + Ar(s) + pT++;
}
function ky(s) {
  for (let e = s.children.length - 1; e >= 0; e--) ky(s.children[e]);
  return s.id && (s.id = Sy(s.nodeName)), s;
}
function fe(s, e) {
  let t, i;
  for (i = (s = Array.isArray(s) ? s : [s]).length - 1; i >= 0; i--) for (t in e) s[i].prototype[t] = e[t];
}
function De(s) {
  return function(...e) {
    const t = e[e.length - 1];
    return !t || t.constructor !== Object || t instanceof Array ? s.apply(this, e) : s.apply(this, e.slice(0, -1)).attr(t);
  };
}
we("Dom", { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const s = this.position();
  return this.parent().add(this.remove(), s + 1), this;
}, backward: function() {
  const s = this.position();
  return this.parent().add(this.remove(), s ? s - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(s) {
  (s = Et(s)).remove();
  const e = this.position();
  return this.parent().add(s, e), this;
}, after: function(s) {
  (s = Et(s)).remove();
  const e = this.position();
  return this.parent().add(s, e + 1), this;
}, insertBefore: function(s) {
  return (s = Et(s)).before(this), this;
}, insertAfter: function(s) {
  return (s = Et(s)).after(this), this;
} });
const Py = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, gT = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, mT = /rgb\((\d+),(\d+),(\d+)\)/, OT = /(#[a-z_][a-z0-9\-_]*)/i, xT = /\)\s*,?\s*/, bT = /\s/g, vm = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i, wm = /^rgb\(/, Sm = /^(\s+)?$/, km = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, yT = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, Ps = /[\s,]+/, Ap = /[MLHVCSQTAZ]/i;
function vT(s) {
  const e = Math.round(s), t = Math.max(0, Math.min(255, e)).toString(16);
  return t.length === 1 ? "0" + t : t;
}
function qn(s, e) {
  for (let t = e.length; t--; ) if (s[e[t]] == null) return !1;
  return !0;
}
function Eh(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + 6 * (e - s) * t : t < 0.5 ? e : t < 2 / 3 ? s + (e - s) * (2 / 3 - t) * 6 : s;
}
we("Dom", { classes: function() {
  const s = this.attr("class");
  return s == null ? [] : s.trim().split(Ps);
}, hasClass: function(s) {
  return this.classes().indexOf(s) !== -1;
}, addClass: function(s) {
  if (!this.hasClass(s)) {
    const e = this.classes();
    e.push(s), this.attr("class", e.join(" "));
  }
  return this;
}, removeClass: function(s) {
  return this.hasClass(s) && this.attr("class", this.classes().filter(function(e) {
    return e !== s;
  }).join(" ")), this;
}, toggleClass: function(s) {
  return this.hasClass(s) ? this.removeClass(s) : this.addClass(s);
} }), we("Dom", { css: function(s, e) {
  const t = {};
  if (arguments.length === 0) return this.node.style.cssText.split(/\s*;\s*/).filter(function(i) {
    return !!i.length;
  }).forEach(function(i) {
    const n = i.split(/\s*:\s*/);
    t[n[0]] = n[1];
  }), t;
  if (arguments.length < 2) {
    if (Array.isArray(s)) {
      for (const i of s) {
        const n = i;
        t[i] = this.node.style.getPropertyValue(n);
      }
      return t;
    }
    if (typeof s == "string") return this.node.style.getPropertyValue(s);
    if (typeof s == "object") for (const i in s) this.node.style.setProperty(i, s[i] == null || Sm.test(s[i]) ? "" : s[i]);
  }
  return arguments.length === 2 && this.node.style.setProperty(s, e == null || Sm.test(e) ? "" : e), this;
}, show: function() {
  return this.css("display", "");
}, hide: function() {
  return this.css("display", "none");
}, visible: function() {
  return this.css("display") !== "none";
} }), we("Dom", { data: function(s, e, t) {
  if (s == null) return this.data(kp(function(i, n) {
    let r;
    const a = i.length, o = [];
    for (r = 0; r < a; r++) n(i[r]) && o.push(i[r]);
    return o;
  }(this.node.attributes, (i) => i.nodeName.indexOf("data-") === 0), (i) => i.nodeName.slice(5)));
  if (s instanceof Array) {
    const i = {};
    for (const n of s) i[n] = this.data(n);
    return i;
  }
  if (typeof s == "object") for (e in s) this.data(e, s[e]);
  else if (arguments.length < 2) try {
    return JSON.parse(this.attr("data-" + s));
  } catch {
    return this.attr("data-" + s);
  }
  else this.attr("data-" + s, e === null ? null : t === !0 || typeof e == "string" || typeof e == "number" ? e : JSON.stringify(e));
  return this;
} }), we("Dom", { remember: function(s, e) {
  if (typeof arguments[0] == "object") for (const t in s) this.remember(t, s[t]);
  else {
    if (arguments.length === 1) return this.memory()[s];
    this.memory()[s] = e;
  }
  return this;
}, forget: function() {
  if (arguments.length === 0) this._memory = {};
  else for (let s = arguments.length - 1; s >= 0; s--) delete this.memory()[arguments[s]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });
class qe {
  constructor(...e) {
    this.init(...e);
  }
  static isColor(e) {
    return e && (e instanceof qe || this.isRgb(e) || this.test(e));
  }
  static isRgb(e) {
    return e && typeof e.r == "number" && typeof e.g == "number" && typeof e.b == "number";
  }
  static random(e = "vibrant", t) {
    const { random: i, round: n, sin: r, PI: a } = Math;
    if (e === "vibrant") {
      const o = 24 * i() + 57, l = 38 * i() + 45, c = 360 * i();
      return new qe(o, l, c, "lch");
    }
    if (e === "sine") {
      const o = n(80 * r(2 * a * (t = t ?? i()) / 0.5 + 0.01) + 150), l = n(50 * r(2 * a * t / 0.5 + 4.6) + 200), c = n(100 * r(2 * a * t / 0.5 + 2.3) + 150);
      return new qe(o, l, c);
    }
    if (e === "pastel") {
      const o = 8 * i() + 86, l = 17 * i() + 9, c = 360 * i();
      return new qe(o, l, c, "lch");
    }
    if (e === "dark") {
      const o = 10 + 10 * i(), l = 50 * i() + 86, c = 360 * i();
      return new qe(o, l, c, "lch");
    }
    if (e === "rgb") {
      const o = 255 * i(), l = 255 * i(), c = 255 * i();
      return new qe(o, l, c);
    }
    if (e === "lab") {
      const o = 100 * i(), l = 256 * i() - 128, c = 256 * i() - 128;
      return new qe(o, l, c, "lab");
    }
    if (e === "grey") {
      const o = 255 * i();
      return new qe(o, o, o);
    }
    throw new Error("Unsupported random color mode");
  }
  static test(e) {
    return typeof e == "string" && (vm.test(e) || wm.test(e));
  }
  cmyk() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [n, r, a] = [e, t, i].map((l) => l / 255), o = Math.min(1 - n, 1 - r, 1 - a);
    return o === 1 ? new qe(0, 0, 0, 1, "cmyk") : new qe((1 - n - o) / (1 - o), (1 - r - o) / (1 - o), (1 - a - o) / (1 - o), o, "cmyk");
  }
  hsl() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [n, r, a] = [e, t, i].map((d) => d / 255), o = Math.max(n, r, a), l = Math.min(n, r, a), c = (o + l) / 2, h = o === l, u = o - l;
    return new qe(360 * (h ? 0 : o === n ? ((r - a) / u + (r < a ? 6 : 0)) / 6 : o === r ? ((a - n) / u + 2) / 6 : o === a ? ((n - r) / u + 4) / 6 : 0), 100 * (h ? 0 : c > 0.5 ? u / (2 - o - l) : u / (o + l)), 100 * c, "hsl");
  }
  init(e = 0, t = 0, i = 0, n = 0, r = "rgb") {
    if (e = e || 0, this.space) for (const u in this.space) delete this[this.space[u]];
    if (typeof e == "number") r = typeof n == "string" ? n : r, n = typeof n == "string" ? 0 : n, Object.assign(this, { _a: e, _b: t, _c: i, _d: n, space: r });
    else if (e instanceof Array) this.space = t || (typeof e[3] == "string" ? e[3] : e[4]) || "rgb", Object.assign(this, { _a: e[0], _b: e[1], _c: e[2], _d: e[3] || 0 });
    else if (e instanceof Object) {
      const u = function(d, f) {
        const p = qn(d, "rgb") ? { _a: d.r, _b: d.g, _c: d.b, _d: 0, space: "rgb" } : qn(d, "xyz") ? { _a: d.x, _b: d.y, _c: d.z, _d: 0, space: "xyz" } : qn(d, "hsl") ? { _a: d.h, _b: d.s, _c: d.l, _d: 0, space: "hsl" } : qn(d, "lab") ? { _a: d.l, _b: d.a, _c: d.b, _d: 0, space: "lab" } : qn(d, "lch") ? { _a: d.l, _b: d.c, _c: d.h, _d: 0, space: "lch" } : qn(d, "cmyk") ? { _a: d.c, _b: d.m, _c: d.y, _d: d.k, space: "cmyk" } : { _a: 0, _b: 0, _c: 0, space: "rgb" };
        return p.space = f || p.space, p;
      }(e, t);
      Object.assign(this, u);
    } else if (typeof e == "string") if (wm.test(e)) {
      const u = e.replace(bT, ""), [d, f, p] = mT.exec(u).slice(1, 4).map((g) => parseInt(g));
      Object.assign(this, { _a: d, _b: f, _c: p, _d: 0, space: "rgb" });
    } else {
      if (!vm.test(e)) throw Error("Unsupported string format, can't construct Color");
      {
        const u = (g) => parseInt(g, 16), [, d, f, p] = gT.exec(function(g) {
          return g.length === 4 ? ["#", g.substring(1, 2), g.substring(1, 2), g.substring(2, 3), g.substring(2, 3), g.substring(3, 4), g.substring(3, 4)].join("") : g;
        }(e)).map(u);
        Object.assign(this, { _a: d, _b: f, _c: p, _d: 0, space: "rgb" });
      }
    }
    const { _a: a, _b: o, _c: l, _d: c } = this, h = this.space === "rgb" ? { r: a, g: o, b: l } : this.space === "xyz" ? { x: a, y: o, z: l } : this.space === "hsl" ? { h: a, s: o, l } : this.space === "lab" ? { l: a, a: o, b: l } : this.space === "lch" ? { l: a, c: o, h: l } : this.space === "cmyk" ? { c: a, m: o, y: l, k: c } : {};
    Object.assign(this, h);
  }
  lab() {
    const { x: e, y: t, z: i } = this.xyz();
    return new qe(116 * t - 16, 500 * (e - t), 200 * (t - i), "lab");
  }
  lch() {
    const { l: e, a: t, b: i } = this.lab(), n = Math.sqrt(t ** 2 + i ** 2);
    let r = 180 * Math.atan2(i, t) / Math.PI;
    return r < 0 && (r *= -1, r = 360 - r), new qe(e, n, r, "lch");
  }
  rgb() {
    if (this.space === "rgb") return this;
    if ((e = this.space) === "lab" || e === "xyz" || e === "lch") {
      let { x: t, y: i, z: n } = this;
      if (this.space === "lab" || this.space === "lch") {
        let { l: f, a: p, b: g } = this;
        if (this.space === "lch") {
          const { c: w, h: S } = this, k = Math.PI / 180;
          p = w * Math.cos(k * S), g = w * Math.sin(k * S);
        }
        const m = (f + 16) / 116, O = p / 500 + m, x = m - g / 200, b = 16 / 116, v = 8856e-6, y = 7.787;
        t = 0.95047 * (O ** 3 > v ? O ** 3 : (O - b) / y), i = 1 * (m ** 3 > v ? m ** 3 : (m - b) / y), n = 1.08883 * (x ** 3 > v ? x ** 3 : (x - b) / y);
      }
      const r = 3.2406 * t + -1.5372 * i + -0.4986 * n, a = -0.9689 * t + 1.8758 * i + 0.0415 * n, o = 0.0557 * t + -0.204 * i + 1.057 * n, l = Math.pow, c = 31308e-7, h = r > c ? 1.055 * l(r, 1 / 2.4) - 0.055 : 12.92 * r, u = a > c ? 1.055 * l(a, 1 / 2.4) - 0.055 : 12.92 * a, d = o > c ? 1.055 * l(o, 1 / 2.4) - 0.055 : 12.92 * o;
      return new qe(255 * h, 255 * u, 255 * d);
    }
    if (this.space === "hsl") {
      let { h: t, s: i, l: n } = this;
      if (t /= 360, i /= 100, n /= 100, i === 0)
        return n *= 255, new qe(n, n, n);
      const r = n < 0.5 ? n * (1 + i) : n + i - n * i, a = 2 * n - r, o = 255 * Eh(a, r, t + 1 / 3), l = 255 * Eh(a, r, t), c = 255 * Eh(a, r, t - 1 / 3);
      return new qe(o, l, c);
    }
    if (this.space === "cmyk") {
      const { c: t, m: i, y: n, k: r } = this, a = 255 * (1 - Math.min(1, t * (1 - r) + r)), o = 255 * (1 - Math.min(1, i * (1 - r) + r)), l = 255 * (1 - Math.min(1, n * (1 - r) + r));
      return new qe(a, o, l);
    }
    return this;
    var e;
  }
  toArray() {
    const { _a: e, _b: t, _c: i, _d: n, space: r } = this;
    return [e, t, i, n, r];
  }
  toHex() {
    const [e, t, i] = this._clamped().map(vT);
    return `#${e}${t}${i}`;
  }
  toRgb() {
    const [e, t, i] = this._clamped();
    return `rgb(${e},${t},${i})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [n, r, a] = [e, t, i].map((m) => m / 255), o = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, l = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, c = a > 0.04045 ? Math.pow((a + 0.055) / 1.055, 2.4) : a / 12.92, h = (0.4124 * o + 0.3576 * l + 0.1805 * c) / 0.95047, u = (0.2126 * o + 0.7152 * l + 0.0722 * c) / 1, d = (0.0193 * o + 0.1192 * l + 0.9505 * c) / 1.08883, f = h > 8856e-6 ? Math.pow(h, 1 / 3) : 7.787 * h + 16 / 116, p = u > 8856e-6 ? Math.pow(u, 1 / 3) : 7.787 * u + 16 / 116, g = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116;
    return new qe(f, p, g, "xyz");
  }
  _clamped() {
    const { _a: e, _b: t, _c: i } = this.rgb(), { max: n, min: r, round: a } = Math;
    return [e, t, i].map((o) => n(0, r(a(o), 255)));
  }
}
class Me {
  constructor(...e) {
    this.init(...e);
  }
  clone() {
    return new Me(this);
  }
  init(e, t) {
    const r = Array.isArray(e) ? { x: e[0], y: e[1] } : typeof e == "object" ? { x: e.x, y: e.y } : { x: e, y: t };
    return this.x = r.x == null ? 0 : r.x, this.y = r.y == null ? 0 : r.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(e) {
    return this.clone().transformO(e);
  }
  transformO(e) {
    ce.isMatrixLike(e) || (e = new ce(e));
    const { x: t, y: i } = this;
    return this.x = e.a * t + e.c * i + e.e, this.y = e.b * t + e.d * i + e.f, this;
  }
}
function Dn(s, e, t) {
  return Math.abs(e - s) < 1e-6;
}
class ce {
  constructor(...e) {
    this.init(...e);
  }
  static formatTransforms(e) {
    const t = e.flip === "both" || e.flip === !0, i = e.flip && (t || e.flip === "x") ? -1 : 1, n = e.flip && (t || e.flip === "y") ? -1 : 1, r = e.skew && e.skew.length ? e.skew[0] : isFinite(e.skew) ? e.skew : isFinite(e.skewX) ? e.skewX : 0, a = e.skew && e.skew.length ? e.skew[1] : isFinite(e.skew) ? e.skew : isFinite(e.skewY) ? e.skewY : 0, o = e.scale && e.scale.length ? e.scale[0] * i : isFinite(e.scale) ? e.scale * i : isFinite(e.scaleX) ? e.scaleX * i : i, l = e.scale && e.scale.length ? e.scale[1] * n : isFinite(e.scale) ? e.scale * n : isFinite(e.scaleY) ? e.scaleY * n : n, c = e.shear || 0, h = e.rotate || e.theta || 0, u = new Me(e.origin || e.around || e.ox || e.originX, e.oy || e.originY), d = u.x, f = u.y, p = new Me(e.position || e.px || e.positionX || NaN, e.py || e.positionY || NaN), g = p.x, m = p.y, O = new Me(e.translate || e.tx || e.translateX, e.ty || e.translateY), x = O.x, b = O.y, v = new Me(e.relative || e.rx || e.relativeX, e.ry || e.relativeY);
    return { scaleX: o, scaleY: l, skewX: r, skewY: a, shear: c, theta: h, rx: v.x, ry: v.y, tx: x, ty: b, ox: d, oy: f, px: g, py: m };
  }
  static fromArray(e) {
    return { a: e[0], b: e[1], c: e[2], d: e[3], e: e[4], f: e[5] };
  }
  static isMatrixLike(e) {
    return e.a != null || e.b != null || e.c != null || e.d != null || e.e != null || e.f != null;
  }
  static matrixMultiply(e, t, i) {
    const n = e.a * t.a + e.c * t.b, r = e.b * t.a + e.d * t.b, a = e.a * t.c + e.c * t.d, o = e.b * t.c + e.d * t.d, l = e.e + e.a * t.e + e.c * t.f, c = e.f + e.b * t.e + e.d * t.f;
    return i.a = n, i.b = r, i.c = a, i.d = o, i.e = l, i.f = c, i;
  }
  around(e, t, i) {
    return this.clone().aroundO(e, t, i);
  }
  aroundO(e, t, i) {
    const n = e || 0, r = t || 0;
    return this.translateO(-n, -r).lmultiplyO(i).translateO(n, r);
  }
  clone() {
    return new ce(this);
  }
  decompose(e = 0, t = 0) {
    const i = this.a, n = this.b, r = this.c, a = this.d, o = this.e, l = this.f, c = i * a - n * r, h = c > 0 ? 1 : -1, u = h * Math.sqrt(i * i + n * n), d = Math.atan2(h * n, h * i), f = 180 / Math.PI * d, p = Math.cos(d), g = Math.sin(d), m = (i * r + n * a) / c, O = r * u / (m * i - n) || a * u / (m * n + i);
    return { scaleX: u, scaleY: O, shear: m, rotate: f, translateX: o - e + e * p * u + t * (m * p * u - g * O), translateY: l - t + e * g * u + t * (m * g * u + p * O), originX: e, originY: t, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(e) {
    if (e === this) return !0;
    const t = new ce(e);
    return Dn(this.a, t.a) && Dn(this.b, t.b) && Dn(this.c, t.c) && Dn(this.d, t.d) && Dn(this.e, t.e) && Dn(this.f, t.f);
  }
  flip(e, t) {
    return this.clone().flipO(e, t);
  }
  flipO(e, t) {
    return e === "x" ? this.scaleO(-1, 1, t, 0) : e === "y" ? this.scaleO(1, -1, 0, t) : this.scaleO(-1, -1, e, t || e);
  }
  init(e) {
    const t = ce.fromArray([1, 0, 0, 1, 0, 0]);
    return e = e instanceof kt ? e.matrixify() : typeof e == "string" ? ce.fromArray(e.split(Ps).map(parseFloat)) : Array.isArray(e) ? ce.fromArray(e) : typeof e == "object" && ce.isMatrixLike(e) ? e : typeof e == "object" ? new ce().transform(e) : arguments.length === 6 ? ce.fromArray([].slice.call(arguments)) : t, this.a = e.a != null ? e.a : t.a, this.b = e.b != null ? e.b : t.b, this.c = e.c != null ? e.c : t.c, this.d = e.d != null ? e.d : t.d, this.e = e.e != null ? e.e : t.e, this.f = e.f != null ? e.f : t.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const e = this.a, t = this.b, i = this.c, n = this.d, r = this.e, a = this.f, o = e * n - t * i;
    if (!o) throw new Error("Cannot invert " + this);
    const l = n / o, c = -t / o, h = -i / o, u = e / o, d = -(l * r + h * a), f = -(c * r + u * a);
    return this.a = l, this.b = c, this.c = h, this.d = u, this.e = d, this.f = f, this;
  }
  lmultiply(e) {
    return this.clone().lmultiplyO(e);
  }
  lmultiplyO(e) {
    const t = e instanceof ce ? e : new ce(e);
    return ce.matrixMultiply(t, this, this);
  }
  multiply(e) {
    return this.clone().multiplyO(e);
  }
  multiplyO(e) {
    const t = e instanceof ce ? e : new ce(e);
    return ce.matrixMultiply(this, t, this);
  }
  rotate(e, t, i) {
    return this.clone().rotateO(e, t, i);
  }
  rotateO(e, t = 0, i = 0) {
    e = Th(e);
    const n = Math.cos(e), r = Math.sin(e), { a, b: o, c: l, d: c, e: h, f: u } = this;
    return this.a = a * n - o * r, this.b = o * n + a * r, this.c = l * n - c * r, this.d = c * n + l * r, this.e = h * n - u * r + i * r - t * n + t, this.f = u * n + h * r - t * r - i * n + i, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(e, t = e, i = 0, n = 0) {
    arguments.length === 3 && (n = i, i = t, t = e);
    const { a: r, b: a, c: o, d: l, e: c, f: h } = this;
    return this.a = r * e, this.b = a * t, this.c = o * e, this.d = l * t, this.e = c * e - i * e + i, this.f = h * t - n * t + n, this;
  }
  shear(e, t, i) {
    return this.clone().shearO(e, t, i);
  }
  shearO(e, t = 0, i = 0) {
    const { a: n, b: r, c: a, d: o, e: l, f: c } = this;
    return this.a = n + r * e, this.c = a + o * e, this.e = l + c * e - i * e, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(e, t = e, i = 0, n = 0) {
    arguments.length === 3 && (n = i, i = t, t = e), e = Th(e), t = Th(t);
    const r = Math.tan(e), a = Math.tan(t), { a: o, b: l, c, d: h, e: u, f: d } = this;
    return this.a = o + l * r, this.b = l + o * a, this.c = c + h * r, this.d = h + c * a, this.e = u + d * r - n * r, this.f = d + u * a - i * a, this;
  }
  skewX(e, t, i) {
    return this.skew(e, 0, t, i);
  }
  skewY(e, t, i) {
    return this.skew(0, e, t, i);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  transform(e) {
    if (ce.isMatrixLike(e))
      return new ce(e).multiplyO(this);
    const t = ce.formatTransforms(e), { x: i, y: n } = new Me(t.ox, t.oy).transform(this), r = new ce().translateO(t.rx, t.ry).lmultiplyO(this).translateO(-i, -n).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(i, n);
    if (isFinite(t.px) || isFinite(t.py)) {
      const a = new Me(i, n).transform(r), o = isFinite(t.px) ? t.px - a.x : 0, l = isFinite(t.py) ? t.py - a.y : 0;
      r.translateO(o, l);
    }
    return r.translateO(t.tx, t.ty), r;
  }
  translate(e, t) {
    return this.clone().translateO(e, t);
  }
  translateO(e, t) {
    return this.e += e || 0, this.f += t || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
}
function Rs() {
  if (!Rs.nodes) {
    const s = Et().size(2, 0);
    s.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";"), s.attr("focusable", "false"), s.attr("aria-hidden", "true");
    const e = s.path().node;
    Rs.nodes = { svg: s, path: e };
  }
  if (!Rs.nodes.svg.node.parentNode) {
    const s = Te.document.body || Te.document.documentElement;
    Rs.nodes.svg.addTo(s);
  }
  return Rs.nodes;
}
function Qy(s) {
  return !(s.width || s.height || s.x || s.y);
}
Re(ce, "Matrix");
class it {
  constructor(...e) {
    this.init(...e);
  }
  addOffset() {
    return this.x += Te.window.pageXOffset, this.y += Te.window.pageYOffset, new it(this);
  }
  init(e) {
    return e = typeof e == "string" ? e.split(Ps).map(parseFloat) : Array.isArray(e) ? e : typeof e == "object" ? [e.left != null ? e.left : e.x, e.top != null ? e.top : e.y, e.width, e.height] : arguments.length === 4 ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = e[0] || 0, this.y = e[1] || 0, this.width = this.w = e[2] || 0, this.height = this.h = e[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return Qy(this);
  }
  merge(e) {
    const t = Math.min(this.x, e.x), i = Math.min(this.y, e.y), n = Math.max(this.x + this.width, e.x + e.width) - t, r = Math.max(this.y + this.height, e.y + e.height) - i;
    return new it(t, i, n, r);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(e) {
    e instanceof ce || (e = new ce(e));
    let t = 1 / 0, i = -1 / 0, n = 1 / 0, r = -1 / 0;
    return [new Me(this.x, this.y), new Me(this.x2, this.y), new Me(this.x, this.y2), new Me(this.x2, this.y2)].forEach(function(a) {
      a = a.transform(e), t = Math.min(t, a.x), i = Math.max(i, a.x), n = Math.min(n, a.y), r = Math.max(r, a.y);
    }), new it(t, n, i - t, r - n);
  }
}
function Pm(s, e, t) {
  let i;
  try {
    if (i = e(s.node), Qy(i) && (n = s.node) !== Te.document && !(Te.document.documentElement.contains || function(r) {
      for (; r.parentNode; ) r = r.parentNode;
      return r === Te.document;
    }).call(Te.document.documentElement, n)) throw new Error("Element not in the dom");
  } catch {
    i = t(s);
  }
  var n;
  return i;
}
we({ viewbox: { viewbox(s, e, t, i) {
  return s == null ? new it(this.attr("viewBox")) : this.attr("viewBox", new it(s, e, t, i));
}, zoom(s, e) {
  let { width: t, height: i } = this.attr(["width", "height"]);
  if ((t || i) && typeof t != "string" && typeof i != "string" || (t = this.node.clientWidth, i = this.node.clientHeight), !t || !i) throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
  const n = this.viewbox(), r = t / n.width, a = i / n.height, o = Math.min(r, a);
  if (s == null) return o;
  let l = o / s;
  l === 1 / 0 && (l = Number.MAX_SAFE_INTEGER / 100), e = e || new Me(t / 2 / r + n.x, i / 2 / a + n.y);
  const c = new it(n).transform(new ce({ scale: l, origin: e }));
  return this.viewbox(c);
} } }), Re(it, "Box");
class kn extends Array {
  constructor(e = [], ...t) {
    if (super(e, ...t), typeof e == "number") return this;
    this.length = 0, this.push(...e);
  }
}
fe([kn], { each(s, ...e) {
  return typeof s == "function" ? this.map((t, i, n) => s.call(t, t, i, n)) : this.map((t) => t[s](...e));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
const wT = ["toArray", "constructor", "each"];
function _n(s, e) {
  return new kn(kp((e || Te.document).querySelectorAll(s), function(t) {
    return ai(t);
  }));
}
kn.extend = function(s) {
  s = s.reduce((e, t) => (wT.includes(t) || t[0] === "_" || (t in Array.prototype && (e["$" + t] = Array.prototype[t]), e[t] = function(...i) {
    return this.each(t, ...i);
  }), e), {}), fe([kn], s);
};
let ST = 0;
const Cy = {};
function Ay(s) {
  let e = s.getEventHolder();
  return e === Te.window && (e = Cy), e.events || (e.events = {}), e.events;
}
function Tp(s) {
  return s.getEventTarget();
}
function gs(s, e, t, i, n) {
  const r = t.bind(i || s), a = Et(s), o = Ay(a), l = Tp(a);
  e = Array.isArray(e) ? e : e.split(Ps), t._svgjsListenerId || (t._svgjsListenerId = ++ST), e.forEach(function(c) {
    const h = c.split(".")[0], u = c.split(".")[1] || "*";
    o[h] = o[h] || {}, o[h][u] = o[h][u] || {}, o[h][u][t._svgjsListenerId] = r, l.addEventListener(h, r, n || !1);
  });
}
function ci(s, e, t, i) {
  const n = Et(s), r = Ay(n), a = Tp(n);
  (typeof t != "function" || (t = t._svgjsListenerId)) && (e = Array.isArray(e) ? e : (e || "").split(Ps)).forEach(function(o) {
    const l = o && o.split(".")[0], c = o && o.split(".")[1];
    let h, u;
    if (t) r[l] && r[l][c || "*"] && (a.removeEventListener(l, r[l][c || "*"][t], i || !1), delete r[l][c || "*"][t]);
    else if (l && c) {
      if (r[l] && r[l][c]) {
        for (u in r[l][c]) ci(a, [l, c].join("."), u);
        delete r[l][c];
      }
    } else if (c) for (o in r) for (h in r[o]) c === h && ci(a, [o, c].join("."));
    else if (l) {
      if (r[l]) {
        for (h in r[l]) ci(a, [l, h].join("."));
        delete r[l];
      }
    } else {
      for (o in r) ci(a, o);
      (function(d) {
        let f = d.getEventHolder();
        f === Te.window && (f = Cy), f.events && (f.events = {});
      })(n);
    }
  });
}
class fo extends Qp {
  addEventListener() {
  }
  dispatch(e, t, i) {
    return function(n, r, a, o) {
      const l = Tp(n);
      return r instanceof Te.window.Event || (r = new Te.window.CustomEvent(r, { detail: a, cancelable: !0, ...o })), l.dispatchEvent(r), r;
    }(this, e, t, i);
  }
  dispatchEvent(e) {
    const t = this.getEventHolder().events;
    if (!t) return !0;
    const i = t[e.type];
    for (const n in i) for (const r in i[n]) i[n][r](e);
    return !e.defaultPrevented;
  }
  fire(e, t, i) {
    return this.dispatch(e, t, i), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(e, t, i) {
    return ci(this, e, t, i), this;
  }
  on(e, t, i, n) {
    return gs(this, e, t, i, n), this;
  }
  removeEventListener() {
  }
}
function Qm() {
}
Re(fo, "EventTarget");
const Xh = 400, kT = ">", PT = 0, QT = { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "text-anchor": "start" };
class Pn extends Array {
  constructor(...e) {
    super(...e), this.init(...e);
  }
  clone() {
    return new this.constructor(this);
  }
  init(e) {
    return typeof e == "number" || (this.length = 0, this.push(...this.parse(e))), this;
  }
  parse(e = []) {
    return e instanceof Array ? e : e.trim().split(Ps).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  valueOf() {
    const e = [];
    return e.push(...this), e;
  }
}
class Oe {
  constructor(...e) {
    this.init(...e);
  }
  convert(e) {
    return new Oe(this.value, e);
  }
  divide(e) {
    return e = new Oe(e), new Oe(this / e, this.unit || e.unit);
  }
  init(e, t) {
    return t = Array.isArray(e) ? e[1] : t, e = Array.isArray(e) ? e[0] : e, this.value = 0, this.unit = t || "", typeof e == "number" ? this.value = isNaN(e) ? 0 : isFinite(e) ? e : e < 0 ? -34e37 : 34e37 : typeof e == "string" ? (t = e.match(Py)) && (this.value = parseFloat(t[1]), t[5] === "%" ? this.value /= 100 : t[5] === "s" && (this.value *= 1e3), this.unit = t[5]) : e instanceof Oe && (this.value = e.valueOf(), this.unit = e.unit), this;
  }
  minus(e) {
    return e = new Oe(e), new Oe(this - e, this.unit || e.unit);
  }
  plus(e) {
    return e = new Oe(e), new Oe(this + e, this.unit || e.unit);
  }
  times(e) {
    return e = new Oe(e), new Oe(this * e, this.unit || e.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (this.unit === "%" ? ~~(1e8 * this.value) / 1e6 : this.unit === "s" ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
}
const CT = /* @__PURE__ */ new Set(["fill", "stroke", "color", "bgcolor", "stop-color", "flood-color", "lighting-color"]), Ty = [];
class Ds extends fo {
  constructor(e, t) {
    super(), this.node = e, this.type = e.nodeName, t && e !== t && this.attr(t);
  }
  add(e, t) {
    return (e = Et(e)).removeNamespace && this.node instanceof Te.window.SVGElement && e.removeNamespace(), t == null ? this.node.appendChild(e.node) : e.node !== this.node.childNodes[t] && this.node.insertBefore(e.node, this.node.childNodes[t]), this;
  }
  addTo(e, t) {
    return Et(e).put(this, t);
  }
  children() {
    return new kn(kp(this.node.children, function(e) {
      return ai(e);
    }));
  }
  clear() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(e = !0, t = !0) {
    this.writeDataToDom();
    let i = this.node.cloneNode(e);
    return t && (i = ky(i)), new this.constructor(i);
  }
  each(e, t) {
    const i = this.children();
    let n, r;
    for (n = 0, r = i.length; n < r; n++) e.apply(i[n], [n, i]), t && i[n].each(e, t);
    return this;
  }
  element(e, t) {
    return this.put(new Ds(ka(e), t));
  }
  first() {
    return ai(this.node.firstChild);
  }
  get(e) {
    return ai(this.node.childNodes[e]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(e) {
    return this.index(e) >= 0;
  }
  html(e, t) {
    return this.xml(e, t, "http://www.w3.org/1999/xhtml");
  }
  id(e) {
    return e !== void 0 || this.node.id || (this.node.id = Sy(this.type)), this.attr("id", e);
  }
  index(e) {
    return [].slice.call(this.node.childNodes).indexOf(e.node);
  }
  last() {
    return ai(this.node.lastChild);
  }
  matches(e) {
    const t = this.node, i = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return i && i.call(t, e);
  }
  parent(e) {
    let t = this;
    if (!t.node.parentNode) return null;
    if (t = ai(t.node.parentNode), !e) return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e) return t;
    while (t = ai(t.node.parentNode));
    return t;
  }
  put(e, t) {
    return e = Et(e), this.add(e, t), e;
  }
  putIn(e, t) {
    return Et(e).add(this, t);
  }
  remove() {
    return this.parent() && this.parent().removeElement(this), this;
  }
  removeElement(e) {
    return this.node.removeChild(e.node), this;
  }
  replace(e) {
    return e = Et(e), this.node.parentNode && this.node.parentNode.replaceChild(e.node, this.node), e;
  }
  round(e = 2, t = null) {
    const i = 10 ** e, n = this.attr(t);
    for (const r in n) typeof n[r] == "number" && (n[r] = Math.round(n[r] * i) / i);
    return this.attr(n), this;
  }
  svg(e, t) {
    return this.xml(e, t, Pp);
  }
  toString() {
    return this.id();
  }
  words(e) {
    return this.node.textContent = e, this;
  }
  wrap(e) {
    const t = this.parent();
    if (!t) return this.addTo(e);
    const i = t.index(this);
    return t.put(e, i).put(this);
  }
  writeDataToDom() {
    return this.each(function() {
      this.writeDataToDom();
    }), this;
  }
  xml(e, t, i) {
    if (typeof e == "boolean" && (i = t, t = e, e = null), e == null || typeof e == "function") {
      t = t == null || t, this.writeDataToDom();
      let o = this;
      if (e != null) {
        if (o = ai(o.node.cloneNode(!0)), t) {
          const l = e(o);
          if (o = l || o, l === !1) return "";
        }
        o.each(function() {
          const l = e(this), c = l || this;
          l === !1 ? this.remove() : l && this !== c && this.replace(c);
        }, !0);
      }
      return t ? o.node.outerHTML : o.node.innerHTML;
    }
    t = t != null && t;
    const n = ka("wrapper", i), r = Te.document.createDocumentFragment();
    n.innerHTML = e;
    for (let o = n.children.length; o--; ) r.appendChild(n.firstElementChild);
    const a = this.parent();
    return t ? this.replace(r) && a : this.add(r);
  }
}
fe(Ds, { attr: function(s, e, t) {
  if (s == null) {
    s = {}, e = this.node.attributes;
    for (const i of e) s[i.nodeName] = km.test(i.nodeValue) ? parseFloat(i.nodeValue) : i.nodeValue;
    return s;
  }
  if (s instanceof Array) return s.reduce((i, n) => (i[n] = this.attr(n), i), {});
  if (typeof s == "object" && s.constructor === Object) for (e in s) this.attr(e, s[e]);
  else if (e === null) this.node.removeAttribute(s);
  else {
    if (e == null) return (e = this.node.getAttribute(s)) == null ? QT[s] : km.test(e) ? parseFloat(e) : e;
    typeof (e = Ty.reduce((i, n) => n(s, i, this), e)) == "number" ? e = new Oe(e) : CT.has(s) && qe.isColor(e) ? e = new qe(e) : e.constructor === Array && (e = new Pn(e)), s === "leading" ? this.leading && this.leading(e) : typeof t == "string" ? this.node.setAttributeNS(t, s, e.toString()) : this.node.setAttribute(s, e.toString()), !this.rebuild || s !== "font-size" && s !== "x" || this.rebuild();
  }
  return this;
}, find: function(s) {
  return _n(s, this.node);
}, findOne: function(s) {
  return ai(this.node.querySelector(s));
} }), Re(Ds, "Dom");
let kt = class extends Ds {
  constructor(s, e) {
    super(s, e), this.dom = {}, this.node.instance = this, (s.hasAttribute("data-svgjs") || s.hasAttribute("svgjs:data")) && this.setData(JSON.parse(s.getAttribute("data-svgjs")) ?? JSON.parse(s.getAttribute("svgjs:data")) ?? {});
  }
  center(s, e) {
    return this.cx(s).cy(e);
  }
  cx(s) {
    return s == null ? this.x() + this.width() / 2 : this.x(s - this.width() / 2);
  }
  cy(s) {
    return s == null ? this.y() + this.height() / 2 : this.y(s - this.height() / 2);
  }
  defs() {
    const s = this.root();
    return s && s.defs();
  }
  dmove(s, e) {
    return this.dx(s).dy(e);
  }
  dx(s = 0) {
    return this.x(new Oe(s).plus(this.x()));
  }
  dy(s = 0) {
    return this.y(new Oe(s).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(s) {
    return this.attr("height", s);
  }
  move(s, e) {
    return this.x(s).y(e);
  }
  parents(s = this.root()) {
    const e = typeof s == "string";
    e || (s = Et(s));
    const t = new kn();
    let i = this;
    for (; (i = i.parent()) && i.node !== Te.document && i.nodeName !== "#document-fragment" && (t.push(i), e || i.node !== s.node) && (!e || !i.matches(s)); ) if (i.node === this.root().node) return null;
    return t;
  }
  reference(s) {
    if (!(s = this.attr(s))) return null;
    const e = (s + "").match(OT);
    return e ? Et(e[1]) : null;
  }
  root() {
    const s = this.parent(function(e) {
      return On[e];
    }(Cp));
    return s && s.root();
  }
  setData(s) {
    return this.dom = s, this;
  }
  size(s, e) {
    const t = Tr(this, s, e);
    return this.width(new Oe(t.width)).height(new Oe(t.height));
  }
  width(s) {
    return this.attr("width", s);
  }
  writeDataToDom() {
    return wy(this, this.dom), super.writeDataToDom();
  }
  x(s) {
    return this.attr("x", s);
  }
  y(s) {
    return this.attr("y", s);
  }
};
fe(kt, { bbox: function() {
  const s = Pm(this, (e) => e.getBBox(), (e) => {
    try {
      const t = e.clone().addTo(Rs().svg).show(), i = t.node.getBBox();
      return t.remove(), i;
    } catch (t) {
      throw new Error(`Getting bbox of element "${e.node.nodeName}" is not possible: ${t.toString()}`);
    }
  });
  return new it(s);
}, rbox: function(s) {
  const e = Pm(this, (i) => i.getBoundingClientRect(), (i) => {
    throw new Error(`Getting rbox of element "${i.node.nodeName}" is not possible`);
  }), t = new it(e);
  return s ? t.transform(s.screenCTM().inverseO()) : t.addOffset();
}, inside: function(s, e) {
  const t = this.bbox();
  return s > t.x && e > t.y && s < t.x + t.width && e < t.y + t.height;
}, point: function(s, e) {
  return new Me(s, e).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new ce(this.node.getCTM());
}, screenCTM: function() {
  try {
    if (typeof this.isRoot == "function" && !this.isRoot()) {
      const s = this.rect(1, 1), e = s.node.getScreenCTM();
      return s.remove(), new ce(e);
    }
    return new ce(this.node.getScreenCTM());
  } catch {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new ce();
  }
} }), Re(kt, "Element");
const Dr = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(s, e) {
  return e === "color" ? s : s + "-" + e;
} };
["fill", "stroke"].forEach(function(s) {
  const e = {};
  let t;
  e[s] = function(i) {
    if (i === void 0) return this.attr(s);
    if (typeof i == "string" || i instanceof qe || qe.isRgb(i) || i instanceof kt) this.attr(s, i);
    else for (t = Dr[s].length - 1; t >= 0; t--) i[Dr[s][t]] != null && this.attr(Dr.prefix(s, Dr[s][t]), i[Dr[s][t]]);
    return this;
  }, we(["Element", "Runner"], e);
}), we(["Element", "Runner"], { matrix: function(s, e, t, i, n, r) {
  return s == null ? new ce(this) : this.attr("transform", new ce(s, e, t, i, n, r));
}, rotate: function(s, e, t) {
  return this.transform({ rotate: s, ox: e, oy: t }, !0);
}, skew: function(s, e, t, i) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ skew: s, ox: e, oy: t }, !0) : this.transform({ skew: [s, e], ox: t, oy: i }, !0);
}, shear: function(s, e, t) {
  return this.transform({ shear: s, ox: e, oy: t }, !0);
}, scale: function(s, e, t, i) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ scale: s, ox: e, oy: t }, !0) : this.transform({ scale: [s, e], ox: t, oy: i }, !0);
}, translate: function(s, e) {
  return this.transform({ translate: [s, e] }, !0);
}, relative: function(s, e) {
  return this.transform({ relative: [s, e] }, !0);
}, flip: function(s = "both", e = "center") {
  return "xybothtrue".indexOf(s) === -1 && (e = s, s = "both"), this.transform({ flip: s, origin: e }, !0);
}, opacity: function(s) {
  return this.attr("opacity", s);
} }), we("radius", { radius: function(s, e = s) {
  return (this._element || this).type === "radialGradient" ? this.attr("r", new Oe(s)) : this.rx(s).ry(e);
} }), we("Path", { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(s) {
  return new Me(this.node.getPointAtLength(s));
} }), we(["Element", "Runner"], { font: function(s, e) {
  if (typeof s == "object") {
    for (e in s) this.font(e, s[e]);
    return this;
  }
  return s === "leading" ? this.leading(e) : s === "anchor" ? this.attr("text-anchor", e) : s === "size" || s === "family" || s === "weight" || s === "stretch" || s === "variant" || s === "style" ? this.attr("font-" + s, e) : this.attr(s, e);
} });
we("Element", ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel", "contextmenu", "wheel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel"].reduce(function(s, e) {
  return s[e] = function(t) {
    return t === null ? this.off(e) : this.on(e, t), this;
  }, s;
}, {})), we("Element", { untransform: function() {
  return this.attr("transform", null);
}, matrixify: function() {
  return (this.attr("transform") || "").split(xT).slice(0, -1).map(function(e) {
    const t = e.trim().split("(");
    return [t[0], t[1].split(Ps).map(function(i) {
      return parseFloat(i);
    })];
  }).reverse().reduce(function(e, t) {
    return t[0] === "matrix" ? e.lmultiply(ce.fromArray(t[1])) : e[t[0]].apply(e, t[1]);
  }, new ce());
}, toParent: function(s, e) {
  if (this === s) return this;
  if (xd(this.node)) return this.addTo(s, e);
  const t = this.screenCTM(), i = s.screenCTM().inverse();
  return this.addTo(s, e).untransform().transform(i.multiply(t)), this;
}, toRoot: function(s) {
  return this.toParent(this.root(), s);
}, transform: function(s, e) {
  if (s == null || typeof s == "string") {
    const i = new ce(this).decompose();
    return s == null ? i : i[s];
  }
  ce.isMatrixLike(s) || (s = { ...s, origin: Od(s, this) });
  const t = new ce(e === !0 ? this : e || !1).transform(s);
  return this.attr("transform", t);
} });
class Lt extends kt {
  flatten() {
    return this.each(function() {
      if (this instanceof Lt) return this.flatten().ungroup();
    }), this;
  }
  ungroup(e = this.parent(), t = e.index(this)) {
    return t = t === -1 ? e.children().length : t, this.each(function(i, n) {
      return n[n.length - i - 1].toParent(e, t);
    }), this.remove();
  }
}
Re(Lt, "Container");
class Fc extends Lt {
  constructor(e, t = e) {
    super(Be("defs", e), t);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
}
Re(Fc, "Defs");
class si extends kt {
}
function $p(s) {
  return this.attr("rx", s);
}
function Rp(s) {
  return this.attr("ry", s);
}
function $y(s) {
  return s == null ? this.cx() - this.rx() : this.cx(s + this.rx());
}
function Ry(s) {
  return s == null ? this.cy() - this.ry() : this.cy(s + this.ry());
}
function Ey(s) {
  return this.attr("cx", s);
}
function Xy(s) {
  return this.attr("cy", s);
}
function My(s) {
  return s == null ? 2 * this.rx() : this.rx(new Oe(s).divide(2));
}
function _y(s) {
  return s == null ? 2 * this.ry() : this.ry(new Oe(s).divide(2));
}
Re(si, "Shape");
var AT = Object.freeze({ __proto__: null, cx: Ey, cy: Xy, height: _y, rx: $p, ry: Rp, width: My, x: $y, y: Ry });
class ml extends si {
  constructor(e, t = e) {
    super(Be("ellipse", e), t);
  }
  size(e, t) {
    const i = Tr(this, e, t);
    return this.rx(new Oe(i.width).divide(2)).ry(new Oe(i.height).divide(2));
  }
}
fe(ml, AT), we("Container", { ellipse: De(function(s = 0, e = s) {
  return this.put(new ml()).size(s, e).move(0, 0);
}) }), Re(ml, "Ellipse");
class Ly extends Ds {
  constructor(e = Te.document.createDocumentFragment()) {
    super(e);
  }
  xml(e, t, i) {
    if (typeof e == "boolean" && (i = t, t = e, e = null), e == null || typeof e == "function") {
      const n = new Ds(ka("wrapper", i));
      return n.add(this.node.cloneNode(!0)), n.xml(!1, i);
    }
    return super.xml(e, !1, i);
  }
}
function zy(s, e) {
  return (this._element || this).type === "radialGradient" ? this.attr({ fx: new Oe(s), fy: new Oe(e) }) : this.attr({ x1: new Oe(s), y1: new Oe(e) });
}
function Iy(s, e) {
  return (this._element || this).type === "radialGradient" ? this.attr({ cx: new Oe(s), cy: new Oe(e) }) : this.attr({ x2: new Oe(s), y2: new Oe(e) });
}
Re(Ly, "Fragment");
var TT = Object.freeze({ __proto__: null, from: zy, to: Iy });
class ca extends Lt {
  constructor(e, t) {
    super(Be(e + "Gradient", typeof e == "string" ? null : e), t);
  }
  attr(e, t, i) {
    return e === "transform" && (e = "gradientTransform"), super.attr(e, t, i);
  }
  bbox() {
    return new it();
  }
  targets() {
    return _n("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(e) {
    return this.clear(), typeof e == "function" && e.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
fe(ca, TT), we({ Container: { gradient(...s) {
  return this.defs().gradient(...s);
} }, Defs: { gradient: De(function(s, e) {
  return this.put(new ca(s)).update(e);
}) } }), Re(ca, "Gradient");
class Pa extends Lt {
  constructor(e, t = e) {
    super(Be("pattern", e), t);
  }
  attr(e, t, i) {
    return e === "transform" && (e = "patternTransform"), super.attr(e, t, i);
  }
  bbox() {
    return new it();
  }
  targets() {
    return _n("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(e) {
    return this.clear(), typeof e == "function" && e.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
we({ Container: { pattern(...s) {
  return this.defs().pattern(...s);
} }, Defs: { pattern: De(function(s, e, t) {
  return this.put(new Pa()).update(t).attr({ x: 0, y: 0, width: s, height: e, patternUnits: "userSpaceOnUse" });
}) } }), Re(Pa, "Pattern");
let Ol = class extends si {
  constructor(s, e = s) {
    super(Be("image", s), e);
  }
  load(s, e) {
    if (!s) return this;
    const t = new Te.window.Image();
    return gs(t, "load", function(i) {
      const n = this.parent(Pa);
      this.width() === 0 && this.height() === 0 && this.size(t.width, t.height), n instanceof Pa && n.width() === 0 && n.height() === 0 && n.size(this.width(), this.height()), typeof e == "function" && e.call(this, i);
    }, this), gs(t, "load error", function() {
      ci(t);
    }), this.attr("href", t.src = s, $r);
  }
};
var Cm;
Cm = function(s, e, t) {
  return s !== "fill" && s !== "stroke" || yT.test(e) && (e = t.root().defs().image(e)), e instanceof Ol && (e = t.root().defs().pattern(0, 0, (i) => {
    i.add(e);
  })), e;
}, Ty.push(Cm), we({ Container: { image: De(function(s, e) {
  return this.put(new Ol()).size(0, 0).load(s, e);
}) } }), Re(Ol, "Image");
class Bs extends Pn {
  bbox() {
    let e = -1 / 0, t = -1 / 0, i = 1 / 0, n = 1 / 0;
    return this.forEach(function(r) {
      e = Math.max(r[0], e), t = Math.max(r[1], t), i = Math.min(r[0], i), n = Math.min(r[1], n);
    }), new it(i, n, e - i, t - n);
  }
  move(e, t) {
    const i = this.bbox();
    if (e -= i.x, t -= i.y, !isNaN(e) && !isNaN(t)) for (let n = this.length - 1; n >= 0; n--) this[n] = [this[n][0] + e, this[n][1] + t];
    return this;
  }
  parse(e = [0, 0]) {
    const t = [];
    (e = e instanceof Array ? Array.prototype.concat.apply([], e) : e.trim().split(Ps).map(parseFloat)).length % 2 != 0 && e.pop();
    for (let i = 0, n = e.length; i < n; i += 2) t.push([e[i], e[i + 1]]);
    return t;
  }
  size(e, t) {
    let i;
    const n = this.bbox();
    for (i = this.length - 1; i >= 0; i--) n.width && (this[i][0] = (this[i][0] - n.x) * e / n.width + n.x), n.height && (this[i][1] = (this[i][1] - n.y) * t / n.height + n.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const e = [];
    for (let t = 0, i = this.length; t < i; t++) e.push(this[t].join(","));
    return e.join(" ");
  }
  transform(e) {
    return this.clone().transformO(e);
  }
  transformO(e) {
    ce.isMatrixLike(e) || (e = new ce(e));
    for (let t = this.length; t--; ) {
      const [i, n] = this[t];
      this[t][0] = e.a * i + e.c * n + e.e, this[t][1] = e.b * i + e.d * n + e.f;
    }
    return this;
  }
}
const $T = Bs;
var Ep = Object.freeze({ __proto__: null, MorphArray: $T, height: function(s) {
  const e = this.bbox();
  return s == null ? e.height : this.size(e.width, s);
}, width: function(s) {
  const e = this.bbox();
  return s == null ? e.width : this.size(s, e.height);
}, x: function(s) {
  return s == null ? this.bbox().x : this.move(s, this.bbox().y);
}, y: function(s) {
  return s == null ? this.bbox().y : this.move(this.bbox().x, s);
} });
let on = class extends si {
  constructor(s, e = s) {
    super(Be("line", s), e);
  }
  array() {
    return new Bs([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  move(s, e) {
    return this.attr(this.array().move(s, e).toLine());
  }
  plot(s, e, t, i) {
    return s == null ? this.array() : (s = e !== void 0 ? { x1: s, y1: e, x2: t, y2: i } : new Bs(s).toLine(), this.attr(s));
  }
  size(s, e) {
    const t = Tr(this, s, e);
    return this.attr(this.array().size(t.width, t.height).toLine());
  }
};
fe(on, Ep), we({ Container: { line: De(function(...s) {
  return on.prototype.plot.apply(this.put(new on()), s[0] != null ? s : [0, 0, 0, 0]);
}) } }), Re(on, "Line");
let xl = class extends Lt {
  constructor(s, e = s) {
    super(Be("marker", s), e);
  }
  height(s) {
    return this.attr("markerHeight", s);
  }
  orient(s) {
    return this.attr("orient", s);
  }
  ref(s, e) {
    return this.attr("refX", s).attr("refY", e);
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
  update(s) {
    return this.clear(), typeof s == "function" && s.call(this, this), this;
  }
  width(s) {
    return this.attr("markerWidth", s);
  }
};
function Hn(s, e) {
  return function(t) {
    return t == null ? this[s] : (this[s] = t, e && e.call(this), this);
  };
}
we({ Container: { marker(...s) {
  return this.defs().marker(...s);
} }, Defs: { marker: De(function(s, e, t) {
  return this.put(new xl()).size(s, e).ref(s / 2, e / 2).viewbox(0, 0, s, e).attr("orient", "auto").update(t);
}) }, marker: { marker(s, e, t, i) {
  let n = ["marker"];
  return s !== "all" && n.push(s), n = n.join("-"), s = arguments[1] instanceof xl ? arguments[1] : this.defs().marker(e, t, i), this.attr(n, s);
} } }), Re(xl, "Marker");
const RT = { "-": function(s) {
  return s;
}, "<>": function(s) {
  return -Math.cos(s * Math.PI) / 2 + 0.5;
}, ">": function(s) {
  return Math.sin(s * Math.PI / 2);
}, "<": function(s) {
  return 1 - Math.cos(s * Math.PI / 2);
}, bezier: function(s, e, t, i) {
  return function(n) {
    return n < 0 ? s > 0 ? e / s * n : t > 0 ? i / t * n : 0 : n > 1 ? t < 1 ? (1 - i) / (1 - t) * n + (i - t) / (1 - t) : s < 1 ? (1 - e) / (1 - s) * n + (e - s) / (1 - s) : 1 : 3 * n * (1 - n) ** 2 * e + 3 * n ** 2 * (1 - n) * i + n ** 3;
  };
}, steps: function(s, e = "end") {
  e = e.split("-").reverse()[0];
  let t = s;
  return e === "none" ? --t : e === "both" && ++t, (i, n = !1) => {
    let r = Math.floor(i * s);
    const a = i * r % 1 == 0;
    return e !== "start" && e !== "both" || ++r, n && a && --r, i >= 0 && r < 0 && (r = 0), i <= 1 && r > t && (r = t), r / t;
  };
} };
class Xp {
  done() {
    return !1;
  }
}
class bd extends Xp {
  constructor(e = kT) {
    super(), this.ease = RT[e] || e;
  }
  step(e, t, i) {
    return typeof e != "number" ? i < 1 ? e : t : e + (t - e) * this.ease(i);
  }
}
class Kl extends Xp {
  constructor(e) {
    super(), this.stepper = e;
  }
  done(e) {
    return e.done;
  }
  step(e, t, i, n) {
    return this.stepper(e, t, i, n);
  }
}
function Am() {
  const s = (this._duration || 500) / 1e3, e = this._overshoot || 0, t = Math.PI, i = Math.log(e / 100 + 1e-10), n = -i / Math.sqrt(t * t + i * i), r = 3.9 / (n * s);
  this.d = 2 * n * r, this.k = r * r;
}
fe(class extends Kl {
  constructor(s = 500, e = 0) {
    super(), this.duration(s).overshoot(e);
  }
  step(s, e, t, i) {
    if (typeof s == "string") return s;
    if (i.done = t === 1 / 0, t === 1 / 0) return e;
    if (t === 0) return s;
    t > 100 && (t = 16), t /= 1e3;
    const n = i.velocity || 0, r = -this.d * n - this.k * (s - e), a = s + n * t + r * t * t / 2;
    return i.velocity = n + r * t, i.done = Math.abs(e - a) + Math.abs(n) < 2e-3, i.done ? e : a;
  }
}, { duration: Hn("_duration", Am), overshoot: Hn("_overshoot", Am) });
fe(class extends Kl {
  constructor(s = 0.1, e = 0.01, t = 0, i = 1e3) {
    super(), this.p(s).i(e).d(t).windup(i);
  }
  step(s, e, t, i) {
    if (typeof s == "string") return s;
    if (i.done = t === 1 / 0, t === 1 / 0) return e;
    if (t === 0) return s;
    const n = e - s;
    let r = (i.integral || 0) + n * t;
    const a = (n - (i.error || 0)) / t, o = this._windup;
    return o !== !1 && (r = Math.max(-o, Math.min(r, o))), i.error = n, i.integral = r, i.done = Math.abs(n) < 1e-3, i.done ? e : s + (this.P * n + this.I * r + this.D * a);
  }
}, { windup: Hn("_windup"), p: Hn("P"), i: Hn("I"), d: Hn("D") });
const ET = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 }, yd = { M: function(s, e, t) {
  return e.x = t.x = s[0], e.y = t.y = s[1], ["M", e.x, e.y];
}, L: function(s, e) {
  return e.x = s[0], e.y = s[1], ["L", s[0], s[1]];
}, H: function(s, e) {
  return e.x = s[0], ["H", s[0]];
}, V: function(s, e) {
  return e.y = s[0], ["V", s[0]];
}, C: function(s, e) {
  return e.x = s[4], e.y = s[5], ["C", s[0], s[1], s[2], s[3], s[4], s[5]];
}, S: function(s, e) {
  return e.x = s[2], e.y = s[3], ["S", s[0], s[1], s[2], s[3]];
}, Q: function(s, e) {
  return e.x = s[2], e.y = s[3], ["Q", s[0], s[1], s[2], s[3]];
}, T: function(s, e) {
  return e.x = s[0], e.y = s[1], ["T", s[0], s[1]];
}, Z: function(s, e, t) {
  return e.x = t.x, e.y = t.y, ["Z"];
}, A: function(s, e) {
  return e.x = s[5], e.y = s[6], ["A", s[0], s[1], s[2], s[3], s[4], s[5], s[6]];
} }, Mh = "mlhvqtcsaz".split("");
for (let s = 0, e = Mh.length; s < e; ++s) yd[Mh[s]] = /* @__PURE__ */ function(t) {
  return function(i, n, r) {
    if (t === "H") i[0] = i[0] + n.x;
    else if (t === "V") i[0] = i[0] + n.y;
    else if (t === "A") i[5] = i[5] + n.x, i[6] = i[6] + n.y;
    else for (let a = 0, o = i.length; a < o; ++a) i[a] = i[a] + (a % 2 ? n.y : n.x);
    return yd[t](i, n, r);
  };
}(Mh[s].toUpperCase());
function vd(s) {
  return s.segment.length && s.segment.length - 1 === ET[s.segment[0].toUpperCase()];
}
function XT(s, e) {
  s.inNumber && Ks(s, !1);
  const t = Ap.test(e);
  if (t) s.segment = [e];
  else {
    const i = s.lastCommand, n = i.toLowerCase(), r = i === n;
    s.segment = [n === "m" ? r ? "l" : "L" : i];
  }
  return s.inSegment = !0, s.lastCommand = s.segment[0], t;
}
function Ks(s, e) {
  if (!s.inNumber) throw new Error("Parser Error");
  s.number && s.segment.push(parseFloat(s.number)), s.inNumber = e, s.number = "", s.pointSeen = !1, s.hasExponent = !1, vd(s) && wd(s);
}
function wd(s) {
  s.inSegment = !1, s.absolute && (s.segment = function(e) {
    const t = e.segment[0];
    return yd[t](e.segment.slice(1), e.p, e.p0);
  }(s)), s.segments.push(s.segment);
}
function MT(s) {
  if (!s.segment.length) return !1;
  const e = s.segment[0].toUpperCase() === "A", t = s.segment.length;
  return e && (t === 4 || t === 5);
}
function _T(s) {
  return s.lastToken.toUpperCase() === "E";
}
const LT = /* @__PURE__ */ new Set([" ", ",", "	", `
`, "\r", "\f"]);
class Si extends Pn {
  bbox() {
    return Rs().path.setAttribute("d", this.toString()), new it(Rs.nodes.path.getBBox());
  }
  move(e, t) {
    const i = this.bbox();
    if (e -= i.x, t -= i.y, !isNaN(e) && !isNaN(t)) for (let n, r = this.length - 1; r >= 0; r--) n = this[r][0], n === "M" || n === "L" || n === "T" ? (this[r][1] += e, this[r][2] += t) : n === "H" ? this[r][1] += e : n === "V" ? this[r][1] += t : n === "C" || n === "S" || n === "Q" ? (this[r][1] += e, this[r][2] += t, this[r][3] += e, this[r][4] += t, n === "C" && (this[r][5] += e, this[r][6] += t)) : n === "A" && (this[r][6] += e, this[r][7] += t);
    return this;
  }
  parse(e = "M0 0") {
    return Array.isArray(e) && (e = Array.prototype.concat.apply([], e).toString()), function(t, i = !0) {
      let n = 0, r = "";
      const a = { segment: [], inNumber: !1, number: "", lastToken: "", inSegment: !1, segments: [], pointSeen: !1, hasExponent: !1, absolute: i, p0: new Me(), p: new Me() };
      for (; a.lastToken = r, r = t.charAt(n++); ) if (a.inSegment || !XT(a, r)) if (r !== ".") if (isNaN(parseInt(r))) if (LT.has(r)) a.inNumber && Ks(a, !1);
      else if (r !== "-" && r !== "+") if (r.toUpperCase() !== "E") {
        if (Ap.test(r)) {
          if (a.inNumber) Ks(a, !1);
          else {
            if (!vd(a)) throw new Error("parser Error");
            wd(a);
          }
          --n;
        }
      } else a.number += r, a.hasExponent = !0;
      else {
        if (a.inNumber && !_T(a)) {
          Ks(a, !1), --n;
          continue;
        }
        a.number += r, a.inNumber = !0;
      }
      else {
        if (a.number === "0" || MT(a)) {
          a.inNumber = !0, a.number = r, Ks(a, !0);
          continue;
        }
        a.inNumber = !0, a.number += r;
      }
      else {
        if (a.pointSeen || a.hasExponent) {
          Ks(a, !1), --n;
          continue;
        }
        a.inNumber = !0, a.pointSeen = !0, a.number += r;
      }
      return a.inNumber && Ks(a, !1), a.inSegment && vd(a) && wd(a), a.segments;
    }(e);
  }
  size(e, t) {
    const i = this.bbox();
    let n, r;
    for (i.width = i.width === 0 ? 1 : i.width, i.height = i.height === 0 ? 1 : i.height, n = this.length - 1; n >= 0; n--) r = this[n][0], r === "M" || r === "L" || r === "T" ? (this[n][1] = (this[n][1] - i.x) * e / i.width + i.x, this[n][2] = (this[n][2] - i.y) * t / i.height + i.y) : r === "H" ? this[n][1] = (this[n][1] - i.x) * e / i.width + i.x : r === "V" ? this[n][1] = (this[n][1] - i.y) * t / i.height + i.y : r === "C" || r === "S" || r === "Q" ? (this[n][1] = (this[n][1] - i.x) * e / i.width + i.x, this[n][2] = (this[n][2] - i.y) * t / i.height + i.y, this[n][3] = (this[n][3] - i.x) * e / i.width + i.x, this[n][4] = (this[n][4] - i.y) * t / i.height + i.y, r === "C" && (this[n][5] = (this[n][5] - i.x) * e / i.width + i.x, this[n][6] = (this[n][6] - i.y) * t / i.height + i.y)) : r === "A" && (this[n][1] = this[n][1] * e / i.width, this[n][2] = this[n][2] * t / i.height, this[n][6] = (this[n][6] - i.x) * e / i.width + i.x, this[n][7] = (this[n][7] - i.y) * t / i.height + i.y);
    return this;
  }
  toString() {
    return function(e) {
      let t = "";
      for (let i = 0, n = e.length; i < n; i++) t += e[i][0], e[i][1] != null && (t += e[i][1], e[i][2] != null && (t += " ", t += e[i][2], e[i][3] != null && (t += " ", t += e[i][3], t += " ", t += e[i][4], e[i][5] != null && (t += " ", t += e[i][5], t += " ", t += e[i][6], e[i][7] != null && (t += " ", t += e[i][7])))));
      return t + " ";
    }(this);
  }
}
const qy = (s) => {
  const e = typeof s;
  return e === "number" ? Oe : e === "string" ? qe.isColor(s) ? qe : Ps.test(s) ? Ap.test(s) ? Si : Pn : Py.test(s) ? Oe : Sd : kd.indexOf(s.constructor) > -1 ? s.constructor : Array.isArray(s) ? Pn : e === "object" ? Qa : Sd;
};
class Js {
  constructor(e) {
    this._stepper = e || new bd("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(e) {
    return this._morphObj.morph(this._from, this._to, e, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce(function(e, t) {
      return e && t;
    }, !0);
  }
  from(e) {
    return e == null ? this._from : (this._from = this._set(e), this);
  }
  stepper(e) {
    return e == null ? this._stepper : (this._stepper = e, this);
  }
  to(e) {
    return e == null ? this._to : (this._to = this._set(e), this);
  }
  type(e) {
    return e == null ? this._type : (this._type = e, this);
  }
  _set(e) {
    this._type || this.type(qy(e));
    let t = new this._type(e);
    return this._type === qe && (t = this._to ? t[this._to[4]]() : this._from ? t[this._from[4]]() : t), this._type === Qa && (t = this._to ? t.align(this._to) : this._from ? t.align(this._from) : t), t = t.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(t.length)).map(Object).map(function(i) {
      return i.done = !0, i;
    }), t;
  }
}
class Sd {
  constructor(...e) {
    this.init(...e);
  }
  init(e) {
    return e = Array.isArray(e) ? e[0] : e, this.value = e, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
}
class po {
  constructor(...e) {
    this.init(...e);
  }
  init(e) {
    return Array.isArray(e) && (e = { scaleX: e[0], scaleY: e[1], shear: e[2], rotate: e[3], translateX: e[4], translateY: e[5], originX: e[6], originY: e[7] }), Object.assign(this, po.defaults, e), this;
  }
  toArray() {
    const e = this;
    return [e.scaleX, e.scaleY, e.shear, e.rotate, e.translateX, e.translateY, e.originX, e.originY];
  }
}
po.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
const zT = (s, e) => s[0] < e[0] ? -1 : s[0] > e[0] ? 1 : 0;
class Qa {
  constructor(...e) {
    this.init(...e);
  }
  align(e) {
    const t = this.values;
    for (let i = 0, n = t.length; i < n; ++i) {
      if (t[i + 1] === e[i + 1]) {
        if (t[i + 1] === qe && e[i + 7] !== t[i + 7]) {
          const o = e[i + 7], l = new qe(this.values.splice(i + 3, 5))[o]().toArray();
          this.values.splice(i + 3, 0, ...l);
        }
        i += t[i + 2] + 2;
        continue;
      }
      if (!e[i + 1]) return this;
      const r = new e[i + 1]().toArray(), a = t[i + 2] + 3;
      t.splice(i, a, e[i], e[i + 1], e[i + 2], ...r), i += t[i + 2] + 2;
    }
    return this;
  }
  init(e) {
    if (this.values = [], Array.isArray(e)) return void (this.values = e.slice());
    e = e || {};
    const t = [];
    for (const i in e) {
      const n = qy(e[i]), r = new n(e[i]).toArray();
      t.push([i, n, r.length, ...r]);
    }
    return t.sort(zT), this.values = t.reduce((i, n) => i.concat(n), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const e = {}, t = this.values;
    for (; t.length; ) {
      const i = t.shift(), n = t.shift(), r = t.shift(), a = t.splice(0, r);
      e[i] = new n(a);
    }
    return e;
  }
}
const kd = [Sd, po, Qa];
class er extends si {
  constructor(e, t = e) {
    super(Be("path", e), t);
  }
  array() {
    return this._array || (this._array = new Si(this.attr("d")));
  }
  clear() {
    return delete this._array, this;
  }
  height(e) {
    return e == null ? this.bbox().height : this.size(this.bbox().width, e);
  }
  move(e, t) {
    return this.attr("d", this.array().move(e, t));
  }
  plot(e) {
    return e == null ? this.array() : this.clear().attr("d", typeof e == "string" ? e : this._array = new Si(e));
  }
  size(e, t) {
    const i = Tr(this, e, t);
    return this.attr("d", this.array().size(i.width, i.height));
  }
  width(e) {
    return e == null ? this.bbox().width : this.size(e, this.bbox().height);
  }
  x(e) {
    return e == null ? this.bbox().x : this.move(e, this.bbox().y);
  }
  y(e) {
    return e == null ? this.bbox().y : this.move(this.bbox().x, e);
  }
}
er.prototype.MorphArray = Si, we({ Container: { path: De(function(s) {
  return this.put(new er()).plot(s || new Si());
}) } }), Re(er, "Path");
var Dy = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new Bs(this.attr("points")));
}, clear: function() {
  return delete this._array, this;
}, move: function(s, e) {
  return this.attr("points", this.array().move(s, e));
}, plot: function(s) {
  return s == null ? this.array() : this.clear().attr("points", typeof s == "string" ? s : this._array = new Bs(s));
}, size: function(s, e) {
  const t = Tr(this, s, e);
  return this.attr("points", this.array().size(t.width, t.height));
} });
class ln extends si {
  constructor(e, t = e) {
    super(Be("polygon", e), t);
  }
}
we({ Container: { polygon: De(function(s) {
  return this.put(new ln()).plot(s || new Bs());
}) } }), fe(ln, Ep), fe(ln, Dy), Re(ln, "Polygon");
class cn extends si {
  constructor(e, t = e) {
    super(Be("polyline", e), t);
  }
}
we({ Container: { polyline: De(function(s) {
  return this.put(new cn()).plot(s || new Bs());
}) } }), fe(cn, Ep), fe(cn, Dy), Re(cn, "Polyline");
class bl extends si {
  constructor(e, t = e) {
    super(Be("rect", e), t);
  }
}
fe(bl, { rx: $p, ry: Rp }), we({ Container: { rect: De(function(s, e) {
  return this.put(new bl()).size(s, e);
}) } }), Re(bl, "Rect");
class _h {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  push(e) {
    const t = e.next !== void 0 ? e : { value: e, next: null, prev: null };
    return this._last ? (t.prev = this._last, this._last.next = t, this._last = t) : (this._last = t, this._first = t), t;
  }
  remove(e) {
    e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this._last && (this._last = e.prev), e === this._first && (this._first = e.next), e.prev = null, e.next = null;
  }
  shift() {
    const e = this._first;
    return e ? (this._first = e.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, e.value) : null;
  }
}
const _e = { nextDraw: null, frames: new _h(), timeouts: new _h(), immediates: new _h(), timer: () => Te.window.performance || Te.window.Date, transforms: [], frame(s) {
  const e = _e.frames.push({ run: s });
  return _e.nextDraw === null && (_e.nextDraw = Te.window.requestAnimationFrame(_e._draw)), e;
}, timeout(s, e) {
  e = e || 0;
  const t = _e.timer().now() + e, i = _e.timeouts.push({ run: s, time: t });
  return _e.nextDraw === null && (_e.nextDraw = Te.window.requestAnimationFrame(_e._draw)), i;
}, immediate(s) {
  const e = _e.immediates.push(s);
  return _e.nextDraw === null && (_e.nextDraw = Te.window.requestAnimationFrame(_e._draw)), e;
}, cancelFrame(s) {
  s != null && _e.frames.remove(s);
}, clearTimeout(s) {
  s != null && _e.timeouts.remove(s);
}, cancelImmediate(s) {
  s != null && _e.immediates.remove(s);
}, _draw(s) {
  let e = null;
  const t = _e.timeouts.last();
  for (; (e = _e.timeouts.shift()) && (s >= e.time ? e.run() : _e.timeouts.push(e), e !== t); ) ;
  let i = null;
  const n = _e.frames.last();
  for (; i !== n && (i = _e.frames.shift()); ) i.run(s);
  let r = null;
  for (; r = _e.immediates.shift(); ) r();
  _e.nextDraw = _e.timeouts.first() || _e.frames.first() ? Te.window.requestAnimationFrame(_e._draw) : null;
} }, IT = function(s) {
  const e = s.start, t = s.runner.duration();
  return { start: e, duration: t, end: e + t, runner: s.runner };
}, qT = function() {
  const s = Te.window;
  return (s.performance || s.Date).now();
};
class By extends fo {
  constructor(e = qT) {
    super(), this._timeSource = e, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const e = this.getLastRunnerInfo(), t = e ? e.runner.duration() : 0;
    return (e ? e.start : this._time) + t;
  }
  getEndTimeOfTimeline() {
    const e = this._runners.map((t) => t.start + t.runner.duration());
    return Math.max(0, ...e);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(e) {
    return this._runners[this._runnerIds.indexOf(e)] || null;
  }
  pause() {
    return this._paused = !0, this._continue();
  }
  persist(e) {
    return e == null ? this._persist : (this._persist = e, this);
  }
  play() {
    return this._paused = !1, this.updateTime()._continue();
  }
  reverse(e) {
    const t = this.speed();
    if (e == null) return this.speed(-t);
    const i = Math.abs(t);
    return this.speed(e ? -i : i);
  }
  schedule(e, t, i) {
    if (e == null) return this._runners.map(IT);
    let n = 0;
    const r = this.getEndTime();
    if (t = t || 0, i == null || i === "last" || i === "after") n = r;
    else if (i === "absolute" || i === "start") n = t, t = 0;
    else if (i === "now") n = this._time;
    else if (i === "relative") {
      const l = this.getRunnerInfoById(e.id);
      l && (n = l.start + t, t = 0);
    } else {
      if (i !== "with-last") throw new Error('Invalid value for the "when" parameter');
      {
        const l = this.getLastRunnerInfo();
        n = l ? l.start : this._time;
      }
    }
    e.unschedule(), e.timeline(this);
    const a = e.persist(), o = { persist: a === null ? this._persist : a, start: n + t, runner: e };
    return this._lastRunnerId = e.id, this._runners.push(o), this._runners.sort((l, c) => l.start - c.start), this._runnerIds = this._runners.map((l) => l.runner.id), this.updateTime()._continue(), this;
  }
  seek(e) {
    return this.time(this._time + e);
  }
  source(e) {
    return e == null ? this._timeSource : (this._timeSource = e, this);
  }
  speed(e) {
    return e == null ? this._speed : (this._speed = e, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(e) {
    return e == null ? this._time : (this._time = e, this._continue(!0));
  }
  unschedule(e) {
    const t = this._runnerIds.indexOf(e.id);
    return t < 0 || (this._runners.splice(t, 1), this._runnerIds.splice(t, 1), e.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(e = !1) {
    return _e.cancelFrame(this._nextFrame), this._nextFrame = null, e ? this._stepImmediate() : (this._paused || (this._nextFrame = _e.frame(this._step)), this);
  }
  _stepFn(e = !1) {
    const t = this._timeSource();
    let i = t - this._lastSourceTime;
    e && (i = 0);
    const n = this._speed * i + (this._time - this._lastStepTime);
    this._lastSourceTime = t, e || (this._time += n, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
    for (let a = this._runners.length; a--; ) {
      const o = this._runners[a], l = o.runner;
      this._time - o.start <= 0 && l.reset();
    }
    let r = !1;
    for (let a = 0, o = this._runners.length; a < o; a++) {
      const l = this._runners[a], c = l.runner;
      let h = n;
      const u = this._time - l.start;
      if (u <= 0) {
        r = !0;
        continue;
      }
      u < h && (h = u), c.active() && (c.step(h).done ? l.persist !== !0 && c.duration() - c.time() + this._time + l.persist < this._time && (c.unschedule(), --a, --o) : r = !0);
    }
    return r && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = !0, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, !1), this._stepImmediate = this._stepFn.bind(this, !0);
  }
}
we({ Element: { timeline: function(s) {
  return s == null ? (this._timeline = this._timeline || new By(), this._timeline) : (this._timeline = s, this);
} } });
class ti extends fo {
  constructor(e) {
    super(), this.id = ti.id++, e = typeof (e = e ?? Xh) == "function" ? new Kl(e) : e, this._element = null, this._timeline = null, this.done = !1, this._queue = [], this._duration = typeof e == "number" && e, this._isDeclarative = e instanceof Kl, this._stepper = this._isDeclarative ? e : new bd(), this._history = {}, this.enabled = !0, this._time = 0, this._lastTime = 0, this._reseted = !0, this.transforms = new ce(), this.transformId = 1, this._haveReversed = !1, this._reverse = !1, this._loopsDone = 0, this._swing = !1, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(e, t, i) {
    let n = 1, r = !1, a = 0;
    return t = t ?? PT, i = i || "last", typeof (e = e ?? Xh) != "object" || e instanceof Xp || (t = e.delay ?? t, i = e.when ?? i, r = e.swing || r, n = e.times ?? n, a = e.wait ?? a, e = e.duration ?? Xh), { duration: e, delay: t, swing: r, times: n, wait: a, when: i };
  }
  active(e) {
    return e == null ? this.enabled : (this.enabled = e, this);
  }
  addTransform(e) {
    return this.transforms.lmultiplyO(e), this;
  }
  after(e) {
    return this.on("finished", e);
  }
  animate(e, t, i) {
    const n = ti.sanitise(e, t, i), r = new ti(n.duration);
    return this._timeline && r.timeline(this._timeline), this._element && r.element(this._element), r.loop(n).schedule(n.delay, n.when);
  }
  clearTransform() {
    return this.transforms = new ce(), this;
  }
  clearTransformsFromQueue() {
    this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter((e) => !e.isTransform));
  }
  delay(e) {
    return this.animate(0, e);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(e) {
    return this.queue(null, e);
  }
  ease(e) {
    return this._stepper = new bd(e), this;
  }
  element(e) {
    return e == null ? this._element : (this._element = e, e._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(e, t, i) {
    return typeof e == "object" && (t = e.swing, i = e.wait, e = e.times), this._times = e || 1 / 0, this._swing = t || !1, this._wait = i || 0, this._times === !0 && (this._times = 1 / 0), this;
  }
  loops(e) {
    const t = this._duration + this._wait;
    if (e == null) {
      const r = Math.floor(this._time / t), a = (this._time - r * t) / this._duration;
      return Math.min(r + a, this._times);
    }
    const i = e % 1, n = t * Math.floor(e) + this._duration * i;
    return this.time(n);
  }
  persist(e) {
    return e == null ? this._persist : (this._persist = e, this);
  }
  position(e) {
    const t = this._time, i = this._duration, n = this._wait, r = this._times, a = this._swing, o = this._reverse;
    let l;
    if (e == null) {
      const u = function(f) {
        const p = a * Math.floor(f % (2 * (n + i)) / (n + i)), g = p && !o || !p && o, m = Math.pow(-1, g) * (f % (n + i)) / i + g;
        return Math.max(Math.min(m, 1), 0);
      }, d = r * (n + i) - n;
      return l = t <= 0 ? Math.round(u(1e-5)) : t < d ? u(t) : Math.round(u(d - 1e-5)), l;
    }
    const c = Math.floor(this.loops()), h = a && c % 2 == 0;
    return l = c + (h && !o || o && h ? e : 1 - e), this.loops(l);
  }
  progress(e) {
    return e == null ? Math.min(1, this._time / this.duration()) : this.time(e * this.duration());
  }
  queue(e, t, i, n) {
    return this._queue.push({ initialiser: e || Qm, runner: t || Qm, retarget: i, isTransform: n, initialised: !1, finished: !1 }), this.timeline() && this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = !0), this;
  }
  reverse(e) {
    return this._reverse = e ?? !this._reverse, this;
  }
  schedule(e, t, i) {
    if (e instanceof By || (i = t, t = e, e = this.timeline()), !e) throw Error("Runner cannot be scheduled without timeline");
    return e.schedule(this, t, i), this;
  }
  step(e) {
    if (!this.enabled) return this;
    e = e ?? 16, this._time += e;
    const t = this.position(), i = this._lastPosition !== t && this._time >= 0;
    this._lastPosition = t;
    const n = this.duration(), r = this._lastTime <= 0 && this._time > 0, a = this._lastTime < n && this._time >= n;
    this._lastTime = this._time, r && this.fire("start", this);
    const o = this._isDeclarative;
    this.done = !o && !a && this._time >= n, this._reseted = !1;
    let l = !1;
    return (i || o) && (this._initialise(i), this.transforms = new ce(), l = this._run(o ? e : t), this.fire("step", this)), this.done = this.done || l && o, a && this.fire("finished", this), this;
  }
  time(e) {
    if (e == null) return this._time;
    const t = e - this._time;
    return this.step(t), this;
  }
  timeline(e) {
    return e === void 0 ? this._timeline : (this._timeline = e, this);
  }
  unschedule() {
    const e = this.timeline();
    return e && e.unschedule(this), this;
  }
  _initialise(e) {
    if (e || this._isDeclarative) for (let t = 0, i = this._queue.length; t < i; ++t) {
      const n = this._queue[t], r = this._isDeclarative || !n.initialised && e;
      e = !n.finished, r && e && (n.initialiser.call(this), n.initialised = !0);
    }
  }
  _rememberMorpher(e, t) {
    if (this._history[e] = { morpher: t, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const i = this.timeline();
      i && i.play();
    }
  }
  _run(e) {
    let t = !0;
    for (let i = 0, n = this._queue.length; i < n; ++i) {
      const r = this._queue[i], a = r.runner.call(this, e);
      r.finished = r.finished || a === !0, t = t && r.finished;
    }
    return t;
  }
  _tryRetarget(e, t, i) {
    if (this._history[e]) {
      if (!this._history[e].caller.initialised) {
        const r = this._queue.indexOf(this._history[e].caller);
        return this._queue.splice(r, 1), !1;
      }
      this._history[e].caller.retarget ? this._history[e].caller.retarget.call(this, t, i) : this._history[e].morpher.to(t), this._history[e].caller.finished = !1;
      const n = this.timeline();
      return n && n.play(), !0;
    }
    return !1;
  }
}
ti.id = 0;
class Jl {
  constructor(e = new ce(), t = -1, i = !0) {
    this.transforms = e, this.id = t, this.done = i;
  }
  clearTransformsFromQueue() {
  }
}
fe([ti, Jl], { mergeWith(s) {
  return new Jl(s.transforms.lmultiply(this.transforms), s.id);
} });
const Wy = (s, e) => s.lmultiplyO(e), Yy = (s) => s.transforms;
function DT() {
  const s = this._transformationRunners.runners.map(Yy).reduce(Wy, new ce());
  this.transform(s), this._transformationRunners.merge(), this._transformationRunners.length() === 1 && (this._frameId = null);
}
class BT {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(e) {
    if (this.runners.includes(e)) return;
    const t = e.id + 1;
    return this.runners.push(e), this.ids.push(t), this;
  }
  clearBefore(e) {
    const t = this.ids.indexOf(e + 1) || 1;
    return this.ids.splice(0, t, 0), this.runners.splice(0, t, new Jl()).forEach((i) => i.clearTransformsFromQueue()), this;
  }
  edit(e, t) {
    const i = this.ids.indexOf(e + 1);
    return this.ids.splice(i, 1, e + 1), this.runners.splice(i, 1, t), this;
  }
  getByID(e) {
    return this.runners[this.ids.indexOf(e + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let e = null;
    for (let t = 0; t < this.runners.length; ++t) {
      const i = this.runners[t];
      if (e && i.done && e.done && (!i._timeline || !i._timeline._runnerIds.includes(i.id)) && (!e._timeline || !e._timeline._runnerIds.includes(e.id))) {
        this.remove(i.id);
        const n = i.mergeWith(e);
        this.edit(e.id, n), e = n, --t;
      } else e = i;
    }
    return this;
  }
  remove(e) {
    const t = this.ids.indexOf(e + 1);
    return this.ids.splice(t, 1), this.runners.splice(t, 1), this;
  }
}
we({ Element: { animate(s, e, t) {
  const i = ti.sanitise(s, e, t), n = this.timeline();
  return new ti(i.duration).loop(i).element(this).timeline(n.play()).schedule(i.delay, i.when);
}, delay(s, e) {
  return this.animate(0, s, e);
}, _clearTransformRunnersBefore(s) {
  this._transformationRunners.clearBefore(s.id);
}, _currentTransform(s) {
  return this._transformationRunners.runners.filter((e) => e.id <= s.id).map(Yy).reduce(Wy, new ce());
}, _addRunner(s) {
  this._transformationRunners.add(s), _e.cancelImmediate(this._frameId), this._frameId = _e.immediate(DT.bind(this));
}, _prepareRunner() {
  this._frameId == null && (this._transformationRunners = new BT().add(new Jl(new ce(this))));
} } });
fe(ti, { attr(s, e) {
  return this.styleAttr("attr", s, e);
}, css(s, e) {
  return this.styleAttr("css", s, e);
}, styleAttr(s, e, t) {
  if (typeof e == "string") return this.styleAttr(s, { [e]: t });
  let i = e;
  if (this._tryRetarget(s, i)) return this;
  let n = new Js(this._stepper).to(i), r = Object.keys(i);
  return this.queue(function() {
    n = n.from(this.element()[s](r));
  }, function(a) {
    return this.element()[s](n.at(a).valueOf()), n.done();
  }, function(a) {
    const o = Object.keys(a), l = (c = r, o.filter((u) => !c.includes(u)));
    var c;
    if (l.length) {
      const u = this.element()[s](l), d = new Qa(n.from()).valueOf();
      Object.assign(d, u), n.from(d);
    }
    const h = new Qa(n.to()).valueOf();
    Object.assign(h, a), n.to(h), r = o, i = a;
  }), this._rememberMorpher(s, n), this;
}, zoom(s, e) {
  if (this._tryRetarget("zoom", s, e)) return this;
  let t = new Js(this._stepper).to(new Oe(s));
  return this.queue(function() {
    t = t.from(this.element().zoom());
  }, function(i) {
    return this.element().zoom(t.at(i), e), t.done();
  }, function(i, n) {
    e = n, t.to(i);
  }), this._rememberMorpher("zoom", t), this;
}, transform(s, e, t) {
  if (e = s.relative || e, this._isDeclarative && !e && this._tryRetarget("transform", s)) return this;
  const i = ce.isMatrixLike(s);
  t = s.affine != null ? s.affine : t ?? !i;
  const n = new Js(this._stepper).type(t ? po : ce);
  let r, a, o, l, c;
  return this.queue(function() {
    a = a || this.element(), r = r || Od(s, a), c = new ce(e ? void 0 : a), a._addRunner(this), e || a._clearTransformRunnersBefore(this);
  }, function(h) {
    e || this.clearTransform();
    const { x: u, y: d } = new Me(r).transform(a._currentTransform(this));
    let f = new ce({ ...s, origin: [u, d] }), p = this._isDeclarative && o ? o : c;
    if (t) {
      f = f.decompose(u, d), p = p.decompose(u, d);
      const m = f.rotate, O = p.rotate, x = [m - 360, m, m + 360], b = x.map((w) => Math.abs(w - O)), v = Math.min(...b), y = b.indexOf(v);
      f.rotate = x[y];
    }
    e && (i || (f.rotate = s.rotate || 0), this._isDeclarative && l && (p.rotate = l)), n.from(p), n.to(f);
    const g = n.at(h);
    return l = g.rotate, o = new ce(g), this.addTransform(o), a._addRunner(this), n.done();
  }, function(h) {
    (h.origin || "center").toString() !== (s.origin || "center").toString() && (r = Od(h, a)), s = { ...h, origin: r };
  }, !0), this._isDeclarative && this._rememberMorpher("transform", n), this;
}, x(s) {
  return this._queueNumber("x", s);
}, y(s) {
  return this._queueNumber("y", s);
}, ax(s) {
  return this._queueNumber("ax", s);
}, ay(s) {
  return this._queueNumber("ay", s);
}, dx(s = 0) {
  return this._queueNumberDelta("x", s);
}, dy(s = 0) {
  return this._queueNumberDelta("y", s);
}, dmove(s, e) {
  return this.dx(s).dy(e);
}, _queueNumberDelta(s, e) {
  if (e = new Oe(e), this._tryRetarget(s, e)) return this;
  const t = new Js(this._stepper).to(e);
  let i = null;
  return this.queue(function() {
    i = this.element()[s](), t.from(i), t.to(i + e);
  }, function(n) {
    return this.element()[s](t.at(n)), t.done();
  }, function(n) {
    t.to(i + new Oe(n));
  }), this._rememberMorpher(s, t), this;
}, _queueObject(s, e) {
  if (this._tryRetarget(s, e)) return this;
  const t = new Js(this._stepper).to(e);
  return this.queue(function() {
    t.from(this.element()[s]());
  }, function(i) {
    return this.element()[s](t.at(i)), t.done();
  }), this._rememberMorpher(s, t), this;
}, _queueNumber(s, e) {
  return this._queueObject(s, new Oe(e));
}, cx(s) {
  return this._queueNumber("cx", s);
}, cy(s) {
  return this._queueNumber("cy", s);
}, move(s, e) {
  return this.x(s).y(e);
}, amove(s, e) {
  return this.ax(s).ay(e);
}, center(s, e) {
  return this.cx(s).cy(e);
}, size(s, e) {
  let t;
  return s && e || (t = this._element.bbox()), s || (s = t.width / t.height * e), e || (e = t.height / t.width * s), this.width(s).height(e);
}, width(s) {
  return this._queueNumber("width", s);
}, height(s) {
  return this._queueNumber("height", s);
}, plot(s, e, t, i) {
  if (arguments.length === 4) return this.plot([s, e, t, i]);
  if (this._tryRetarget("plot", s)) return this;
  const n = new Js(this._stepper).type(this._element.MorphArray).to(s);
  return this.queue(function() {
    n.from(this._element.array());
  }, function(r) {
    return this._element.plot(n.at(r)), n.done();
  }), this._rememberMorpher("plot", n), this;
}, leading(s) {
  return this._queueNumber("leading", s);
}, viewbox(s, e, t, i) {
  return this._queueObject("viewbox", new it(s, e, t, i));
}, update(s) {
  return typeof s != "object" ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (s.opacity != null && this.attr("stop-opacity", s.opacity), s.color != null && this.attr("stop-color", s.color), s.offset != null && this.attr("offset", s.offset), this);
} }), fe(ti, { rx: $p, ry: Rp, from: zy, to: Iy }), Re(ti, "Runner");
class Pd extends Lt {
  constructor(e, t = e) {
    super(Be("svg", e), t), this.namespace();
  }
  defs() {
    return this.isRoot() ? ai(this.node.querySelector("defs")) || this.put(new Fc()) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof Te.window.SVGElement) && this.node.parentNode.nodeName !== "#document-fragment";
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: Pp, version: "1.1" }).attr("xmlns:xlink", $r, $h) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr("xmlns:xlink", null, $h).attr("xmlns:svgjs", null, $h);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
}
we({ Container: { nested: De(function() {
  return this.put(new Pd());
}) } }), Re(Pd, "Svg", !0);
let Qd = class extends Lt {
  constructor(s, e = s) {
    super(Be("symbol", s), e);
  }
};
we({ Container: { symbol: De(function() {
  return this.put(new Qd());
}) } }), Re(Qd, "Symbol");
var Zy = Object.freeze({ __proto__: null, amove: function(s, e) {
  return this.ax(s).ay(e);
}, ax: function(s) {
  return this.attr("x", s);
}, ay: function(s) {
  return this.attr("y", s);
}, build: function(s) {
  return this._build = !!s, this;
}, center: function(s, e, t = this.bbox()) {
  return this.cx(s, t).cy(e, t);
}, cx: function(s, e = this.bbox()) {
  return s == null ? e.cx : this.attr("x", this.attr("x") + s - e.cx);
}, cy: function(s, e = this.bbox()) {
  return s == null ? e.cy : this.attr("y", this.attr("y") + s - e.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(s, e, t = this.bbox()) {
  return this.x(s, t).y(e, t);
}, plain: function(s) {
  return this._build === !1 && this.clear(), this.node.appendChild(Te.document.createTextNode(s)), this;
}, x: function(s, e = this.bbox()) {
  return s == null ? e.x : this.attr("x", this.attr("x") + s - e.x);
}, y: function(s, e = this.bbox()) {
  return s == null ? e.y : this.attr("y", this.attr("y") + s - e.y);
} });
class ki extends si {
  constructor(e, t = e) {
    super(Be("text", e), t), this.dom.leading = this.dom.leading ?? new Oe(1.3), this._rebuild = !0, this._build = !1;
  }
  leading(e) {
    return e == null ? this.dom.leading : (this.dom.leading = new Oe(e), this.rebuild());
  }
  rebuild(e) {
    if (typeof e == "boolean" && (this._rebuild = e), this._rebuild) {
      const t = this;
      let i = 0;
      const n = this.dom.leading;
      this.each(function(r) {
        if (xd(this.node)) return;
        const a = Te.window.getComputedStyle(this.node).getPropertyValue("font-size"), o = n * new Oe(a);
        this.dom.newLined && (this.attr("x", t.attr("x")), this.text() === `
` ? i += o : (this.attr("dy", r ? o + i : 0), i = 0));
      }), this.fire("rebuild");
    }
    return this;
  }
  setData(e) {
    return this.dom = e, this.dom.leading = new Oe(e.leading || 1.3), this;
  }
  writeDataToDom() {
    return wy(this, this.dom, { leading: 1.3 }), this;
  }
  text(e) {
    if (e === void 0) {
      const t = this.node.childNodes;
      let i = 0;
      e = "";
      for (let n = 0, r = t.length; n < r; ++n) t[n].nodeName === "textPath" || xd(t[n]) ? n === 0 && (i = n + 1) : (n !== i && t[n].nodeType !== 3 && ai(t[n]).dom.newLined === !0 && (e += `
`), e += t[n].textContent);
      return e;
    }
    if (this.clear().build(!0), typeof e == "function") e.call(this, this);
    else for (let t = 0, i = (e = (e + "").split(`
`)).length; t < i; t++) this.newLine(e[t]);
    return this.build(!1).rebuild();
  }
}
fe(ki, Zy), we({ Container: { text: De(function(s = "") {
  return this.put(new ki()).text(s);
}), plain: De(function(s = "") {
  return this.put(new ki()).plain(s);
}) } }), Re(ki, "Text");
class yl extends si {
  constructor(e, t = e) {
    super(Be("tspan", e), t), this._build = !1;
  }
  dx(e) {
    return this.attr("dx", e);
  }
  dy(e) {
    return this.attr("dy", e);
  }
  newLine() {
    this.dom.newLined = !0;
    const e = this.parent();
    if (!(e instanceof ki)) return this;
    const t = e.index(this), i = Te.window.getComputedStyle(this.node).getPropertyValue("font-size"), n = e.dom.leading * new Oe(i);
    return this.dy(t ? n : 0).attr("x", e.x());
  }
  text(e) {
    return e == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof e == "function" ? (this.clear().build(!0), e.call(this, this), this.build(!1)) : this.plain(e), this);
  }
}
fe(yl, Zy), we({ Tspan: { tspan: De(function(s = "") {
  const e = new yl();
  return this._build || this.clear(), this.put(e).text(s);
}) }, Text: { newLine: function(s = "") {
  return this.tspan(s).newLine();
} } }), Re(yl, "Tspan");
class Lh extends si {
  constructor(e, t = e) {
    super(Be("circle", e), t);
  }
  radius(e) {
    return this.attr("r", e);
  }
  rx(e) {
    return this.attr("r", e);
  }
  ry(e) {
    return this.rx(e);
  }
  size(e) {
    return this.radius(new Oe(e).divide(2));
  }
}
fe(Lh, { x: $y, y: Ry, cx: Ey, cy: Xy, width: My, height: _y }), we({ Container: { circle: De(function(s = 0) {
  return this.put(new Lh()).size(s).move(0, 0);
}) } }), Re(Lh, "Circle");
class zh extends Lt {
  constructor(e, t = e) {
    super(Be("clipPath", e), t);
  }
  remove() {
    return this.targets().forEach(function(e) {
      e.unclip();
    }), super.remove();
  }
  targets() {
    return _n("svg [clip-path*=" + this.id() + "]");
  }
}
we({ Container: { clip: De(function() {
  return this.defs().put(new zh());
}) }, Element: { clipper() {
  return this.reference("clip-path");
}, clipWith(s) {
  const e = s instanceof zh ? s : this.parent().clip().add(s);
  return this.attr("clip-path", "url(#" + e.id() + ")");
}, unclip() {
  return this.attr("clip-path", null);
} } }), Re(zh, "ClipPath");
class Tm extends kt {
  constructor(e, t = e) {
    super(Be("foreignObject", e), t);
  }
}
we({ Container: { foreignObject: De(function(s, e) {
  return this.put(new Tm()).size(s, e);
}) } }), Re(Tm, "ForeignObject");
var Ny = Object.freeze({ __proto__: null, dmove: function(s, e) {
  return this.children().forEach((t) => {
    let i;
    try {
      i = t.node instanceof uo().SVGSVGElement ? new it(t.attr(["x", "y", "width", "height"])) : t.bbox();
    } catch {
      return;
    }
    const n = new ce(t), r = n.translate(s, e).transform(n.inverse()), a = new Me(i.x, i.y).transform(r);
    t.move(a.x, a.y);
  }), this;
}, dx: function(s) {
  return this.dmove(s, 0);
}, dy: function(s) {
  return this.dmove(0, s);
}, height: function(s, e = this.bbox()) {
  return s == null ? e.height : this.size(e.width, s, e);
}, move: function(s = 0, e = 0, t = this.bbox()) {
  const i = s - t.x, n = e - t.y;
  return this.dmove(i, n);
}, size: function(s, e, t = this.bbox()) {
  const i = Tr(this, s, e, t), n = i.width / t.width, r = i.height / t.height;
  return this.children().forEach((a) => {
    const o = new Me(t).transform(new ce(a).inverse());
    a.scale(n, r, o.x, o.y);
  }), this;
}, width: function(s, e = this.bbox()) {
  return s == null ? e.width : this.size(s, e.height, e);
}, x: function(s, e = this.bbox()) {
  return s == null ? e.x : this.move(s, e.y, e);
}, y: function(s, e = this.bbox()) {
  return s == null ? e.y : this.move(e.x, s, e);
} });
class zs extends Lt {
  constructor(e, t = e) {
    super(Be("g", e), t);
  }
}
fe(zs, Ny), we({ Container: { group: De(function() {
  return this.put(new zs());
}) } }), Re(zs, "G");
class _o extends Lt {
  constructor(e, t = e) {
    super(Be("a", e), t);
  }
  target(e) {
    return this.attr("target", e);
  }
  to(e) {
    return this.attr("href", e, $r);
  }
}
fe(_o, Ny), we({ Container: { link: De(function(s) {
  return this.put(new _o()).to(s);
}) }, Element: { unlink() {
  const s = this.linker();
  if (!s) return this;
  const e = s.parent();
  if (!e) return this.remove();
  const t = e.index(s);
  return e.add(this, t), s.remove(), this;
}, linkTo(s) {
  let e = this.linker();
  return e || (e = new _o(), this.wrap(e)), typeof s == "function" ? s.call(e, e) : e.to(s), this;
}, linker() {
  const s = this.parent();
  return s && s.node.nodeName.toLowerCase() === "a" ? s : null;
} } }), Re(_o, "A");
class Ih extends Lt {
  constructor(e, t = e) {
    super(Be("mask", e), t);
  }
  remove() {
    return this.targets().forEach(function(e) {
      e.unmask();
    }), super.remove();
  }
  targets() {
    return _n("svg [mask*=" + this.id() + "]");
  }
}
we({ Container: { mask: De(function() {
  return this.defs().put(new Ih());
}) }, Element: { masker() {
  return this.reference("mask");
}, maskWith(s) {
  const e = s instanceof Ih ? s : this.parent().mask().add(s);
  return this.attr("mask", "url(#" + e.id() + ")");
}, unmask() {
  return this.attr("mask", null);
} } }), Re(Ih, "Mask");
class $m extends kt {
  constructor(e, t = e) {
    super(Be("stop", e), t);
  }
  update(e) {
    return (typeof e == "number" || e instanceof Oe) && (e = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), e.opacity != null && this.attr("stop-opacity", e.opacity), e.color != null && this.attr("stop-color", e.color), e.offset != null && this.attr("offset", new Oe(e.offset)), this;
  }
}
we({ Gradient: { stop: function(s, e, t) {
  return this.put(new $m()).update(s, e, t);
} } }), Re($m, "Stop");
class qh extends kt {
  constructor(e, t = e) {
    super(Be("style", e), t);
  }
  addText(e = "") {
    return this.node.textContent += e, this;
  }
  font(e, t, i = {}) {
    return this.rule("@font-face", { fontFamily: e, src: t, ...i });
  }
  rule(e, t) {
    return this.addText(function(i, n) {
      if (!i) return "";
      if (!n) return i;
      let r = i + "{";
      for (const a in n) r += a.replace(/([A-Z])/g, function(o, l) {
        return "-" + l.toLowerCase();
      }) + ":" + n[a] + ";";
      return r += "}", r;
    }(e, t));
  }
}
we("Dom", { style(s, e) {
  return this.put(new qh()).rule(s, e);
}, fontface(s, e, t) {
  return this.put(new qh()).font(s, e, t);
} }), Re(qh, "Style");
class Dh extends ki {
  constructor(e, t = e) {
    super(Be("textPath", e), t);
  }
  array() {
    const e = this.track();
    return e ? e.array() : null;
  }
  plot(e) {
    const t = this.track();
    let i = null;
    return t && (i = t.plot(e)), e == null ? i : this;
  }
  track() {
    return this.reference("href");
  }
}
we({ Container: { textPath: De(function(s, e) {
  return s instanceof ki || (s = this.text(s)), s.path(e);
}) }, Text: { path: De(function(s, e = !0) {
  const t = new Dh();
  let i;
  if (s instanceof er || (s = this.defs().path(s)), t.attr("href", "#" + s, $r), e) for (; i = this.node.firstChild; ) t.node.appendChild(i);
  return this.put(t);
}), textPath() {
  return this.findOne("textPath");
} }, Path: { text: De(function(s) {
  return s instanceof ki || (s = new ki().addTo(this.parent()).text(s)), s.path(this);
}), targets() {
  return _n("svg textPath").filter((s) => (s.attr("href") || "").includes(this.id()));
} } }), Dh.prototype.MorphArray = Si, Re(Dh, "TextPath");
class Rm extends si {
  constructor(e, t = e) {
    super(Be("use", e), t);
  }
  use(e, t) {
    return this.attr("href", (t || "") + "#" + e, $r);
  }
}
we({ Container: { use: De(function(s, e) {
  return this.put(new Rm()).use(s, e);
}) } }), Re(Rm, "Use");
const WT = Et;
fe([Pd, Qd, Ol, Pa, xl], zt("viewbox")), fe([on, cn, ln, er], zt("marker")), fe(ki, zt("Text")), fe(er, zt("Path")), fe(Fc, zt("Defs")), fe([ki, yl], zt("Tspan")), fe([bl, ml, ca, ti], zt("radius")), fe(fo, zt("EventTarget")), fe(Ds, zt("Dom")), fe(kt, zt("Element")), fe(si, zt("Shape")), fe([Lt, Ly], zt("Container")), fe(ca, zt("Gradient")), fe(ti, zt("Runner")), kn.extend([...new Set(yy)]), function(s = []) {
  kd.push(...[].concat(s));
}([Oe, qe, it, ce, Pn, Bs, Si, Me]), fe(kd, { to(s) {
  return new Js().type(this.constructor).from(this.toArray()).to(s);
}, fromArray(s) {
  return this.init(s), this;
}, toConsumable() {
  return this.toArray();
}, morph(s, e, t, i, n) {
  return this.fromArray(s.map(function(r, a) {
    return i.step(r, e[a], t, n[a], n);
  }));
} });
class je extends kt {
  constructor(e) {
    super(Be("filter", e), e), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = !0;
  }
  put(e, t) {
    return !(e = super.put(e, t)).attr("in") && this.$autoSetIn && e.attr("in", this.$source), e.attr("result") || e.attr("result", e.id()), e;
  }
  remove() {
    return this.targets().each("unfilter"), super.remove();
  }
  targets() {
    return _n('svg [filter*="' + this.id() + '"]');
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
}
class Mp extends kt {
  constructor(e, t) {
    super(e, t), this.result(this.id());
  }
  in(e) {
    if (e == null) {
      const t = this.attr("in");
      return this.parent() && this.parent().find(`[result="${t}"]`)[0] || t;
    }
    return this.attr("in", e);
  }
  result(e) {
    return this.attr("result", e);
  }
  toString() {
    return this.result();
  }
}
const ni = (s) => function(...e) {
  for (let t = s.length; t--; ) e[t] != null && this.attr(s[t], e[t]);
}, YT = { blend: ni(["in", "in2", "mode"]), colorMatrix: ni(["type", "values"]), composite: ni(["in", "in2", "operator"]), convolveMatrix: function(s) {
  s = new Pn(s).toString(), this.attr({ order: Math.sqrt(s.split(" ").length), kernelMatrix: s });
}, diffuseLighting: ni(["surfaceScale", "lightingColor", "diffuseConstant", "kernelUnitLength"]), displacementMap: ni(["in", "in2", "scale", "xChannelSelector", "yChannelSelector"]), dropShadow: ni(["in", "dx", "dy", "stdDeviation"]), flood: ni(["flood-color", "flood-opacity"]), gaussianBlur: function(s = 0, e = s) {
  this.attr("stdDeviation", s + " " + e);
}, image: function(s) {
  this.attr("href", s, $r);
}, morphology: ni(["operator", "radius"]), offset: ni(["dx", "dy"]), specularLighting: ni(["surfaceScale", "lightingColor", "diffuseConstant", "specularExponent", "kernelUnitLength"]), tile: ni([]), turbulence: ni(["baseFrequency", "numOctaves", "seed", "stitchTiles", "type"]) };
["blend", "colorMatrix", "componentTransfer", "composite", "convolveMatrix", "diffuseLighting", "displacementMap", "dropShadow", "flood", "gaussianBlur", "image", "merge", "morphology", "offset", "specularLighting", "tile", "turbulence"].forEach((s) => {
  const e = Ar(s), t = YT[s];
  je[e + "Effect"] = class extends Mp {
    constructor(i) {
      super(Be("fe" + e, i), i);
    }
    update(i) {
      return t.apply(this, i), this;
    }
  }, je.prototype[s] = De(function(i, ...n) {
    const r = new je[e + "Effect"]();
    return i == null ? this.put(r) : (typeof i == "function" ? i.call(r, r) : n.unshift(i), this.put(r).update(n));
  });
}), fe(je, { merge(s) {
  const e = this.put(new je.MergeEffect());
  return typeof s == "function" ? (s.call(e, e), e) : ((s instanceof Array ? s : [...arguments]).forEach((t) => {
    t instanceof je.MergeNode ? e.put(t) : e.mergeNode(t);
  }), e);
}, componentTransfer(s = {}) {
  const e = this.put(new je.ComponentTransferEffect());
  if (typeof s == "function") return s.call(e, e), e;
  s.r || s.g || s.b || s.a || (s = { r: s, g: s, b: s, a: s });
  for (const t in s) e.add(new je["Func" + t.toUpperCase()](s[t]));
  return e;
} });
["distantLight", "pointLight", "spotLight", "mergeNode", "FuncR", "FuncG", "FuncB", "FuncA"].forEach((s) => {
  const e = Ar(s);
  je[e] = class extends Mp {
    constructor(t) {
      super(Be("fe" + e, t), t);
    }
  };
});
["funcR", "funcG", "funcB", "funcA"].forEach(function(s) {
  const e = je[Ar(s)], t = De(function() {
    return this.put(new e());
  });
  je.ComponentTransferEffect.prototype[s] = t;
});
["distantLight", "pointLight", "spotLight"].forEach((s) => {
  const e = je[Ar(s)], t = De(function() {
    return this.put(new e());
  });
  je.DiffuseLightingEffect.prototype[s] = t, je.SpecularLightingEffect.prototype[s] = t;
}), fe(je.MergeEffect, { mergeNode(s) {
  return this.put(new je.MergeNode()).attr("in", s);
} }), fe(Fc, { filter: function(s) {
  const e = this.put(new je());
  return typeof s == "function" && s.call(e, e), e;
} }), fe(Lt, { filter: function(s) {
  return this.defs().filter(s);
} }), fe(kt, { filterWith: function(s) {
  const e = s instanceof je ? s : this.defs().filter(s);
  return this.attr("filter", e);
}, unfilter: function(s) {
  return this.attr("filter", null);
}, filterer() {
  return this.reference("filter");
} });
const ZT = { blend: function(s, e) {
  return this.parent() && this.parent().blend(this, s, e);
}, colorMatrix: function(s, e) {
  return this.parent() && this.parent().colorMatrix(s, e).in(this);
}, componentTransfer: function(s) {
  return this.parent() && this.parent().componentTransfer(s).in(this);
}, composite: function(s, e) {
  return this.parent() && this.parent().composite(this, s, e);
}, convolveMatrix: function(s) {
  return this.parent() && this.parent().convolveMatrix(s).in(this);
}, diffuseLighting: function(s, e, t, i) {
  return this.parent() && this.parent().diffuseLighting(s, t, i).in(this);
}, displacementMap: function(s, e, t, i) {
  return this.parent() && this.parent().displacementMap(this, s, e, t, i);
}, dropShadow: function(s, e, t) {
  return this.parent() && this.parent().dropShadow(this, s, e, t).in(this);
}, flood: function(s, e) {
  return this.parent() && this.parent().flood(s, e);
}, gaussianBlur: function(s, e) {
  return this.parent() && this.parent().gaussianBlur(s, e).in(this);
}, image: function(s) {
  return this.parent() && this.parent().image(s);
}, merge: function(s) {
  return s = s instanceof Array ? s : [...s], this.parent() && this.parent().merge(this, ...s);
}, morphology: function(s, e) {
  return this.parent() && this.parent().morphology(s, e).in(this);
}, offset: function(s, e) {
  return this.parent() && this.parent().offset(s, e).in(this);
}, specularLighting: function(s, e, t, i, n) {
  return this.parent() && this.parent().specularLighting(s, t, i, n).in(this);
}, tile: function() {
  return this.parent() && this.parent().tile().in(this);
}, turbulence: function(s, e, t, i, n) {
  return this.parent() && this.parent().turbulence(s, e, t, i, n).in(this);
} };
fe(Mp, ZT), fe(je.MergeEffect, { in: function(s) {
  return s instanceof je.MergeNode ? this.add(s, 0) : this.add(new je.MergeNode().in(s), 0), this;
} }), fe([je.CompositeEffect, je.BlendEffect, je.DisplacementMapEffect], { in2: function(s) {
  if (s == null) {
    const e = this.attr("in2");
    return this.parent() && this.parent().find(`[result="${e}"]`)[0] || e;
  }
  return this.attr("in2", s);
} }), je.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var vt = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "getDefaultFilter", value: function(e, t) {
    var i = this.w;
    e.unfilter(!0), new je().size("120%", "180%", "-5%", "-40%"), i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t);
  } }, { key: "applyFilter", value: function(e, t, i) {
    var n, r = this, a = this.w;
    if (e.unfilter(!0), i !== "none") {
      var o, l, c = a.config.chart.dropShadow, h = i === "lighten" ? 2 : 0.3;
      e.filterWith(function(u) {
        u.colorMatrix({ type: "matrix", values: `
          `.concat(h, ` 0 0 0 0
          0 `).concat(h, ` 0 0 0
          0 0 `).concat(h, ` 0 0
          0 0 0 1 0
        `), in: "SourceGraphic", result: "brightness" }), c.enabled && r.addShadow(u, t, c, "brightness");
      }), !c.noUserSpaceOnUse && ((o = e.filterer()) === null || o === void 0 || (l = o.node) === null || l === void 0 || l.setAttribute("filterUnits", "userSpaceOnUse")), this._scaleFilterSize((n = e.filterer()) === null || n === void 0 ? void 0 : n.node);
    } else this.getDefaultFilter(e, t);
  } }, { key: "addShadow", value: function(e, t, i, n) {
    var r, a = this.w, o = i.blur, l = i.top, c = i.left, h = i.color, u = i.opacity;
    if (h = Array.isArray(h) ? h[t] : h, ((r = a.config.chart.dropShadow.enabledOnSeries) === null || r === void 0 ? void 0 : r.length) > 0 && a.config.chart.dropShadow.enabledOnSeries.indexOf(t) === -1) return e;
    e.offset({ in: n, dx: c, dy: l, result: "offset" }), e.gaussianBlur({ in: "offset", stdDeviation: o, result: "blur" }), e.flood({ "flood-color": h, "flood-opacity": u, result: "flood" }), e.composite({ in: "flood", in2: "blur", operator: "in", result: "shadow" }), e.merge(["shadow", n]);
  } }, { key: "dropShadow", value: function(e, t) {
    var i, n, r, a, o, l = this, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, h = this.w;
    return e.unfilter(!0), E.isMsEdge() && h.config.chart.type === "radialBar" || ((i = h.config.chart.dropShadow.enabledOnSeries) === null || i === void 0 ? void 0 : i.length) > 0 && ((r = h.config.chart.dropShadow.enabledOnSeries) === null || r === void 0 ? void 0 : r.indexOf(c)) === -1 ? e : (e.filterWith(function(u) {
      l.addShadow(u, c, t, "SourceGraphic");
    }), t.noUserSpaceOnUse || (a = e.filterer()) === null || a === void 0 || (o = a.node) === null || o === void 0 || o.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize((n = e.filterer()) === null || n === void 0 ? void 0 : n.node), e);
  } }, { key: "setSelectionFilter", value: function(e, t, i) {
    var n = this.w;
    if (n.globals.selectedDataPoints[t] !== void 0 && n.globals.selectedDataPoints[t].indexOf(i) > -1) {
      e.node.setAttribute("selected", !0);
      var r = n.config.states.active.filter;
      r !== "none" && this.applyFilter(e, t, r.type);
    }
  } }, { key: "_scaleFilterSize", value: function(e) {
    e && function(t) {
      for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
    }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
  } }]), s;
}(), Z = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "roundPathCorners", value: function(e, t) {
    function i(k, A, T) {
      var C = A.x - k.x, P = A.y - k.y, $ = Math.sqrt(C * C + P * P);
      return n(k, A, Math.min(1, T / $));
    }
    function n(k, A, T) {
      return { x: k.x + (A.x - k.x) * T, y: k.y + (A.y - k.y) * T };
    }
    function r(k, A) {
      k.length > 2 && (k[k.length - 2] = A.x, k[k.length - 1] = A.y);
    }
    function a(k) {
      return { x: parseFloat(k[k.length - 2]), y: parseFloat(k[k.length - 1]) };
    }
    e.indexOf("NaN") > -1 && (e = "");
    var o = e.split(/[,\s]/).reduce(function(k, A) {
      var T = A.match(/^([a-zA-Z])(.+)/);
      return T ? (k.push(T[1]), k.push(T[2])) : k.push(A), k;
    }, []).reduce(function(k, A) {
      return parseFloat(A) == A && k.length ? k[k.length - 1].push(A) : k.push([A]), k;
    }, []), l = [];
    if (o.length > 1) {
      var c = a(o[0]), h = null;
      o[o.length - 1][0] == "Z" && o[0].length > 2 && (h = ["L", c.x, c.y], o[o.length - 1] = h), l.push(o[0]);
      for (var u = 1; u < o.length; u++) {
        var d = l[l.length - 1], f = o[u], p = f == h ? o[1] : o[u + 1];
        if (p && d && d.length > 2 && f[0] == "L" && p.length > 2 && p[0] == "L") {
          var g, m, O = a(d), x = a(f), b = a(p);
          g = i(x, O, t), m = i(x, b, t), r(f, g), f.origPoint = x, l.push(f);
          var v = n(g, x, 0.5), y = n(x, m, 0.5), w = ["C", v.x, v.y, y.x, y.y, m.x, m.y];
          w.origPoint = x, l.push(w);
        } else l.push(f);
      }
      if (h) {
        var S = a(l[l.length - 1]);
        l.push(["Z"]), r(l[0], S);
      }
    } else l = o;
    return l.reduce(function(k, A) {
      return k + A.join(" ") + " ";
    }, "");
  } }, { key: "drawLine", value: function(e, t, i, n) {
    var r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
    return this.w.globals.dom.Paper.line().attr({ x1: e, y1: t, x2: i, y2: n, stroke: r, "stroke-dasharray": a, "stroke-width": o, "stroke-linecap": l });
  } }, { key: "drawRect", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, c = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, h = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, u = this.w.globals.dom.Paper.rect();
    return u.attr({ x: e, y: t, width: i > 0 ? i : 0, height: n > 0 ? n : 0, rx: r, ry: r, opacity: o, "stroke-width": l !== null ? l : 0, stroke: c !== null ? c : "none", "stroke-dasharray": h }), u.node.setAttribute("fill", a), u;
  } }, { key: "drawPolygon", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
    return this.w.globals.dom.Paper.polygon(e).attr({ fill: n, stroke: t, "stroke-width": i });
  } }, { key: "drawCircle", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    e < 0 && (e = 0);
    var i = this.w.globals.dom.Paper.circle(2 * e);
    return t !== null && i.attr(t), i;
  } }, { key: "drawPath", value: function(e) {
    var t = e.d, i = t === void 0 ? "" : t, n = e.stroke, r = n === void 0 ? "#a8a8a8" : n, a = e.strokeWidth, o = a === void 0 ? 1 : a, l = e.fill, c = e.fillOpacity, h = c === void 0 ? 1 : c, u = e.strokeOpacity, d = u === void 0 ? 1 : u, f = e.classes, p = e.strokeLinecap, g = p === void 0 ? null : p, m = e.strokeDashArray, O = m === void 0 ? 0 : m, x = this.w;
    return g === null && (g = x.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(x.globals.gridHeight)), x.globals.dom.Paper.path(i).attr({ fill: l, "fill-opacity": h, stroke: r, "stroke-opacity": d, "stroke-linecap": g, "stroke-width": o, "stroke-dasharray": O, class: f });
  } }, { key: "group", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = this.w.globals.dom.Paper.group();
    return e !== null && t.attr(e), t;
  } }, { key: "move", value: function(e, t) {
    var i = ["M", e, t].join(" ");
    return i;
  } }, { key: "line", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = null;
    return i === null ? n = [" L", e, t].join(" ") : i === "H" ? n = [" H", e].join(" ") : i === "V" && (n = [" V", t].join(" ")), n;
  } }, { key: "curve", value: function(e, t, i, n, r, a) {
    var o = ["C", e, t, i, n, r, a].join(" ");
    return o;
  } }, { key: "quadraticCurve", value: function(e, t, i, n) {
    return ["Q", e, t, i, n].join(" ");
  } }, { key: "arc", value: function(e, t, i, n, r, a, o) {
    var l = "A";
    arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (l = "a");
    var c = [l, e, t, i, n, r, a, o].join(" ");
    return c;
  } }, { key: "renderPaths", value: function(e) {
    var t, i = e.j, n = e.realIndex, r = e.pathFrom, a = e.pathTo, o = e.stroke, l = e.strokeWidth, c = e.strokeLinecap, h = e.fill, u = e.animationDelay, d = e.initialSpeed, f = e.dataChangeSpeed, p = e.className, g = e.chartType, m = e.shouldClipToGrid, O = m === void 0 || m, x = e.bindEventsOnPaths, b = x === void 0 || x, v = e.drawShadow, y = v === void 0 || v, w = this.w, S = new vt(this.ctx), k = new Cr(this.ctx), A = this.w.config.chart.animations.enabled, T = A && this.w.config.chart.animations.dynamicAnimation.enabled;
    if (r && r.startsWith("M 0 0") && a) {
      var C = a.match(/^M\s+[\d.-]+\s+[\d.-]+/);
      C && (r = r.replace(/^M\s+0\s+0/, C[0]));
    }
    var P = !!(A && !w.globals.resized || T && w.globals.dataChanged && w.globals.shouldAnimate);
    P ? t = r : (t = a, w.globals.animationEnded = !0);
    var $ = w.config.stroke.dashArray, R = 0;
    R = Array.isArray($) ? $[n] : w.config.stroke.dashArray;
    var X = this.drawPath({ d: t, stroke: o, strokeWidth: l, fill: h, fillOpacity: 1, classes: p, strokeLinecap: c, strokeDashArray: R });
    X.attr("index", n), O && (g === "bar" && !w.globals.isHorizontal || w.globals.comboCharts ? X.attr({ "clip-path": "url(#gridRectBarMask".concat(w.globals.cuid, ")") }) : X.attr({ "clip-path": "url(#gridRectMask".concat(w.globals.cuid, ")") })), w.config.chart.dropShadow.enabled && y && S.dropShadow(X, w.config.chart.dropShadow, n), b && (X.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, X)), X.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, X)), X.node.addEventListener("mousedown", this.pathMouseDown.bind(this, X))), X.attr({ pathTo: a, pathFrom: r });
    var M = { el: X, j: i, realIndex: n, pathFrom: r, pathTo: a, fill: h, strokeWidth: l, delay: u };
    return !A || w.globals.resized || w.globals.dataChanged ? !w.globals.resized && w.globals.dataChanged || k.showDelayedElements() : k.animatePathsGradually(F(F({}, M), {}, { speed: d })), w.globals.dataChanged && T && P && k.animatePathsGradually(F(F({}, M), {}, { speed: f })), X;
  } }, { key: "drawPattern", value: function(e, t, i) {
    var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(t, i, function(a) {
      e === "horizontalLines" ? a.line(0, 0, i, 0).stroke({ color: n, width: r + 1 }) : e === "verticalLines" ? a.line(0, 0, 0, t).stroke({ color: n, width: r + 1 }) : e === "slantedLines" ? a.line(0, 0, t, i).stroke({ color: n, width: r }) : e === "squares" ? a.rect(t, i).fill("none").stroke({ color: n, width: r }) : e === "circles" && a.circle(t).fill("none").stroke({ color: n, width: r });
    });
  } }, { key: "drawGradient", value: function(e, t, i, n, r) {
    var a, o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, c = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [], h = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, u = this.w;
    t.length < 9 && t.indexOf("#") === 0 && (t = E.hexToRgba(t, n)), i.length < 9 && i.indexOf("#") === 0 && (i = E.hexToRgba(i, r));
    var d = 0, f = 1, p = 1, g = null;
    l !== null && (d = l[0] !== void 0 ? l[0] / 100 : 0, f = l[1] !== void 0 ? l[1] / 100 : 1, p = l[2] !== void 0 ? l[2] / 100 : 1, g = l[3] !== void 0 ? l[3] / 100 : null);
    var m = !(u.config.chart.type !== "donut" && u.config.chart.type !== "pie" && u.config.chart.type !== "polarArea" && u.config.chart.type !== "bubble");
    if (a = c && c.length !== 0 ? u.globals.dom.Paper.gradient(m ? "radial" : "linear", function(b) {
      (Array.isArray(c[h]) ? c[h] : c).forEach(function(v) {
        b.stop(v.offset / 100, v.color, v.opacity);
      });
    }) : u.globals.dom.Paper.gradient(m ? "radial" : "linear", function(b) {
      b.stop(d, t, n), b.stop(f, i, r), b.stop(p, i, r), g !== null && b.stop(g, t, n);
    }), m) {
      var O = u.globals.gridWidth / 2, x = u.globals.gridHeight / 2;
      u.config.chart.type !== "bubble" ? a.attr({ gradientUnits: "userSpaceOnUse", cx: O, cy: x, r: o }) : a.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else e === "vertical" ? a.from(0, 0).to(0, 1) : e === "diagonal" ? a.from(0, 0).to(1, 1) : e === "horizontal" ? a.from(0, 1).to(1, 1) : e === "diagonal2" && a.from(1, 0).to(0, 1);
    return a;
  } }, { key: "getTextBasedOnMaxWidth", value: function(e) {
    var t = e.text, i = e.maxWidth, n = e.fontSize, r = e.fontFamily, a = this.getTextRects(t, n, r), o = a.width / t.length, l = Math.floor(i / o);
    return i < a.width ? t.slice(0, l - 3) + "..." : t;
  } }, { key: "drawText", value: function(e) {
    var t = this, i = e.x, n = e.y, r = e.text, a = e.textAnchor, o = e.fontSize, l = e.fontFamily, c = e.fontWeight, h = e.foreColor, u = e.opacity, d = e.maxWidth, f = e.cssClass, p = f === void 0 ? "" : f, g = e.isPlainText, m = g === void 0 || g, O = e.dominantBaseline, x = O === void 0 ? "auto" : O, b = this.w;
    r === void 0 && (r = "");
    var v = r;
    a || (a = "start"), h && h.length || (h = b.config.chart.foreColor), l = l || b.config.chart.fontFamily, c = c || "regular";
    var y, w = { maxWidth: d, fontSize: o = o || "11px", fontFamily: l };
    return Array.isArray(r) ? y = b.globals.dom.Paper.text(function(S) {
      for (var k = 0; k < r.length; k++) v = r[k], d && (v = t.getTextBasedOnMaxWidth(F({ text: r[k] }, w))), k === 0 ? S.tspan(v) : S.tspan(v).newLine();
    }) : (d && (v = this.getTextBasedOnMaxWidth(F({ text: r }, w))), y = m ? b.globals.dom.Paper.plain(r) : b.globals.dom.Paper.text(function(S) {
      return S.tspan(v);
    })), y.attr({ x: i, y: n, "text-anchor": a, "dominant-baseline": x, "font-size": o, "font-family": l, "font-weight": c, fill: h, class: "apexcharts-text " + p }), y.node.style.fontFamily = l, y.node.style.opacity = u, y;
  } }, { key: "getMarkerPath", value: function(e, t, i, n) {
    var r = "";
    switch (i) {
      case "cross":
        r = "M ".concat(e - (n /= 1.4), " ").concat(t - n, " L ").concat(e + n, " ").concat(t + n, "  M ").concat(e - n, " ").concat(t + n, " L ").concat(e + n, " ").concat(t - n);
        break;
      case "plus":
        r = "M ".concat(e - (n /= 1.12), " ").concat(t, " L ").concat(e + n, " ").concat(t, "  M ").concat(e, " ").concat(t - n, " L ").concat(e, " ").concat(t + n);
        break;
      case "star":
      case "sparkle":
        var a = 5;
        n *= 1.15, i === "sparkle" && (n /= 1.1, a = 4);
        for (var o = Math.PI / a, l = 0; l <= 2 * a; l++) {
          var c = l * o, h = l % 2 == 0 ? n : n / 2;
          r += (l === 0 ? "M" : "L") + (e + h * Math.sin(c)) + "," + (t - h * Math.cos(c));
        }
        r += "Z";
        break;
      case "triangle":
        r = "M ".concat(e, " ").concat(t - n, ` 
             L `).concat(e + n, " ").concat(t + n, ` 
             L `).concat(e - n, " ").concat(t + n, ` 
             Z`);
        break;
      case "square":
      case "rect":
        r = "M ".concat(e - (n /= 1.125), " ").concat(t - n, ` 
           L `).concat(e + n, " ").concat(t - n, ` 
           L `).concat(e + n, " ").concat(t + n, ` 
           L `).concat(e - n, " ").concat(t + n, ` 
           Z`);
        break;
      case "diamond":
        n *= 1.05, r = "M ".concat(e, " ").concat(t - n, ` 
             L `).concat(e + n, " ").concat(t, ` 
             L `).concat(e, " ").concat(t + n, ` 
             L `).concat(e - n, " ").concat(t, ` 
            Z`);
        break;
      case "line":
        r = "M ".concat(e - (n /= 1.1), " ").concat(t, ` 
           L `).concat(e + n, " ").concat(t);
        break;
      default:
        n *= 2, r = "M ".concat(e, ", ").concat(t, ` 
           m -`).concat(n / 2, `, 0 
           a `).concat(n / 2, ",").concat(n / 2, " 0 1,0 ").concat(n, `,0 
           a `).concat(n / 2, ",").concat(n / 2, " 0 1,0 -").concat(n, ",0");
    }
    return r;
  } }, { key: "drawMarkerShape", value: function(e, t, i, n, r) {
    var a = this.drawPath({ d: this.getMarkerPath(e, t, i, n, r), stroke: r.pointStrokeColor, strokeDashArray: r.pointStrokeDashArray, strokeWidth: r.pointStrokeWidth, fill: r.pointFillColor, fillOpacity: r.pointFillOpacity, strokeOpacity: r.pointStrokeOpacity });
    return a.attr({ cx: e, cy: t, shape: r.shape, class: r.class ? r.class : "" }), a;
  } }, { key: "drawMarker", value: function(e, t, i) {
    e = e || 0;
    var n = i.pSize || 0;
    return E.isNumber(t) || (n = 0, t = 0), this.drawMarkerShape(e, t, i?.shape, n, F(F({}, i), i.shape === "line" || i.shape === "plus" || i.shape === "cross" ? { pointStrokeColor: i.pointFillColor, pointStrokeOpacity: i.pointFillOpacity } : {}));
  } }, { key: "pathMouseEnter", value: function(e, t) {
    var i = this.w, n = new vt(this.ctx), r = parseInt(e.node.getAttribute("index"), 10), a = parseInt(e.node.getAttribute("j"), 10);
    if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(t, this.ctx, { seriesIndex: r, dataPointIndex: a, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, { seriesIndex: r, dataPointIndex: a, w: i }]), (i.config.states.active.filter.type === "none" || e.node.getAttribute("selected") !== "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
      var o = i.config.states.hover.filter;
      n.applyFilter(e, r, o.type);
    }
  } }, { key: "pathMouseLeave", value: function(e, t) {
    var i = this.w, n = new vt(this.ctx), r = parseInt(e.node.getAttribute("index"), 10), a = parseInt(e.node.getAttribute("j"), 10);
    typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(t, this.ctx, { seriesIndex: r, dataPointIndex: a, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, { seriesIndex: r, dataPointIndex: a, w: i }]), i.config.states.active.filter.type !== "none" && e.node.getAttribute("selected") === "true" || i.config.states.hover.filter.type !== "none" && n.getDefaultFilter(e, r);
  } }, { key: "pathMouseDown", value: function(e, t) {
    var i = this.w, n = new vt(this.ctx), r = parseInt(e.node.getAttribute("index"), 10), a = parseInt(e.node.getAttribute("j"), 10), o = "false";
    if (e.node.getAttribute("selected") === "true") {
      if (e.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[r].indexOf(a) > -1) {
        var l = i.globals.selectedDataPoints[r].indexOf(a);
        i.globals.selectedDataPoints[r].splice(l, 1);
      }
    } else {
      if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
        i.globals.selectedDataPoints = [];
        var c = i.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h = i.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), u = function(p) {
          Array.prototype.forEach.call(p, function(g) {
            g.node.setAttribute("selected", "false"), n.getDefaultFilter(g, r);
          });
        };
        u(c), u(h);
      }
      e.node.setAttribute("selected", "true"), o = "true", i.globals.selectedDataPoints[r] === void 0 && (i.globals.selectedDataPoints[r] = []), i.globals.selectedDataPoints[r].push(a);
    }
    if (o === "true") {
      var d = i.config.states.active.filter;
      if (d !== "none") n.applyFilter(e, r, d.type);
      else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
        var f = i.config.states.hover.filter;
        n.applyFilter(e, r, f.type);
      }
    } else i.config.states.active.filter.type !== "none" && (i.config.states.hover.filter.type === "none" || i.globals.isTouchDevice ? n.getDefaultFilter(e, r) : (f = i.config.states.hover.filter, n.applyFilter(e, r, f.type)));
    typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(t, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: r, dataPointIndex: a, w: i }), t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: r, dataPointIndex: a, w: i }]);
  } }, { key: "rotateAroundCenter", value: function(e) {
    var t = {};
    return e && typeof e.getBBox == "function" && (t = e.getBBox()), { x: t.x + t.width / 2, y: t.y + t.height / 2 };
  } }, { key: "getTextRects", value: function(e, t, i, n) {
    var r = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = this.w, o = this.drawText({ x: -200, y: -200, text: e, textAnchor: "start", fontSize: t, fontFamily: i, foreColor: "#fff", opacity: 0 });
    n && o.attr("transform", n), a.globals.dom.Paper.add(o);
    var l = o.bbox();
    return r || (l = o.node.getBoundingClientRect()), o.remove(), { width: l.width, height: l.height };
  } }, { key: "placeTextWithEllipsis", value: function(e, t, i) {
    if (typeof e.getComputedTextLength == "function" && (e.textContent = t, t.length > 0 && e.getComputedTextLength() >= i / 1.1)) {
      for (var n = t.length - 3; n > 0; n -= 3) if (e.getSubStringLength(0, n) <= i / 1.1) return void (e.textContent = t.substring(0, n) + "...");
      e.textContent = ".";
    }
  } }], [{ key: "setAttrs", value: function(e, t) {
    for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
  } }]), s;
}(), st = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "getStackedSeriesTotals", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = this.w, i = [];
    if (t.globals.series.length === 0) return i;
    for (var n = 0; n < t.globals.series[t.globals.maxValsInArrayIndex].length; n++) {
      for (var r = 0, a = 0; a < t.globals.series.length; a++) t.globals.series[a][n] !== void 0 && e.indexOf(a) === -1 && (r += t.globals.series[a][n]);
      i.push(r);
    }
    return i;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return e === null ? this.w.config.series.reduce(function(t, i) {
      return t + i;
    }, 0) : this.w.globals.series[e].reduce(function(t, i) {
      return t + i;
    }, 0);
  } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
    var e = this, t = this.w, i = [];
    return t.globals.seriesGroups.forEach(function(n) {
      var r = [];
      t.config.series.forEach(function(o, l) {
        n.indexOf(t.globals.seriesNames[l]) > -1 && r.push(l);
      });
      var a = t.globals.series.map(function(o, l) {
        return r.indexOf(l) === -1 ? l : -1;
      }).filter(function(o) {
        return o !== -1;
      });
      i.push(e.getStackedSeriesTotals(a));
    }), i;
  } }, { key: "setSeriesYAxisMappings", value: function() {
    var e = this.w.globals, t = this.w.config, i = [], n = [], r = [], a = e.series.length > t.yaxis.length || t.yaxis.some(function(u) {
      return Array.isArray(u.seriesName);
    });
    t.series.forEach(function(u, d) {
      r.push(d), n.push(null);
    }), t.yaxis.forEach(function(u, d) {
      i[d] = [];
    });
    var o = [];
    t.yaxis.forEach(function(u, d) {
      var f = !1;
      if (u.seriesName) {
        var p = [];
        Array.isArray(u.seriesName) ? p = u.seriesName : p.push(u.seriesName), p.forEach(function(g) {
          t.series.forEach(function(m, O) {
            if (m.name === g) {
              var x = O;
              d === O || a ? !a || r.indexOf(O) > -1 ? i[d].push([d, O]) : console.warn("Series '" + m.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i[O].push([O, d]), x = d), f = !0, (x = r.indexOf(x)) !== -1 && r.splice(x, 1);
            }
          });
        });
      }
      f || o.push(d);
    }), i = i.map(function(u, d) {
      var f = [];
      return u.forEach(function(p) {
        n[p[1]] = p[0], f.push(p[1]);
      }), f;
    });
    for (var l = t.yaxis.length - 1, c = 0; c < o.length && (l = o[c], i[l] = [], r); c++) {
      var h = r[0];
      r.shift(), i[l].push(h), n[h] = l;
    }
    r.forEach(function(u) {
      i[l].push(u), n[u] = l;
    }), e.seriesYAxisMap = i.map(function(u) {
      return u;
    }), e.seriesYAxisReverseMap = n.map(function(u) {
      return u;
    }), e.seriesYAxisMap.forEach(function(u, d) {
      u.forEach(function(f) {
        t.series[f] && t.series[f].group === void 0 && (t.series[f].group = "apexcharts-axis-".concat(d.toString()));
      });
    });
  } }, { key: "isSeriesNull", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return (e === null ? this.w.config.series.filter(function(t) {
      return t !== null;
    }) : this.w.config.series[e].data.filter(function(t) {
      return t !== null;
    })).length === 0;
  } }, { key: "seriesHaveSameValues", value: function(e) {
    return this.w.globals.series[e].every(function(t, i, n) {
      return t === n[0];
    });
  } }, { key: "getCategoryLabels", value: function(e) {
    var t = this.w, i = e.slice();
    return t.config.xaxis.convertedCatToNumeric && (i = e.map(function(n, r) {
      return t.config.xaxis.labels.formatter(n - t.globals.minX + 1);
    })), i;
  } }, { key: "getLargestSeries", value: function() {
    var e = this.w;
    e.globals.maxValsInArrayIndex = e.globals.series.map(function(t) {
      return t.length;
    }).indexOf(Math.max.apply(Math, e.globals.series.map(function(t) {
      return t.length;
    })));
  } }, { key: "getLargestMarkerSize", value: function() {
    var e = this.w, t = 0;
    return e.globals.markers.size.forEach(function(i) {
      t = Math.max(t, i);
    }), e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach(function(i) {
      t = Math.max(t, i.size);
    }), t > 0 && (e.config.markers.hover.size > 0 ? t = e.config.markers.hover.size : t += e.config.markers.hover.sizeOffset), e.globals.markers.largestSize = t, t;
  } }, { key: "getSeriesTotals", value: function() {
    var e = this.w;
    e.globals.seriesTotals = e.globals.series.map(function(t, i) {
      var n = 0;
      if (Array.isArray(t)) for (var r = 0; r < t.length; r++) n += t[r];
      else n += t;
      return n;
    });
  } }, { key: "getSeriesTotalsXRange", value: function(e, t) {
    var i = this.w;
    return i.globals.series.map(function(n, r) {
      for (var a = 0, o = 0; o < n.length; o++) i.globals.seriesX[r][o] > e && i.globals.seriesX[r][o] < t && (a += n[o]);
      return a;
    });
  } }, { key: "getPercentSeries", value: function() {
    var e = this.w;
    e.globals.seriesPercent = e.globals.series.map(function(t, i) {
      var n = [];
      if (Array.isArray(t)) for (var r = 0; r < t.length; r++) {
        var a = e.globals.stackedSeriesTotals[r], o = 0;
        a && (o = 100 * t[r] / a), n.push(o);
      }
      else {
        var l = 100 * t / e.globals.seriesTotals.reduce(function(c, h) {
          return c + h;
        }, 0);
        n.push(l);
      }
      return n;
    });
  } }, { key: "getCalculatedRatios", value: function() {
    var e, t, i, n = this, r = this.w, a = r.globals, o = [], l = 0, c = [], h = 0.1, u = 0;
    if (a.yRange = [], a.isMultipleYAxis) for (var d = 0; d < a.minYArr.length; d++) a.yRange.push(Math.abs(a.minYArr[d] - a.maxYArr[d])), c.push(0);
    else a.yRange.push(Math.abs(a.minY - a.maxY));
    a.xRange = Math.abs(a.maxX - a.minX), a.zRange = Math.abs(a.maxZ - a.minZ);
    for (var f = 0; f < a.yRange.length; f++) o.push(a.yRange[f] / a.gridHeight);
    if (t = a.xRange / a.gridWidth, e = a.yRange / a.gridWidth, i = a.xRange / a.gridHeight, (l = a.zRange / a.gridHeight * 16) || (l = 1), a.minY !== Number.MIN_VALUE && Math.abs(a.minY) !== 0 && (a.hasNegs = !0), r.globals.seriesYAxisReverseMap.length > 0) {
      var p = function(m, O) {
        var x = r.config.yaxis[r.globals.seriesYAxisReverseMap[O]], b = m < 0 ? -1 : 1;
        return m = Math.abs(m), x.logarithmic && (m = n.getBaseLog(x.logBase, m)), -b * m / o[O];
      };
      if (a.isMultipleYAxis) {
        c = [];
        for (var g = 0; g < o.length; g++) c.push(p(a.minYArr[g], g));
      } else (c = []).push(p(a.minY, 0)), a.minY !== Number.MIN_VALUE && Math.abs(a.minY) !== 0 && (h = -a.minY / e, u = a.minX / t);
    } else (c = []).push(0), h = 0, u = 0;
    return { yRatio: o, invertedYRatio: e, zRatio: l, xRatio: t, invertedXRatio: i, baseLineInvertedY: h, baseLineY: c, baseLineX: u };
  } }, { key: "getLogSeries", value: function(e) {
    var t = this, i = this.w;
    return i.globals.seriesLog = e.map(function(n, r) {
      var a = i.globals.seriesYAxisReverseMap[r];
      return i.config.yaxis[a] && i.config.yaxis[a].logarithmic ? n.map(function(o) {
        return o === null ? null : t.getLogVal(i.config.yaxis[a].logBase, o, r);
      }) : n;
    }), i.globals.invalidLogScale ? e : i.globals.seriesLog;
  } }, { key: "getLogValAtSeriesIndex", value: function(e, t) {
    if (e === null) return null;
    var i = this.w, n = i.globals.seriesYAxisReverseMap[t];
    return i.config.yaxis[n] && i.config.yaxis[n].logarithmic ? this.getLogVal(i.config.yaxis[n].logBase, e, t) : e;
  } }, { key: "getBaseLog", value: function(e, t) {
    return Math.log(t) / Math.log(e);
  } }, { key: "getLogVal", value: function(e, t, i) {
    if (t <= 0) return 0;
    var n = this.w, r = n.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(e, n.globals.minYArr[i]), a = (n.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(e, n.globals.maxYArr[i])) - r;
    return t < 1 ? t / a : (this.getBaseLog(e, t) - r) / a;
  } }, { key: "getLogYRatios", value: function(e) {
    var t = this, i = this.w, n = this.w.globals;
    return n.yLogRatio = e.slice(), n.logYRange = n.yRange.map(function(r, a) {
      var o = i.globals.seriesYAxisReverseMap[a];
      if (i.config.yaxis[o] && t.w.config.yaxis[o].logarithmic) {
        var l, c = -Number.MAX_VALUE, h = Number.MIN_VALUE;
        return n.seriesLog.forEach(function(u, d) {
          u.forEach(function(f) {
            i.config.yaxis[d] && i.config.yaxis[d].logarithmic && (c = Math.max(f, c), h = Math.min(f, h));
          });
        }), l = Math.pow(n.yRange[a], Math.abs(h - c) / n.yRange[a]), n.yLogRatio[a] = l / n.gridHeight, l;
      }
    }), n.invalidLogScale ? e.slice() : n.yLogRatio;
  } }, { key: "drawSeriesByGroup", value: function(e, t, i, n) {
    var r = this.w, a = [];
    return e.series.length > 0 && t.forEach(function(o) {
      var l = [], c = [];
      e.i.forEach(function(h, u) {
        r.config.series[h].group === o && (l.push(e.series[u]), c.push(h));
      }), l.length > 0 && a.push(n.draw(l, i, c));
    }), a;
  } }], [{ key: "checkComboSeries", value: function(e, t) {
    var i = !1, n = 0, r = 0;
    return t === void 0 && (t = "line"), e.length && e[0].type !== void 0 && e.forEach(function(a) {
      a.type !== "bar" && a.type !== "column" && a.type !== "candlestick" && a.type !== "boxPlot" || n++, a.type !== void 0 && a.type !== t && r++;
    }), r > 0 && (i = !0), { comboBarCount: n, comboCharts: i };
  } }, { key: "extendArrayProps", value: function(e, t, i) {
    var n, r, a, o, l, c;
    return (n = t) !== null && n !== void 0 && n.yaxis && (t = e.extendYAxis(t, i)), (r = t) !== null && r !== void 0 && r.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)), (a = t) !== null && a !== void 0 && (o = a.annotations) !== null && o !== void 0 && o.xaxis && (t = e.extendXAxisAnnotations(t)), (l = t) !== null && l !== void 0 && (c = l.annotations) !== null && c !== void 0 && c.points && (t = e.extendPointAnnotations(t))), t;
  } }]), s;
}(), jc = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.annoCtx = e;
  }
  return te(s, [{ key: "setOrientations", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.w;
    if (e.label.orientation === "vertical") {
      var n = t !== null ? t : 0, r = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(n, "']"));
      if (r !== null) {
        var a = r.getBoundingClientRect();
        r.setAttribute("x", parseFloat(r.getAttribute("x")) - a.height + 4);
        var o = e.label.position === "top" ? a.width : -a.width;
        r.setAttribute("y", parseFloat(r.getAttribute("y")) + o);
        var l = this.annoCtx.graphics.rotateAroundCenter(r), c = l.x, h = l.y;
        r.setAttribute("transform", "rotate(-90 ".concat(c, " ").concat(h, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(e, t) {
    var i = this.w;
    if (!e || !t.label.text || !String(t.label.text).trim()) return null;
    var n = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), r = e.getBoundingClientRect(), a = t.label.style.padding, o = a.left, l = a.right, c = a.top, h = a.bottom;
    if (t.label.orientation === "vertical") {
      var u = [o, l, c, h];
      c = u[0], h = u[1], o = u[2], l = u[3];
    }
    var d = r.left - n.left - o, f = r.top - n.top - c, p = this.annoCtx.graphics.drawRect(d - i.globals.barPadForNumericAxis, f, r.width + o + l, r.height + c + h, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0);
    return t.id && p.node.classList.add(t.id), p;
  } }, { key: "annotationsBackground", value: function() {
    var e = this, t = this.w, i = function(n, r, a) {
      var o = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(r, "']"));
      if (o) {
        var l = o.parentNode, c = e.addBackgroundToAnno(o, n);
        c && (l.insertBefore(c.node, o), n.label.mouseEnter && c.node.addEventListener("mouseenter", n.label.mouseEnter.bind(e, n)), n.label.mouseLeave && c.node.addEventListener("mouseleave", n.label.mouseLeave.bind(e, n)), n.label.click && c.node.addEventListener("click", n.label.click.bind(e, n)));
      }
    };
    t.config.annotations.xaxis.forEach(function(n, r) {
      return i(n, r, "xaxis");
    }), t.config.annotations.yaxis.forEach(function(n, r) {
      return i(n, r, "yaxis");
    }), t.config.annotations.points.forEach(function(n, r) {
      return i(n, r, "point");
    });
  } }, { key: "getY1Y2", value: function(e, t) {
    var i, n = this.w, r = e === "y1" ? t.y : t.y2, a = !1;
    if (this.annoCtx.invertAxis) {
      var o = n.config.xaxis.convertedCatToNumeric ? n.globals.categoryLabels : n.globals.labels, l = o.indexOf(r), c = n.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(l + 1, ")"));
      i = c ? parseFloat(c.getAttribute("y")) : (n.globals.gridHeight / o.length - 1) * (l + 1) - n.globals.barHeight, t.seriesIndex !== void 0 && n.globals.barHeight && (i -= n.globals.barHeight / 2 * (n.globals.series.length - 1) - n.globals.barHeight * t.seriesIndex);
    } else {
      var h, u = n.globals.seriesYAxisMap[t.yAxisIndex][0], d = n.config.yaxis[t.yAxisIndex].logarithmic ? new st(this.annoCtx.ctx).getLogVal(n.config.yaxis[t.yAxisIndex].logBase, r, u) / n.globals.yLogRatio[u] : (r - n.globals.minYArr[u]) / (n.globals.yRange[u] / n.globals.gridHeight);
      i = n.globals.gridHeight - Math.min(Math.max(d, 0), n.globals.gridHeight), a = d > n.globals.gridHeight || d < 0, !t.marker || t.y !== void 0 && t.y !== null || (i = 0), (h = n.config.yaxis[t.yAxisIndex]) !== null && h !== void 0 && h.reversed && (i = d);
    }
    return typeof r == "string" && r.includes("px") && (i = parseFloat(r)), { yP: i, clipped: a };
  } }, { key: "getX1X2", value: function(e, t) {
    var i = this.w, n = e === "x1" ? t.x : t.x2, r = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, a = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, o = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, l = !1, c = this.annoCtx.inversedReversedAxis ? (a - n) / (o / i.globals.gridWidth) : (n - r) / (o / i.globals.gridWidth);
    return i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || i.config.chart.sparkline.enabled || (c = this.getStringX(n)), typeof n == "string" && n.includes("px") && (c = parseFloat(n)), n == null && t.marker && (c = i.globals.gridWidth), t.seriesIndex !== void 0 && i.globals.barWidth && !this.annoCtx.invertAxis && (c -= i.globals.barWidth / 2 * (i.globals.series.length - 1) - i.globals.barWidth * t.seriesIndex), typeof c != "number" && (c = 0, l = !0), parseFloat(c.toFixed(10)) > parseFloat(i.globals.gridWidth.toFixed(10)) ? (c = i.globals.gridWidth, l = !0) : c < 0 && (c = 0, l = !0), { x: c, clipped: l };
  } }, { key: "getStringX", value: function(e) {
    var t = this.w, i = e;
    t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
    var n = t.globals.labels.map(function(a) {
      return Array.isArray(a) ? a.join(" ") : a;
    }).indexOf(e), r = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(n + 1, ")"));
    return r && (i = parseFloat(r.getAttribute("x"))), i;
  } }]), s;
}(), NT = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new jc(this.annoCtx);
  }
  return te(s, [{ key: "addXaxisAnnotation", value: function(e, t, i) {
    var n, r = this.w, a = this.helpers.getX1X2("x1", e), o = a.x, l = a.clipped, c = !0, h = e.label.text, u = e.strokeDashArray;
    if (E.isNumber(o)) {
      if (e.x2 === null || e.x2 === void 0) {
        if (!l) {
          var d = this.annoCtx.graphics.drawLine(o + e.offsetX, 0 + e.offsetY, o + e.offsetX, r.globals.gridHeight + e.offsetY, e.borderColor, u, e.borderWidth);
          t.appendChild(d.node), e.id && d.node.classList.add(e.id);
        }
      } else {
        var f = this.helpers.getX1X2("x2", e);
        if (n = f.x, c = f.clipped, n < o) {
          var p = o;
          o = n, n = p;
        }
        var g = this.annoCtx.graphics.drawRect(o + e.offsetX, 0 + e.offsetY, n - o, r.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, u);
        g.node.classList.add("apexcharts-annotation-rect"), g.attr("clip-path", "url(#gridRectMask".concat(r.globals.cuid, ")")), t.appendChild(g.node), e.id && g.node.classList.add(e.id);
      }
      if (!l || !c) {
        var m = this.annoCtx.graphics.getTextRects(h, parseFloat(e.label.style.fontSize)), O = e.label.position === "top" ? 4 : e.label.position === "center" ? r.globals.gridHeight / 2 + (e.label.orientation === "vertical" ? m.width / 2 : 0) : r.globals.gridHeight, x = this.annoCtx.graphics.drawText({ x: o + e.label.offsetX, y: O + e.label.offsetY - (e.label.orientation === "vertical" ? e.label.position === "top" ? m.width / 2 - 12 : -m.width / 2 : 0), text: h, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
        x.attr({ rel: i }), t.appendChild(x.node), this.annoCtx.helpers.setOrientations(e, i);
      }
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return t.config.annotations.xaxis.map(function(n, r) {
      e.addXaxisAnnotation(n, i.node, r);
    }), i;
  } }]), s;
}(), xt = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return te(s, [{ key: "isValidDate", value: function(e) {
    return typeof e != "number" && !isNaN(this.parseDate(e));
  } }, { key: "getTimeStamp", value: function(e) {
    return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e;
  } }, { key: "getDate", value: function(e) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e);
  } }, { key: "parseDate", value: function(e) {
    var t = Date.parse(e);
    if (!isNaN(t)) return this.getTimeStamp(e);
    var i = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i = this.getTimeStamp(i);
  } }, { key: "parseDateWithTimezone", value: function(e) {
    return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  } }, { key: "formatDate", value: function(e, t) {
    var i = this.w.globals.locale, n = this.w.config.xaxis.labels.datetimeUTC, r = ["\0"].concat(dt(i.months)), a = [""].concat(dt(i.shortMonths)), o = [""].concat(dt(i.days)), l = [""].concat(dt(i.shortDays));
    function c(k, A) {
      var T = k + "";
      for (A = A || 2; T.length < A; ) T = "0" + T;
      return T;
    }
    var h = n ? e.getUTCFullYear() : e.getFullYear();
    t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + h)).replace(/(^|[^\\])yy/g, "$1" + h.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h);
    var u = (n ? e.getUTCMonth() : e.getMonth()) + 1;
    t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + r[0])).replace(/(^|[^\\])MMM/g, "$1" + a[0])).replace(/(^|[^\\])MM/g, "$1" + c(u))).replace(/(^|[^\\])M/g, "$1" + u);
    var d = n ? e.getUTCDate() : e.getDate();
    t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + o[0])).replace(/(^|[^\\])ddd/g, "$1" + l[0])).replace(/(^|[^\\])dd/g, "$1" + c(d))).replace(/(^|[^\\])d/g, "$1" + d);
    var f = n ? e.getUTCHours() : e.getHours(), p = f > 12 ? f - 12 : f === 0 ? 12 : f;
    t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + c(f))).replace(/(^|[^\\])H/g, "$1" + f)).replace(/(^|[^\\])hh+/g, "$1" + c(p))).replace(/(^|[^\\])h/g, "$1" + p);
    var g = n ? e.getUTCMinutes() : e.getMinutes();
    t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + c(g))).replace(/(^|[^\\])m/g, "$1" + g);
    var m = n ? e.getUTCSeconds() : e.getSeconds();
    t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + c(m))).replace(/(^|[^\\])s/g, "$1" + m);
    var O = n ? e.getUTCMilliseconds() : e.getMilliseconds();
    t = t.replace(/(^|[^\\])fff+/g, "$1" + c(O, 3)), O = Math.round(O / 10), t = t.replace(/(^|[^\\])ff/g, "$1" + c(O)), O = Math.round(O / 10);
    var x = f < 12 ? "AM" : "PM";
    t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + O)).replace(/(^|[^\\])TT+/g, "$1" + x)).replace(/(^|[^\\])T/g, "$1" + x.charAt(0));
    var b = x.toLowerCase();
    t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + b)).replace(/(^|[^\\])t/g, "$1" + b.charAt(0));
    var v = -e.getTimezoneOffset(), y = n || !v ? "Z" : v > 0 ? "+" : "-";
    if (!n) {
      var w = (v = Math.abs(v)) % 60;
      y += c(Math.floor(v / 60)) + ":" + c(w);
    }
    t = t.replace(/(^|[^\\])K/g, "$1" + y);
    var S = (n ? e.getUTCDay() : e.getDay()) + 1;
    return t = (t = (t = (t = (t = t.replace(new RegExp(o[0], "g"), o[S])).replace(new RegExp(l[0], "g"), l[S])).replace(new RegExp(r[0], "g"), r[u])).replace(new RegExp(a[0], "g"), a[u])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(e, t, i) {
    var n = this.w;
    n.config.xaxis.min !== void 0 && (e = n.config.xaxis.min), n.config.xaxis.max !== void 0 && (t = n.config.xaxis.max);
    var r = this.getDate(e), a = this.getDate(t), o = this.formatDate(r, "yyyy MM dd HH mm ss fff").split(" "), l = this.formatDate(a, "yyyy MM dd HH mm ss fff").split(" ");
    return { minMillisecond: parseInt(o[6], 10), maxMillisecond: parseInt(l[6], 10), minSecond: parseInt(o[5], 10), maxSecond: parseInt(l[5], 10), minMinute: parseInt(o[4], 10), maxMinute: parseInt(l[4], 10), minHour: parseInt(o[3], 10), maxHour: parseInt(l[3], 10), minDate: parseInt(o[2], 10), maxDate: parseInt(l[2], 10), minMonth: parseInt(o[1], 10) - 1, maxMonth: parseInt(l[1], 10) - 1, minYear: parseInt(o[0], 10), maxYear: parseInt(l[0], 10) };
  } }, { key: "isLeapYear", value: function(e) {
    return e % 4 == 0 && e % 100 != 0 || e % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(e, t, i) {
    return this.determineDaysOfMonths(e, t) - i;
  } }, { key: "determineDaysOfYear", value: function(e) {
    var t = 365;
    return this.isLeapYear(e) && (t = 366), t;
  } }, { key: "determineRemainingDaysOfYear", value: function(e, t, i) {
    var n = this.daysCntOfYear[t] + i;
    return t > 1 && this.isLeapYear() && n++, n;
  } }, { key: "determineDaysOfMonths", value: function(e, t) {
    var i = 30;
    switch (e = E.monthMod(e), !0) {
      case this.months30.indexOf(e) > -1:
        e === 2 && (i = this.isLeapYear(t) ? 29 : 28);
        break;
      case this.months31.indexOf(e) > -1:
      default:
        i = 31;
    }
    return i;
  } }]), s;
}(), go = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM";
  }
  return te(s, [{ key: "xLabelFormat", value: function(e, t, i, n) {
    var r = this.w;
    if (r.config.xaxis.type === "datetime" && r.config.xaxis.labels.formatter === void 0 && r.config.tooltip.x.formatter === void 0) {
      var a = new xt(this.ctx);
      return a.formatDate(a.getDate(t), r.config.tooltip.x.format);
    }
    return e(t, i, n);
  } }, { key: "defaultGeneralFormatter", value: function(e) {
    return Array.isArray(e) ? e.map(function(t) {
      return t;
    }) : e;
  } }, { key: "defaultYFormatter", value: function(e, t, i) {
    var n = this.w;
    if (E.isNumber(e)) if (n.globals.yValueDecimal !== 0) e = e.toFixed(t.decimalsInFloat !== void 0 ? t.decimalsInFloat : n.globals.yValueDecimal);
    else {
      var r = e.toFixed(0);
      e = e == r ? r : e.toFixed(1);
    }
    return e;
  } }, { key: "setLabelFormatters", value: function() {
    var e = this, t = this.w;
    return t.globals.xaxisTooltipFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.globals.ttKeyFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.globals.ttZFormatter = function(i) {
      return i;
    }, t.globals.legendFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.config.xaxis.labels.formatter !== void 0 ? t.globals.xLabelFormatter = t.config.xaxis.labels.formatter : t.globals.xLabelFormatter = function(i) {
      if (E.isNumber(i)) {
        if (!t.config.xaxis.convertedCatToNumeric && t.config.xaxis.type === "numeric") {
          if (E.isNumber(t.config.xaxis.decimalsInFloat)) return i.toFixed(t.config.xaxis.decimalsInFloat);
          var n = t.globals.maxX - t.globals.minX;
          return n > 0 && n < 100 ? i.toFixed(1) : i.toFixed(0);
        }
        return t.globals.isBarHorizontal && t.globals.maxY - t.globals.minYArr < 4 ? i.toFixed(1) : i.toFixed(0);
      }
      return i;
    }, typeof t.config.tooltip.x.formatter == "function" ? t.globals.ttKeyFormatter = t.config.tooltip.x.formatter : t.globals.ttKeyFormatter = t.globals.xLabelFormatter, typeof t.config.xaxis.tooltip.formatter == "function" && (t.globals.xaxisTooltipFormatter = t.config.xaxis.tooltip.formatter), (Array.isArray(t.config.tooltip.y) || t.config.tooltip.y.formatter !== void 0) && (t.globals.ttVal = t.config.tooltip.y), t.config.tooltip.z.formatter !== void 0 && (t.globals.ttZFormatter = t.config.tooltip.z.formatter), t.config.legend.formatter !== void 0 && (t.globals.legendFormatter = t.config.legend.formatter), t.config.yaxis.forEach(function(i, n) {
      i.labels.formatter !== void 0 ? t.globals.yLabelFormatters[n] = i.labels.formatter : t.globals.yLabelFormatters[n] = function(r) {
        return t.globals.xyCharts ? Array.isArray(r) ? r.map(function(a) {
          return e.defaultYFormatter(a, i, n);
        }) : e.defaultYFormatter(r, i, n) : r;
      };
    }), t.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var e = this.w;
    if (e.config.chart.type === "heatmap") {
      e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
      var t = e.globals.seriesNames.reduce(function(i, n) {
        return i.length > n.length ? i : n;
      }, 0);
      e.globals.yAxisScale[0].niceMax = t, e.globals.yAxisScale[0].niceMin = t;
    }
  } }]), s;
}(), Ws = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "getLabel", value: function(e, t, i, n) {
    var r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", o = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], l = this.w, c = e[n] === void 0 ? "" : e[n], h = c, u = l.globals.xLabelFormatter, d = l.config.xaxis.labels.formatter, f = !1, p = new go(this.ctx), g = c;
    o && (h = p.xLabelFormat(u, c, g, { i: n, dateFormatter: new xt(this.ctx).formatDate, w: l }), d !== void 0 && (h = d(c, e[n], { i: n, dateFormatter: new xt(this.ctx).formatDate, w: l })));
    var m, O;
    t.length > 0 ? (m = t[n].unit, O = null, t.forEach(function(y) {
      y.unit === "month" ? O = "year" : y.unit === "day" ? O = "month" : y.unit === "hour" ? O = "day" : y.unit === "minute" && (O = "hour");
    }), f = O === m, i = t[n].position, h = t[n].value) : l.config.xaxis.type === "datetime" && d === void 0 && (h = ""), h === void 0 && (h = ""), h = Array.isArray(h) ? h : h.toString();
    var x = new Z(this.ctx), b = {};
    b = l.globals.rotateXLabels && o ? x.getTextRects(h, parseInt(a, 10), null, "rotate(".concat(l.config.xaxis.labels.rotate, " 0 0)"), !1) : x.getTextRects(h, parseInt(a, 10));
    var v = !l.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(h) && (String(h) === "NaN" || r.indexOf(h) >= 0 && v) && (h = ""), { x: i, text: h, textRect: b, isBold: f };
  } }, { key: "checkLabelBasedOnTickamount", value: function(e, t, i) {
    var n = this.w, r = n.config.xaxis.tickAmount;
    return r === "dataPoints" && (r = Math.round(n.globals.gridWidth / 120)), r > i || e % Math.round(i / (r + 1)) == 0 || (t.text = ""), t;
  } }, { key: "checkForOverflowingLabels", value: function(e, t, i, n, r) {
    var a = this.w;
    if (e === 0 && a.globals.skipFirstTimelinelabel && (t.text = ""), e === i - 1 && a.globals.skipLastTimelinelabel && (t.text = ""), a.config.xaxis.labels.hideOverlappingLabels && n.length > 0) {
      var o = r[r.length - 1];
      t.x < o.textRect.width / (a.globals.rotateXLabels ? Math.abs(a.config.xaxis.labels.rotate) / 12 : 1.01) + o.x && (t.text = "");
    }
    return t;
  } }, { key: "checkForReversedLabels", value: function(e, t) {
    var i = this.w;
    return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(), t;
  } }, { key: "yAxisAllSeriesCollapsed", value: function(e) {
    var t = this.w.globals;
    return !t.seriesYAxisMap[e].some(function(i) {
      return t.collapsedSeriesIndices.indexOf(i) === -1;
    });
  } }, { key: "translateYAxisIndex", value: function(e) {
    var t = this.w, i = t.globals, n = t.config.yaxis;
    return i.series.length > n.length || n.some(function(r) {
      return Array.isArray(r.seriesName);
    }) ? e : i.seriesYAxisReverseMap[e];
  } }, { key: "isYAxisHidden", value: function(e) {
    var t = this.w, i = t.config.yaxis[e];
    if (!i.show || this.yAxisAllSeriesCollapsed(e)) return !0;
    if (!i.showForNullSeries) {
      var n = t.globals.seriesYAxisMap[e], r = new st(this.ctx);
      return n.every(function(a) {
        return r.isSeriesNull(a);
      });
    }
    return !1;
  } }, { key: "getYAxisForeColor", value: function(e, t) {
    var i = this.w;
    return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, i.globals.yAxisScale[t].result.length, !1), e;
  } }, { key: "drawYAxisTicks", value: function(e, t, i, n, r, a, o) {
    var l = this.w, c = new Z(this.ctx), h = l.globals.translateY + l.config.yaxis[r].labels.offsetY;
    if (l.globals.isBarHorizontal ? h = 0 : l.config.chart.type === "heatmap" && (h += a / 2), n.show && t > 0) {
      l.config.yaxis[r].opposite === !0 && (e += n.width);
      for (var u = t; u >= 0; u--) {
        var d = c.drawLine(e + i.offsetX - n.width + n.offsetX, h + n.offsetY, e + i.offsetX + n.offsetX, h + n.offsetY, n.color);
        o.add(d), h += a;
      }
    }
  } }]), s;
}(), VT = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.annoCtx = e, this.helpers = new jc(this.annoCtx), this.axesUtils = new Ws(this.annoCtx);
  }
  return te(s, [{ key: "addYaxisAnnotation", value: function(e, t, i) {
    var n, r = this.w, a = e.strokeDashArray, o = this.helpers.getY1Y2("y1", e), l = o.yP, c = o.clipped, h = !0, u = !1, d = e.label.text;
    if (e.y2 === null || e.y2 === void 0) {
      if (!c) {
        u = !0;
        var f = this.annoCtx.graphics.drawLine(0 + e.offsetX, l + e.offsetY, this._getYAxisAnnotationWidth(e), l + e.offsetY, e.borderColor, a, e.borderWidth);
        t.appendChild(f.node), e.id && f.node.classList.add(e.id);
      }
    } else {
      if (n = (o = this.helpers.getY1Y2("y2", e)).yP, h = o.clipped, n > l) {
        var p = l;
        l = n, n = p;
      }
      if (!c || !h) {
        u = !0;
        var g = this.annoCtx.graphics.drawRect(0 + e.offsetX, n + e.offsetY, this._getYAxisAnnotationWidth(e), l - n, 0, e.fillColor, e.opacity, 1, e.borderColor, a);
        g.node.classList.add("apexcharts-annotation-rect"), g.attr("clip-path", "url(#gridRectMask".concat(r.globals.cuid, ")")), t.appendChild(g.node), e.id && g.node.classList.add(e.id);
      }
    }
    if (u) {
      var m = e.label.position === "right" ? r.globals.gridWidth : e.label.position === "center" ? r.globals.gridWidth / 2 : 0, O = this.annoCtx.graphics.drawText({ x: m + e.label.offsetX, y: (n ?? l) + e.label.offsetY - 3, text: d, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
      O.attr({ rel: i }), t.appendChild(O.node);
    }
  } }, { key: "_getYAxisAnnotationWidth", value: function(e) {
    var t = this.w;
    return t.globals.gridWidth, (e.width.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX;
  } }, { key: "drawYAxisAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return t.config.annotations.yaxis.forEach(function(n, r) {
      n.yAxisIndex = e.axesUtils.translateYAxisIndex(n.yAxisIndex), e.axesUtils.isYAxisHidden(n.yAxisIndex) && e.axesUtils.yAxisAllSeriesCollapsed(n.yAxisIndex) || e.addYaxisAnnotation(n, i.node, r);
    }), i;
  } }]), s;
}(), FT = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.annoCtx = e, this.helpers = new jc(this.annoCtx);
  }
  return te(s, [{ key: "addPointAnnotation", value: function(e, t, i) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(e.seriesIndex) > -1)) {
      var n = this.helpers.getX1X2("x1", e), r = n.x, a = n.clipped, o = (n = this.helpers.getY1Y2("y1", e)).yP, l = n.clipped;
      if (E.isNumber(r) && !l && !a) {
        var c = { pSize: e.marker.size, pointStrokeWidth: e.marker.strokeWidth, pointFillColor: e.marker.fillColor, pointStrokeColor: e.marker.strokeColor, shape: e.marker.shape, pRadius: e.marker.radius, class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id ? e.id : "") }, h = this.annoCtx.graphics.drawMarker(r + e.marker.offsetX, o + e.marker.offsetY, c);
        t.appendChild(h.node);
        var u = e.label.text ? e.label.text : "", d = this.annoCtx.graphics.drawText({ x: r + e.label.offsetX, y: o + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6, text: u, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
        if (d.attr({ rel: i }), t.appendChild(d.node), e.customSVG.SVG) {
          var f = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass });
          f.attr({ transform: "translate(".concat(r + e.customSVG.offsetX, ", ").concat(o + e.customSVG.offsetY, ")") }), f.node.innerHTML = e.customSVG.SVG, t.appendChild(f.node);
        }
        if (e.image.path) {
          var p = e.image.width ? e.image.width : 20, g = e.image.height ? e.image.height : 20;
          h = this.annoCtx.addImage({ x: r + e.image.offsetX - p / 2, y: o + e.image.offsetY - g / 2, width: p, height: g, path: e.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        e.mouseEnter && h.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)), e.mouseLeave && h.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e)), e.click && h.node.addEventListener("click", e.click.bind(this, e));
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
    return t.config.annotations.points.map(function(n, r) {
      e.addPointAnnotation(n, i.node, r);
    }), i;
  } }]), s;
}(), Vy = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, sn = function() {
  function s() {
    ee(this, s), this.yAxis = { show: !0, showAlways: !1, showForNullSeries: !0, seriesName: void 0, opposite: !1, reversed: !1, logarithmic: !1, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: !1, max: void 0, min: void 0, floating: !1, decimalsInFloat: void 0, labels: { show: !0, showDuplicates: !1, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: !1, offsetX: 0 }, crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return te(s, [{ key: "init", value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: !0, speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 } }, background: "", locales: [Vy], defaultLocale: "en", dropShadow: { enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.7 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: !0, redrawOnWindowResize: !0, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: !1, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: !1 }, brush: { enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0 }, stacked: !1, stackOnlyBar: !0, stackType: "normal", toolbar: { show: !0, offsetX: 0, offsetY: 0, tools: { download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: !0, type: "x", autoScaleYaxis: !1, allowMouseWheelZoom: !0, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: !1, colors: { threshold: 0, colorAboveThreshold: void 0, colorBelowThreshold: void 0 } }, area: { fillTo: "origin" }, bar: { horizontal: !1, columnWidth: "70%", barHeight: "70%", distributed: !1, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: !0, rangeBarGroupRows: !1, hideZeroBarsWhenGrouped: !1, isDumbbell: !1, dumbbellColors: void 0, isFunnel: !1, isFunnel3d: !0, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: !0, orientation: "horizontal", total: { enabled: !1, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: !0, shadeIntensity: 0.5, reverseNegativeShade: !1, distributed: !1, useFillColorAsStroke: !1, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: !0, shadeIntensity: 0.5, distributed: !1, reverseNegativeShade: !1, useFillColorAsStroke: !1, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 }, seriesTitle: { show: !0, offsetY: 1, offsetX: 1, borderColor: "#000", borderWidth: 1, borderRadius: 2, style: { background: "rgba(0, 0, 0, 0.6)", color: "#fff", fontSize: "12px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: !1, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: !0, position: "front", dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: !0, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: !0, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(e) {
      return e;
    } }, value: { show: !0, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(e) {
      return e + "%";
    } }, total: { show: !1, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(e) {
      return e.globals.seriesTotals.reduce(function(t, i) {
        return t + i;
      }, 0) / e.globals.series.length + "%";
    } } }, barLabels: { enabled: !1, offsetX: 0, offsetY: 0, useSeriesColors: !0, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(e) {
      return e;
    }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: !0, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: !1, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(e) {
      return e;
    } }, value: { show: !0, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(e) {
      return e;
    } }, total: { show: !1, showAlways: !1, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(e) {
      return e.globals.seriesTotals.reduce(function(t, i) {
        return t + i;
      }, 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: !0, enabledOnSeries: void 0, formatter: function(e) {
      return e !== null ? e : "";
    }, textAnchor: "middle", distributed: !1, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: !0, foreColor: "#fff", backgroundColor: void 0, borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: !0, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: !1 } }, yaxis: { lines: { show: !0 } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: !0, showForSingleSeries: !1, showForNullSeries: !0, showForZeroSeries: !0, floating: !1, position: "bottom", horizontalAlign: "center", inverseOrder: !1, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: !0, clusterGroupedSeriesOrientation: "vertical", labels: { colors: void 0, useSeriesColors: !1 }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: !0 }, onItemHover: { highlightDataSeries: !0 } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: !0, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { hover: { filter: { type: "lighten" } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken" } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: !0, enabledOnSeries: void 0, shared: !0, hideEmptySeries: !1, followCursor: !1, intersect: !1, inverseOrder: !1, custom: void 0, fillSeriesColor: !1, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: !1 }, x: { show: !0, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(e) {
      return e ? e + ": " : "";
    } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: !0, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: !1, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: !0, rotate: -45, rotateAlways: !1, hideOverlappingLabels: !0, trim: !1, minHeight: void 0, maxHeight: 120, showDuplicates: !0, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: !0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: !1, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: !0, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), s;
}(), jT = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.graphics = new Z(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new jc(this), this.xAxisAnnotations = new NT(this), this.yAxisAnnotations = new VT(this), this.pointsAnnotations = new FT(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return te(s, [{ key: "drawAxesAnnotations", value: function() {
    var e = this.w;
    if (e.globals.axisCharts && e.globals.dataPoints) {
      for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), n = this.pointsAnnotations.drawPointAnnotations(), r = e.config.chart.animations.enabled, a = [t, i, n], o = [i.node, t.node, n.node], l = 0; l < 3; l++) e.globals.dom.elGraphical.add(a[l]), !r || e.globals.resized || e.globals.dataChanged || e.config.chart.type !== "scatter" && e.config.chart.type !== "bubble" && e.globals.dataPoints > 1 && o[l].classList.add("apexcharts-element-hidden"), e.globals.delayedElements.push({ el: o[l], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: "drawImageAnnos", value: function() {
    var e = this;
    this.w.config.annotations.images.map(function(t, i) {
      e.addImage(t, i);
    });
  } }, { key: "drawTextAnnos", value: function() {
    var e = this;
    this.w.config.annotations.texts.map(function(t, i) {
      e.addText(t, i);
    });
  } }, { key: "addXaxisAnnotation", value: function(e, t, i) {
    this.xAxisAnnotations.addXaxisAnnotation(e, t, i);
  } }, { key: "addYaxisAnnotation", value: function(e, t, i) {
    this.yAxisAnnotations.addYaxisAnnotation(e, t, i);
  } }, { key: "addPointAnnotation", value: function(e, t, i) {
    this.pointsAnnotations.addPointAnnotation(e, t, i);
  } }, { key: "addText", value: function(e, t) {
    var i = e.x, n = e.y, r = e.text, a = e.textAnchor, o = e.foreColor, l = e.fontSize, c = e.fontFamily, h = e.fontWeight, u = e.cssClass, d = e.backgroundColor, f = e.borderWidth, p = e.strokeDashArray, g = e.borderRadius, m = e.borderColor, O = e.appendTo, x = O === void 0 ? ".apexcharts-svg" : O, b = e.paddingLeft, v = b === void 0 ? 4 : b, y = e.paddingRight, w = y === void 0 ? 4 : y, S = e.paddingBottom, k = S === void 0 ? 2 : S, A = e.paddingTop, T = A === void 0 ? 2 : A, C = this.w, P = this.graphics.drawText({ x: i, y: n, text: r, textAnchor: a || "start", fontSize: l || "12px", fontWeight: h || "regular", fontFamily: c || C.config.chart.fontFamily, foreColor: o || C.config.chart.foreColor, cssClass: u }), $ = C.globals.dom.baseEl.querySelector(x);
    $ && $.appendChild(P.node);
    var R = P.bbox();
    if (r) {
      var X = this.graphics.drawRect(R.x - v, R.y - T, R.width + v + w, R.height + k + T, g, d || "transparent", 1, f, m, p);
      $.insertBefore(X.node, P.node);
    }
  } }, { key: "addImage", value: function(e, t) {
    var i = this.w, n = e.path, r = e.x, a = r === void 0 ? 0 : r, o = e.y, l = o === void 0 ? 0 : o, c = e.width, h = c === void 0 ? 20 : c, u = e.height, d = u === void 0 ? 20 : u, f = e.appendTo, p = f === void 0 ? ".apexcharts-svg" : f, g = i.globals.dom.Paper.image(n);
    g.size(h, d).move(a, l);
    var m = i.globals.dom.baseEl.querySelector(p);
    return m && m.appendChild(g.node), g;
  } }, { key: "addXaxisAnnotationExternal", value: function(e, t, i) {
    return this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
  } }, { key: "addYaxisAnnotationExternal", value: function(e, t, i) {
    return this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
  } }, { key: "addPointAnnotationExternal", value: function(e, t, i) {
    return this.invertAxis === void 0 && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
  } }, { key: "addAnnotationExternal", value: function(e) {
    var t = e.params, i = e.pushToMemory, n = e.context, r = e.type, a = e.contextMethod, o = n, l = o.w, c = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(r, "-annotations")), h = c.childNodes.length + 1, u = new sn(), d = Object.assign({}, r === "xaxis" ? u.xAxisAnnotation : r === "yaxis" ? u.yAxisAnnotation : u.pointAnnotation), f = E.extend(d, t);
    switch (r) {
      case "xaxis":
        this.addXaxisAnnotation(f, c, h);
        break;
      case "yaxis":
        this.addYaxisAnnotation(f, c, h);
        break;
      case "point":
        this.addPointAnnotation(f, c, h);
    }
    var p = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(r, "-annotations .apexcharts-").concat(r, "-annotation-label[rel='").concat(h, "']")), g = this.helpers.addBackgroundToAnno(p, f);
    return g && c.insertBefore(g.node, p), i && l.globals.memory.methodsToExec.push({ context: o, id: f.id ? f.id : E.randomId(), method: a, label: "addAnnotation", params: t }), n;
  } }, { key: "clearAnnotations", value: function(e) {
    for (var t = e.w, i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), n = t.globals.memory.methodsToExec.length - 1; n >= 0; n--) t.globals.memory.methodsToExec[n].label !== "addText" && t.globals.memory.methodsToExec[n].label !== "addAnnotation" || t.globals.memory.methodsToExec.splice(n, 1);
    i = E.listToArray(i), Array.prototype.forEach.call(i, function(r) {
      for (; r.firstChild; ) r.removeChild(r.firstChild);
    });
  } }, { key: "removeAnnotation", value: function(e, t) {
    var i = e.w, n = i.globals.dom.baseEl.querySelectorAll(".".concat(t));
    n && (i.globals.memory.methodsToExec.map(function(r, a) {
      r.id === t && i.globals.memory.methodsToExec.splice(a, 1);
    }), Object.keys(i.config.annotations).forEach(function(r) {
      var a = i.config.annotations[r];
      Array.isArray(a) && (i.config.annotations[r] = a.filter(function(o) {
        return o.id !== t;
      }));
    }), Array.prototype.forEach.call(n, function(r) {
      r.parentElement.removeChild(r);
    }));
  } }]), s;
}(), Bh = function(s) {
  var e, t = s.isTimeline, i = s.ctx, n = s.seriesIndex, r = s.dataPointIndex, a = s.y1, o = s.y2, l = s.w, c = l.globals.seriesRangeStart[n][r], h = l.globals.seriesRangeEnd[n][r], u = l.globals.labels[r], d = l.config.series[n].name ? l.config.series[n].name : "", f = l.globals.ttKeyFormatter, p = l.config.tooltip.y.title.formatter, g = { w: l, seriesIndex: n, dataPointIndex: r, start: c, end: h };
  typeof p == "function" && (d = p(d, g)), (e = l.config.series[n].data[r]) !== null && e !== void 0 && e.x && (u = l.config.series[n].data[r].x), t || l.config.xaxis.type === "datetime" && (u = new go(i).xLabelFormat(l.globals.ttKeyFormatter, u, u, { i: void 0, dateFormatter: new xt(i).formatDate, w: l })), typeof f == "function" && (u = f(u, g)), Number.isFinite(a) && Number.isFinite(o) && (c = a, h = o);
  var m = "", O = "", x = l.globals.colors[n];
  if (l.config.tooltip.x.formatter === void 0) if (l.config.xaxis.type === "datetime") {
    var b = new xt(i);
    m = b.formatDate(b.getDate(c), l.config.tooltip.x.format), O = b.formatDate(b.getDate(h), l.config.tooltip.x.format);
  } else m = c, O = h;
  else m = l.config.tooltip.x.formatter(c), O = l.config.tooltip.x.formatter(h);
  return { start: c, end: h, startVal: m, endVal: O, ylabel: u, color: x, seriesName: d };
}, Wh = function(s) {
  var e = s.color, t = s.seriesName, i = s.ylabel, n = s.start, r = s.end, a = s.seriesIndex, o = s.dataPointIndex, l = s.ctx.tooltip.tooltipLabels.getFormatters(a);
  n = l.yLbFormatter(n), r = l.yLbFormatter(r);
  var c = l.yLbFormatter(s.w.globals.series[a][o]), h = `<span class="value start-value">
  `.concat(n, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(r, `
  </span>`);
  return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (t || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (s.w.globals.comboCharts ? s.w.config.series[a].type === "rangeArea" || s.w.config.series[a].type === "rangeBar" ? h : "<span>".concat(c, "</span>") : h) + " </div></div>";
}, Ca = function() {
  function s(e) {
    ee(this, s), this.opts = e;
  }
  return te(s, [{ key: "hideYAxis", value: function() {
    this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
  } }, { key: "line", value: function() {
    return { dataLabels: { enabled: !1 }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(e) {
    return this.hideYAxis(), E.extend(e, { grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: !1 }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } }, chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 } });
  } }, { key: "slope", value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !0, formatter: function(e, t) {
      var i = t.w.config.series[t.seriesIndex].name;
      return e !== null ? i + ": " + e : "";
    }, background: { enabled: !1 }, offsetX: -5 }, grid: { xaxis: { lines: { show: !0 } }, yaxis: { lines: { show: !1 } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: !1 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, stroke: { width: 5, curve: "straight" } };
  } }, { key: "bar", value: function() {
    return { chart: { stacked: !1 }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } }, stroke: { width: 0, lineCap: "square" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { tooltip: { enabled: !1 }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: !1 }, stroke: { width: 0 } } } };
  } }, { key: "funnel", value: function() {
    return this.hideYAxis(), F(F({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: !1 } } }, plotOptions: { bar: { horizontal: !0, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: !1, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } } });
  } }, { key: "candlestick", value: function() {
    var e = this;
    return { stroke: { width: 1 }, fill: { opacity: 1 }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(t) {
      var i = t.seriesIndex, n = t.dataPointIndex, r = t.w;
      return e._getBoxTooltip(r, i, n, ["Open", "High", "", "Low", "Close"], "candlestick");
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "boxPlot", value: function() {
    var e = this;
    return { chart: { animations: { dynamicAnimation: { enabled: !1 } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(t) {
      var i = t.seriesIndex, n = t.dataPointIndex, r = t.w;
      return e._getBoxTooltip(r, i, n, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { chart: { animations: { animateGradually: !1 } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: !1, formatter: function(e, t) {
      t.ctx;
      var i = t.seriesIndex, n = t.dataPointIndex, r = t.w, a = function() {
        var o = r.globals.seriesRangeStart[i][n];
        return r.globals.seriesRangeEnd[i][n] - o;
      };
      return r.globals.comboCharts ? r.config.series[i].type === "rangeBar" || r.config.series[i].type === "rangeArea" ? a() : e : a();
    }, background: { enabled: !1 }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: !1, followCursor: !0, custom: function(e) {
      return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? function(t) {
        var i = Bh(F(F({}, t), {}, { isTimeline: !0 })), n = i.color, r = i.seriesName, a = i.ylabel, o = i.startVal, l = i.endVal;
        return Wh(F(F({}, t), {}, { color: n, seriesName: r, ylabel: a, start: o, end: l }));
      }(e) : function(t) {
        var i = Bh(t), n = i.color, r = i.seriesName, a = i.ylabel, o = i.start, l = i.end;
        return Wh(F(F({}, t), {}, { color: n, seriesName: r, ylabel: a, start: o, end: l }));
      }(e);
    } }, xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "dumbbell", value: function(e) {
    var t, i;
    return (t = e.plotOptions.bar) !== null && t !== void 0 && t.barHeight || (e.plotOptions.bar.barHeight = 2), (i = e.plotOptions.bar) !== null && i !== void 0 && i.columnWidth || (e.plotOptions.bar.columnWidth = 2), e;
  } }, { key: "area", value: function() {
    return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: !1 } };
  } }, { key: "rangeArea", value: function() {
    return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: !1, shared: !0, followCursor: !0, custom: function(e) {
      return function(t) {
        var i = Bh(t), n = i.color, r = i.seriesName, a = i.ylabel, o = i.start, l = i.end;
        return Wh(F(F({}, t), {}, { color: n, seriesName: r, ylabel: a, start: o, end: l }));
      }(e);
    } } };
  } }, { key: "brush", value: function(e) {
    return E.extend(e, { chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } } });
  } }, { key: "stacked100", value: function(e) {
    e.dataLabels = e.dataLabels || {}, e.dataLabels.formatter = e.dataLabels.formatter || void 0;
    var t = e.dataLabels.formatter;
    return e.yaxis.forEach(function(i, n) {
      e.yaxis[n].min = 0, e.yaxis[n].max = 100;
    }), e.chart.type === "bar" && (e.dataLabels.formatter = t || function(i) {
      return typeof i == "number" && i ? i.toFixed(0) + "%" : i;
    }), e;
  } }, { key: "stackedBars", value: function() {
    var e = this.bar();
    return F(F({}, e), {}, { plotOptions: F(F({}, e.plotOptions), {}, { bar: F(F({}, e.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
  } }, { key: "convertCatToNumeric", value: function(e) {
    return e.xaxis.convertedCatToNumeric = !0, e;
  } }, { key: "convertCatToNumericXaxis", value: function(e, t, i) {
    e.xaxis.type = "numeric", e.xaxis.labels = e.xaxis.labels || {}, e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(a) {
      return E.isNumber(a) ? Math.floor(a) : a;
    };
    var n = e.xaxis.labels.formatter, r = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
    return i && i.length && (r = i.map(function(a) {
      return Array.isArray(a) ? a : String(a);
    })), r && r.length && (e.xaxis.labels.formatter = function(a) {
      return E.isNumber(a) ? n(r[Math.floor(a) - 1]) : n(a);
    }), e.xaxis.categories = [], e.labels = [], e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints", e;
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
  } }, { key: "treemap", value: function() {
    return { chart: { zoom: { enabled: !1 } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: !0, width: 2, colors: ["#fff"] }, legend: { show: !1 }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: !0, x: { show: !1 } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: !1 } }, plotOptions: { pie: { donut: { labels: { show: !1 } } } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "polarArea", value: function() {
    return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, enabled: !1 }, stroke: { show: !0, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: !1, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(e) {
      return e;
    }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: !1, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: !1, position: "right" }, tooltip: { enabled: !1, fillSeriesColor: !0 }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "_getBoxTooltip", value: function(e, t, i, n, r) {
    var a = e.globals.seriesCandleO[t][i], o = e.globals.seriesCandleH[t][i], l = e.globals.seriesCandleM[t][i], c = e.globals.seriesCandleL[t][i], h = e.globals.seriesCandleC[t][i];
    return e.config.series[t].type && e.config.series[t].type !== r ? `<div class="apexcharts-custom-tooltip">
          `.concat(e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][i], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(n[0], ': <span class="value">') + a + "</span></div>" + "<div>".concat(n[1], ': <span class="value">') + o + "</span></div>" + (l ? "<div>".concat(n[2], ': <span class="value">') + l + "</span></div>" : "") + "<div>".concat(n[3], ': <span class="value">') + c + "</span></div>" + "<div>".concat(n[4], ': <span class="value">') + h + "</span></div></div>";
  } }]), s;
}(), Aa = function() {
  function s(e) {
    ee(this, s), this.opts = e;
  }
  return te(s, [{ key: "init", value: function(e) {
    var t = e.responsiveOverride, i = this.opts, n = new sn(), r = new Ca(i);
    this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
    var a = n.init(), o = {};
    if (i && lr(i) === "object") {
      var l, c, h, u, d, f, p, g, m, O, x = {};
      x = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) !== -1 ? r[i.chart.type]() : r.line(), (l = i.plotOptions) !== null && l !== void 0 && (c = l.bar) !== null && c !== void 0 && c.isFunnel && (x = r.funnel()), i.chart.stacked && i.chart.type === "bar" && (x = r.stackedBars()), (h = i.chart.brush) !== null && h !== void 0 && h.enabled && (x = r.brush(x)), (u = i.plotOptions) !== null && u !== void 0 && (d = u.line) !== null && d !== void 0 && d.isSlopeChart && (x = r.slope()), i.chart.stacked && i.chart.stackType === "100%" && (i = r.stacked100(i)), (f = i.plotOptions) !== null && f !== void 0 && (p = f.bar) !== null && p !== void 0 && p.isDumbbell && (i = r.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, t || (i.xaxis.convertedCatToNumeric = !1), ((g = (i = this.checkForCatToNumericXAxis(this.chartType, x, i)).chart.sparkline) !== null && g !== void 0 && g.enabled || (m = window.Apex.chart) !== null && m !== void 0 && (O = m.sparkline) !== null && O !== void 0 && O.enabled) && (x = r.sparkline(x)), o = E.extend(a, x);
    }
    var b = E.extend(o, window.Apex);
    return a = E.extend(b, i), a = this.handleUserInputErrors(a);
  } }, { key: "checkForCatToNumericXAxis", value: function(e, t, i) {
    var n, r, a = new Ca(i), o = (e === "bar" || e === "boxPlot") && ((n = i.plotOptions) === null || n === void 0 || (r = n.bar) === null || r === void 0 ? void 0 : r.horizontal), l = e === "pie" || e === "polarArea" || e === "donut" || e === "radar" || e === "radialBar" || e === "heatmap", c = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric", h = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement;
    return o || l || !c || h === "between" || (i = a.convertCatToNumeric(i)), i;
  } }, { key: "extendYAxis", value: function(e, t) {
    var i = new sn();
    (e.yaxis === void 0 || !e.yaxis || Array.isArray(e.yaxis) && e.yaxis.length === 0) && (e.yaxis = {}), e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = E.extend(e.yaxis, window.Apex.yaxis)), e.yaxis.constructor !== Array ? e.yaxis = [E.extend(i.yAxis, e.yaxis)] : e.yaxis = E.extendArray(e.yaxis, i.yAxis);
    var n = !1;
    e.yaxis.forEach(function(a) {
      a.logarithmic && (n = !0);
    });
    var r = e.series;
    return t && !r && (r = t.config.series), n && r.length !== e.yaxis.length && r.length && (e.yaxis = r.map(function(a, o) {
      if (a.name || (r[o].name = "series-".concat(o + 1)), e.yaxis[o]) return e.yaxis[o].seriesName = r[o].name, e.yaxis[o];
      var l = E.extend(i.yAxis, e.yaxis[0]);
      return l.show = !1, l;
    })), n && r.length > 1 && r.length !== e.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), e;
  } }, { key: "extendAnnotations", value: function(e) {
    return e.annotations === void 0 && (e.annotations = {}, e.annotations.yaxis = [], e.annotations.xaxis = [], e.annotations.points = []), e = this.extendYAxisAnnotations(e), e = this.extendXAxisAnnotations(e), e = this.extendPointAnnotations(e);
  } }, { key: "extendYAxisAnnotations", value: function(e) {
    var t = new sn();
    return e.annotations.yaxis = E.extendArray(e.annotations.yaxis !== void 0 ? e.annotations.yaxis : [], t.yAxisAnnotation), e;
  } }, { key: "extendXAxisAnnotations", value: function(e) {
    var t = new sn();
    return e.annotations.xaxis = E.extendArray(e.annotations.xaxis !== void 0 ? e.annotations.xaxis : [], t.xAxisAnnotation), e;
  } }, { key: "extendPointAnnotations", value: function(e) {
    var t = new sn();
    return e.annotations.points = E.extendArray(e.annotations.points !== void 0 ? e.annotations.points : [], t.pointAnnotation), e;
  } }, { key: "checkForDarkTheme", value: function(e) {
    e.theme && e.theme.mode === "dark" && (e.tooltip || (e.tooltip = {}), e.tooltip.theme !== "light" && (e.tooltip.theme = "dark"), e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"), e.theme.palette || (e.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(e) {
    var t = e;
    if (t.tooltip.shared && t.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if (t.chart.type === "bar" && t.plotOptions.bar.horizontal) {
      if (t.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      t.yaxis[0].reversed && (t.yaxis[0].opposite = !0), t.xaxis.tooltip.enabled = !1, t.yaxis[0].tooltip.enabled = !1, t.chart.zoom.enabled = !1;
    }
    return t.chart.type !== "bar" && t.chart.type !== "rangeBar" || t.tooltip.shared && t.xaxis.crosshairs.width === "barWidth" && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"), t.chart.type !== "candlestick" && t.chart.type !== "boxPlot" || t.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(t.chart.type, " chart is not supported.")), t.yaxis[0].reversed = !1), t;
  } }]), s;
}(), Fy = function() {
  function s() {
    ee(this, s);
  }
  return te(s, [{ key: "initGlobalVars", value: function(e) {
    e.series = [], e.seriesCandleO = [], e.seriesCandleH = [], e.seriesCandleM = [], e.seriesCandleL = [], e.seriesCandleC = [], e.seriesRangeStart = [], e.seriesRangeEnd = [], e.seriesRange = [], e.seriesPercent = [], e.seriesGoals = [], e.seriesX = [], e.seriesZ = [], e.seriesNames = [], e.seriesTotals = [], e.seriesLog = [], e.seriesColors = [], e.stackedSeriesTotals = [], e.seriesXvalues = [], e.seriesYvalues = [], e.labels = [], e.hasXaxisGroups = !1, e.groups = [], e.barGroups = [], e.lineGroups = [], e.areaGroups = [], e.hasSeriesGroups = !1, e.seriesGroups = [], e.categoryLabels = [], e.timescaleLabels = [], e.noLabelsProvided = !1, e.resizeTimer = null, e.selectionResizeTimer = null, e.lastWheelExecution = 0, e.delayedElements = [], e.pointsArray = [], e.dataLabelsRects = [], e.isXNumeric = !1, e.skipLastTimelinelabel = !1, e.skipFirstTimelinelabel = !1, e.isDataXYZ = !1, e.isMultiLineX = !1, e.isMultipleYAxis = !1, e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE, e.minYArr = [], e.maxYArr = [], e.maxX = -Number.MAX_VALUE, e.minX = Number.MAX_VALUE, e.initialMaxX = -Number.MAX_VALUE, e.initialMinX = Number.MAX_VALUE, e.maxDate = 0, e.minDate = Number.MAX_VALUE, e.minZ = Number.MAX_VALUE, e.maxZ = -Number.MAX_VALUE, e.minXDiff = Number.MAX_VALUE, e.yAxisScale = [], e.xAxisScale = null, e.xAxisTicksPositions = [], e.yLabelsCoords = [], e.yTitleCoords = [], e.barPadForNumericAxis = 0, e.padHorizontal = 0, e.xRange = 0, e.yRange = [], e.zRange = 0, e.dataPoints = 0, e.xTickAmount = 0, e.multiAxisTickAmount = 0;
  } }, { key: "globalVars", value: function(e) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: e.markers.size, largestSize: 0 }, animationEnded: !1, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: !1, isExecCalled: !1, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: !1, allSeriesCollapsed: !1, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: !1, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: !1, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: e.chart.toolbar.autoSelected === "zoom" && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled, panEnabled: e.chart.toolbar.autoSelected === "pan" && e.chart.toolbar.tools.pan, selectionEnabled: e.chart.toolbar.autoSelected === "selection" && e.chart.toolbar.tools.selection, yaxis: null, mousedown: !1, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: !1, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: !0, skipLastTimelinelabel: !1, skipFirstTimelinelabel: !1, delayedElements: [], axisCharts: !0, isDataXYZ: !1, isSlopeChart: e.plotOptions.line.isSlopeChart, resized: !1, resizeTimer: null, comboCharts: !1, dataChanged: !1, previousPaths: [], allSeriesHasEqualX: !0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: !1, zoomed: !1, gridWidth: 0, gridHeight: 0, rotateXLabels: !1, defaultLabels: !1, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: "init", value: function(e) {
    var t = this.globalVars(e);
    return this.initGlobalVars(t), t.initialConfig = E.extend({}, e), t.initialSeries = E.clone(e.series), t.lastXAxis = E.clone(t.initialConfig.xaxis), t.lastYAxis = E.clone(t.initialConfig.yaxis), t;
  } }]), s;
}(), HT = function() {
  function s(e) {
    ee(this, s), this.opts = e;
  }
  return te(s, [{ key: "init", value: function() {
    var e = new Aa(this.opts).init({ responsiveOverride: !1 });
    return { config: e, globals: new Fy().init(e) };
  } }]), s;
}(), Ci = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return te(s, [{ key: "clippedImgArea", value: function(e) {
    var t = this.w, i = t.config, n = parseInt(t.globals.gridWidth, 10), r = parseInt(t.globals.gridHeight, 10), a = n > r ? n : r, o = e.image, l = 0, c = 0;
    e.width === void 0 && e.height === void 0 ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (l = i.fill.image.width + 1, c = i.fill.image.height) : (l = a + 1, c = a) : (l = e.width, c = e.height);
    var h = document.createElementNS(t.globals.SVGNS, "pattern");
    Z.setAttrs(h, { id: e.patternID, patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse", width: l + "px", height: c + "px" });
    var u = document.createElementNS(t.globals.SVGNS, "image");
    h.appendChild(u), u.setAttributeNS(window.SVG.xlink, "href", o), Z.setAttrs(u, { x: 0, y: 0, preserveAspectRatio: "none", width: l + "px", height: c + "px" }), u.style.opacity = e.opacity, t.globals.dom.elDefs.node.appendChild(h);
  } }, { key: "getSeriesIndex", value: function(e) {
    var t = this.w, i = t.config.chart.type;
    return (i === "bar" || i === "rangeBar") && t.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = e.seriesNumber : this.seriesIndex = e.seriesNumber % t.globals.series.length, this.seriesIndex;
  } }, { key: "computeColorStops", value: function(e, t) {
    var i, n = this.w, r = null, a = null, o = ia(e);
    try {
      for (o.s(); !(i = o.n()).done; ) {
        var l = i.value;
        l >= t.threshold ? (r === null || l > r) && (r = l) : (a === null || l < a) && (a = l);
      }
    } catch (u) {
      o.e(u);
    } finally {
      o.f();
    }
    r === null && (r = t.threshold), a === null && (a = t.threshold);
    var c = r - t.threshold + (t.threshold - a);
    c === 0 && (c = 1);
    var h = 100 - (t.threshold - a) / c * 100;
    return [{ offset: h = Math.max(0, Math.min(h, 100)), color: t.colorAboveThreshold, opacity: n.config.fill.opacity }, { offset: 0, color: t.colorBelowThreshold, opacity: n.config.fill.opacity }];
  } }, { key: "fillPath", value: function(e) {
    var t, i, n, r = this.w;
    this.opts = e;
    var a, o, l, c = this.w.config;
    this.seriesIndex = this.getSeriesIndex(e);
    var h = c.plotOptions.line.colors.colorAboveThreshold && c.plotOptions.line.colors.colorBelowThreshold, u = this.getFillColors()[this.seriesIndex];
    r.globals.seriesColors[this.seriesIndex] !== void 0 && (u = r.globals.seriesColors[this.seriesIndex]), typeof u == "function" && (u = u({ seriesIndex: this.seriesIndex, dataPointIndex: e.dataPointIndex, value: e.value, w: r }));
    var d, f, p, g = e.fillType ? e.fillType : this.getFillType(this.seriesIndex), m = Array.isArray(c.fill.opacity) ? c.fill.opacity[this.seriesIndex] : c.fill.opacity, O = g === "gradient" || h;
    e.color && (u = e.color), (t = r.config.series[this.seriesIndex]) !== null && t !== void 0 && (i = t.data) !== null && i !== void 0 && (n = i[e.dataPointIndex]) !== null && n !== void 0 && n.fillColor && (u = (d = r.config.series[this.seriesIndex]) === null || d === void 0 || (f = d.data) === null || f === void 0 || (p = f[e.dataPointIndex]) === null || p === void 0 ? void 0 : p.fillColor), u || (u = "#fff", console.warn("undefined color - ApexCharts"));
    var x = u;
    if (u.indexOf("rgb") === -1 ? u.indexOf("#") === -1 ? x = u : u.length < 9 && (x = E.hexToRgba(u, m)) : u.indexOf("rgba") > -1 ? m = E.getOpacityFromRGBA(u) : x = E.hexToRgba(E.rgb2hex(u), m), e.opacity && (m = e.opacity), g === "pattern" && (o = this.handlePatternFill({ fillConfig: e.fillConfig, patternFill: o, fillColor: u, fillOpacity: m, defaultColor: x })), O) {
      var b = dt(c.fill.gradient.colorStops) || [], v = c.fill.gradient.type;
      h && (b[this.seriesIndex] = this.computeColorStops(r.globals.series[this.seriesIndex], c.plotOptions.line.colors), v = "vertical"), l = this.handleGradientFill({ type: v, fillConfig: e.fillConfig, fillColor: u, fillOpacity: m, colorStops: b, i: this.seriesIndex });
    }
    if (g === "image") {
      var y = c.fill.image.src, w = e.patternID ? e.patternID : "", S = "pattern".concat(r.globals.cuid).concat(e.seriesNumber + 1).concat(w);
      this.patternIDs.indexOf(S) === -1 && (this.clippedImgArea({ opacity: m, image: Array.isArray(y) ? e.seriesNumber < y.length ? y[e.seriesNumber] : y[0] : y, width: e.width ? e.width : void 0, height: e.height ? e.height : void 0, patternUnits: e.patternUnits, patternID: S }), this.patternIDs.push(S)), a = "url(#".concat(S, ")");
    } else a = O ? l : g === "pattern" ? o : x;
    return e.solid && (a = x), a;
  } }, { key: "getFillType", value: function(e) {
    var t = this.w;
    return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var e = this.w, t = e.config, i = this.opts, n = [];
    return e.globals.comboCharts ? e.config.series[this.seriesIndex].type === "line" ? Array.isArray(e.globals.stroke.colors) ? n = e.globals.stroke.colors : n.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? n = e.globals.fill.colors : n.push(e.globals.fill.colors) : t.chart.type === "line" ? Array.isArray(e.globals.stroke.colors) ? n = e.globals.stroke.colors : n.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? n = e.globals.fill.colors : n.push(e.globals.fill.colors), i.fillColors !== void 0 && (n = [], Array.isArray(i.fillColors) ? n = i.fillColors.slice() : n.push(i.fillColors)), n;
  } }, { key: "handlePatternFill", value: function(e) {
    var t = e.fillConfig, i = e.patternFill, n = e.fillColor, r = e.fillOpacity, a = e.defaultColor, o = this.w.config.fill;
    t && (o = t);
    var l = this.opts, c = new Z(this.ctx), h = Array.isArray(o.pattern.strokeWidth) ? o.pattern.strokeWidth[this.seriesIndex] : o.pattern.strokeWidth, u = n;
    return Array.isArray(o.pattern.style) ? i = o.pattern.style[l.seriesNumber] !== void 0 ? c.drawPattern(o.pattern.style[l.seriesNumber], o.pattern.width, o.pattern.height, u, h, r) : a : i = c.drawPattern(o.pattern.style, o.pattern.width, o.pattern.height, u, h, r), i;
  } }, { key: "handleGradientFill", value: function(e) {
    var t = e.type, i = e.fillColor, n = e.fillOpacity, r = e.fillConfig, a = e.colorStops, o = e.i, l = this.w.config.fill;
    r && (l = F(F({}, l), r));
    var c = this.opts, h = new Z(this.ctx), u = new E();
    t = t || l.gradient.type;
    var d, f = i, p = l.gradient.opacityFrom === void 0 ? n : Array.isArray(l.gradient.opacityFrom) ? l.gradient.opacityFrom[o] : l.gradient.opacityFrom;
    f.indexOf("rgba") > -1 && (p = E.getOpacityFromRGBA(f));
    var g = l.gradient.opacityTo === void 0 ? n : Array.isArray(l.gradient.opacityTo) ? l.gradient.opacityTo[o] : l.gradient.opacityTo;
    if (l.gradient.gradientToColors === void 0 || l.gradient.gradientToColors.length === 0) d = l.gradient.shade === "dark" ? u.shadeColor(-1 * parseFloat(l.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? E.rgb2hex(i) : i) : u.shadeColor(parseFloat(l.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? E.rgb2hex(i) : i);
    else if (l.gradient.gradientToColors[c.seriesNumber]) {
      var m = l.gradient.gradientToColors[c.seriesNumber];
      d = m, m.indexOf("rgba") > -1 && (g = E.getOpacityFromRGBA(m));
    } else d = i;
    if (l.gradient.gradientFrom && (f = l.gradient.gradientFrom), l.gradient.gradientTo && (d = l.gradient.gradientTo), l.gradient.inverseColors) {
      var O = f;
      f = d, d = O;
    }
    return f.indexOf("rgb") > -1 && (f = E.rgb2hex(f)), d.indexOf("rgb") > -1 && (d = E.rgb2hex(d)), h.drawGradient(t, f, d, p, g, c.size, l.gradient.stops, a, o);
  } }]), s;
}(), Rr = function() {
  function s(e, t) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "setGlobalMarkerSize", value: function() {
    var e = this.w;
    if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size], e.globals.markers.size.length > 0) {
      if (e.globals.markers.size.length < e.globals.series.length + 1) for (var t = 0; t <= e.globals.series.length; t++) e.globals.markers.size[t] === void 0 && e.globals.markers.size.push(e.globals.markers.size[0]);
    } else e.globals.markers.size = e.config.series.map(function(i) {
      return e.config.markers.size;
    });
  } }, { key: "plotChartMarkers", value: function(e) {
    var t = e.pointsPos, i = e.seriesIndex, n = e.j, r = e.pSize, a = e.alwaysDrawMarker, o = a !== void 0 && a, l = e.isVirtualPoint, c = l !== void 0 && l, h = this.w, u = i, d = t, f = null, p = new Z(this.ctx), g = h.config.markers.discrete && h.config.markers.discrete.length;
    if (Array.isArray(d.x)) for (var m = 0; m < d.x.length; m++) {
      var O = void 0, x = n, b = !E.isNumber(d.y[m]);
      h.globals.markers.largestSize === 0 && h.globals.hasNullValues && h.globals.series[u][n + 1] !== null && !c && (b = !0), n === 1 && m === 0 && (x = 0), n === 1 && m === 1 && (x = 1);
      var v = "apexcharts-marker";
      if (h.config.chart.type !== "line" && h.config.chart.type !== "area" || h.globals.comboCharts || h.config.tooltip.intersect || (v += " no-pointer-events"), (Array.isArray(h.config.markers.size) ? h.globals.markers.size[i] > 0 : h.config.markers.size > 0) || o || g) {
        b || (v += " w".concat(E.randomId()));
        var y = this.getMarkerConfig({ cssClass: v, seriesIndex: i, dataPointIndex: x });
        h.config.series[u].data[x] && (h.config.series[u].data[x].fillColor && (y.pointFillColor = h.config.series[u].data[x].fillColor), h.config.series[u].data[x].strokeColor && (y.pointStrokeColor = h.config.series[u].data[x].strokeColor)), r !== void 0 && (y.pSize = r), (d.x[m] < -h.globals.markers.largestSize || d.x[m] > h.globals.gridWidth + h.globals.markers.largestSize || d.y[m] < -h.globals.markers.largestSize || d.y[m] > h.globals.gridHeight + h.globals.markers.largestSize) && (y.pSize = 0), !b && ((h.globals.markers.size[i] > 0 || o || g) && !f && (f = p.group({ class: o || g ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h.globals.cuid, ")")), (O = p.drawMarker(d.x[m], d.y[m], y)).attr("rel", x), O.attr("j", x), O.attr("index", i), O.node.setAttribute("default-marker-size", y.pSize), new vt(this.ctx).setSelectionFilter(O, i, x), this.addEvents(O), f && f.add(O));
      } else h.globals.pointsArray[i] === void 0 && (h.globals.pointsArray[i] = []), h.globals.pointsArray[i].push([d.x[m], d.y[m]]);
    }
    return f;
  } }, { key: "getMarkerConfig", value: function(e) {
    var t = e.cssClass, i = e.seriesIndex, n = e.dataPointIndex, r = n === void 0 ? null : n, a = e.radius, o = a === void 0 ? null : a, l = e.size, c = l === void 0 ? null : l, h = e.strokeWidth, u = h === void 0 ? null : h, d = this.w, f = this.getMarkerStyle(i), p = c === null ? d.globals.markers.size[i] : c, g = d.config.markers;
    return r !== null && g.discrete.length && g.discrete.map(function(m) {
      m.seriesIndex === i && m.dataPointIndex === r && (f.pointStrokeColor = m.strokeColor, f.pointFillColor = m.fillColor, p = m.size, f.pointShape = m.shape);
    }), { pSize: o === null ? p : o, pRadius: o !== null ? o : g.radius, pointStrokeWidth: u !== null ? u : Array.isArray(g.strokeWidth) ? g.strokeWidth[i] : g.strokeWidth, pointStrokeColor: f.pointStrokeColor, pointFillColor: f.pointFillColor, shape: f.pointShape || (Array.isArray(g.shape) ? g.shape[i] : g.shape), class: t, pointStrokeOpacity: Array.isArray(g.strokeOpacity) ? g.strokeOpacity[i] : g.strokeOpacity, pointStrokeDashArray: Array.isArray(g.strokeDashArray) ? g.strokeDashArray[i] : g.strokeDashArray, pointFillOpacity: Array.isArray(g.fillOpacity) ? g.fillOpacity[i] : g.fillOpacity, seriesIndex: i };
  } }, { key: "addEvents", value: function(e) {
    var t = this.w, i = new Z(this.ctx);
    e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e)), e.node.addEventListener("click", t.config.markers.onClick), e.node.addEventListener("dblclick", t.config.markers.onDblClick), e.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e), { passive: !0 });
  } }, { key: "getMarkerStyle", value: function(e) {
    var t = this.w, i = t.globals.markers.colors, n = t.config.markers.strokeColor || t.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(n) ? n[e] : n, pointFillColor: Array.isArray(i) ? i[e] : i };
  } }]), s;
}(), jy = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return te(s, [{ key: "draw", value: function(e, t, i) {
    var n = this.w, r = new Z(this.ctx), a = i.realIndex, o = i.pointsPos, l = i.zRatio, c = i.elParent, h = r.group({ class: "apexcharts-series-markers apexcharts-series-".concat(n.config.chart.type) });
    if (h.attr("clip-path", "url(#gridRectMarkerMask".concat(n.globals.cuid, ")")), Array.isArray(o.x)) for (var u = 0; u < o.x.length; u++) {
      var d = t + 1, f = !0;
      t === 0 && u === 0 && (d = 0), t === 0 && u === 1 && (d = 1);
      var p = n.globals.markers.size[a];
      if (l !== 1 / 0) {
        var g = n.config.plotOptions.bubble;
        p = n.globals.seriesZ[a][d], g.zScaling && (p /= l), g.minBubbleRadius && p < g.minBubbleRadius && (p = g.minBubbleRadius), g.maxBubbleRadius && p > g.maxBubbleRadius && (p = g.maxBubbleRadius);
      }
      var m = o.x[u], O = o.y[u];
      if (p = p || 0, O !== null && n.globals.series[a][d] !== void 0 || (f = !1), f) {
        var x = this.drawPoint(m, O, p, a, d, t);
        h.add(x);
      }
      c.add(h);
    }
  } }, { key: "drawPoint", value: function(e, t, i, n, r, a) {
    var o = this.w, l = n, c = new Cr(this.ctx), h = new vt(this.ctx), u = new Ci(this.ctx), d = new Rr(this.ctx), f = new Z(this.ctx), p = d.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l, dataPointIndex: r, radius: o.config.chart.type === "bubble" || o.globals.comboCharts && o.config.series[n] && o.config.series[n].type === "bubble" ? i : null }), g = u.fillPath({ seriesNumber: n, dataPointIndex: r, color: p.pointFillColor, patternUnits: "objectBoundingBox", value: o.globals.series[n][a] }), m = f.drawMarker(e, t, p);
    if (o.config.series[l].data[r] && o.config.series[l].data[r].fillColor && (g = o.config.series[l].data[r].fillColor), m.attr({ fill: g }), o.config.chart.dropShadow.enabled) {
      var O = o.config.chart.dropShadow;
      h.dropShadow(m, O, n);
    }
    if (!this.initialAnim || o.globals.dataChanged || o.globals.resized) o.globals.animationEnded = !0;
    else {
      var x = o.config.chart.animations.speed;
      c.animateMarker(m, x, o.globals.easing, function() {
        window.setTimeout(function() {
          c.animationCompleted(m);
        }, 100);
      });
    }
    return m.attr({ rel: r, j: r, index: n, "default-marker-size": p.pSize }), h.setSelectionFilter(m, n, r), d.addEvents(m), m.node.classList.add("apexcharts-marker"), m;
  } }, { key: "centerTextInBubble", value: function(e) {
    var t = this.w;
    return { y: e += parseInt(t.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), s;
}(), cr = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "dataLabelsCorrection", value: function(e, t, i, n, r, a, o) {
    var l = this.w, c = !1, h = new Z(this.ctx).getTextRects(i, o), u = h.width, d = h.height;
    t < 0 && (t = 0), t > l.globals.gridHeight + d && (t = l.globals.gridHeight + d / 2), l.globals.dataLabelsRects[n] === void 0 && (l.globals.dataLabelsRects[n] = []), l.globals.dataLabelsRects[n].push({ x: e, y: t, width: u, height: d });
    var f = l.globals.dataLabelsRects[n].length - 2, p = l.globals.lastDrawnDataLabelsIndexes[n] !== void 0 ? l.globals.lastDrawnDataLabelsIndexes[n][l.globals.lastDrawnDataLabelsIndexes[n].length - 1] : 0;
    if (l.globals.dataLabelsRects[n][f] !== void 0) {
      var g = l.globals.dataLabelsRects[n][p];
      (e > g.x + g.width || t > g.y + g.height || t + d < g.y || e + u < g.x) && (c = !0);
    }
    return (r === 0 || a) && (c = !0), { x: e, y: t, textRects: h, drawnextLabel: c };
  } }, { key: "drawDataLabel", value: function(e) {
    var t = this, i = e.type, n = e.pos, r = e.i, a = e.j, o = e.isRangeStart, l = e.strokeWidth, c = l === void 0 ? 2 : l, h = this.w, u = new Z(this.ctx), d = h.config.dataLabels, f = 0, p = 0, g = a, m = null;
    if (h.globals.collapsedSeriesIndices.indexOf(r) !== -1 || !d.enabled || !Array.isArray(n.x)) return m;
    m = u.group({ class: "apexcharts-data-labels" });
    for (var O = 0; O < n.x.length; O++) if (f = n.x[O] + d.offsetX, p = n.y[O] + d.offsetY + c, !isNaN(f)) {
      a === 1 && O === 0 && (g = 0), a === 1 && O === 1 && (g = 1);
      var x = h.globals.series[r][g];
      i === "rangeArea" && (x = o ? h.globals.seriesRangeStart[r][g] : h.globals.seriesRangeEnd[r][g]);
      var b = "", v = function(w) {
        return h.config.dataLabels.formatter(w, { ctx: t.ctx, seriesIndex: r, dataPointIndex: g, w: h });
      };
      h.config.chart.type === "bubble" ? (b = v(x = h.globals.seriesZ[r][g]), p = n.y[O], p = new jy(this.ctx).centerTextInBubble(p, r, g).y) : x !== void 0 && (b = v(x));
      var y = h.config.dataLabels.textAnchor;
      h.globals.isSlopeChart && (y = g === 0 ? "end" : g === h.config.series[r].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: f, y: p, text: b, i: r, j: g, parent: m, offsetCorrection: !0, dataLabelsConfig: h.config.dataLabels, textAnchor: y });
    }
    return m;
  } }, { key: "plotDataLabelsText", value: function(e) {
    var t = this.w, i = new Z(this.ctx), n = e.x, r = e.y, a = e.i, o = e.j, l = e.text, c = e.textAnchor, h = e.fontSize, u = e.parent, d = e.dataLabelsConfig, f = e.color, p = e.alwaysDrawDataLabel, g = e.offsetCorrection, m = e.className, O = null;
    if (Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(a) < 0) return O;
    var x = { x: n, y: r, drawnextLabel: !0, textRects: null };
    g && (x = this.dataLabelsCorrection(n, r, l, a, o, p, parseInt(d.style.fontSize, 10))), t.globals.zoomed || (n = x.x, r = x.y), x.textRects && (n < -20 - x.textRects.width || n > t.globals.gridWidth + x.textRects.width + 30) && (l = "");
    var b = t.globals.dataLabels.style.colors[a];
    ((t.config.chart.type === "bar" || t.config.chart.type === "rangeBar") && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (b = t.globals.dataLabels.style.colors[o]), typeof b == "function" && (b = b({ series: t.globals.series, seriesIndex: a, dataPointIndex: o, w: t })), f && (b = f);
    var v = d.offsetX, y = d.offsetY;
    if (t.config.chart.type !== "bar" && t.config.chart.type !== "rangeBar" || (v = 0, y = 0), t.globals.isSlopeChart && (o !== 0 && (v = -2 * d.offsetX + 5), o !== 0 && o !== t.config.series[a].data.length - 1 && (v = 0)), x.drawnextLabel) {
      if ((O = i.drawText({ width: 100, height: parseInt(d.style.fontSize, 10), x: n + v, y: r + y, foreColor: b, textAnchor: c || d.textAnchor, text: l, fontSize: h || d.style.fontSize, fontFamily: d.style.fontFamily, fontWeight: d.style.fontWeight || "normal" })).attr({ class: m || "apexcharts-datalabel", cx: n, cy: r }), d.dropShadow.enabled) {
        var w = d.dropShadow;
        new vt(this.ctx).dropShadow(O, w);
      }
      u.add(O), t.globals.lastDrawnDataLabelsIndexes[a] === void 0 && (t.globals.lastDrawnDataLabelsIndexes[a] = []), t.globals.lastDrawnDataLabelsIndexes[a].push(o);
    }
    return O;
  } }, { key: "addBackgroundToDataLabel", value: function(e, t) {
    var i = this.w, n = i.config.dataLabels.background, r = n.padding, a = n.padding / 2, o = t.width, l = t.height, c = new Z(this.ctx).drawRect(t.x - r, t.y - a / 2, o + 2 * r, l + a, n.borderRadius, i.config.chart.background !== "transparent" && i.config.chart.background ? i.config.chart.background : "#fff", n.opacity, n.borderWidth, n.borderColor);
    return n.dropShadow.enabled && new vt(this.ctx).dropShadow(c, n.dropShadow), c;
  } }, { key: "dataLabelsBackground", value: function() {
    var e = this.w;
    if (e.config.chart.type !== "bubble") for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t.length; i++) {
      var n = t[i], r = n.getBBox(), a = null;
      if (r.width && r.height && (a = this.addBackgroundToDataLabel(n, r)), a) {
        n.parentNode.insertBefore(a.node, n);
        var o = e.config.dataLabels.background.backgroundColor || n.getAttribute("fill");
        e.config.chart.animations.enabled && !e.globals.resized && !e.globals.dataChanged ? a.animate().attr({ fill: o }) : a.attr({ fill: o }), n.setAttribute("fill", e.config.dataLabels.background.foreColor);
      }
    }
  } }, { key: "bringForward", value: function() {
    for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), n = 0; n < t.length; n++) i && i.insertBefore(t[n], i.nextSibling);
  } }]), s;
}(), pi = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  return te(s, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  } }, { key: "getSeriesByName", value: function(e) {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(E.escapeString(e), "']"));
  } }, { key: "isSeriesHidden", value: function(e) {
    var t = this.getSeriesByName(e), i = parseInt(t.getAttribute("data:realIndex"), 10);
    return { isHidden: t.classList.contains("apexcharts-series-collapsed"), realIndex: i };
  } }, { key: "addCollapsedClassToSeries", value: function(e, t) {
    var i = this.w;
    function n(r) {
      for (var a = 0; a < r.length; a++) r[a].index === t && e.node.classList.add("apexcharts-series-collapsed");
    }
    n(i.globals.collapsedSeries), n(i.globals.ancillaryCollapsedSeries);
  } }, { key: "toggleSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    return this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, t.isHidden), t.isHidden;
  } }, { key: "showSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !0);
  } }, { key: "hideSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !1);
  } }, { key: "resetSeries", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], n = this.w, r = E.clone(n.globals.initialSeries);
    n.globals.previousPaths = [], i ? (n.globals.collapsedSeries = [], n.globals.ancillaryCollapsedSeries = [], n.globals.collapsedSeriesIndices = [], n.globals.ancillaryCollapsedSeriesIndices = []) : r = this.emptyCollapsedSeries(r), n.config.series = r, e && (t && (n.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(r, n.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: "emptyCollapsedSeries", value: function(e) {
    for (var t = this.w, i = 0; i < e.length; i++) t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = []);
    return e;
  } }, { key: "highlightSeries", value: function(e) {
    var t = this.w, i = this.getSeriesByName(e), n = parseInt(i?.getAttribute("data:realIndex"), 10), r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), a = null, o = null, l = null;
    if (t.globals.axisCharts || t.config.chart.type === "radialBar") if (t.globals.axisCharts) {
      a = t.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(n, "']")), o = t.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(n, "']"));
      var c = t.globals.seriesYAxisReverseMap[n];
      l = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(c, "']"));
    } else a = t.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(n + 1, "']"));
    else a = t.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(n + 1, "'] path"));
    for (var h = 0; h < r.length; h++) r[h].classList.add(this.legendInactiveClass);
    if (a) t.globals.axisCharts || a.parentNode.classList.remove(this.legendInactiveClass), a.classList.remove(this.legendInactiveClass), o !== null && o.classList.remove(this.legendInactiveClass), l !== null && l.classList.remove(this.legendInactiveClass);
    else for (var u = 0; u < r.length; u++) r[u].classList.remove(this.legendInactiveClass);
  } }, { key: "toggleSeriesOnHover", value: function(e, t) {
    var i = this.w;
    t || (t = e.target);
    var n = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
    if (e.type === "mousemove") {
      var r = parseInt(t.getAttribute("rel"), 10) - 1;
      this.highlightSeries(i.globals.seriesNames[r]);
    } else if (e.type === "mouseout") for (var a = 0; a < n.length; a++) n[a].classList.remove(this.legendInactiveClass);
  } }, { key: "highlightRangeInSeries", value: function(e, t) {
    var i = this, n = this.w, r = n.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), a = function(c) {
      for (var h = 0; h < r.length; h++) r[h].classList[c](i.legendInactiveClass);
    };
    if (e.type === "mousemove") {
      var o = parseInt(t.getAttribute("rel"), 10) - 1;
      a("add");
      var l = n.config.plotOptions.heatmap.colorScale.ranges;
      (function(c, h) {
        for (var u = 0; u < r.length; u++) {
          var d = Number(r[u].getAttribute("val"));
          d >= c.from && (d < c.to || c.to === h && d === h) && r[u].classList.remove(i.legendInactiveClass);
        }
      })(l[o], l.reduce(function(c, h) {
        return Math.max(c, h.to);
      }, 0));
    } else e.type === "mouseout" && a("remove");
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = this.w, n = 0;
    if (i.config.series.length > 1) {
      for (var r = i.config.series.map(function(o, l) {
        return o.data && o.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(l) === -1 && (!i.globals.comboCharts || t.length === 0 || t.length && t.indexOf(i.config.series[l].type) > -1) ? l : -1;
      }), a = e === "asc" ? 0 : r.length - 1; e === "asc" ? a < r.length : a >= 0; e === "asc" ? a++ : a--) if (r[a] !== -1) {
        n = r[a];
        break;
      }
    }
    return n;
  } }, { key: "getBarSeriesIndices", value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map(function(e, t) {
      return e.type === "bar" || e.type === "column" ? t : -1;
    }).filter(function(e) {
      return e !== -1;
    }) : this.w.config.series.map(function(e, t) {
      return t;
    });
  } }, { key: "getPreviousPaths", value: function() {
    var e = this.w;
    function t(a, o, l) {
      for (var c = a[o].childNodes, h = { type: l, paths: [], realIndex: a[o].getAttribute("data:realIndex") }, u = 0; u < c.length; u++) if (c[u].hasAttribute("pathTo")) {
        var d = c[u].getAttribute("pathTo");
        h.paths.push({ d });
      }
      e.globals.previousPaths.push(h);
    }
    e.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(a) {
      for (var o, l = (o = a, e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(o, "-series .apexcharts-series"))), c = 0; c < l.length; c++) t(l, c, a);
    });
    var i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series"));
    if (i.length > 0) for (var n = function(a) {
      for (var o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(a, "'] rect")), l = [], c = function(u) {
        var d = function(p) {
          return o[u].getAttribute(p);
        }, f = { x: parseFloat(d("x")), y: parseFloat(d("y")), width: parseFloat(d("width")), height: parseFloat(d("height")) };
        l.push({ rect: f, color: o[u].getAttribute("color") });
      }, h = 0; h < o.length; h++) c(h);
      e.globals.previousPaths.push(l);
    }, r = 0; r < i.length; r++) n(r);
    e.globals.axisCharts || (e.globals.previousPaths = e.globals.series);
  } }, { key: "clearPreviousPaths", value: function() {
    var e = this.w;
    e.globals.previousPaths = [], e.globals.allSeriesCollapsed = !1;
  } }, { key: "handleNoData", value: function() {
    var e = this.w, t = e.config.noData, i = new Z(this.ctx), n = e.globals.svgWidth / 2, r = e.globals.svgHeight / 2, a = "middle";
    if (e.globals.noData = !0, e.globals.animationEnded = !0, t.align === "left" ? (n = 10, a = "start") : t.align === "right" && (n = e.globals.svgWidth - 10, a = "end"), t.verticalAlign === "top" ? r = 50 : t.verticalAlign === "bottom" && (r = e.globals.svgHeight - 50), n += t.offsetX, r = r + parseInt(t.style.fontSize, 10) + 2 + t.offsetY, t.text !== void 0 && t.text !== "") {
      var o = i.drawText({ x: n, y: r, text: t.text, textAnchor: a, fontSize: t.style.fontSize, fontFamily: t.style.fontFamily, foreColor: t.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      e.globals.dom.Paper.add(o);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(e) {
    for (var t = this.w, i = 0; i < e.length; i++) if (e[i].length === 0) for (var n = 0; n < e[t.globals.maxValsInArrayIndex].length; n++) e[i].push(0);
    return e;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var e = !0, t = this.w, i = this.filteredSeriesX(), n = 0; n < i.length - 1; n++) if (i[n][0] !== i[n + 1][0]) {
      e = !1;
      break;
    }
    return t.globals.allSeriesHasEqualX = e, e;
  } }, { key: "filteredSeriesX", value: function() {
    var e = this.w.globals.seriesX.map(function(t) {
      return t.length > 0 ? t : [];
    });
    return e;
  } }]), s;
}(), _p = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new st(this.ctx);
  }
  return te(s, [{ key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var e = this.w.config.series.slice(), t = new pi(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), e[this.activeSeriesIndex].data !== void 0 && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].x !== void 0 && e[this.activeSeriesIndex].data[0] !== null) return !0;
  } }, { key: "isFormat2DArray", value: function() {
    var e = this.w.config.series.slice(), t = new pi(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), e[this.activeSeriesIndex].data !== void 0 && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== void 0 && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].constructor === Array) return !0;
  } }, { key: "handleFormat2DArray", value: function(e, t) {
    for (var i = this.w.config, n = this.w.globals, r = i.chart.type === "boxPlot" || i.series[t].type === "boxPlot", a = 0; a < e[t].data.length; a++) if (e[t].data[a][1] !== void 0 && (Array.isArray(e[t].data[a][1]) && e[t].data[a][1].length === 4 && !r ? this.twoDSeries.push(E.parseNumber(e[t].data[a][1][3])) : e[t].data[a].length >= 5 ? this.twoDSeries.push(E.parseNumber(e[t].data[a][4])) : this.twoDSeries.push(E.parseNumber(e[t].data[a][1])), n.dataFormatXNumeric = !0), i.xaxis.type === "datetime") {
      var o = new Date(e[t].data[a][0]);
      o = new Date(o).getTime(), this.twoDSeriesX.push(o);
    } else this.twoDSeriesX.push(e[t].data[a][0]);
    for (var l = 0; l < e[t].data.length; l++) e[t].data[l][2] !== void 0 && (this.threeDSeries.push(e[t].data[l][2]), n.isDataXYZ = !0);
  } }, { key: "handleFormatXY", value: function(e, t) {
    var i = this.w.config, n = this.w.globals, r = new xt(this.ctx), a = t;
    n.collapsedSeriesIndices.indexOf(t) > -1 && (a = this.activeSeriesIndex);
    for (var o = 0; o < e[t].data.length; o++) e[t].data[o].y !== void 0 && (Array.isArray(e[t].data[o].y) ? this.twoDSeries.push(E.parseNumber(e[t].data[o].y[e[t].data[o].y.length - 1])) : this.twoDSeries.push(E.parseNumber(e[t].data[o].y))), e[t].data[o].goals !== void 0 && Array.isArray(e[t].data[o].goals) ? (this.seriesGoals[t] === void 0 && (this.seriesGoals[t] = []), this.seriesGoals[t].push(e[t].data[o].goals)) : (this.seriesGoals[t] === void 0 && (this.seriesGoals[t] = []), this.seriesGoals[t].push(null));
    for (var l = 0; l < e[a].data.length; l++) {
      var c = typeof e[a].data[l].x == "string", h = Array.isArray(e[a].data[l].x), u = !h && !!r.isValidDate(e[a].data[l].x);
      if (c || u) if (c || i.xaxis.convertedCatToNumeric) {
        var d = n.isBarHorizontal && n.isRangeData;
        i.xaxis.type !== "datetime" || d ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[a].data[l].x), isNaN(e[a].data[l].x) || this.w.config.xaxis.type === "category" || typeof e[a].data[l].x == "string" || (n.isXNumeric = !0)) : this.twoDSeriesX.push(r.parseDate(e[a].data[l].x));
      } else i.xaxis.type === "datetime" ? this.twoDSeriesX.push(r.parseDate(e[a].data[l].x.toString())) : (n.dataFormatXNumeric = !0, n.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(e[a].data[l].x)));
      else h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[a].data[l].x)) : (n.isXNumeric = !0, n.dataFormatXNumeric = !0, this.twoDSeriesX.push(e[a].data[l].x));
    }
    if (e[t].data[0] && e[t].data[0].z !== void 0) {
      for (var f = 0; f < e[t].data.length; f++) this.threeDSeries.push(e[t].data[f].z);
      n.isDataXYZ = !0;
    }
  } }, { key: "handleRangeData", value: function(e, t) {
    var i = this.w.globals, n = {};
    return this.isFormat2DArray() ? n = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (n = this.handleRangeDataFormat("xy", e, t)), i.seriesRangeStart[t] = n.start === void 0 ? [] : n.start, i.seriesRangeEnd[t] = n.end === void 0 ? [] : n.end, i.seriesRange[t] = n.rangeUniques, i.seriesRange.forEach(function(r, a) {
      r && r.forEach(function(o, l) {
        o.y.forEach(function(c, h) {
          for (var u = 0; u < o.y.length; u++) if (h !== u) {
            var d = c.y1, f = c.y2, p = o.y[u].y1;
            d <= o.y[u].y2 && p <= f && (o.overlaps.indexOf(c.rangeName) < 0 && o.overlaps.push(c.rangeName), o.overlaps.indexOf(o.y[u].rangeName) < 0 && o.overlaps.push(o.y[u].rangeName));
          }
        });
      });
    }), n;
  } }, { key: "handleCandleStickBoxData", value: function(e, t) {
    var i = this.w.globals, n = {};
    return this.isFormat2DArray() ? n = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (n = this.handleCandleStickBoxDataFormat("xy", e, t)), i.seriesCandleO[t] = n.o, i.seriesCandleH[t] = n.h, i.seriesCandleM[t] = n.m, i.seriesCandleL[t] = n.l, i.seriesCandleC[t] = n.c, n;
  } }, { key: "handleRangeDataFormat", value: function(e, t, i) {
    var n = [], r = [], a = t[i].data.filter(function(h, u, d) {
      return u === d.findIndex(function(f) {
        return f.x === h.x;
      });
    }).map(function(h, u) {
      return { x: h.x, overlaps: [], y: [] };
    });
    if (e === "array") for (var o = 0; o < t[i].data.length; o++) Array.isArray(t[i].data[o]) ? (n.push(t[i].data[o][1][0]), r.push(t[i].data[o][1][1])) : (n.push(t[i].data[o]), r.push(t[i].data[o]));
    else if (e === "xy") for (var l = function(h) {
      var u = Array.isArray(t[i].data[h].y), d = E.randomId(), f = t[i].data[h].x, p = { y1: u ? t[i].data[h].y[0] : t[i].data[h].y, y2: u ? t[i].data[h].y[1] : t[i].data[h].y, rangeName: d };
      t[i].data[h].rangeName = d;
      var g = a.findIndex(function(m) {
        return m.x === f;
      });
      a[g].y.push(p), n.push(p.y1), r.push(p.y2);
    }, c = 0; c < t[i].data.length; c++) l(c);
    return { start: n, end: r, rangeUniques: a };
  } }, { key: "handleCandleStickBoxDataFormat", value: function(e, t, i) {
    var n = this.w, r = n.config.chart.type === "boxPlot" || n.config.series[i].type === "boxPlot", a = [], o = [], l = [], c = [], h = [];
    if (e === "array") if (r && t[i].data[0].length === 6 || !r && t[i].data[0].length === 5) for (var u = 0; u < t[i].data.length; u++) a.push(t[i].data[u][1]), o.push(t[i].data[u][2]), r ? (l.push(t[i].data[u][3]), c.push(t[i].data[u][4]), h.push(t[i].data[u][5])) : (c.push(t[i].data[u][3]), h.push(t[i].data[u][4]));
    else for (var d = 0; d < t[i].data.length; d++) Array.isArray(t[i].data[d][1]) && (a.push(t[i].data[d][1][0]), o.push(t[i].data[d][1][1]), r ? (l.push(t[i].data[d][1][2]), c.push(t[i].data[d][1][3]), h.push(t[i].data[d][1][4])) : (c.push(t[i].data[d][1][2]), h.push(t[i].data[d][1][3])));
    else if (e === "xy") for (var f = 0; f < t[i].data.length; f++) Array.isArray(t[i].data[f].y) && (a.push(t[i].data[f].y[0]), o.push(t[i].data[f].y[1]), r ? (l.push(t[i].data[f].y[2]), c.push(t[i].data[f].y[3]), h.push(t[i].data[f].y[4])) : (c.push(t[i].data[f].y[2]), h.push(t[i].data[f].y[3])));
    return { o: a, h: o, m: l, l: c, c: h };
  } }, { key: "parseDataAxisCharts", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, n = this.w.config, r = this.w.globals, a = new xt(i), o = n.labels.length > 0 ? n.labels.slice() : n.xaxis.categories.slice();
    r.isRangeBar = n.chart.type === "rangeBar" && r.isBarHorizontal, r.hasXaxisGroups = n.xaxis.type === "category" && n.xaxis.group.groups.length > 0, r.hasXaxisGroups && (r.groups = n.xaxis.group.groups), e.forEach(function(f, p) {
      f.name !== void 0 ? r.seriesNames.push(f.name) : r.seriesNames.push("series-" + parseInt(p + 1, 10));
    }), this.coreUtils.setSeriesYAxisMappings();
    var l = [], c = dt(new Set(n.series.map(function(f) {
      return f.group;
    })));
    n.series.forEach(function(f, p) {
      var g = c.indexOf(f.group);
      l[g] || (l[g] = []), l[g].push(r.seriesNames[p]);
    }), r.seriesGroups = l;
    for (var h = function() {
      for (var f = 0; f < o.length; f++) if (typeof o[f] == "string") {
        if (!a.isValidDate(o[f])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
        t.twoDSeriesX.push(a.parseDate(o[f]));
      } else t.twoDSeriesX.push(o[f]);
    }, u = 0; u < e.length; u++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], e[u].data === void 0) return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if (n.chart.type !== "rangeBar" && n.chart.type !== "rangeArea" && e[u].type !== "rangeBar" && e[u].type !== "rangeArea" || (r.isRangeData = !0, this.handleRangeData(e, u)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(e, u) : this.isFormatXY() && this.handleFormatXY(e, u), n.chart.type !== "candlestick" && e[u].type !== "candlestick" && n.chart.type !== "boxPlot" && e[u].type !== "boxPlot" || this.handleCandleStickBoxData(e, u), r.series.push(this.twoDSeries), r.labels.push(this.twoDSeriesX), r.seriesX.push(this.twoDSeriesX), r.seriesGoals = this.seriesGoals, u !== this.activeSeriesIndex || this.fallbackToCategory || (r.isXNumeric = !0);
      else {
        n.xaxis.type === "datetime" ? (r.isXNumeric = !0, h(), r.seriesX.push(this.twoDSeriesX)) : n.xaxis.type === "numeric" && (r.isXNumeric = !0, o.length > 0 && (this.twoDSeriesX = o, r.seriesX.push(this.twoDSeriesX))), r.labels.push(this.twoDSeriesX);
        var d = e[u].data.map(function(f) {
          return E.parseNumber(f);
        });
        r.series.push(d);
      }
      r.seriesZ.push(this.threeDSeries), e[u].color !== void 0 ? r.seriesColors.push(e[u].color) : r.seriesColors.push(void 0);
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(e) {
    var t = this.w.globals, i = this.w.config;
    t.series = e.slice(), t.seriesNames = i.labels.slice();
    for (var n = 0; n < t.series.length; n++) t.seriesNames[n] === void 0 && t.seriesNames.push("series-" + (n + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(e) {
    var t = this.w.config, i = this.w.globals;
    t.xaxis.categories.length > 0 ? i.labels = t.xaxis.categories : t.labels.length > 0 ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(n) {
      n.forEach(function(r) {
        i.labels.indexOf(r.x) < 0 && r.x && i.labels.push(r.x);
      });
    }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), t.xaxis.convertedCatToNumeric && (new Ca(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]), this._generateExternalLabels(e))) : this._generateExternalLabels(e);
  } }, { key: "_generateExternalLabels", value: function(e) {
    var t = this.w.globals, i = this.w.config, n = [];
    if (t.axisCharts) {
      if (t.series.length > 0) if (this.isFormatXY()) for (var r = i.series.map(function(u, d) {
        return u.data.filter(function(f, p, g) {
          return g.findIndex(function(m) {
            return m.x === f.x;
          }) === p;
        });
      }), a = r.reduce(function(u, d, f, p) {
        return p[u].length > d.length ? u : f;
      }, 0), o = 0; o < r[a].length; o++) n.push(o + 1);
      else for (var l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) n.push(l + 1);
      t.seriesX = [];
      for (var c = 0; c < e.length; c++) t.seriesX.push(n);
      this.w.globals.isBarHorizontal || (t.isXNumeric = !0);
    }
    if (n.length === 0) {
      n = t.axisCharts ? [] : t.series.map(function(u, d) {
        return d + 1;
      });
      for (var h = 0; h < e.length; h++) t.seriesX.push(n);
    }
    t.labels = n, i.xaxis.convertedCatToNumeric && (t.categoryLabels = n.map(function(u) {
      return i.xaxis.labels.formatter(u);
    })), t.noLabelsProvided = !0;
  } }, { key: "parseData", value: function(e) {
    var t = this.w, i = t.config, n = t.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), n.axisCharts ? (this.parseDataAxisCharts(e), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e), i.chart.stacked) {
      var r = new pi(this.ctx);
      n.series = r.setNullSeriesToZeroValues(n.series);
    }
    this.coreUtils.getSeriesTotals(), n.axisCharts && (n.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), n.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), n.dataFormatXNumeric || n.isXNumeric && (i.xaxis.type !== "numeric" || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(e);
    for (var a = this.coreUtils.getCategoryLabels(n.labels), o = 0; o < a.length; o++) if (Array.isArray(a[o])) {
      n.isMultiLineX = !0;
      break;
    }
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var e = this.w, t = [];
    e.globals.seriesYAxisMap.forEach(function(i, n) {
      var r = 0;
      i.forEach(function(a) {
        e.globals.collapsedSeriesIndices.indexOf(a) !== -1 && r++;
      }), r > 0 && r == i.length && t.push(n);
    }), e.globals.ignoreYAxisIndexes = t.map(function(i) {
      return i;
    });
  } }]), s;
}(), ha = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "svgStringToNode", value: function(e) {
    return new DOMParser().parseFromString(e, "image/svg+xml").documentElement;
  } }, { key: "scaleSvgNode", value: function(e, t) {
    var i = parseFloat(e.getAttributeNS(null, "width")), n = parseFloat(e.getAttributeNS(null, "height"));
    e.setAttributeNS(null, "width", i * t), e.setAttributeNS(null, "height", n * t), e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + n);
  } }, { key: "getSvgString", value: function(e) {
    var t = this;
    return new Promise(function(i) {
      var n = t.w, r = e || n.config.chart.toolbar.export.scale || n.config.chart.toolbar.export.width / n.globals.svgWidth;
      r || (r = 1);
      var a = n.globals.svgWidth * r, o = n.globals.svgHeight * r, l = n.globals.dom.elWrap.cloneNode(!0);
      l.style.width = a + "px", l.style.height = o + "px";
      var c = new XMLSerializer().serializeToString(l), h = `
        <svg xmlns="http://www.w3.org/2000/svg"
          version="1.1"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          class="apexcharts-svg"
          xmlns:data="ApexChartsNS"
          transform="translate(0, 0)"
          width="`.concat(n.globals.svgWidth, 'px" height="').concat(n.globals.svgHeight, `px">
          <foreignObject width="100%" height="100%">
            <div xmlns="http://www.w3.org/1999/xhtml" style="width:`).concat(a, "px; height:").concat(o, `px;">
            <style type="text/css">
              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {
                display: none;
              }
            </style>
              `).concat(c, `
            </div>
          </foreignObject>
        </svg>
      `), u = t.svgStringToNode(h);
      r !== 1 && t.scaleSvgNode(u, r), t.convertImagesToBase64(u).then(function() {
        h = new XMLSerializer().serializeToString(u), i(h.replace(/&nbsp;/g, "&#160;"));
      });
    });
  } }, { key: "convertImagesToBase64", value: function(e) {
    var t = this, i = e.getElementsByTagName("image"), n = Array.from(i).map(function(r) {
      var a = r.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      return a && !a.startsWith("data:") ? t.getBase64FromUrl(a).then(function(o) {
        r.setAttributeNS("http://www.w3.org/1999/xlink", "href", o);
      }).catch(function(o) {
        console.error("Error converting image to base64:", o);
      }) : Promise.resolve();
    });
    return Promise.all(n);
  } }, { key: "getBase64FromUrl", value: function(e) {
    return new Promise(function(t, i) {
      var n = new Image();
      n.crossOrigin = "Anonymous", n.onload = function() {
        var r = document.createElement("canvas");
        r.width = n.width, r.height = n.height, r.getContext("2d").drawImage(n, 0, 0), t(r.toDataURL());
      }, n.onerror = i, n.src = e;
    });
  } }, { key: "svgUrl", value: function() {
    var e = this;
    return new Promise(function(t) {
      e.getSvgString().then(function(i) {
        var n = new Blob([i], { type: "image/svg+xml;charset=utf-8" });
        t(URL.createObjectURL(n));
      });
    });
  } }, { key: "dataURI", value: function(e) {
    var t = this;
    return new Promise(function(i) {
      var n = t.w, r = e ? e.scale || e.width / n.globals.svgWidth : 1, a = document.createElement("canvas");
      a.width = n.globals.svgWidth * r, a.height = parseInt(n.globals.dom.elWrap.style.height, 10) * r;
      var o = n.config.chart.background !== "transparent" && n.config.chart.background ? n.config.chart.background : "#fff", l = a.getContext("2d");
      l.fillStyle = o, l.fillRect(0, 0, a.width * r, a.height * r), t.getSvgString(r).then(function(c) {
        var h = "data:image/svg+xml," + encodeURIComponent(c), u = new Image();
        u.crossOrigin = "anonymous", u.onload = function() {
          if (l.drawImage(u, 0, 0), a.msToBlob) {
            var d = a.msToBlob();
            i({ blob: d });
          } else {
            var f = a.toDataURL("image/png");
            i({ imgURI: f });
          }
        }, u.src = h;
      });
    });
  } }, { key: "exportToSVG", value: function() {
    var e = this;
    this.svgUrl().then(function(t) {
      e.triggerDownload(t, e.w.config.chart.toolbar.export.svg.filename, ".svg");
    });
  } }, { key: "exportToPng", value: function() {
    var e = this, t = this.w.config.chart.toolbar.export.scale, i = this.w.config.chart.toolbar.export.width, n = t ? { scale: t } : i ? { width: i } : void 0;
    this.dataURI(n).then(function(r) {
      var a = r.imgURI, o = r.blob;
      o ? navigator.msSaveOrOpenBlob(o, e.w.globals.chartID + ".png") : e.triggerDownload(a, e.w.config.chart.toolbar.export.png.filename, ".png");
    });
  } }, { key: "exportToCSV", value: function(e) {
    var t = this, i = e.series, n = e.fileName, r = e.columnDelimiter, a = r === void 0 ? "," : r, o = e.lineDelimiter, l = o === void 0 ? `
` : o, c = this.w;
    i || (i = c.config.series);
    var h = [], u = [], d = "", f = c.globals.series.map(function(y, w) {
      return c.globals.collapsedSeriesIndices.indexOf(w) === -1 ? y : [];
    }), p = function(y) {
      return typeof c.config.chart.toolbar.export.csv.categoryFormatter == "function" ? c.config.chart.toolbar.export.csv.categoryFormatter(y) : c.config.xaxis.type === "datetime" && String(y).length >= 10 ? new Date(y).toDateString() : E.isNumber(y) ? y : y.split(a).join("");
    }, g = function(y) {
      return typeof c.config.chart.toolbar.export.csv.valueFormatter == "function" ? c.config.chart.toolbar.export.csv.valueFormatter(y) : y;
    }, m = Math.max.apply(Math, dt(i.map(function(y) {
      return y.data ? y.data.length : 0;
    }))), O = new _p(this.ctx), x = new Ws(this.ctx), b = function(y) {
      var w = "";
      if (c.globals.axisCharts) {
        if (c.config.xaxis.type === "category" || c.config.xaxis.convertedCatToNumeric) if (c.globals.isBarHorizontal) {
          var S = c.globals.yLabelFormatters[0], k = new pi(t.ctx).getActiveConfigSeriesIndex();
          w = S(c.globals.labels[y], { seriesIndex: k, dataPointIndex: y, w: c });
        } else w = x.getLabel(c.globals.labels, c.globals.timescaleLabels, 0, y).text;
        c.config.xaxis.type === "datetime" && (c.config.xaxis.categories.length ? w = c.config.xaxis.categories[y] : c.config.labels.length && (w = c.config.labels[y]));
      } else w = c.config.labels[y];
      return w === null ? "nullvalue" : (Array.isArray(w) && (w = w.join(" ")), E.isNumber(w) ? w : w.split(a).join(""));
    }, v = function(y, w) {
      if (h.length && w === 0 && u.push(h.join(a)), y.data) {
        y.data = y.data.length && y.data || dt(Array(m)).map(function() {
          return "";
        });
        for (var S = 0; S < y.data.length; S++) {
          h = [];
          var k = b(S);
          if (k !== "nullvalue") {
            if (k || (O.isFormatXY() ? k = i[w].data[S].x : O.isFormat2DArray() && (k = i[w].data[S] ? i[w].data[S][0] : "")), w === 0) {
              h.push(p(k));
              for (var A = 0; A < c.globals.series.length; A++) {
                var T, C = O.isFormatXY() ? (T = i[A].data[S]) === null || T === void 0 ? void 0 : T.y : f[A][S];
                h.push(g(C));
              }
            }
            (c.config.chart.type === "candlestick" || y.type && y.type === "candlestick") && (h.pop(), h.push(c.globals.seriesCandleO[w][S]), h.push(c.globals.seriesCandleH[w][S]), h.push(c.globals.seriesCandleL[w][S]), h.push(c.globals.seriesCandleC[w][S])), (c.config.chart.type === "boxPlot" || y.type && y.type === "boxPlot") && (h.pop(), h.push(c.globals.seriesCandleO[w][S]), h.push(c.globals.seriesCandleH[w][S]), h.push(c.globals.seriesCandleM[w][S]), h.push(c.globals.seriesCandleL[w][S]), h.push(c.globals.seriesCandleC[w][S])), c.config.chart.type === "rangeBar" && (h.pop(), h.push(c.globals.seriesRangeStart[w][S]), h.push(c.globals.seriesRangeEnd[w][S])), h.length && u.push(h.join(a));
          }
        }
      }
    };
    h.push(c.config.chart.toolbar.export.csv.headerCategory), c.config.chart.type === "boxPlot" ? (h.push("minimum"), h.push("q1"), h.push("median"), h.push("q3"), h.push("maximum")) : c.config.chart.type === "candlestick" ? (h.push("open"), h.push("high"), h.push("low"), h.push("close")) : c.config.chart.type === "rangeBar" ? (h.push("minimum"), h.push("maximum")) : i.map(function(y, w) {
      var S = (y.name ? y.name : "series-".concat(w)) + "";
      c.globals.axisCharts && h.push(S.split(a).join("") ? S.split(a).join("") : "series-".concat(w));
    }), c.globals.axisCharts || (h.push(c.config.chart.toolbar.export.csv.headerValue), u.push(h.join(a))), c.globals.allSeriesHasEqualX || !c.globals.axisCharts || c.config.xaxis.categories.length || c.config.labels.length ? i.map(function(y, w) {
      c.globals.axisCharts ? v(y, w) : ((h = []).push(p(c.globals.labels[w])), h.push(g(f[w])), u.push(h.join(a)));
    }) : function() {
      var y = /* @__PURE__ */ new Set(), w = {};
      i.forEach(function(S, k) {
        S?.data.forEach(function(A) {
          var T, C;
          if (O.isFormatXY()) T = A.x, C = A.y;
          else {
            if (!O.isFormat2DArray()) return;
            T = A[0], C = A[1];
          }
          w[T] || (w[T] = Array(i.length).fill("")), w[T][k] = g(C), y.add(T);
        });
      }), h.length && u.push(h.join(a)), Array.from(y).sort().forEach(function(S) {
        u.push([p(S), w[S].join(a)]);
      });
    }(), d += u.join(l), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + d), n || c.config.chart.toolbar.export.csv.filename, ".csv");
  } }, { key: "triggerDownload", value: function(e, t, i) {
    var n = document.createElement("a");
    n.href = e, n.download = (t || this.w.globals.chartID) + i, document.body.appendChild(n), n.click(), document.body.removeChild(n);
  } }]), s;
}(), Ta = function() {
  function s(e, t) {
    ee(this, s), this.ctx = e, this.elgrid = t, this.w = e.w;
    var i = this.w;
    this.axesUtils = new Ws(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
  }
  return te(s, [{ key: "drawXaxis", value: function() {
    var e = this.w, t = new Z(this.ctx), i = t.group({ class: "apexcharts-xaxis", transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")") }), n = t.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")") });
    i.add(n);
    for (var r = [], a = 0; a < this.xaxisLabels.length; a++) r.push(this.xaxisLabels[a]);
    if (this.drawXAxisLabelAndGroup(!0, t, n, r, e.globals.isXNumeric, function(p, g) {
      return g;
    }), e.globals.hasXaxisGroups) {
      var o = e.globals.groups;
      r = [];
      for (var l = 0; l < o.length; l++) r.push(o[l].title);
      var c = {};
      e.config.xaxis.group.style && (c.xaxisFontSize = e.config.xaxis.group.style.fontSize, c.xaxisFontFamily = e.config.xaxis.group.style.fontFamily, c.xaxisForeColors = e.config.xaxis.group.style.colors, c.fontWeight = e.config.xaxis.group.style.fontWeight, c.cssClass = e.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, t, n, r, !1, function(p, g) {
        return o[p].cols * g;
      }, c);
    }
    if (e.config.xaxis.title.text !== void 0) {
      var h = t.group({ class: "apexcharts-xaxis-title" }), u = t.drawText({ x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (e.config.xaxis.position === "bottom" ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY, text: e.config.xaxis.title.text, textAnchor: "middle", fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, fontWeight: e.config.xaxis.title.style.fontWeight, foreColor: e.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass });
      h.add(u), i.add(h);
    }
    if (e.config.xaxis.axisBorder.show) {
      var d = e.globals.barPadForNumericAxis, f = t.drawLine(e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - d, this.offY, this.xaxisBorderWidth + d, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(f) : i.add(f);
    }
    return i;
  } }, { key: "drawXAxisLabelAndGroup", value: function(e, t, i, n, r, a) {
    var o, l = this, c = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, h = [], u = [], d = this.w, f = c.xaxisFontSize || this.xaxisFontSize, p = c.xaxisFontFamily || this.xaxisFontFamily, g = c.xaxisForeColors || this.xaxisForeColors, m = c.fontWeight || d.config.xaxis.labels.style.fontWeight, O = c.cssClass || d.config.xaxis.labels.style.cssClass, x = d.globals.padHorizontal, b = n.length, v = d.config.xaxis.type === "category" ? d.globals.dataPoints : b;
    if (v === 0 && b > v && (v = b), r) {
      var y = Math.max(Number(d.config.xaxis.tickAmount) || 1, v > 1 ? v - 1 : v);
      o = d.globals.gridWidth / Math.min(y, b - 1), x = x + a(0, o) / 2 + d.config.xaxis.labels.offsetX;
    } else o = d.globals.gridWidth / v, x = x + a(0, o) + d.config.xaxis.labels.offsetX;
    for (var w = function(k) {
      var A = x - a(k, o) / 2 + d.config.xaxis.labels.offsetX;
      k === 0 && b === 1 && o / 2 === x && v === 1 && (A = d.globals.gridWidth / 2);
      var T = l.axesUtils.getLabel(n, d.globals.timescaleLabels, A, k, h, f, e), C = 28;
      if (d.globals.rotateXLabels && e && (C = 22), d.config.xaxis.title.text && d.config.xaxis.position === "top" && (C += parseFloat(d.config.xaxis.title.style.fontSize) + 2), e || (C = C + parseFloat(f) + (d.globals.xAxisLabelsHeight - d.globals.xAxisGroupLabelsHeight) + (d.globals.rotateXLabels ? 10 : 0)), T = d.config.xaxis.tickAmount !== void 0 && d.config.xaxis.tickAmount !== "dataPoints" && d.config.xaxis.type !== "datetime" ? l.axesUtils.checkLabelBasedOnTickamount(k, T, b) : l.axesUtils.checkForOverflowingLabels(k, T, b, h, u), d.config.xaxis.labels.show) {
        var P = t.drawText({ x: T.x, y: l.offY + d.config.xaxis.labels.offsetY + C - (d.config.xaxis.position === "top" ? d.globals.xAxisHeight + d.config.xaxis.axisTicks.height - 2 : 0), text: T.text, textAnchor: "middle", fontWeight: T.isBold ? 600 : m, fontSize: f, fontFamily: p, foreColor: Array.isArray(g) ? e && d.config.xaxis.convertedCatToNumeric ? g[d.globals.minX + k - 1] : g[k] : g, isPlainText: !1, cssClass: (e ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + O });
        if (i.add(P), P.on("click", function(R) {
          if (typeof d.config.chart.events.xAxisLabelClick == "function") {
            var X = Object.assign({}, d, { labelIndex: k });
            d.config.chart.events.xAxisLabelClick(R, l.ctx, X);
          }
        }), e) {
          var $ = document.createElementNS(d.globals.SVGNS, "title");
          $.textContent = Array.isArray(T.text) ? T.text.join(" ") : T.text, P.node.appendChild($), T.text !== "" && (h.push(T.text), u.push(T));
        }
      }
      k < b - 1 && (x += a(k + 1, o));
    }, S = 0; S <= b - 1; S++) w(S);
  } }, { key: "drawXaxisInversed", value: function(e) {
    var t, i, n = this, r = this.w, a = new Z(this.ctx), o = r.config.yaxis[0].opposite ? r.globals.translateYAxisX[e] : 0, l = a.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: e }), c = a.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o + ", 0)" });
    l.add(c);
    var h = [];
    if (r.config.yaxis[e].show) for (var u = 0; u < this.xaxisLabels.length; u++) h.push(this.xaxisLabels[u]);
    t = r.globals.gridHeight / h.length, i = -t / 2.2;
    var d = r.globals.yLabelFormatters[0], f = r.config.yaxis[0].labels;
    if (f.show) for (var p = function(y) {
      var w = h[y] === void 0 ? "" : h[y];
      w = d(w, { seriesIndex: e, dataPointIndex: y, w: r });
      var S = n.axesUtils.getYAxisForeColor(f.style.colors, e), k = 0;
      Array.isArray(w) && (k = w.length / 2 * parseInt(f.style.fontSize, 10));
      var A = f.offsetX - 15, T = "end";
      n.yaxis.opposite && (T = "start"), r.config.yaxis[0].labels.align === "left" ? (A = f.offsetX, T = "start") : r.config.yaxis[0].labels.align === "center" ? (A = f.offsetX, T = "middle") : r.config.yaxis[0].labels.align === "right" && (T = "end");
      var C = a.drawText({ x: A, y: i + t + f.offsetY - k, text: w, textAnchor: T, foreColor: Array.isArray(S) ? S[y] : S, fontSize: f.style.fontSize, fontFamily: f.style.fontFamily, fontWeight: f.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + f.style.cssClass, maxWidth: f.maxWidth });
      c.add(C), C.on("click", function(R) {
        if (typeof r.config.chart.events.xAxisLabelClick == "function") {
          var X = Object.assign({}, r, { labelIndex: y });
          r.config.chart.events.xAxisLabelClick(R, n.ctx, X);
        }
      });
      var P = document.createElementNS(r.globals.SVGNS, "title");
      if (P.textContent = Array.isArray(w) ? w.join(" ") : w, C.node.appendChild(P), r.config.yaxis[e].labels.rotate !== 0) {
        var $ = a.rotateAroundCenter(C.node);
        C.node.setAttribute("transform", "rotate(".concat(r.config.yaxis[e].labels.rotate, " 0 ").concat($.y, ")"));
      }
      i += t;
    }, g = 0; g <= h.length - 1; g++) p(g);
    if (r.config.yaxis[0].title.text !== void 0) {
      var m = a.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o + ", 0)" }), O = a.drawText({ x: r.config.yaxis[0].title.offsetX, y: r.globals.gridHeight / 2 + r.config.yaxis[0].title.offsetY, text: r.config.yaxis[0].title.text, textAnchor: "middle", foreColor: r.config.yaxis[0].title.style.color, fontSize: r.config.yaxis[0].title.style.fontSize, fontWeight: r.config.yaxis[0].title.style.fontWeight, fontFamily: r.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + r.config.yaxis[0].title.style.cssClass });
      m.add(O), l.add(m);
    }
    var x = 0;
    this.isCategoryBarHorizontal && r.config.yaxis[0].opposite && (x = r.globals.gridWidth);
    var b = r.config.xaxis.axisBorder;
    if (b.show) {
      var v = a.drawLine(r.globals.padHorizontal + b.offsetX + x, 1 + b.offsetY, r.globals.padHorizontal + b.offsetX + x, r.globals.gridHeight + b.offsetY, b.color, 0);
      this.elgrid && this.elgrid.elGridBorders && r.config.grid.show ? this.elgrid.elGridBorders.add(v) : l.add(v);
    }
    return r.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(x, h.length, r.config.yaxis[0].axisBorder, r.config.yaxis[0].axisTicks, 0, t, l), l;
  } }, { key: "drawXaxisTicks", value: function(e, t, i) {
    var n = this.w, r = e;
    if (!(e < 0 || e - 2 > n.globals.gridWidth)) {
      var a = this.offY + n.config.xaxis.axisTicks.offsetY;
      if (t = t + a + n.config.xaxis.axisTicks.height, n.config.xaxis.position === "top" && (t = a - n.config.xaxis.axisTicks.height), n.config.xaxis.axisTicks.show) {
        var o = new Z(this.ctx).drawLine(e + n.config.xaxis.axisTicks.offsetX, a + n.config.xaxis.offsetY, r + n.config.xaxis.axisTicks.offsetX, t + n.config.xaxis.offsetY, n.config.xaxis.axisTicks.color);
        i.add(o), o.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var e = this.w, t = [], i = this.xaxisLabels.length, n = e.globals.padHorizontal;
    if (e.globals.timescaleLabels.length > 0) for (var r = 0; r < i; r++) n = this.xaxisLabels[r].position, t.push(n);
    else for (var a = i, o = 0; o < a; o++) {
      var l = a;
      e.globals.isXNumeric && e.config.chart.type !== "bar" && (l -= 1), n += e.globals.gridWidth / l, t.push(n);
    }
    return t;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var e = this.w, t = new Z(this.ctx), i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
    if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways) for (var o = 0; o < n.length; o++) {
      var l = t.rotateAroundCenter(n[o]);
      l.y = l.y - 1, l.x = l.x + 1, n[o].setAttribute("transform", "rotate(".concat(e.config.xaxis.labels.rotate, " ").concat(l.x, " ").concat(l.y, ")")), n[o].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
      var c = n[o].childNodes;
      e.config.xaxis.labels.trim && Array.prototype.forEach.call(c, function(f) {
        t.placeTextWithEllipsis(f, f.textContent, e.globals.xAxisLabelsHeight - (e.config.legend.position === "bottom" ? 20 : 10));
      });
    }
    else (function() {
      for (var f = e.globals.gridWidth / (e.globals.labels.length + 1), p = 0; p < n.length; p++) {
        var g = n[p].childNodes;
        e.config.xaxis.labels.trim && e.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(g, function(m) {
          t.placeTextWithEllipsis(m, m.textContent, f);
        });
      }
    })();
    if (r.length > 0) {
      var h = r[r.length - 1].getBBox(), u = r[0].getBBox();
      h.x < -20 && r[r.length - 1].parentNode.removeChild(r[r.length - 1]), u.x + u.width > e.globals.gridWidth && !e.globals.isBarHorizontal && r[0].parentNode.removeChild(r[0]);
      for (var d = 0; d < a.length; d++) t.placeTextWithEllipsis(a[d], a[d].textContent, e.config.yaxis[0].labels.maxWidth - (e.config.yaxis[0].title.text ? 2 * parseFloat(e.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), s;
}(), Hy = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.xaxisLabels = t.globals.labels.slice(), this.axesUtils = new Ws(e), this.isRangeBar = t.globals.seriesRange.length && t.globals.isBarHorizontal, t.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t.globals.timescaleLabels.slice());
  }
  return te(s, [{ key: "drawGridArea", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = this.w, i = new Z(this.ctx);
    e || (e = i.group({ class: "apexcharts-grid" }));
    var n = i.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent"), r = i.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
    return e.add(r), e.add(n), e;
  } }, { key: "drawGrid", value: function() {
    if (this.w.globals.axisCharts) {
      var e = this.renderGrid();
      return this.drawGridArea(e.el), e;
    }
    return null;
  } }, { key: "createGridMask", value: function() {
    var e = this.w, t = e.globals, i = new Z(this.ctx), n = Array.isArray(e.config.stroke.width) ? Math.max.apply(Math, dt(e.config.stroke.width)) : e.config.stroke.width, r = function(h) {
      var u = document.createElementNS(t.SVGNS, "clipPath");
      return u.setAttribute("id", h), u;
    };
    t.dom.elGridRectMask = r("gridRectMask".concat(t.cuid)), t.dom.elGridRectBarMask = r("gridRectBarMask".concat(t.cuid)), t.dom.elGridRectMarkerMask = r("gridRectMarkerMask".concat(t.cuid)), t.dom.elForecastMask = r("forecastMask".concat(t.cuid)), t.dom.elNonForecastMask = r("nonForecastMask".concat(t.cuid));
    var a = 0, o = 0;
    (["bar", "rangeBar", "candlestick", "boxPlot"].includes(e.config.chart.type) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (a = Math.max(e.config.grid.padding.left, t.barPadForNumericAxis), o = Math.max(e.config.grid.padding.right, t.barPadForNumericAxis)), t.dom.elGridRect = i.drawRect(-n / 2 - 2, -n / 2 - 2, t.gridWidth + n + 4, t.gridHeight + n + 4, 0, "#fff"), t.dom.elGridRectBar = i.drawRect(-n / 2 - a - 2, -n / 2 - 2, t.gridWidth + n + o + a + 4, t.gridHeight + n + 4, 0, "#fff");
    var l = e.globals.markers.largestSize;
    t.dom.elGridRectMarker = i.drawRect(-l, -l, t.gridWidth + 2 * l, t.gridHeight + 2 * l, 0, "#fff"), t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node), t.dom.elGridRectBarMask.appendChild(t.dom.elGridRectBar.node), t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
    var c = t.dom.baseEl.querySelector("defs");
    c.appendChild(t.dom.elGridRectMask), c.appendChild(t.dom.elGridRectBarMask), c.appendChild(t.dom.elGridRectMarkerMask), c.appendChild(t.dom.elForecastMask), c.appendChild(t.dom.elNonForecastMask);
  } }, { key: "_drawGridLines", value: function(e) {
    var t = e.i, i = e.x1, n = e.y1, r = e.x2, a = e.y2, o = e.xCount, l = e.parent, c = this.w;
    if (!(t === 0 && c.globals.skipFirstTimelinelabel || t === o - 1 && c.globals.skipLastTimelinelabel && !c.config.xaxis.labels.formatter || c.config.chart.type === "radar")) {
      c.config.grid.xaxis.lines.show && this._drawGridLine({ i: t, x1: i, y1: n, x2: r, y2: a, xCount: o, parent: l });
      var h = 0;
      if (c.globals.hasXaxisGroups && c.config.xaxis.tickPlacement === "between") {
        var u = c.globals.groups;
        if (u) {
          for (var d = 0, f = 0; d < t && f < u.length; f++) d += u[f].cols;
          d === t && (h = 0.6 * c.globals.xAxisLabelsHeight);
        }
      }
      new Ta(this.ctx).drawXaxisTicks(i, h, c.globals.dom.elGraphical);
    }
  } }, { key: "_drawGridLine", value: function(e) {
    var t = e.i, i = e.x1, n = e.y1, r = e.x2, a = e.y2, o = e.xCount, l = e.parent, c = this.w, h = l.node.classList.contains("apexcharts-gridlines-horizontal"), u = c.globals.barPadForNumericAxis, d = n === 0 && a === 0 || i === 0 && r === 0 || n === c.globals.gridHeight && a === c.globals.gridHeight || c.globals.isBarHorizontal && (t === 0 || t === o - 1), f = new Z(this).drawLine(i - (h ? u : 0), n, r + (h ? u : 0), a, c.config.grid.borderColor, c.config.grid.strokeDashArray);
    f.node.classList.add("apexcharts-gridline"), d && c.config.grid.show ? this.elGridBorders.add(f) : l.add(f);
  } }, { key: "_drawGridBandRect", value: function(e) {
    var t = e.c, i = e.x1, n = e.y1, r = e.x2, a = e.y2, o = e.type, l = this.w, c = new Z(this.ctx), h = l.globals.barPadForNumericAxis, u = l.config.grid[o].colors[t], d = c.drawRect(i - (o === "row" ? h : 0), n, r + (o === "row" ? 2 * h : 0), a, 0, u, l.config.grid[o].opacity);
    this.elg.add(d), d.attr("clip-path", "url(#gridRectMask".concat(l.globals.cuid, ")")), d.node.classList.add("apexcharts-grid-".concat(o));
  } }, { key: "_drawXYLines", value: function(e) {
    var t = this, i = e.xCount, n = e.tickAmount, r = this.w;
    if (r.config.grid.xaxis.lines.show || r.config.xaxis.axisTicks.show) {
      var a, o = r.globals.padHorizontal, l = r.globals.gridHeight;
      r.globals.timescaleLabels.length ? function(p) {
        for (var g = p.xC, m = p.x1, O = p.y1, x = p.x2, b = p.y2, v = 0; v < g; v++) m = t.xaxisLabels[v].position, x = t.xaxisLabels[v].position, t._drawGridLines({ i: v, x1: m, y1: O, x2: x, y2: b, xCount: i, parent: t.elgridLinesV });
      }({ xC: i, x1: o, y1: 0, x2: a, y2: l }) : (r.globals.isXNumeric && (i = r.globals.xAxisScale.result.length), function(p) {
        for (var g = p.xC, m = p.x1, O = p.y1, x = p.x2, b = p.y2, v = 0; v < g + (r.globals.isXNumeric ? 0 : 1); v++) v === 0 && g === 1 && r.globals.dataPoints === 1 && (x = m = r.globals.gridWidth / 2), t._drawGridLines({ i: v, x1: m, y1: O, x2: x, y2: b, xCount: i, parent: t.elgridLinesV }), x = m += r.globals.gridWidth / (r.globals.isXNumeric ? g - 1 : g);
      }({ xC: i, x1: o, y1: 0, x2: a, y2: l }));
    }
    if (r.config.grid.yaxis.lines.show) {
      var c = 0, h = 0, u = r.globals.gridWidth, d = n + 1;
      this.isRangeBar && (d = r.globals.labels.length);
      for (var f = 0; f < d + (this.isRangeBar ? 1 : 0); f++) this._drawGridLine({ i: f, xCount: d + (this.isRangeBar ? 1 : 0), x1: 0, y1: c, x2: u, y2: h, parent: this.elgridLinesH }), h = c += r.globals.gridHeight / (this.isRangeBar ? d : n);
    }
  } }, { key: "_drawInvertedXYLines", value: function(e) {
    var t = e.xCount, i = this.w;
    if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) for (var n, r = i.globals.padHorizontal, a = i.globals.gridHeight, o = 0; o < t + 1; o++)
      i.config.grid.xaxis.lines.show && this._drawGridLine({ i: o, xCount: t + 1, x1: r, y1: 0, x2: n, y2: a, parent: this.elgridLinesV }), new Ta(this.ctx).drawXaxisTicks(r, 0, i.globals.dom.elGraphical), n = r += i.globals.gridWidth / t;
    if (i.config.grid.yaxis.lines.show) for (var l = 0, c = 0, h = i.globals.gridWidth, u = 0; u < i.globals.dataPoints + 1; u++) this._drawGridLine({ i: u, xCount: i.globals.dataPoints + 1, x1: 0, y1: l, x2: h, y2: c, parent: this.elgridLinesH }), c = l += i.globals.gridHeight / i.globals.dataPoints;
  } }, { key: "renderGrid", value: function() {
    var e = this.w, t = e.globals, i = new Z(this.ctx);
    this.elg = i.group({ class: "apexcharts-grid" }), this.elgridLinesH = i.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), e.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var n = 0; n < t.seriesYAxisMap.length && t.ignoreYAxisIndexes.includes(n); ) n++;
    n === t.seriesYAxisMap.length && (n = 0);
    var r, a = t.yAxisScale[n].result.length - 1;
    if (!t.isBarHorizontal || this.isRangeBar) {
      var o, l, c;
      r = this.xaxisLabels.length, this.isRangeBar && (a = t.labels.length, e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (r = e.config.xaxis.tickAmount), ((o = t.yAxisScale) === null || o === void 0 || (l = o[n]) === null || l === void 0 || (c = l.result) === null || c === void 0 ? void 0 : c.length) > 0 && e.config.xaxis.type !== "datetime" && (r = t.yAxisScale[n].result.length - 1)), this._drawXYLines({ xCount: r, tickAmount: a });
    } else r = a, a = t.xTickAmount, this._drawInvertedXYLines({ xCount: r, tickAmount: a });
    return this.drawGridBands(r, a), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.gridWidth / r };
  } }, { key: "drawGridBands", value: function(e, t) {
    var i, n, r = this, a = this.w;
    if (((i = a.config.grid.row.colors) === null || i === void 0 ? void 0 : i.length) > 0 && function(p, g, m, O, x, b) {
      for (var v = 0, y = 0; v < g; v++, y++) y >= a.config.grid[p].colors.length && (y = 0), r._drawGridBandRect({ c: y, x1: m, y1: O, x2: x, y2: b, type: p }), O += a.globals.gridHeight / t;
    }("row", t, 0, 0, a.globals.gridWidth, a.globals.gridHeight / t), ((n = a.config.grid.column.colors) === null || n === void 0 ? void 0 : n.length) > 0) {
      var o = a.globals.isBarHorizontal || a.config.xaxis.tickPlacement !== "on" || a.config.xaxis.type !== "category" && !a.config.xaxis.convertedCatToNumeric ? e : e - 1;
      a.globals.isXNumeric && (o = a.globals.xAxisScale.result.length - 1);
      for (var l = a.globals.padHorizontal, c = a.globals.padHorizontal + a.globals.gridWidth / o, h = a.globals.gridHeight, u = 0, d = 0; u < e; u++, d++) {
        var f;
        d >= a.config.grid.column.colors.length && (d = 0), a.config.xaxis.type === "datetime" && (l = this.xaxisLabels[u].position, c = (((f = this.xaxisLabels[u + 1]) === null || f === void 0 ? void 0 : f.position) || a.globals.gridWidth) - this.xaxisLabels[u].position), this._drawGridBandRect({ c: d, x1: l, y1: 0, x2: c, y2: h, type: "column" }), l += a.globals.gridWidth / o;
      }
    }
  } }]), s;
}(), Uy = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.coreUtils = new st(this.ctx);
  }
  return te(s, [{ key: "niceScale", value: function(e, t) {
    var i, n, r, a, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, l = 1e-11, c = this.w, h = c.globals;
    h.isBarHorizontal ? (i = c.config.xaxis, n = Math.max((h.svgWidth - 100) / 25, 2)) : (i = c.config.yaxis[o], n = Math.max((h.svgHeight - 100) / 15, 2)), E.isNumber(n) || (n = 10), r = i.min !== void 0 && i.min !== null, a = i.max !== void 0 && i.min !== null;
    var u = i.stepSize !== void 0 && i.stepSize !== null, d = i.tickAmount !== void 0 && i.tickAmount !== null, f = d ? i.tickAmount : h.niceScaleDefaultTicks[Math.min(Math.round(n / 2), h.niceScaleDefaultTicks.length - 1)];
    if (h.isMultipleYAxis && !d && h.multiAxisTickAmount > 0 && (f = h.multiAxisTickAmount, d = !0), f = f === "dataPoints" ? h.dataPoints - 1 : Math.abs(Math.round(f)), (e === Number.MIN_VALUE && t === 0 || !E.isNumber(e) && !E.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE) && (e = E.isNumber(i.min) ? i.min : 0, t = E.isNumber(i.max) ? i.max : e + f, h.allSeriesCollapsed = !1), e > t) {
      console.warn("axis.min cannot be greater than axis.max: swapping min and max");
      var p = t;
      t = e, e = p;
    } else e === t && (e = e === 0 ? 0 : e - 1, t = t === 0 ? 2 : t + 1);
    var g = [];
    f < 1 && (f = 1);
    var m = f, O = Math.abs(t - e);
    !r && e > 0 && e / O < 0.15 && (e = 0, r = !0), !a && t < 0 && -t / O < 0.15 && (t = 0, a = !0);
    var x = (O = Math.abs(t - e)) / m, b = x, v = Math.floor(Math.log10(b)), y = Math.pow(10, v), w = Math.ceil(b / y);
    if (x = b = (w = h.niceScaleAllowedMagMsd[h.yValueDecimal === 0 ? 0 : 1][w]) * y, h.isBarHorizontal && i.stepSize && i.type !== "datetime" ? (x = i.stepSize, u = !0) : u && (x = i.stepSize), u && i.forceNiceScale) {
      var S = Math.floor(Math.log10(x));
      x *= Math.pow(10, v - S);
    }
    if (r && a) {
      var k = O / m;
      if (d) if (u) if (E.mod(O, x) != 0) {
        var A = E.getGCD(x, k);
        x = k / A < 10 ? A : k;
      } else E.mod(x, k) == 0 ? x = k : (k = x, d = !1);
      else x = k;
      else if (u) E.mod(O, x) == 0 ? k = x : x = k;
      else if (E.mod(O, x) == 0) k = x;
      else {
        k = O / (m = Math.ceil(O / x));
        var T = E.getGCD(O, x);
        O / T < n && (k = T), x = k;
      }
      m = Math.round(O / x);
    } else {
      if (r || a) {
        if (a) if (d) e = t - x * m;
        else {
          var C = e;
          e = x * Math.floor(e / x), Math.abs(t - e) / E.getGCD(O, x) > n && (e = t - x * f, e += x * Math.floor((C - e) / x));
        }
        else if (r) if (d) t = e + x * m;
        else {
          var P = t;
          t = x * Math.ceil(t / x), Math.abs(t - e) / E.getGCD(O, x) > n && (t = e + x * f, t += x * Math.ceil((P - t) / x));
        }
      } else if (h.isMultipleYAxis && d) {
        var $ = x * Math.floor(e / x), R = $ + x * m;
        R < t && (x *= 2), R = t, t = (e = $) + x * m, O = Math.abs(t - e), e > 0 && e < Math.abs(R - t) && (e = 0, t = x * m), t < 0 && -t < Math.abs($ - e) && (t = 0, e = -x * m);
      } else e = x * Math.floor(e / x), t = x * Math.ceil(t / x);
      O = Math.abs(t - e), x = E.getGCD(O, x), m = Math.round(O / x);
    }
    if (d || r || a || (m = Math.ceil((O - l) / (x + l))) > 16 && E.getPrimeFactors(m).length < 2 && m++, !d && i.forceNiceScale && h.yValueDecimal === 0 && m > O && (m = O, x = Math.round(O / m)), m > n && (!d && !u || i.forceNiceScale)) {
      var X = E.getPrimeFactors(m), M = X.length - 1, z = m;
      e: for (var I = 0; I < M; I++) for (var Y = 0; Y <= M - I; Y++) {
        for (var V = Math.min(Y + I, M), N = z, _ = 1, U = Y; U <= V; U++) _ *= X[U];
        if ((N /= _) < n) {
          z = N;
          break e;
        }
      }
      x = z === m ? O : O / z, m = Math.round(O / x);
    }
    h.isMultipleYAxis && h.multiAxisTickAmount == 0 && h.ignoreYAxisIndexes.indexOf(o) < 0 && (h.multiAxisTickAmount = m);
    var q = e - x, oe = x * l;
    do
      q += x, g.push(E.stripNumber(q, 7));
    while (t - q > oe);
    return { result: g, niceMin: g[0], niceMax: g[g.length - 1] };
  } }, { key: "linearScale", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0, a = Math.abs(t - e), o = [];
    if (e === t) return { result: o = [e], niceMin: o[0], niceMax: o[o.length - 1] };
    (i = this._adjustTicksForSmallRange(i, n, a)) === "dataPoints" && (i = this.w.globals.dataPoints - 1), r || (r = a / i), r = Math.round(100 * (r + Number.EPSILON)) / 100, i === Number.MAX_VALUE && (i = 5, r = 1);
    for (var l = e; i >= 0; ) o.push(l), l = E.preciseAddition(l, r), i -= 1;
    return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
  } }, { key: "logarithmicScaleNice", value: function(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    for (var n = [], r = Math.ceil(Math.log(t) / Math.log(i) + 1), a = Math.floor(Math.log(e) / Math.log(i)); a < r; a++) n.push(Math.pow(i, a));
    return { result: n, niceMin: n[0], niceMax: n[n.length - 1] };
  } }, { key: "logarithmicScale", value: function(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    for (var n = [], r = Math.log(t) / Math.log(i), a = Math.log(e) / Math.log(i), o = r - a, l = Math.round(o), c = o / l, h = 0, u = a; h < l; h++, u += c) n.push(Math.pow(i, u));
    return n.push(Math.pow(i, r)), { result: n, niceMin: e, niceMax: t };
  } }, { key: "_adjustTicksForSmallRange", value: function(e, t, i) {
    var n = e;
    if (t !== void 0 && this.w.config.yaxis[t].labels.formatter && this.w.config.yaxis[t].tickAmount === void 0) {
      var r = Number(this.w.config.yaxis[t].labels.formatter(1));
      E.isNumber(r) && this.w.globals.yValueDecimal === 0 && (n = Math.ceil(i));
    }
    return n < e ? n : e;
  } }, { key: "setYScaleForIndex", value: function(e, t, i) {
    var n = this.w.globals, r = this.w.config, a = n.isBarHorizontal ? r.xaxis : r.yaxis[e];
    n.yAxisScale[e] === void 0 && (n.yAxisScale[e] = []);
    var o = Math.abs(i - t);
    a.logarithmic && o <= 5 && (n.invalidLogScale = !0), a.logarithmic && o > 5 ? (n.allSeriesCollapsed = !1, n.yAxisScale[e] = a.forceNiceScale ? this.logarithmicScaleNice(t, i, a.logBase) : this.logarithmicScale(t, i, a.logBase)) : i !== -Number.MAX_VALUE && E.isNumber(i) && t !== Number.MAX_VALUE && E.isNumber(t) ? (n.allSeriesCollapsed = !1, n.yAxisScale[e] = this.niceScale(t, i, e)) : n.yAxisScale[e] = this.niceScale(Number.MIN_VALUE, 0, e);
  } }, { key: "setXScale", value: function(e, t) {
    var i = this.w, n = i.globals;
    if (t !== -Number.MAX_VALUE && E.isNumber(t)) {
      var r = n.xTickAmount;
      n.xAxisScale = this.linearScale(e, t, r, 0, i.config.xaxis.stepSize);
    } else n.xAxisScale = this.linearScale(0, 10, 10);
    return n.xAxisScale;
  } }, { key: "scaleMultipleYAxes", value: function() {
    var e = this, t = this.w.config, i = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var n = i.seriesYAxisMap, r = i.minYArr, a = i.maxYArr;
    i.allSeriesCollapsed = !0, i.barGroups = [], n.forEach(function(o, l) {
      var c = [];
      o.forEach(function(h) {
        var u, d = (u = t.series[h]) === null || u === void 0 ? void 0 : u.group;
        c.indexOf(d) < 0 && c.push(d);
      }), o.length > 0 ? function() {
        var h, u, d = Number.MAX_VALUE, f = -Number.MAX_VALUE, p = d, g = f;
        if (t.chart.stacked) (function() {
          var x = new Array(i.dataPoints).fill(0), b = [], v = [], y = [];
          c.forEach(function() {
            b.push(x.map(function() {
              return Number.MIN_VALUE;
            })), v.push(x.map(function() {
              return Number.MIN_VALUE;
            })), y.push(x.map(function() {
              return Number.MIN_VALUE;
            }));
          });
          for (var w = function(k) {
            !h && t.series[o[k]].type && (h = t.series[o[k]].type);
            var A = o[k];
            u = t.series[A].group ? t.series[A].group : "axis-".concat(l), !(i.collapsedSeriesIndices.indexOf(A) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(A) < 0) || (i.allSeriesCollapsed = !1, c.forEach(function(T, C) {
              if (t.series[A].group === T) for (var P = 0; P < i.series[A].length; P++) {
                var $ = i.series[A][P];
                $ >= 0 ? v[C][P] += $ : y[C][P] += $, b[C][P] += $, p = Math.min(p, $), g = Math.max(g, $);
              }
            })), h !== "bar" && h !== "column" || i.barGroups.push(u);
          }, S = 0; S < o.length; S++) w(S);
          h || (h = t.chart.type), h === "bar" || h === "column" ? c.forEach(function(k, A) {
            d = Math.min(d, Math.min.apply(null, y[A])), f = Math.max(f, Math.max.apply(null, v[A]));
          }) : (c.forEach(function(k, A) {
            p = Math.min(p, Math.min.apply(null, b[A])), g = Math.max(g, Math.max.apply(null, b[A]));
          }), d = p, f = g), d === Number.MIN_VALUE && f === Number.MIN_VALUE && (f = -Number.MAX_VALUE);
        })();
        else for (var m = 0; m < o.length; m++) {
          var O = o[m];
          d = Math.min(d, r[O]), f = Math.max(f, a[O]), !(i.collapsedSeriesIndices.indexOf(O) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(O) < 0) || (i.allSeriesCollapsed = !1);
        }
        t.yaxis[l].min !== void 0 && (d = typeof t.yaxis[l].min == "function" ? t.yaxis[l].min(d) : t.yaxis[l].min), t.yaxis[l].max !== void 0 && (f = typeof t.yaxis[l].max == "function" ? t.yaxis[l].max(f) : t.yaxis[l].max), i.barGroups = i.barGroups.filter(function(x, b, v) {
          return v.indexOf(x) === b;
        }), e.setYScaleForIndex(l, d, f), o.forEach(function(x) {
          r[x] = i.yAxisScale[l].niceMin, a[x] = i.yAxisScale[l].niceMax;
        });
      }() : e.setYScaleForIndex(l, 0, -Number.MAX_VALUE);
    });
  } }]), s;
}(), Cd = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.scales = new Uy(e);
  }
  return te(s, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, r = this.w.config, a = this.w.globals, o = -Number.MAX_VALUE, l = Number.MIN_VALUE;
    n === null && (n = e + 1);
    var c = a.series, h = c, u = c;
    r.chart.type === "candlestick" ? (h = a.seriesCandleL, u = a.seriesCandleH) : r.chart.type === "boxPlot" ? (h = a.seriesCandleO, u = a.seriesCandleC) : a.isRangeData && (h = a.seriesRangeStart, u = a.seriesRangeEnd);
    var d = !1;
    if (a.seriesX.length >= n) {
      var f, p = (f = a.brushSource) === null || f === void 0 ? void 0 : f.w.config.chart.brush;
      (r.chart.zoom.enabled && r.chart.zoom.autoScaleYaxis || p != null && p.enabled && p != null && p.autoScaleYaxis) && (d = !0);
    }
    for (var g = e; g < n; g++) {
      a.dataPoints = Math.max(a.dataPoints, c[g].length);
      var m = r.series[g].type;
      a.categoryLabels.length && (a.dataPoints = a.categoryLabels.filter(function(A) {
        return A !== void 0;
      }).length), a.labels.length && r.xaxis.type !== "datetime" && a.series.reduce(function(A, T) {
        return A + T.length;
      }, 0) !== 0 && (a.dataPoints = Math.max(a.dataPoints, a.labels.length));
      var O = 0, x = c[g].length - 1;
      if (d) {
        if (r.xaxis.min) for (; O < x && a.seriesX[g][O] < r.xaxis.min; O++) ;
        if (r.xaxis.max) for (; x > O && a.seriesX[g][x] > r.xaxis.max; x--) ;
      }
      for (var b = O; b <= x && b < a.series[g].length; b++) {
        var v = c[g][b];
        if (v !== null && E.isNumber(v)) {
          var y, w, S, k;
          switch (((y = u[g]) === null || y === void 0 ? void 0 : y[b]) !== void 0 && (o = Math.max(o, u[g][b]), t = Math.min(t, u[g][b])), ((w = h[g]) === null || w === void 0 ? void 0 : w[b]) !== void 0 && (t = Math.min(t, h[g][b]), i = Math.max(i, h[g][b])), m) {
            case "candlestick":
              a.seriesCandleC[g][b] !== void 0 && (o = Math.max(o, a.seriesCandleH[g][b]), t = Math.min(t, a.seriesCandleL[g][b]));
              break;
            case "boxPlot":
              a.seriesCandleC[g][b] !== void 0 && (o = Math.max(o, a.seriesCandleC[g][b]), t = Math.min(t, a.seriesCandleO[g][b]));
          }
          m && m !== "candlestick" && m !== "boxPlot" && m !== "rangeArea" && m !== "rangeBar" && (o = Math.max(o, a.series[g][b]), t = Math.min(t, a.series[g][b])), a.seriesGoals[g] && a.seriesGoals[g][b] && Array.isArray(a.seriesGoals[g][b]) && a.seriesGoals[g][b].forEach(function(A) {
            o = Math.max(o, A.value), t = Math.min(t, A.value);
          }), i = o, v = E.noExponents(v), E.isFloat(v) && (a.yValueDecimal = Math.max(a.yValueDecimal, v.toString().split(".")[1].length)), l > ((S = h[g]) === null || S === void 0 ? void 0 : S[b]) && ((k = h[g]) === null || k === void 0 ? void 0 : k[b]) < 0 && (l = h[g][b]);
        } else a.hasNullValues = !0;
      }
      m !== "bar" && m !== "column" || (l < 0 && o < 0 && (o = 0, i = Math.max(i, 0)), l === Number.MIN_VALUE && (l = 0, t = Math.min(t, 0)));
    }
    return r.chart.type === "rangeBar" && a.seriesRangeStart.length && a.isBarHorizontal && (l = t), r.chart.type === "bar" && (l < 0 && o < 0 && (o = 0), l === Number.MIN_VALUE && (l = 0)), { minY: l, maxY: o, lowestY: t, highestY: i };
  } }, { key: "setYRange", value: function() {
    var e = this.w.globals, t = this.w.config;
    e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE;
    var i, n = Number.MAX_VALUE;
    if (e.isMultipleYAxis) {
      n = Number.MAX_VALUE;
      for (var r = 0; r < e.series.length; r++) i = this.getMinYMaxY(r), e.minYArr[r] = i.lowestY, e.maxYArr[r] = i.highestY, n = Math.min(n, i.lowestY);
    }
    return i = this.getMinYMaxY(0, n, null, e.series.length), t.chart.type === "bar" ? (e.minY = i.minY, e.maxY = i.maxY) : (e.minY = i.lowestY, e.maxY = i.highestY), n = i.lowestY, t.chart.stacked && this._setStackedMinMax(), t.chart.type === "line" || t.chart.type === "area" || t.chart.type === "scatter" || t.chart.type === "candlestick" || t.chart.type === "boxPlot" || t.chart.type === "rangeBar" && !e.isBarHorizontal ? e.minY === Number.MIN_VALUE && n !== -Number.MAX_VALUE && n !== e.maxY && (e.minY = n) : e.minY = e.minY !== Number.MIN_VALUE ? Math.min(i.minY, e.minY) : i.minY, t.yaxis.forEach(function(a, o) {
      a.max !== void 0 && (typeof a.max == "number" ? e.maxYArr[o] = a.max : typeof a.max == "function" && (e.maxYArr[o] = a.max(e.isMultipleYAxis ? e.maxYArr[o] : e.maxY)), e.maxY = e.maxYArr[o]), a.min !== void 0 && (typeof a.min == "number" ? e.minYArr[o] = a.min : typeof a.min == "function" && (e.minYArr[o] = a.min(e.isMultipleYAxis ? e.minYArr[o] === Number.MIN_VALUE ? 0 : e.minYArr[o] : e.minY)), e.minY = e.minYArr[o]);
    }), e.isBarHorizontal && ["min", "max"].forEach(function(a) {
      t.xaxis[a] !== void 0 && typeof t.xaxis[a] == "number" && (a === "min" ? e.minY = t.xaxis[a] : e.maxY = t.xaxis[a]);
    }), e.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), e.minY = n) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY), e.minY = e.yAxisScale[0].niceMin, e.maxY = e.yAxisScale[0].niceMax, e.minYArr[0] = e.minY, e.maxYArr[0] = e.maxY), e.barGroups = [], e.lineGroups = [], e.areaGroups = [], t.series.forEach(function(a) {
      switch (a.type || t.chart.type) {
        case "bar":
        case "column":
          e.barGroups.push(a.group);
          break;
        case "line":
          e.lineGroups.push(a.group);
          break;
        case "area":
          e.areaGroups.push(a.group);
      }
    }), e.barGroups = e.barGroups.filter(function(a, o, l) {
      return l.indexOf(a) === o;
    }), e.lineGroups = e.lineGroups.filter(function(a, o, l) {
      return l.indexOf(a) === o;
    }), e.areaGroups = e.areaGroups.filter(function(a, o, l) {
      return l.indexOf(a) === o;
    }), { minY: e.minY, maxY: e.maxY, minYArr: e.minYArr, maxYArr: e.maxYArr, yAxisScale: e.yAxisScale };
  } }, { key: "setXRange", value: function() {
    var e = this.w.globals, t = this.w.config, i = t.xaxis.type === "numeric" || t.xaxis.type === "datetime" || t.xaxis.type === "category" && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
    if (e.isXNumeric && function() {
      for (var l = 0; l < e.series.length; l++) if (e.labels[l]) for (var c = 0; c < e.labels[l].length; c++) e.labels[l][c] !== null && E.isNumber(e.labels[l][c]) && (e.maxX = Math.max(e.maxX, e.labels[l][c]), e.initialMaxX = Math.max(e.maxX, e.labels[l][c]), e.minX = Math.min(e.minX, e.labels[l][c]), e.initialMinX = Math.min(e.minX, e.labels[l][c]));
    }(), e.noLabelsProvided && t.xaxis.categories.length === 0 && (e.maxX = e.labels[e.labels.length - 1], e.initialMaxX = e.labels[e.labels.length - 1], e.minX = 1, e.initialMinX = 1), e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
      var n = 10;
      if (t.xaxis.tickAmount === void 0) n = Math.round(e.svgWidth / 150), t.xaxis.type === "numeric" && e.dataPoints < 30 && (n = e.dataPoints - 1), n > e.dataPoints && e.dataPoints !== 0 && (n = e.dataPoints - 1);
      else if (t.xaxis.tickAmount === "dataPoints") {
        if (e.series.length > 1 && (n = e.series[e.maxValsInArrayIndex].length - 1), e.isXNumeric) {
          var r = Math.round(e.maxX - e.minX);
          r < 30 && (n = r - 1);
        }
      } else n = t.xaxis.tickAmount;
      if (e.xTickAmount = n, t.xaxis.max !== void 0 && typeof t.xaxis.max == "number" && (e.maxX = t.xaxis.max), t.xaxis.min !== void 0 && typeof t.xaxis.min == "number" && (e.minX = t.xaxis.min), t.xaxis.range !== void 0 && (e.minX = e.maxX - t.xaxis.range), e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE) if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
        for (var a = [], o = e.minX - 1; o < e.maxX; o++) a.push(o + 1);
        e.xAxisScale = { result: a, niceMin: a[0], niceMax: a[a.length - 1] };
      } else e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
      else e.xAxisScale = this.scales.linearScale(0, n, n, 0, t.xaxis.stepSize), e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, n - 1, 0, t.xaxis.stepSize), e.seriesX = e.labels.slice());
      i && (e.labels = e.xAxisScale.result.slice());
    }
    return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: e.minX, maxX: e.maxX };
  } }, { key: "setZRange", value: function() {
    var e = this.w.globals;
    if (e.isDataXYZ) {
      for (var t = 0; t < e.series.length; t++) if (e.seriesZ[t] !== void 0) for (var i = 0; i < e.seriesZ[t].length; i++) e.seriesZ[t][i] !== null && E.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]), e.minZ = Math.min(e.minZ, e.seriesZ[t][i]));
    }
  } }, { key: "_handleSingleDataPoint", value: function() {
    var e = this.w.globals, t = this.w.config;
    if (e.minX === e.maxX) {
      var i = new xt(this.ctx);
      if (t.xaxis.type === "datetime") {
        var n = i.getDate(e.minX);
        t.xaxis.labels.datetimeUTC ? n.setUTCDate(n.getUTCDate() - 2) : n.setDate(n.getDate() - 2), e.minX = new Date(n).getTime();
        var r = i.getDate(e.maxX);
        t.xaxis.labels.datetimeUTC ? r.setUTCDate(r.getUTCDate() + 2) : r.setDate(r.getDate() + 2), e.maxX = new Date(r).getTime();
      } else (t.xaxis.type === "numeric" || t.xaxis.type === "category" && !e.noLabelsProvided) && (e.minX = e.minX - 2, e.initialMinX = e.minX, e.maxX = e.maxX + 2, e.initialMaxX = e.maxX);
    }
  } }, { key: "_getMinXDiff", value: function() {
    var e = this.w.globals;
    e.isXNumeric && e.seriesX.forEach(function(t, i) {
      if (t.length) {
        t.length === 1 && t.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]);
        var n = t.slice();
        n.sort(function(r, a) {
          return r - a;
        }), n.forEach(function(r, a) {
          if (a > 0) {
            var o = r - n[a - 1];
            o > 0 && (e.minXDiff = Math.min(o, e.minXDiff));
          }
        }), e.dataPoints !== 1 && e.minXDiff !== Number.MAX_VALUE || (e.minXDiff = 0.5);
      }
    });
  } }, { key: "_setStackedMinMax", value: function() {
    var e = this, t = this.w.globals;
    if (t.series.length) {
      var i = t.seriesGroups;
      i.length || (i = [this.w.globals.seriesNames.map(function(a) {
        return a;
      })]);
      var n = {}, r = {};
      i.forEach(function(a) {
        n[a] = [], r[a] = [], e.w.config.series.map(function(o, l) {
          return a.indexOf(t.seriesNames[l]) > -1 ? l : null;
        }).filter(function(o) {
          return o !== null;
        }).forEach(function(o) {
          for (var l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) {
            var c, h, u, d;
            n[a][l] === void 0 && (n[a][l] = 0, r[a][l] = 0), (e.w.config.chart.stacked && !t.comboCharts || e.w.config.chart.stacked && t.comboCharts && (!e.w.config.chart.stackOnlyBar || ((c = e.w.config.series) === null || c === void 0 || (h = c[o]) === null || h === void 0 ? void 0 : h.type) === "bar" || ((u = e.w.config.series) === null || u === void 0 || (d = u[o]) === null || d === void 0 ? void 0 : d.type) === "column")) && t.series[o][l] !== null && E.isNumber(t.series[o][l]) && (t.series[o][l] > 0 ? n[a][l] += parseFloat(t.series[o][l]) + 1e-4 : r[a][l] += parseFloat(t.series[o][l]));
          }
        });
      }), Object.entries(n).forEach(function(a) {
        var o = xy(a, 1)[0];
        n[o].forEach(function(l, c) {
          t.maxY = Math.max(t.maxY, n[o][c]), t.minY = Math.min(t.minY, r[o][c]);
        });
      });
    }
  } }]), s;
}(), Lp = function() {
  function s(e, t) {
    ee(this, s), this.ctx = e, this.elgrid = t, this.w = e.w;
    var i = this.w;
    this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = i.config.xaxis.position === "bottom" ? i.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Ws(e);
  }
  return te(s, [{ key: "drawYaxis", value: function(e) {
    var t = this.w, i = new Z(this.ctx), n = t.config.yaxis[e].labels.style, r = n.fontSize, a = n.fontFamily, o = n.fontWeight, l = i.group({ class: "apexcharts-yaxis", rel: e, transform: "translate(".concat(t.globals.translateYAxisX[e], ", 0)") });
    if (this.axesUtils.isYAxisHidden(e)) return l;
    var c = i.group({ class: "apexcharts-yaxis-texts-g" });
    l.add(c);
    var h = t.globals.yAxisScale[e].result.length - 1, u = t.globals.gridHeight / h, d = t.globals.yLabelFormatters[e], f = this.axesUtils.checkForReversedLabels(e, t.globals.yAxisScale[e].result.slice());
    if (t.config.yaxis[e].labels.show) {
      var p = t.globals.translateY + t.config.yaxis[e].labels.offsetY;
      t.globals.isBarHorizontal ? p = 0 : t.config.chart.type === "heatmap" && (p -= u / 2), p += parseInt(r, 10) / 3;
      for (var g = h; g >= 0; g--) {
        var m = d(f[g], g, t), O = t.config.yaxis[e].labels.padding;
        t.config.yaxis[e].opposite && t.config.yaxis.length !== 0 && (O *= -1);
        var x = this.getTextAnchor(t.config.yaxis[e].labels.align, t.config.yaxis[e].opposite), b = this.axesUtils.getYAxisForeColor(n.colors, e), v = Array.isArray(b) ? b[g] : b, y = E.listToArray(t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-label tspan"))).map(function(S) {
          return S.textContent;
        }), w = i.drawText({ x: O, y: p, text: y.includes(m) && !t.config.yaxis[e].labels.showDuplicates ? "" : m, textAnchor: x, fontSize: r, fontFamily: a, fontWeight: o, maxWidth: t.config.yaxis[e].labels.maxWidth, foreColor: v, isPlainText: !1, cssClass: "apexcharts-yaxis-label ".concat(n.cssClass) });
        c.add(w), this.addTooltip(w, m), t.config.yaxis[e].labels.rotate !== 0 && this.rotateLabel(i, w, firstLabel, t.config.yaxis[e].labels.rotate), p += u;
      }
    }
    return this.addYAxisTitle(i, l, e), this.addAxisBorder(i, l, e, h, u), l;
  } }, { key: "getTextAnchor", value: function(e, t) {
    return e === "left" ? "start" : e === "center" ? "middle" : e === "right" ? "end" : t ? "start" : "end";
  } }, { key: "addTooltip", value: function(e, t) {
    var i = document.createElementNS(this.w.globals.SVGNS, "title");
    i.textContent = Array.isArray(t) ? t.join(" ") : t, e.node.appendChild(i);
  } }, { key: "rotateLabel", value: function(e, t, i, n) {
    var r = e.rotateAroundCenter(i.node), a = e.rotateAroundCenter(t.node);
    t.node.setAttribute("transform", "rotate(".concat(n, " ").concat(r.x, " ").concat(a.y, ")"));
  } }, { key: "addYAxisTitle", value: function(e, t, i) {
    var n = this.w;
    if (n.config.yaxis[i].title.text !== void 0) {
      var r = e.group({ class: "apexcharts-yaxis-title" }), a = n.config.yaxis[i].opposite ? n.globals.translateYAxisX[i] : 0, o = e.drawText({ x: a, y: n.globals.gridHeight / 2 + n.globals.translateY + n.config.yaxis[i].title.offsetY, text: n.config.yaxis[i].title.text, textAnchor: "end", foreColor: n.config.yaxis[i].title.style.color, fontSize: n.config.yaxis[i].title.style.fontSize, fontWeight: n.config.yaxis[i].title.style.fontWeight, fontFamily: n.config.yaxis[i].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(n.config.yaxis[i].title.style.cssClass) });
      r.add(o), t.add(r);
    }
  } }, { key: "addAxisBorder", value: function(e, t, i, n, r) {
    var a = this.w, o = a.config.yaxis[i].axisBorder, l = 31 + o.offsetX;
    if (a.config.yaxis[i].opposite && (l = -31 - o.offsetX), o.show) {
      var c = e.drawLine(l, a.globals.translateY + o.offsetY - 2, l, a.globals.gridHeight + a.globals.translateY + o.offsetY + 2, o.color, 0, o.width);
      t.add(c);
    }
    a.config.yaxis[i].axisTicks.show && this.axesUtils.drawYAxisTicks(l, n, o, a.config.yaxis[i].axisTicks, i, r, t);
  } }, { key: "drawYaxisInversed", value: function(e) {
    var t = this.w, i = new Z(this.ctx), n = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), r = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")") });
    n.add(r);
    var a = t.globals.yAxisScale[e].result.length - 1, o = t.globals.gridWidth / a + 0.1, l = o + t.config.xaxis.labels.offsetX, c = t.globals.xLabelFormatter, h = this.axesUtils.checkForReversedLabels(e, t.globals.yAxisScale[e].result.slice()), u = t.globals.timescaleLabels;
    if (u.length > 0 && (this.xaxisLabels = u.slice(), a = (h = u.slice()).length), t.config.xaxis.labels.show) for (var d = u.length ? 0 : a; u.length ? d < u.length : d >= 0; u.length ? d++ : d--) {
      var f = c(h[d], d, t), p = t.globals.gridWidth + t.globals.padHorizontal - (l - o + t.config.xaxis.labels.offsetX);
      if (u.length) {
        var g = this.axesUtils.getLabel(h, u, p, d, this.drawnLabels, this.xaxisFontSize);
        p = g.x, f = g.text, this.drawnLabels.push(g.text), d === 0 && t.globals.skipFirstTimelinelabel && (f = ""), d === h.length - 1 && t.globals.skipLastTimelinelabel && (f = "");
      }
      var m = i.drawText({ x: p, y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - (t.config.xaxis.position === "top" ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0), text: f, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: t.config.xaxis.labels.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-xaxis-label ".concat(t.config.xaxis.labels.style.cssClass) });
      r.add(m), m.tspan(f), this.addTooltip(m, f), l += o;
    }
    return this.inversedYAxisTitleText(n), this.inversedYAxisBorder(n), n;
  } }, { key: "inversedYAxisBorder", value: function(e) {
    var t = this.w, i = new Z(this.ctx), n = t.config.xaxis.axisBorder;
    if (n.show) {
      var r = 0;
      t.config.chart.type === "bar" && t.globals.isXNumeric && (r -= 15);
      var a = i.drawLine(t.globals.padHorizontal + r + n.offsetX, this.xAxisoffX, t.globals.gridWidth, this.xAxisoffX, n.color, 0, n.height);
      this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(a) : e.add(a);
    }
  } }, { key: "inversedYAxisTitleText", value: function(e) {
    var t = this.w, i = new Z(this.ctx);
    if (t.config.xaxis.title.text !== void 0) {
      var n = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), r = i.drawText({ x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20, text: t.config.xaxis.title.text, textAnchor: "middle", fontSize: t.config.xaxis.title.style.fontSize, fontFamily: t.config.xaxis.title.style.fontFamily, fontWeight: t.config.xaxis.title.style.fontWeight, foreColor: t.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(t.config.xaxis.title.style.cssClass) });
      n.add(r), e.add(n);
    }
  } }, { key: "yAxisTitleRotate", value: function(e, t) {
    var i = this.w, n = new Z(this.ctx), r = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g")), a = r ? r.getBoundingClientRect() : { width: 0, height: 0 }, o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text")), l = o ? o.getBoundingClientRect() : { width: 0, height: 0 };
    if (o) {
      var c = this.xPaddingForYAxisTitle(e, a, l, t);
      o.setAttribute("x", c.xPos - (t ? 10 : 0));
      var h = n.rotateAroundCenter(o);
      o.setAttribute("transform", "rotate(".concat(t ? -1 * i.config.yaxis[e].title.rotate : i.config.yaxis[e].title.rotate, " ").concat(h.x, " ").concat(h.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(e, t, i, n) {
    var r = this.w, a = 0, o = 10;
    return r.config.yaxis[e].title.text === void 0 || e < 0 ? { xPos: a, padd: 0 } : (n ? a = t.width + r.config.yaxis[e].title.offsetX + i.width / 2 + o / 2 : (a = -1 * t.width + r.config.yaxis[e].title.offsetX + o / 2 + i.width / 2, r.globals.isBarHorizontal && (o = 25, a = -1 * t.width - r.config.yaxis[e].title.offsetX - o)), { xPos: a, padd: o });
  } }, { key: "setYAxisXPosition", value: function(e, t) {
    var i = this.w, n = 0, r = 0, a = 18, o = 1;
    i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.forEach(function(l, c) {
      var h = i.globals.ignoreYAxisIndexes.includes(c) || !l.show || l.floating || e[c].width === 0, u = e[c].width + t[c].width;
      l.opposite ? i.globals.isBarHorizontal ? (r = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[c] = r - l.labels.offsetX) : (r = i.globals.gridWidth + i.globals.translateX + o, h || (o += u + 20), i.globals.translateYAxisX[c] = r - l.labels.offsetX + 20) : (n = i.globals.translateX - a, h || (a += u + 20), i.globals.translateYAxisX[c] = n + l.labels.offsetX);
    });
  } }, { key: "setYAxisTextAlignments", value: function() {
    var e = this.w;
    E.listToArray(e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach(function(t, i) {
      var n = e.config.yaxis[i];
      if (n && !n.floating && n.labels.align !== void 0) {
        var r = e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")), a = E.listToArray(e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"))), o = r.getBoundingClientRect();
        a.forEach(function(l) {
          l.setAttribute("text-anchor", n.labels.align);
        }), n.labels.align !== "left" || n.opposite ? n.labels.align === "center" ? r.setAttribute("transform", "translate(".concat(o.width / 2 * (n.opposite ? 1 : -1), ", 0)")) : n.labels.align === "right" && n.opposite && r.setAttribute("transform", "translate(".concat(o.width, ", 0)")) : r.setAttribute("transform", "translate(-".concat(o.width, ", 0)"));
      }
    });
  } }]), s;
}(), UT = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.documentEvent = E.bind(this.documentEvent, this);
  }
  return te(s, [{ key: "addEventListener", value: function(e, t) {
    var i = this.w;
    i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t];
  } }, { key: "removeEventListener", value: function(e, t) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(e)) {
      var n = i.globals.events[e].indexOf(t);
      n !== -1 && i.globals.events[e].splice(n, 1);
    }
  } }, { key: "fireEvent", value: function(e, t) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(e)) {
      t && t.length || (t = []);
      for (var n = i.globals.events[e], r = n.length, a = 0; a < r; a++) n[a].apply(null, t);
    }
  } }, { key: "setupEventHandlers", value: function() {
    var e = this, t = this.w, i = this.ctx, n = t.globals.dom.baseEl.querySelector(t.globals.chartClass);
    this.ctx.eventList.forEach(function(r) {
      n.addEventListener(r, function(a) {
        var o = a.target.getAttribute("i") === null && t.globals.capturedSeriesIndex !== -1 ? t.globals.capturedSeriesIndex : a.target.getAttribute("i"), l = a.target.getAttribute("j") === null && t.globals.capturedDataPointIndex !== -1 ? t.globals.capturedDataPointIndex : a.target.getAttribute("j"), c = Object.assign({}, t, { seriesIndex: t.globals.axisCharts ? o : 0, dataPointIndex: l });
        a.type === "mousemove" || a.type === "touchmove" ? typeof t.config.chart.events.mouseMove == "function" && t.config.chart.events.mouseMove(a, i, c) : a.type === "mouseleave" || a.type === "touchleave" ? typeof t.config.chart.events.mouseLeave == "function" && t.config.chart.events.mouseLeave(a, i, c) : (a.type === "mouseup" && a.which === 1 || a.type === "touchend") && (typeof t.config.chart.events.click == "function" && t.config.chart.events.click(a, i, c), i.ctx.events.fireEvent("click", [a, i, c]));
      }, { capture: !1, passive: !0 });
    }), this.ctx.eventList.forEach(function(r) {
      t.globals.dom.baseEl.addEventListener(r, e.documentEvent, { passive: !0 });
    }), this.ctx.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(e) {
    var t = this.w, i = e.target.className;
    if (e.type === "click") {
      var n = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
      n && n.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && n.classList.remove("apexcharts-menu-open");
    }
    t.globals.clientX = e.type === "touchmove" ? e.touches[0].clientX : e.clientX, t.globals.clientY = e.type === "touchmove" ? e.touches[0].clientY : e.clientY;
  } }]), s;
}(), GT = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "setCurrentLocaleValues", value: function(e) {
    var t = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i = t.filter(function(r) {
      return r.name === e;
    })[0];
    if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var n = E.extend(Vy, i);
    this.w.globals.locale = n.options;
  } }]), s;
}(), KT = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "drawAxis", value: function(e, t) {
    var i, n, r = this, a = this.w.globals, o = this.w.config, l = new Ta(this.ctx, t), c = new Lp(this.ctx, t);
    a.axisCharts && e !== "radar" && (a.isBarHorizontal ? (n = c.drawYaxisInversed(0), i = l.drawXaxisInversed(0), a.dom.elGraphical.add(i), a.dom.elGraphical.add(n)) : (i = l.drawXaxis(), a.dom.elGraphical.add(i), o.yaxis.map(function(h, u) {
      if (a.ignoreYAxisIndexes.indexOf(u) === -1 && (n = c.drawYaxis(u), a.dom.Paper.add(n), r.w.config.grid.position === "back")) {
        var d = a.dom.Paper.children()[1];
        d.remove(), a.dom.Paper.add(d);
      }
    })));
  } }]), s;
}(), Ad = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "drawXCrosshairs", value: function() {
    var e = this.w, t = new Z(this.ctx), i = new vt(this.ctx), n = e.config.xaxis.crosshairs.fill.gradient, r = e.config.xaxis.crosshairs.dropShadow, a = e.config.xaxis.crosshairs.fill.type, o = n.colorFrom, l = n.colorTo, c = n.opacityFrom, h = n.opacityTo, u = n.stops, d = r.enabled, f = r.left, p = r.top, g = r.blur, m = r.color, O = r.opacity, x = e.config.xaxis.crosshairs.fill.color;
    if (e.config.xaxis.crosshairs.show) {
      a === "gradient" && (x = t.drawGradient("vertical", o, l, c, h, null, u, null));
      var b = t.drawRect();
      e.config.xaxis.crosshairs.width === 1 && (b = t.drawLine());
      var v = e.globals.gridHeight;
      (!E.isNumber(v) || v < 0) && (v = 0);
      var y = e.config.xaxis.crosshairs.width;
      (!E.isNumber(y) || y < 0) && (y = 0), b.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: v, width: y, height: v, fill: x, filter: "none", "fill-opacity": e.config.xaxis.crosshairs.opacity, stroke: e.config.xaxis.crosshairs.stroke.color, "stroke-width": e.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray }), d && (b = i.dropShadow(b, { left: f, top: p, blur: g, color: m, opacity: O })), e.globals.dom.elGraphical.add(b);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var e = this.w, t = new Z(this.ctx), i = e.config.yaxis[0].crosshairs, n = e.globals.barPadForNumericAxis;
    if (e.config.yaxis[0].crosshairs.show) {
      var r = t.drawLine(-n, 0, e.globals.gridWidth + n, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
      r.attr({ class: "apexcharts-ycrosshairs" }), e.globals.dom.elGraphical.add(r);
    }
    var a = t.drawLine(-n, 0, e.globals.gridWidth + n, 0, i.stroke.color, 0, 0);
    a.attr({ class: "apexcharts-ycrosshairs-hidden" }), e.globals.dom.elGraphical.add(a);
  } }]), s;
}(), JT = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "checkResponsiveConfig", value: function(e) {
    var t = this, i = this.w, n = i.config;
    if (n.responsive.length !== 0) {
      var r = n.responsive.slice();
      r.sort(function(c, h) {
        return c.breakpoint > h.breakpoint ? 1 : h.breakpoint > c.breakpoint ? -1 : 0;
      }).reverse();
      var a = new Aa({}), o = function() {
        var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = r[0].breakpoint, u = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (u > h) {
          var d = E.clone(i.globals.initialConfig);
          d.series = E.clone(i.config.series);
          var f = st.extendArrayProps(a, d, i);
          c = E.extend(f, c), c = E.extend(i.config, c), t.overrideResponsiveOptions(c);
        } else for (var p = 0; p < r.length; p++) u < r[p].breakpoint && (c = st.extendArrayProps(a, r[p].options, i), c = E.extend(i.config, c), t.overrideResponsiveOptions(c));
      };
      if (e) {
        var l = st.extendArrayProps(a, e, i);
        l = E.extend(i.config, l), o(l = E.extend(l, e));
      } else o({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(e) {
    var t = new Aa(e).init({ responsiveOverride: !0 });
    this.w.config = t;
  } }]), s;
}(), e$ = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.colors = [], this.isColorFn = !1, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return te(s, [{ key: "checkHeatmapDistributed", value: function() {
    var e = this.w.config, t = e.chart, i = e.plotOptions;
    return t.type === "treemap" && i.treemap && i.treemap.distributed || t.type === "heatmap" && i.heatmap && i.heatmap.distributed;
  } }, { key: "checkBarDistributed", value: function() {
    var e = this.w.config, t = e.chart, i = e.plotOptions;
    return i.bar && i.bar.distributed && (t.type === "bar" || t.type === "rangeBar");
  } }, { key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var e = this.w, t = new E();
    e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode || "light"));
    var i = dt(e.config.colors || e.config.fill.colors || []);
    e.globals.colors = this.getColors(i), this.applySeriesColors(e.globals.seriesColors, e.globals.colors), e.config.theme.monochrome.enabled && (e.globals.colors = this.getMonochromeColors(e.config.theme.monochrome, e.globals.series, t));
    var n = e.globals.colors.slice();
    this.pushExtraColors(e.globals.colors), this.applyColorTypes(["fill", "stroke"], n), this.applyDataLabelsColors(n), this.applyRadarPolygonsColors(), this.applyMarkersColors(n);
  } }, { key: "getColors", value: function(e) {
    var t = this, i = this.w;
    return e && e.length !== 0 ? Array.isArray(e) && e.length > 0 && typeof e[0] == "function" ? (this.isColorFn = !0, i.config.series.map(function(n, r) {
      var a = e[r] || e[0];
      return typeof a == "function" ? a({ value: i.globals.axisCharts ? i.globals.series[r][0] || 0 : i.globals.series[r], seriesIndex: r, dataPointIndex: r, w: t.w }) : a;
    })) : e : this.predefined();
  } }, { key: "applySeriesColors", value: function(e, t) {
    e.forEach(function(i, n) {
      i && (t[n] = i);
    });
  } }, { key: "getMonochromeColors", value: function(e, t, i) {
    var n = e.color, r = e.shadeIntensity, a = e.shadeTo, o = this.isBarDistributed || this.isHeatmapDistributed ? t[0].length * t.length : t.length, l = 1 / (o / r), c = 0;
    return Array.from({ length: o }, function() {
      var h = a === "dark" ? i.shadeColor(-1 * c, n) : i.shadeColor(c, n);
      return c += l, h;
    });
  } }, { key: "applyColorTypes", value: function(e, t) {
    var i = this, n = this.w;
    e.forEach(function(r) {
      n.globals[r].colors = n.config[r].colors === void 0 ? i.isColorFn ? n.config.colors : t : n.config[r].colors.slice(), i.pushExtraColors(n.globals[r].colors);
    });
  } }, { key: "applyDataLabelsColors", value: function(e) {
    var t = this.w;
    t.globals.dataLabels.style.colors = t.config.dataLabels.style.colors === void 0 ? e : t.config.dataLabels.style.colors.slice(), this.pushExtraColors(t.globals.dataLabels.style.colors, 50);
  } }, { key: "applyRadarPolygonsColors", value: function() {
    var e = this.w;
    e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors === void 0 ? [e.config.theme.mode === "dark" ? "#343A3F" : "none"] : e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20);
  } }, { key: "applyMarkersColors", value: function(e) {
    var t = this.w;
    t.globals.markers.colors = t.config.markers.colors === void 0 ? e : t.config.markers.colors.slice(), this.pushExtraColors(t.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = this.w, r = t || n.globals.series.length;
    if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || n.config.chart.type === "heatmap" && n.config.plotOptions.heatmap && n.config.plotOptions.heatmap.colorScale.inverse), i && n.globals.series.length && (r = n.globals.series[n.globals.maxValsInArrayIndex].length * n.globals.series.length), e.length < r) for (var a = r - e.length, o = 0; o < a; o++) e.push(e[o]);
  } }, { key: "updateThemeOptions", value: function(e) {
    e.chart = e.chart || {}, e.tooltip = e.tooltip || {};
    var t = e.theme.mode, i = t === "dark" ? "palette4" : t === "light" ? "palette1" : e.theme.palette || "palette1", n = t === "dark" ? "#f6f7f8" : t === "light" ? "#373d3f" : e.chart.foreColor || "#373d3f";
    return e.tooltip.theme = t || "light", e.chart.foreColor = n, e.theme.palette = i, e;
  } }, { key: "predefined", value: function() {
    var e = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
    return e[this.w.config.theme.palette] || e.default;
  } }]), s;
}(), t$ = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(e) {
    var t = this.w, i = e === "title" ? t.config.title : t.config.subtitle, n = t.globals.svgWidth / 2, r = i.offsetY, a = "middle";
    if (i.align === "left" ? (n = 10, a = "start") : i.align === "right" && (n = t.globals.svgWidth - 10, a = "end"), n += i.offsetX, r = r + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
      var o = new Z(this.ctx).drawText({ x: n, y: r, text: i.text, textAnchor: a, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
      o.node.setAttribute("class", "apexcharts-".concat(e, "-text")), t.globals.dom.Paper.add(o);
    }
  } }]), s;
}(), i$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.dCtx = e;
  }
  return te(s, [{ key: "getTitleSubtitleCoords", value: function(e) {
    var t = this.w, i = 0, n = 0, r = e === "title" ? t.config.title.floating : t.config.subtitle.floating, a = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
    if (a !== null && !r) {
      var o = a.getBoundingClientRect();
      i = o.width, n = t.globals.axisCharts ? o.height + 5 : o.height;
    }
    return { width: i, height: n };
  } }, { key: "getLegendsRect", value: function() {
    var e = this.w, t = e.globals.dom.elLegendWrap;
    e.config.legend.height || e.config.legend.position !== "top" && e.config.legend.position !== "bottom" || (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
    var i = Object.assign({}, E.getBoundingClientRect(t));
    return t !== null && !e.config.legend.floating && e.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, e.config.legend.position !== "left" && e.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: "getDatalabelsRect", value: function() {
    var e = this, t = this.w, i = [];
    t.config.series.forEach(function(l, c) {
      l.data.forEach(function(h, u) {
        var d;
        d = t.globals.series[c][u], n = t.config.dataLabels.formatter(d, { ctx: e.dCtx.ctx, seriesIndex: c, dataPointIndex: u, w: t }), i.push(n);
      });
    });
    var n = E.getLargestStringFromArr(i), r = new Z(this.dCtx.ctx), a = t.config.dataLabels.style, o = r.getTextRects(n, parseInt(a.fontSize), a.fontFamily);
    return { width: 1.05 * o.width, height: o.height };
  } }, { key: "getLargestStringFromMultiArr", value: function(e, t) {
    var i = e;
    if (this.w.globals.isMultiLineX) {
      var n = t.map(function(a, o) {
        return Array.isArray(a) ? a.length : 1;
      }), r = Math.max.apply(Math, dt(n));
      i = t[n.indexOf(r)];
    }
    return i;
  } }]), s;
}(), s$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.dCtx = e;
  }
  return te(s, [{ key: "getxAxisLabelsCoords", value: function() {
    var e, t = this.w, i = t.globals.labels.slice();
    if (t.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = t.globals.categoryLabels), t.globals.timescaleLabels.length > 0) {
      var n = this.getxAxisTimeScaleLabelsCoords();
      e = { width: n.width, height: n.height }, t.globals.rotateXLabels = !1;
    } else {
      this.dCtx.lgWidthForSideLegends = t.config.legend.position !== "left" && t.config.legend.position !== "right" || t.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var r = t.globals.xLabelFormatter, a = E.getLargestStringFromArr(i), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(a, i);
      t.globals.isBarHorizontal && (o = a = t.globals.yAxisScale[0].result.reduce(function(p, g) {
        return p.length > g.length ? p : g;
      }, 0));
      var l = new go(this.dCtx.ctx), c = a;
      a = l.xLabelFormat(r, a, c, { i: void 0, dateFormatter: new xt(this.dCtx.ctx).formatDate, w: t }), o = l.xLabelFormat(r, o, c, { i: void 0, dateFormatter: new xt(this.dCtx.ctx).formatDate, w: t }), (t.config.xaxis.convertedCatToNumeric && a === void 0 || String(a).trim() === "") && (o = a = "1");
      var h = new Z(this.dCtx.ctx), u = h.getTextRects(a, t.config.xaxis.labels.style.fontSize), d = u;
      if (a !== o && (d = h.getTextRects(o, t.config.xaxis.labels.style.fontSize)), (e = { width: u.width >= d.width ? u.width : d.width, height: u.height >= d.height ? u.height : d.height }).width * i.length > t.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && t.config.xaxis.labels.rotate !== 0 || t.config.xaxis.labels.rotateAlways) {
        if (!t.globals.isBarHorizontal) {
          t.globals.rotateXLabels = !0;
          var f = function(p) {
            return h.getTextRects(p, t.config.xaxis.labels.style.fontSize, t.config.xaxis.labels.style.fontFamily, "rotate(".concat(t.config.xaxis.labels.rotate, " 0 0)"), !1);
          };
          u = f(a), a !== o && (d = f(o)), e.height = (u.height > d.height ? u.height : d.height) / 1.5, e.width = u.width > d.width ? u.width : d.width;
        }
      } else t.globals.rotateXLabels = !1;
    }
    return t.config.xaxis.labels.show || (e = { width: 0, height: 0 }), { width: e.width, height: e.height };
  } }, { key: "getxAxisGroupLabelsCoords", value: function() {
    var e, t = this.w;
    if (!t.globals.hasXaxisGroups) return { width: 0, height: 0 };
    var i, n = ((e = t.config.xaxis.group.style) === null || e === void 0 ? void 0 : e.fontSize) || t.config.xaxis.labels.style.fontSize, r = t.globals.groups.map(function(u) {
      return u.title;
    }), a = E.getLargestStringFromArr(r), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(a, r), l = new Z(this.dCtx.ctx), c = l.getTextRects(a, n), h = c;
    return a !== o && (h = l.getTextRects(o, n)), i = { width: c.width >= h.width ? c.width : h.width, height: c.height >= h.height ? c.height : h.height }, t.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
  } }, { key: "getxAxisTitleCoords", value: function() {
    var e = this.w, t = 0, i = 0;
    if (e.config.xaxis.title.text !== void 0) {
      var n = new Z(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize);
      t = n.width, i = n.height;
    }
    return { width: t, height: i };
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var e, t = this.w;
    this.dCtx.timescaleLabels = t.globals.timescaleLabels.slice();
    var i = this.dCtx.timescaleLabels.map(function(r) {
      return r.value;
    }), n = i.reduce(function(r, a) {
      return r === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : r.length > a.length ? r : a;
    }, 0);
    return 1.05 * (e = new Z(this.dCtx.ctx).getTextRects(n, t.config.xaxis.labels.style.fontSize)).width * i.length > t.globals.gridWidth && t.config.xaxis.labels.rotate !== 0 && (t.globals.overlappingXLabels = !0), e;
  } }, { key: "additionalPaddingXLabels", value: function(e) {
    var t = this, i = this.w, n = i.globals, r = i.config, a = r.xaxis.type, o = e.width;
    n.skipLastTimelinelabel = !1, n.skipFirstTimelinelabel = !1;
    var l = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, c = function(h, u) {
      r.yaxis.length > 1 && function(d) {
        return n.collapsedSeriesIndices.indexOf(d) !== -1;
      }(u) || function(d) {
        if (t.dCtx.timescaleLabels && t.dCtx.timescaleLabels.length) {
          var f = t.dCtx.timescaleLabels[0], p = t.dCtx.timescaleLabels[t.dCtx.timescaleLabels.length - 1].position + o / 1.75 - t.dCtx.yAxisWidthRight, g = f.position - o / 1.75 + t.dCtx.yAxisWidthLeft, m = i.config.legend.position === "right" && t.dCtx.lgRect.width > 0 ? t.dCtx.lgRect.width : 0;
          p > n.svgWidth - n.translateX - m && (n.skipLastTimelinelabel = !0), g < -(d.show && !d.floating || r.chart.type !== "bar" && r.chart.type !== "candlestick" && r.chart.type !== "rangeBar" && r.chart.type !== "boxPlot" ? 10 : o / 1.75) && (n.skipFirstTimelinelabel = !0);
        } else a === "datetime" ? t.dCtx.gridPad.right < o && !n.rotateXLabels && (n.skipLastTimelinelabel = !0) : a !== "datetime" && t.dCtx.gridPad.right < o / 2 - t.dCtx.yAxisWidthRight && !n.rotateXLabels && !i.config.xaxis.labels.trim && (t.dCtx.xPadRight = o / 2 + 1);
      }(h);
    };
    r.yaxis.forEach(function(h, u) {
      l ? (t.dCtx.gridPad.left < o && (t.dCtx.xPadLeft = o / 2 + 1), t.dCtx.xPadRight = o / 2 + 1) : c(h, u);
    });
  } }]), s;
}(), n$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.dCtx = e;
  }
  return te(s, [{ key: "getyAxisLabelsCoords", value: function() {
    var e = this, t = this.w, i = [], n = 10, r = new Ws(this.dCtx.ctx);
    return t.config.yaxis.map(function(a, o) {
      var l = { seriesIndex: o, dataPointIndex: -1, w: t }, c = t.globals.yAxisScale[o], h = 0;
      if (!r.isYAxisHidden(o) && a.labels.show && a.labels.minWidth !== void 0 && (h = a.labels.minWidth), !r.isYAxisHidden(o) && a.labels.show && c.result.length) {
        var u = t.globals.yLabelFormatters[o], d = c.niceMin === Number.MIN_VALUE ? 0 : c.niceMin, f = c.result.reduce(function(v, y) {
          var w, S;
          return ((w = String(u(v, l))) === null || w === void 0 ? void 0 : w.length) > ((S = String(u(y, l))) === null || S === void 0 ? void 0 : S.length) ? v : y;
        }, d), p = f = u(f, l);
        if (f !== void 0 && f.length !== 0 || (f = c.niceMax), t.globals.isBarHorizontal) {
          n = 0;
          var g = t.globals.labels.slice();
          f = E.getLargestStringFromArr(g), f = u(f, { seriesIndex: o, dataPointIndex: -1, w: t }), p = e.dCtx.dimHelpers.getLargestStringFromMultiArr(f, g);
        }
        var m = new Z(e.dCtx.ctx), O = "rotate(".concat(a.labels.rotate, " 0 0)"), x = m.getTextRects(f, a.labels.style.fontSize, a.labels.style.fontFamily, O, !1), b = x;
        f !== p && (b = m.getTextRects(p, a.labels.style.fontSize, a.labels.style.fontFamily, O, !1)), i.push({ width: (h > b.width || h > x.width ? h : b.width > x.width ? b.width : x.width) + n, height: b.height > x.height ? b.height : x.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getyAxisTitleCoords", value: function() {
    var e = this, t = this.w, i = [];
    return t.config.yaxis.map(function(n, r) {
      if (n.show && n.title.text !== void 0) {
        var a = new Z(e.dCtx.ctx), o = "rotate(".concat(n.title.rotate, " 0 0)"), l = a.getTextRects(n.title.text, n.title.style.fontSize, n.title.style.fontFamily, o, !1);
        i.push({ width: l.width, height: l.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var e = this.w, t = 0, i = 0, n = 0, r = e.globals.yAxisScale.length > 1 ? 10 : 0, a = new Ws(this.dCtx.ctx), o = function(l, c) {
      var h = e.config.yaxis[c].floating, u = 0;
      l.width > 0 && !h ? (u = l.width + r, function(d) {
        return e.globals.ignoreYAxisIndexes.indexOf(d) > -1;
      }(c) && (u = u - l.width - r)) : u = h || a.isYAxisHidden(c) ? 0 : 5, e.config.yaxis[c].opposite ? n += u : i += u, t += u;
    };
    return e.globals.yLabelsCoords.map(function(l, c) {
      o(l, c);
    }), e.globals.yTitleCoords.map(function(l, c) {
      o(l, c);
    }), e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = n, t;
  } }]), s;
}(), r$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.dCtx = e;
  }
  return te(s, [{ key: "gridPadForColumnsInNumericAxis", value: function(e) {
    var t = this.w, i = t.config, n = t.globals;
    if (n.noData || n.collapsedSeries.length + n.ancillaryCollapsedSeries.length === i.series.length) return 0;
    var r = function(f) {
      return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(f);
    }, a = i.chart.type, o = 0, l = r(a) ? i.series.length : 1;
    n.comboBarCount > 0 && (l = n.comboBarCount), n.collapsedSeries.forEach(function(f) {
      r(f.type) && (l -= 1);
    }), i.chart.stacked && (l = 1);
    var c = r(a) || n.comboBarCount > 0, h = Math.abs(n.initialMaxX - n.initialMinX);
    if (c && n.isXNumeric && !n.isBarHorizontal && l > 0 && h !== 0) {
      h <= 3 && (h = n.dataPoints);
      var u = h / e, d = n.minXDiff && n.minXDiff / u > 0 ? n.minXDiff / u : 0;
      d > e / 2 && (d /= 2), (o = d * parseInt(i.plotOptions.bar.columnWidth, 10) / 100) < 1 && (o = 1), n.barPadForNumericAxis = o;
    }
    return o;
  } }, { key: "gridPadFortitleSubtitle", value: function() {
    var e = this, t = this.w, i = t.globals, n = this.dCtx.isSparkline || !i.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach(function(o) {
      t.config[o].text !== void 0 ? n += t.config[o].margin : n += e.dCtx.isSparkline || !i.axisCharts ? 0 : 5;
    }), !t.config.legend.show || t.config.legend.position !== "bottom" || t.config.legend.floating || i.axisCharts || (n += 10);
    var r = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), a = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    i.gridHeight -= r.height + a.height + n, i.translateY += r.height + a.height + n;
  } }, { key: "setGridXPosForDualYAxis", value: function(e, t) {
    var i = this.w, n = new Ws(this.dCtx.ctx);
    i.config.yaxis.forEach(function(r, a) {
      i.globals.ignoreYAxisIndexes.indexOf(a) !== -1 || r.floating || n.isYAxisHidden(a) || (r.opposite && (i.globals.translateX -= t[a].width + e[a].width + parseInt(r.labels.style.fontSize, 10) / 1.2 + 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
    });
  } }]), s;
}(), ec = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new i$(this), this.dimYAxis = new n$(this), this.dimXAxis = new s$(this), this.dimGrid = new r$(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return te(s, [{ key: "plotCoords", value: function() {
    var e = this, t = this.w, i = t.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var n = Array.isArray(t.config.stroke.width) ? Math.max.apply(Math, dt(t.config.stroke.width)) : t.config.stroke.width;
    this.isSparkline && ((t.config.markers.discrete.length > 0 || t.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(a) {
      var o = xy(a, 2), l = o[0], c = o[1];
      e.gridPad[l] = Math.max(c, e.w.globals.markers.largestSize / 1.5);
    }), this.gridPad.top = Math.max(n / 2, this.gridPad.top), this.gridPad.bottom = Math.max(n / 2, this.gridPad.bottom)), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var r = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
    i.gridWidth = i.gridWidth - 2 * r, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (r > 0 ? r : 0), i.translateY = i.translateY + this.gridPad.top;
  } }, { key: "setDimensionsForAxisCharts", value: function() {
    var e = this, t = this.w, i = t.globals, n = this.dimYAxis.getyAxisLabelsCoords(), r = this.dimYAxis.getyAxisTitleCoords();
    i.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), t.globals.yLabelsCoords = [], t.globals.yTitleCoords = [], t.config.yaxis.map(function(f, p) {
      t.globals.yLabelsCoords.push({ width: n[p].width, index: p }), t.globals.yTitleCoords.push({ width: r[p].width, index: p });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var a = this.dimXAxis.getxAxisLabelsCoords(), o = this.dimXAxis.getxAxisGroupLabelsCoords(), l = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(a, l, o), i.translateXAxisY = t.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = t.globals.rotateXLabels && t.globals.isXNumeric && t.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, t.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(t.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + t.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + t.config.xaxis.labels.offsetX;
    var c = this.yAxisWidth, h = this.xAxisHeight;
    i.xAxisLabelsHeight = this.xAxisHeight - l.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - a.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
    var u = 10;
    (t.config.chart.type === "radar" || this.isSparkline) && (c = 0, h = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || t.config.chart.type === "treemap") && (c = 0, h = 0, u = 0), this.isSparkline || t.config.chart.type === "treemap" || this.dimXAxis.additionalPaddingXLabels(a);
    var d = function() {
      i.translateX = c + e.datalabelsCoords.width, i.gridHeight = i.svgHeight - e.lgRect.height - h - (e.isSparkline || t.config.chart.type === "treemap" ? 0 : t.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - c - 2 * e.datalabelsCoords.width;
    };
    switch (t.config.xaxis.position === "top" && (u = i.xAxisHeight - t.config.xaxis.axisTicks.height - 5), t.config.legend.position) {
      case "bottom":
        i.translateY = u, d();
        break;
      case "top":
        i.translateY = this.lgRect.height + u, d();
        break;
      case "left":
        i.translateY = u, i.translateX = this.lgRect.width + c + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h - 12, i.gridWidth = i.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width;
        break;
      case "right":
        i.translateY = u, i.translateX = c + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h - 12, i.gridWidth = i.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(r, n), new Lp(this.ctx).setYAxisXPosition(n, r);
  } }, { key: "setDimensionsForNonAxisCharts", value: function() {
    var e = this.w, t = e.globals, i = e.config, n = 0;
    e.config.legend.show && !e.config.legend.floating && (n = 20);
    var r = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar", a = i.plotOptions[r].offsetY, o = i.plotOptions[r].offsetX;
    if (!i.legend.show || i.legend.floating) {
      t.gridHeight = t.svgHeight;
      var l = t.dom.elWrap.getBoundingClientRect().width;
      return t.gridWidth = Math.min(l, t.gridHeight), t.translateY = a, void (t.translateX = o + (t.svgWidth - t.gridWidth) / 2);
    }
    switch (i.legend.position) {
      case "bottom":
        t.gridHeight = t.svgHeight - this.lgRect.height, t.gridWidth = t.svgWidth, t.translateY = a - 10, t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "top":
        t.gridHeight = t.svgHeight - this.lgRect.height, t.gridWidth = t.svgWidth, t.translateY = this.lgRect.height + a + 10, t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "left":
        t.gridWidth = t.svgWidth - this.lgRect.width - n, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = a, t.translateX = o + this.lgRect.width + n;
        break;
      case "right":
        t.gridWidth = t.svgWidth - this.lgRect.width - n - 5, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = a, t.translateX = o + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "conditionalChecksForAxisCoords", value: function(e, t, i) {
    var n = this.w, r = n.globals.hasXaxisGroups ? 2 : 1, a = i.height + e.height + t.height, o = n.globals.isMultiLineX ? 1.2 : n.globals.LINE_HEIGHT_RATIO, l = n.globals.rotateXLabels ? 22 : 10, c = n.globals.rotateXLabels && n.config.legend.position === "bottom" ? 10 : 0;
    this.xAxisHeight = a * o + r * l + c, this.xAxisWidth = e.width, this.xAxisHeight - t.height > n.config.xaxis.labels.maxHeight && (this.xAxisHeight = n.config.xaxis.labels.maxHeight), n.config.xaxis.labels.minHeight && this.xAxisHeight < n.config.xaxis.labels.minHeight && (this.xAxisHeight = n.config.xaxis.labels.minHeight), n.config.xaxis.floating && (this.xAxisHeight = 0);
    var h = 0, u = 0;
    n.config.yaxis.forEach(function(d) {
      h += d.labels.minWidth, u += d.labels.maxWidth;
    }), this.yAxisWidth < h && (this.yAxisWidth = h), this.yAxisWidth > u && (this.yAxisWidth = u);
  } }]), s;
}(), a$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.lgCtx = e;
  }
  return te(s, [{ key: "getLegendStyles", value: function() {
    var e, t, i, n = document.createElement("style");
    n.setAttribute("type", "text/css");
    var r = ((e = this.lgCtx.ctx) === null || e === void 0 || (t = e.opts) === null || t === void 0 || (i = t.chart) === null || i === void 0 ? void 0 : i.nonce) || this.w.config.chart.nonce;
    r && n.setAttribute("nonce", r);
    var a = document.createTextNode(`
      .apexcharts-flip-y {
        transform: scaleY(-1) translateY(-100%);
        transform-origin: top;
        transform-box: fill-box;
      }
      .apexcharts-flip-x {
        transform: scaleX(-1);
        transform-origin: center;
        transform-box: fill-box;
      }
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apexcharts-legend-group-horizontal {
        flex-direction: column;
      }
      .apexcharts-legend-group {
        display: flex;
      }
      .apexcharts-legend-group-vertical {
        flex-direction: column-reverse;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
        align-items: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
        align-items: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
        align-items: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 1px;
      }

      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }

    `);
    return n.appendChild(a), n;
  } }, { key: "getLegendDimensions", value: function() {
    var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), t = e.width;
    return { clwh: e.height, clww: t };
  } }, { key: "appendToForeignObject", value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: "toggleDataSeries", value: function(e, t) {
    var i = this, n = this.w;
    if (n.globals.axisCharts || n.config.chart.type === "radialBar") {
      n.globals.resized = !0;
      var r = null, a = null;
      n.globals.risingSeries = [], n.globals.axisCharts ? (r = n.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")), a = parseInt(r.getAttribute("data:realIndex"), 10)) : (r = n.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")), a = parseInt(r.getAttribute("rel"), 10) - 1), t ? [{ cs: n.globals.collapsedSeries, csi: n.globals.collapsedSeriesIndices }, { cs: n.globals.ancillaryCollapsedSeries, csi: n.globals.ancillaryCollapsedSeriesIndices }].forEach(function(h) {
        i.riseCollapsedSeries(h.cs, h.csi, a);
      }) : this.hideSeries({ seriesEl: r, realIndex: a });
    } else {
      var o = n.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(e + 1, "'] path")), l = n.config.chart.type;
      if (l === "pie" || l === "polarArea" || l === "donut") {
        var c = n.config.plotOptions.pie.donut.labels;
        new Z(this.lgCtx.ctx).pathMouseDown(o, null), this.lgCtx.ctx.pie.printDataLabelsInner(o.node, c);
      }
      o.fire("click");
    }
  } }, { key: "getSeriesAfterCollapsing", value: function(e) {
    var t = e.realIndex, i = this.w, n = i.globals, r = E.clone(i.config.series);
    if (n.axisCharts) {
      var a = i.config.yaxis[n.seriesYAxisReverseMap[t]], o = { index: t, data: r[t].data.slice(), type: r[t].type || i.config.chart.type };
      if (a && a.show && a.showAlways) n.ancillaryCollapsedSeriesIndices.indexOf(t) < 0 && (n.ancillaryCollapsedSeries.push(o), n.ancillaryCollapsedSeriesIndices.push(t));
      else if (n.collapsedSeriesIndices.indexOf(t) < 0) {
        n.collapsedSeries.push(o), n.collapsedSeriesIndices.push(t);
        var l = n.risingSeries.indexOf(t);
        n.risingSeries.splice(l, 1);
      }
    } else n.collapsedSeries.push({ index: t, data: r[t] }), n.collapsedSeriesIndices.push(t);
    return n.allSeriesCollapsed = n.collapsedSeries.length + n.ancillaryCollapsedSeries.length === i.config.series.length, this._getSeriesBasedOnCollapsedState(r);
  } }, { key: "hideSeries", value: function(e) {
    for (var t = e.seriesEl, i = e.realIndex, n = this.w, r = this.getSeriesAfterCollapsing({ realIndex: i }), a = t.childNodes, o = 0; o < a.length; o++) a[o].classList.contains("apexcharts-series-markers-wrap") && (a[o].classList.contains("apexcharts-hide") ? a[o].classList.remove("apexcharts-hide") : a[o].classList.add("apexcharts-hide"));
    this.lgCtx.ctx.updateHelpers._updateSeries(r, n.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "riseCollapsedSeries", value: function(e, t, i) {
    var n = this.w, r = E.clone(n.config.series);
    if (e.length > 0) {
      for (var a = 0; a < e.length; a++) e[a].index === i && (n.globals.axisCharts ? r[i].data = e[a].data.slice() : r[i] = e[a].data, typeof r[i] != "number" && (r[i].hidden = !1), e.splice(a, 1), t.splice(a, 1), n.globals.risingSeries.push(i));
      r = this._getSeriesBasedOnCollapsedState(r), this.lgCtx.ctx.updateHelpers._updateSeries(r, n.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: "_getSeriesBasedOnCollapsedState", value: function(e) {
    var t = this.w, i = 0;
    return t.globals.axisCharts ? e.forEach(function(n, r) {
      t.globals.collapsedSeriesIndices.indexOf(r) < 0 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(r) < 0 || (e[r].data = [], i++);
    }) : e.forEach(function(n, r) {
      !t.globals.collapsedSeriesIndices.indexOf(r) < 0 && (e[r] = 0, i++);
    }), t.globals.allSeriesCollapsed = i === e.length, e;
  } }]), s;
}(), Gy = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new a$(this);
  }
  return te(s, [{ key: "init", value: function() {
    var e = this.w, t = e.globals, i = e.config, n = i.legend.showForSingleSeries && t.series.length === 1 || this.isBarsDistributed || t.series.length > 1;
    if (this.legendHelpers.appendToForeignObject(), (n || !t.axisCharts) && i.legend.show) {
      for (; t.dom.elLegendWrap.firstChild; ) t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
      this.drawLegends(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : i.legend.position !== "right" && i.legend.position !== "left" || this.legendAlignVertical();
    }
  } }, { key: "createLegendMarker", value: function(e) {
    var t = e.i, i = e.fillcolor, n = this.w, r = document.createElement("span");
    r.classList.add("apexcharts-legend-marker");
    var a = n.config.legend.markers.shape || n.config.markers.shape, o = a;
    Array.isArray(a) && (o = a[t]);
    var l = Array.isArray(n.config.legend.markers.size) ? parseFloat(n.config.legend.markers.size[t]) : parseFloat(n.config.legend.markers.size), c = Array.isArray(n.config.legend.markers.offsetX) ? parseFloat(n.config.legend.markers.offsetX[t]) : parseFloat(n.config.legend.markers.offsetX), h = Array.isArray(n.config.legend.markers.offsetY) ? parseFloat(n.config.legend.markers.offsetY[t]) : parseFloat(n.config.legend.markers.offsetY), u = Array.isArray(n.config.legend.markers.strokeWidth) ? parseFloat(n.config.legend.markers.strokeWidth[t]) : parseFloat(n.config.legend.markers.strokeWidth), d = r.style;
    if (d.height = 2 * (l + u) + "px", d.width = 2 * (l + u) + "px", d.left = c + "px", d.top = h + "px", n.config.legend.markers.customHTML) d.background = "transparent", d.color = i[t], Array.isArray(n.config.legend.markers.customHTML) ? n.config.legend.markers.customHTML[t] && (r.innerHTML = n.config.legend.markers.customHTML[t]()) : r.innerHTML = n.config.legend.markers.customHTML();
    else {
      var f = new Rr(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(o), seriesIndex: t, strokeWidth: u, size: l }), p = window.SVG().addTo(r).size("100%", "100%"), g = new Z(this.ctx).drawMarker(0, 0, F(F({}, f), {}, { pointFillColor: Array.isArray(i) ? i[t] : f.pointFillColor, shape: o }));
      n.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach(function(m) {
        m.node.classList.contains("apexcharts-marker-triangle") ? m.node.style.transform = "translate(50%, 45%)" : m.node.style.transform = "translate(50%, 50%)";
      }), p.add(g);
    }
    return r;
  } }, { key: "drawLegends", value: function() {
    var e = this, t = this, i = this.w, n = i.config.legend.fontFamily, r = i.globals.seriesNames, a = i.config.legend.markers.fillColors ? i.config.legend.markers.fillColors.slice() : i.globals.colors.slice();
    if (i.config.chart.type === "heatmap") {
      var o = i.config.plotOptions.heatmap.colorScale.ranges;
      r = o.map(function(f) {
        return f.name ? f.name : f.from + " - " + f.to;
      }), a = o.map(function(f) {
        return f.color;
      });
    } else this.isBarsDistributed && (r = i.globals.labels.slice());
    i.config.legend.customLegendItems.length && (r = i.config.legend.customLegendItems);
    var l = i.globals.legendFormatter, c = i.config.legend.inverseOrder, h = [];
    i.globals.seriesGroups.length > 1 && i.config.legend.clusterGroupedSeries && i.globals.seriesGroups.forEach(function(f, p) {
      h[p] = document.createElement("div"), h[p].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(p)), i.config.legend.clusterGroupedSeriesOrientation === "horizontal" ? i.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h[p].classList.add("apexcharts-legend-group-vertical");
    });
    for (var u = function(f) {
      var p, g = l(r[f], { seriesIndex: f, w: i }), m = !1, O = !1;
      if (i.globals.collapsedSeries.length > 0) for (var x = 0; x < i.globals.collapsedSeries.length; x++) i.globals.collapsedSeries[x].index === f && (m = !0);
      if (i.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var b = 0; b < i.globals.ancillaryCollapsedSeriesIndices.length; b++) i.globals.ancillaryCollapsedSeriesIndices[b] === f && (O = !0);
      var v = e.createLegendMarker({ i: f, fillcolor: a });
      Z.setAttrs(v, { rel: f + 1, "data:collapsed": m || O }), (m || O) && v.classList.add("apexcharts-inactive-legend");
      var y = document.createElement("div"), w = document.createElement("span");
      w.classList.add("apexcharts-legend-text"), w.innerHTML = Array.isArray(g) ? g.join(" ") : g;
      var S = i.config.legend.labels.useSeriesColors ? i.globals.colors[f] : Array.isArray(i.config.legend.labels.colors) ? (p = i.config.legend.labels.colors) === null || p === void 0 ? void 0 : p[f] : i.config.legend.labels.colors;
      S || (S = i.config.chart.foreColor), w.style.color = S, w.style.fontSize = parseFloat(i.config.legend.fontSize) + "px", w.style.fontWeight = i.config.legend.fontWeight, w.style.fontFamily = n || i.config.chart.fontFamily, Z.setAttrs(w, { rel: f + 1, i: f, "data:default-text": encodeURIComponent(g), "data:collapsed": m || O }), y.appendChild(v), y.appendChild(w);
      var k = new st(e.ctx);
      i.config.legend.showForZeroSeries || k.getSeriesTotalByIndex(f) === 0 && k.seriesHaveSameValues(f) && !k.isSeriesNull(f) && i.globals.collapsedSeriesIndices.indexOf(f) === -1 && i.globals.ancillaryCollapsedSeriesIndices.indexOf(f) === -1 && y.classList.add("apexcharts-hidden-zero-series"), i.config.legend.showForNullSeries || k.isSeriesNull(f) && i.globals.collapsedSeriesIndices.indexOf(f) === -1 && i.globals.ancillaryCollapsedSeriesIndices.indexOf(f) === -1 && y.classList.add("apexcharts-hidden-null-series"), h.length ? i.globals.seriesGroups.forEach(function(A, T) {
        var C;
        A.includes((C = i.config.series[f]) === null || C === void 0 ? void 0 : C.name) && (i.globals.dom.elLegendWrap.appendChild(h[T]), h[T].appendChild(y));
      }) : i.globals.dom.elLegendWrap.appendChild(y), i.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i.config.legend.horizontalAlign)), i.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i.config.legend.position), y.classList.add("apexcharts-legend-series"), y.style.margin = "".concat(i.config.legend.itemMargin.vertical, "px ").concat(i.config.legend.itemMargin.horizontal, "px"), i.globals.dom.elLegendWrap.style.width = i.config.legend.width ? i.config.legend.width + "px" : "", i.globals.dom.elLegendWrap.style.height = i.config.legend.height ? i.config.legend.height + "px" : "", Z.setAttrs(y, { rel: f + 1, seriesName: E.escapeString(r[f]), "data:collapsed": m || O }), (m || O) && y.classList.add("apexcharts-inactive-legend"), i.config.legend.onItemClick.toggleDataSeries || y.classList.add("apexcharts-no-click");
    }, d = c ? r.length - 1 : 0; c ? d >= 0 : d <= r.length - 1; c ? d-- : d++) u(d);
    i.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), i.config.legend.onItemHover.highlightDataSeries && i.config.legend.customLegendItems.length === 0 && (i.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), i.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
  } }, { key: "setLegendWrapXY", value: function(e, t) {
    var i = this.w, n = i.globals.dom.elLegendWrap, r = n.clientHeight, a = 0, o = 0;
    if (i.config.legend.position === "bottom") o = i.globals.svgHeight - Math.min(r, i.globals.svgHeight / 2) - 5;
    else if (i.config.legend.position === "top") {
      var l = new ec(this.ctx), c = l.dimHelpers.getTitleSubtitleCoords("title").height, h = l.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      o = (c > 0 ? c - 10 : 0) + (h > 0 ? h - 10 : 0);
    }
    n.style.position = "absolute", a = a + e + i.config.legend.offsetX, o = o + t + i.config.legend.offsetY, n.style.left = a + "px", n.style.top = o + "px", i.config.legend.position === "right" && (n.style.left = "auto", n.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(u) {
      n.style[u] && (n.style[u] = parseInt(i.config.legend[u], 10) + "px");
    });
  } }, { key: "legendAlignHorizontal", value: function() {
    var e = this.w;
    e.globals.dom.elLegendWrap.style.right = 0;
    var t = new ec(this.ctx), i = t.dimHelpers.getTitleSubtitleCoords("title"), n = t.dimHelpers.getTitleSubtitleCoords("subtitle"), r = 0;
    e.config.legend.position === "top" && (r = i.height + n.height + e.config.title.margin + e.config.subtitle.margin - 10), this.setLegendWrapXY(20, r);
  } }, { key: "legendAlignVertical", value: function() {
    var e = this.w, t = this.legendHelpers.getLegendDimensions(), i = 0;
    e.config.legend.position === "left" && (i = 20), e.config.legend.position === "right" && (i = e.globals.svgWidth - t.clww - 10), this.setLegendWrapXY(i, 20);
  } }, { key: "onLegendHovered", value: function(e) {
    var t = this.w, i = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
    if (t.config.chart.type === "heatmap" || this.isBarsDistributed) {
      if (i) {
        var n = parseInt(e.target.getAttribute("rel"), 10) - 1;
        this.ctx.events.fireEvent("legendHover", [this.ctx, n, this.w]), new pi(this.ctx).highlightRangeInSeries(e, e.target);
      }
    } else !e.target.classList.contains("apexcharts-inactive-legend") && i && new pi(this.ctx).toggleSeriesOnHover(e, e.target);
  } }, { key: "onLegendClick", value: function(e) {
    var t = this.w;
    if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
      var i = parseInt(e.target.getAttribute("rel"), 10) - 1, n = e.target.getAttribute("data:collapsed") === "true", r = this.w.config.chart.events.legendClick;
      typeof r == "function" && r(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
      var a = this.w.config.legend.markers.onClick;
      typeof a == "function" && e.target.classList.contains("apexcharts-legend-marker") && (a(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), t.config.chart.type !== "treemap" && t.config.chart.type !== "heatmap" && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, n);
    }
  } }]), s;
}(), Ky = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = t.globals.minX, this.maxX = t.globals.maxX;
  }
  return te(s, [{ key: "createToolbar", value: function() {
    var e = this, t = this.w, i = function() {
      return document.createElement("div");
    }, n = i();
    if (n.setAttribute("class", "apexcharts-toolbar"), n.style.top = t.config.chart.toolbar.offsetY + "px", n.style.right = 3 - t.config.chart.toolbar.offsetX + "px", t.globals.dom.elWrap.appendChild(n), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = t.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var r = 0; r < this.t.customIcons.length; r++) this.elCustomIcons.push(i());
    var a = [], o = function(u, d, f) {
      var p = u.toLowerCase();
      e.t[p] && t.config.chart.zoom.enabled && a.push({ el: d, icon: typeof e.t[p] == "string" ? e.t[p] : f, title: e.localeValues[u], class: "apexcharts-".concat(p, "-icon") });
    };
    o("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), o("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
    var l = function(u) {
      e.t[u] && t.config.chart[u].enabled && a.push({ el: u === "zoom" ? e.elZoom : e.elSelection, icon: typeof e.t[u] == "string" ? e.t[u] : u === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: e.localeValues[u === "zoom" ? "selectionZoom" : "selection"], class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(u, "-icon") });
    };
    l("zoom"), l("selection"), this.t.pan && t.config.chart.zoom.enabled && a.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && a.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var c = 0; c < this.elCustomIcons.length; c++) a.push({ el: this.elCustomIcons[c], icon: this.t.customIcons[c].icon, title: this.t.customIcons[c].title, index: this.t.customIcons[c].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[c].class });
    a.forEach(function(u, d) {
      u.index && E.moveIndexInArray(a, d, u.index);
    });
    for (var h = 0; h < a.length; h++) Z.setAttrs(a[h].el, { class: a[h].class, title: a[h].title }), a[h].el.innerHTML = a[h].icon, n.appendChild(a[h].el);
    this._createHamburgerMenu(n), t.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: "_createHamburgerMenu", value: function(e) {
    this.elMenuItems = [], e.appendChild(this.elMenu), Z.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var t = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i = 0; i < t.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = t[i].title, Z.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(t[i].name), title: t[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
  } }, { key: "addToolbarEventListeners", value: function() {
    var e = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
      i.classList.contains("exportSVG") ? i.addEventListener("click", e.handleDownload.bind(e, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", e.handleDownload.bind(e, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", e.handleDownload.bind(e, "csv"));
    });
    for (var t = 0; t < this.t.customIcons.length; t++) this.elCustomIcons[t].addEventListener("click", this.t.customIcons[t].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleZoomSelection", value: function(e) {
    this.ctx.getSyncedCharts().forEach(function(t) {
      t.ctx.toolbar.toggleOtherControls();
      var i = e === "selection" ? t.ctx.toolbar.elSelection : t.ctx.toolbar.elZoom, n = e === "selection" ? "selectionEnabled" : "zoomEnabled";
      t.w.globals[n] = !t.w.globals[n], i.classList.contains(t.ctx.toolbar.selectedClass) ? i.classList.remove(t.ctx.toolbar.selectedClass) : i.classList.add(t.ctx.toolbar.selectedClass);
    });
  } }, { key: "getToolbarIconsReference", value: function() {
    var e = this.w;
    this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZoomPanFromToolbar", value: function(e) {
    this.toggleOtherControls(), e === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
    var t = e === "pan" ? this.elPan : this.elZoom, i = e === "pan" ? this.elZoom : this.elPan;
    t && t.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
  } }, { key: "togglePanning", value: function() {
    this.ctx.getSyncedCharts().forEach(function(e) {
      e.ctx.toolbar.toggleOtherControls(), e.w.globals.panEnabled = !e.w.globals.panEnabled, e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass);
    });
  } }, { key: "toggleOtherControls", value: function() {
    var e = this, t = this.w;
    t.globals.panEnabled = !1, t.globals.zoomEnabled = !1, t.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
      i && i.classList.remove(e.selectedClass);
    });
  } }, { key: "handleZoomIn", value: function() {
    var e = this.w;
    e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY);
    var t = (this.minX + this.maxX) / 2, i = (this.minX + t) / 2, n = (this.maxX + t) / 2, r = this._getNewMinXMaxX(i, n);
    e.globals.disableZoomIn || this.zoomUpdateOptions(r.minX, r.maxX);
  } }, { key: "handleZoomOut", value: function() {
    var e = this.w;
    if (e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY), !(e.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
      var t = (this.minX + this.maxX) / 2, i = this.minX - (t - this.minX), n = this.maxX - (t - this.maxX), r = this._getNewMinXMaxX(i, n);
      e.globals.disableZoomOut || this.zoomUpdateOptions(r.minX, r.maxX);
    }
  } }, { key: "_getNewMinXMaxX", value: function(e, t) {
    var i = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i ? Math.floor(e) : e, maxX: i ? Math.floor(t) : t };
  } }, { key: "zoomUpdateOptions", value: function(e, t) {
    var i = this.w;
    if (e !== void 0 || t !== void 0) {
      if (!(i.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1, t = i.globals.dataPoints), t - e < 2))) {
        var n = { min: e, max: t }, r = this.getBeforeZoomRange(n);
        r && (n = r.xaxis);
        var a = { xaxis: n }, o = E.clone(i.globals.initialConfig.yaxis);
        i.config.chart.group || (a.yaxis = o), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(a, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(n, o);
      }
    } else this.handleZoomReset();
  } }, { key: "zoomCallback", value: function(e, t) {
    typeof this.ev.zoomed == "function" && (this.ev.zoomed(this.ctx, { xaxis: e, yaxis: t }), this.ctx.events.fireEvent("zoomed", { xaxis: e, yaxis: t }));
  } }, { key: "getBeforeZoomRange", value: function(e, t) {
    var i = null;
    return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: e, yaxis: t })), i;
  } }, { key: "toggleMenu", value: function() {
    var e = this;
    window.setTimeout(function() {
      e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open");
    }, 0);
  } }, { key: "handleDownload", value: function(e) {
    var t = this.w, i = new ha(this.ctx);
    switch (e) {
      case "svg":
        i.exportToSVG(this.ctx);
        break;
      case "png":
        i.exportToPng(this.ctx);
        break;
      case "csv":
        i.exportToCSV({ series: t.config.series, columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: "handleZoomReset", value: function(e) {
    this.ctx.getSyncedCharts().forEach(function(t) {
      var i = t.w;
      if (i.globals.lastXAxis.min = i.globals.initialConfig.xaxis.min, i.globals.lastXAxis.max = i.globals.initialConfig.xaxis.max, t.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.beforeResetZoom == "function") {
        var n = i.config.chart.events.beforeResetZoom(t, i);
        n && t.updateHelpers.revertDefaultAxisMinMax(n);
      }
      typeof i.config.chart.events.zoomed == "function" && t.ctx.toolbar.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1;
      var r = t.ctx.series.emptyCollapsedSeries(E.clone(i.globals.initialSeries));
      t.updateHelpers._updateSeries(r, i.config.chart.animations.dynamicAnimation.enabled);
    });
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), s;
}(), o$ = function(s) {
  ho(t, Ky);
  var e = co(t);
  function t(i) {
    var n;
    return ee(this, t), (n = e.call(this, i)).ctx = i, n.w = i.w, n.dragged = !1, n.graphics = new Z(n.ctx), n.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], n.clientX = 0, n.clientY = 0, n.startX = 0, n.endX = 0, n.dragX = 0, n.startY = 0, n.endY = 0, n.dragY = 0, n.moveDirection = "none", n.debounceTimer = null, n.debounceDelay = 100, n.wheelDelay = 400, n;
  }
  return te(t, [{ key: "init", value: function(i) {
    var n = this, r = i.xyRatios, a = this.w, o = this;
    this.xyRatios = r, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new it(0, 0, a.globals.gridWidth, a.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a.globals.dom.Paper.add(this.zoomRect), a.globals.dom.Paper.add(this.selectionRect), a.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a.globals.gridWidth, maxY: a.globals.gridHeight }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : a.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a.globals.gridWidth }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(l) {
      n.hoverArea.addEventListener(l, o.svgMouseEvents.bind(o, r), { capture: !1, passive: !0 });
    }), a.config.chart.zoom.enabled && a.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", o.mouseWheelEvent.bind(o), { capture: !1, passive: !1 });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(i, n) {
    var r = this.w, a = this.ctx.toolbar, o = r.globals.zoomEnabled ? r.config.chart.zoom.type : r.config.chart.selection.type, l = r.config.chart.toolbar.autoSelected;
    if (n.shiftKey ? (this.shiftWasPressed = !0, a.enableZoomPanFromToolbar(l === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (a.enableZoomPanFromToolbar(l), this.shiftWasPressed = !1), n.target) {
      var c, h = n.target.classList;
      if (n.target.parentNode && n.target.parentNode !== null && (c = n.target.parentNode.classList), !(h.contains("apexcharts-legend-marker") || h.contains("apexcharts-legend-text") || c && c.contains("apexcharts-toolbar"))) {
        if (this.clientX = n.type === "touchmove" || n.type === "touchstart" ? n.touches[0].clientX : n.type === "touchend" ? n.changedTouches[0].clientX : n.clientX, this.clientY = n.type === "touchmove" || n.type === "touchstart" ? n.touches[0].clientY : n.type === "touchend" ? n.changedTouches[0].clientY : n.clientY, n.type === "mousedown" && n.which === 1 || n.type === "touchstart") {
          var u = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - u.left - r.globals.barPadForNumericAxis, this.startY = this.clientY - u.top, this.dragged = !1, this.w.globals.mousedown = !0;
        }
        (n.type === "mousemove" && n.which === 1 || n.type === "touchmove") && (this.dragged = !0, r.globals.panEnabled ? (r.globals.selection = null, this.w.globals.mousedown && this.panDragging({ context: this, zoomtype: o, xyRatios: i })) : (this.w.globals.mousedown && r.globals.zoomEnabled || this.w.globals.mousedown && r.globals.selectionEnabled) && (this.selection = this.selectionDrawing({ context: this, zoomtype: o }))), n.type !== "mouseup" && n.type !== "touchend" && n.type !== "mouseleave" || this.handleMouseUp({ zoomtype: o }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: "handleMouseUp", value: function(i) {
    var n, r = i.zoomtype, a = i.isResized, o = this.w, l = (n = this.gridRect) === null || n === void 0 ? void 0 : n.getBoundingClientRect();
    l && (this.w.globals.mousedown || a) && (this.endX = this.clientX - l.left - o.globals.barPadForNumericAxis, this.endY = this.clientY - l.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (o.globals.zoomEnabled || o.globals.selectionEnabled) && this.selectionDrawn({ context: this, zoomtype: r })), o.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = !1, this.w.globals.mousedown = !1;
  } }, { key: "mouseWheelEvent", value: function(i) {
    var n = this, r = this.w;
    i.preventDefault();
    var a = Date.now();
    a - r.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(i), r.globals.lastWheelExecution = a), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function() {
      a - r.globals.lastWheelExecution > n.wheelDelay && (n.executeMouseWheelZoom(i), r.globals.lastWheelExecution = a);
    }, this.debounceDelay);
  } }, { key: "executeMouseWheelZoom", value: function(i) {
    var n, r = this.w;
    this.minX = r.globals.isRangeBar ? r.globals.minY : r.globals.minX, this.maxX = r.globals.isRangeBar ? r.globals.maxY : r.globals.maxX;
    var a = (n = this.gridRect) === null || n === void 0 ? void 0 : n.getBoundingClientRect();
    if (a) {
      var o, l, c, h = (i.clientX - a.left) / a.width, u = this.minX, d = this.maxX, f = d - u;
      if (i.deltaY < 0) {
        var p = u + h * f;
        l = p - (o = 0.5 * f) / 2, c = p + o / 2;
      } else l = u - (o = 1.5 * f) / 2, c = d + o / 2;
      if (!r.globals.isRangeBar) {
        l = Math.max(l, r.globals.initialMinX), c = Math.min(c, r.globals.initialMaxX);
        var g = 0.01 * (r.globals.initialMaxX - r.globals.initialMinX);
        if (c - l < g) {
          var m = (l + c) / 2;
          l = m - g / 2, c = m + g / 2;
        }
      }
      var O = this._getNewMinXMaxX(l, c);
      isNaN(O.minX) || isNaN(O.maxX) || this.zoomUpdateOptions(O.minX, O.maxX);
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var i = this, n = this.w;
    if (this.selectionRect) {
      var r = this.selectionRect.node.getBoundingClientRect();
      r.width > 0 && r.height > 0 && (this.selectionRect.select(!1).resize(!1), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(a, o, l, c, h) {
        return h === "l" || h === "r" ? a.circle(8).css({ "stroke-width": 1, stroke: "#333", fill: "#fff" }) : a.circle(0);
      }, updateHandle: function(a, o) {
        return a.center(o[0], o[1]);
      } }).resize().on("resize", function() {
        var a = n.globals.zoomEnabled ? n.config.chart.zoom.type : n.config.chart.selection.type;
        i.handleMouseUp({ zoomtype: a, isResized: !0 });
      }));
    }
  } }, { key: "preselectedSelection", value: function() {
    var i = this.w, n = this.xyRatios;
    if (!i.globals.zoomEnabled) {
      if (i.globals.selection !== void 0 && i.globals.selection !== null) this.drawSelectionRect(F(F({}, i.globals.selection), {}, { translateX: i.globals.translateX, translateY: i.globals.translateY }));
      else if (i.config.chart.selection.xaxis.min !== void 0 && i.config.chart.selection.xaxis.max !== void 0) {
        var r = (i.config.chart.selection.xaxis.min - i.globals.minX) / n.xRatio, a = i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / n.xRatio - r;
        i.globals.isRangeBar && (r = (i.config.chart.selection.xaxis.min - i.globals.yAxisScale[0].niceMin) / n.invertedYRatio, a = (i.config.chart.selection.xaxis.max - i.config.chart.selection.xaxis.min) / n.invertedYRatio);
        var o = { x: r, y: 0, width: a, height: i.globals.gridHeight, translateX: i.globals.translateX, translateY: i.globals.translateY, selectionEnabled: !0 };
        this.drawSelectionRect(o), this.makeSelectionRectDraggable(), typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(this.ctx, { xaxis: { min: i.config.chart.selection.xaxis.min, max: i.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(i) {
    var n = i.x, r = i.y, a = i.width, o = i.height, l = i.translateX, c = l === void 0 ? 0 : l, h = i.translateY, u = h === void 0 ? 0 : h, d = this.w, f = this.zoomRect, p = this.selectionRect;
    if (this.dragged || d.globals.selection !== null) {
      var g = { transform: "translate(" + c + ", " + u + ")" };
      d.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), f.attr({ x: n, y: r, width: a, height: o, fill: d.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": d.config.chart.zoom.zoomedArea.fill.opacity, stroke: d.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": d.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": d.config.chart.zoom.zoomedArea.stroke.opacity }), Z.setAttrs(f.node, g)), d.globals.selectionEnabled && (p.attr({ x: n, y: r, width: a > 0 ? a : 0, height: o > 0 ? o : 0, fill: d.config.chart.selection.fill.color, "fill-opacity": d.config.chart.selection.fill.opacity, stroke: d.config.chart.selection.stroke.color, "stroke-width": d.config.chart.selection.stroke.width, "stroke-dasharray": d.config.chart.selection.stroke.dashArray, "stroke-opacity": d.config.chart.selection.stroke.opacity }), Z.setAttrs(p.node, g));
    }
  } }, { key: "hideSelectionRect", value: function(i) {
    i && i.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(i) {
    var n = i.context, r = i.zoomtype, a = this.w, o = n, l = this.gridRect.getBoundingClientRect(), c = o.startX - 1, h = o.startY, u = !1, d = !1, f = o.clientX - l.left - a.globals.barPadForNumericAxis, p = o.clientY - l.top, g = f - c, m = p - h, O = { translateX: a.globals.translateX, translateY: a.globals.translateY };
    return Math.abs(g + c) > a.globals.gridWidth ? g = a.globals.gridWidth - c : f < 0 && (g = c), c > f && (u = !0, g = Math.abs(g)), h > p && (d = !0, m = Math.abs(m)), O = F(F({}, O = r === "x" ? { x: u ? c - g : c, y: 0, width: g, height: a.globals.gridHeight } : r === "y" ? { x: 0, y: d ? h - m : h, width: a.globals.gridWidth, height: m } : { x: u ? c - g : c, y: d ? h - m : h, width: g, height: m }), {}, { translateX: a.globals.translateX, translateY: a.globals.translateY }), o.drawSelectionRect(O), o.selectionDragging("resizing"), O;
  } }, { key: "selectionDragging", value: function(i, n) {
    var r = this, a = this.w;
    if (n) {
      n.preventDefault();
      var o = n.detail, l = o.handler, c = o.box, h = c.x, u = c.y;
      h < this.constraints.x && (h = this.constraints.x), u < this.constraints.y && (u = this.constraints.y), c.x2 > this.constraints.x2 && (h = this.constraints.x2 - c.w), c.y2 > this.constraints.y2 && (u = this.constraints.y2 - c.h), l.move(h, u);
      var d = this.xyRatios, f = this.selectionRect, p = 0;
      i === "resizing" && (p = 30);
      var g = function(O) {
        return parseFloat(f.node.getAttribute(O));
      }, m = { x: g("x"), y: g("y"), width: g("width"), height: g("height") };
      a.globals.selection = m, typeof a.config.chart.events.selection == "function" && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var O, x, b, v, y = r.gridRect.getBoundingClientRect(), w = f.node.getBoundingClientRect();
        a.globals.isRangeBar ? (O = a.globals.yAxisScale[0].niceMin + (w.left - y.left) * d.invertedYRatio, x = a.globals.yAxisScale[0].niceMin + (w.right - y.left) * d.invertedYRatio, b = 0, v = 1) : (O = a.globals.xAxisScale.niceMin + (w.left - y.left) * d.xRatio, x = a.globals.xAxisScale.niceMin + (w.right - y.left) * d.xRatio, b = a.globals.yAxisScale[0].niceMin + (y.bottom - w.bottom) * d.yRatio[0], v = a.globals.yAxisScale[0].niceMax - (w.top - y.top) * d.yRatio[0]);
        var S = { xaxis: { min: O, max: x }, yaxis: { min: b, max: v } };
        a.config.chart.events.selection(r.ctx, S), a.config.chart.brush.enabled && a.config.chart.events.brushScrolled !== void 0 && a.config.chart.events.brushScrolled(r.ctx, S);
      }, p));
    }
  } }, { key: "selectionDrawn", value: function(i) {
    var n, r, a = i.context, o = i.zoomtype, l = this.w, c = a, h = this.xyRatios, u = this.ctx.toolbar, d = l.globals.zoomEnabled ? c.zoomRect.node.getBoundingClientRect() : c.selectionRect.node.getBoundingClientRect(), f = c.gridRect.getBoundingClientRect(), p = d.left - f.left - l.globals.barPadForNumericAxis, g = d.right - f.left - l.globals.barPadForNumericAxis, m = d.top - f.top, O = d.bottom - f.top;
    l.globals.isRangeBar ? (n = l.globals.yAxisScale[0].niceMin + p * h.invertedYRatio, r = l.globals.yAxisScale[0].niceMin + g * h.invertedYRatio) : (n = l.globals.xAxisScale.niceMin + p * h.xRatio, r = l.globals.xAxisScale.niceMin + g * h.xRatio);
    var x = [], b = [];
    if (l.config.yaxis.forEach(function(T, C) {
      var P = l.globals.seriesYAxisMap[C][0], $ = l.globals.yAxisScale[C].niceMax - h.yRatio[P] * m, R = l.globals.yAxisScale[C].niceMax - h.yRatio[P] * O;
      x.push($), b.push(R);
    }), c.dragged && (c.dragX > 10 || c.dragY > 10) && n !== r) {
      if (l.globals.zoomEnabled) {
        var v = E.clone(l.globals.initialConfig.yaxis), y = E.clone(l.globals.initialConfig.xaxis);
        if (l.globals.zoomed = !0, l.config.xaxis.convertedCatToNumeric && (n = Math.floor(n), r = Math.floor(r), n < 1 && (n = 1, r = l.globals.dataPoints), r - n < 2 && (r = n + 1)), o !== "xy" && o !== "x" || (y = { min: n, max: r }), o !== "xy" && o !== "y" || v.forEach(function(T, C) {
          v[C].min = b[C], v[C].max = x[C];
        }), u) {
          var w = u.getBeforeZoomRange(y, v);
          w && (y = w.xaxis ? w.xaxis : y, v = w.yaxis ? w.yaxis : v);
        }
        var S = { xaxis: y };
        l.config.chart.group || (S.yaxis = v), c.ctx.updateHelpers._updateOptions(S, !1, c.w.config.chart.animations.dynamicAnimation.enabled), typeof l.config.chart.events.zoomed == "function" && u.zoomCallback(y, v);
      } else if (l.globals.selectionEnabled) {
        var k, A = null;
        k = { min: n, max: r }, o !== "xy" && o !== "y" || (A = E.clone(l.config.yaxis)).forEach(function(T, C) {
          A[C].min = b[C], A[C].max = x[C];
        }), l.globals.selection = c.selection, typeof l.config.chart.events.selection == "function" && l.config.chart.events.selection(c.ctx, { xaxis: k, yaxis: A });
      }
    }
  } }, { key: "panDragging", value: function(i) {
    var n = i.context, r = this.w, a = n;
    if (r.globals.lastClientPosition.x !== void 0) {
      var o = r.globals.lastClientPosition.x - a.clientX, l = r.globals.lastClientPosition.y - a.clientY;
      Math.abs(o) > Math.abs(l) && o > 0 ? this.moveDirection = "left" : Math.abs(o) > Math.abs(l) && o < 0 ? this.moveDirection = "right" : Math.abs(l) > Math.abs(o) && l > 0 ? this.moveDirection = "up" : Math.abs(l) > Math.abs(o) && l < 0 && (this.moveDirection = "down");
    }
    r.globals.lastClientPosition = { x: a.clientX, y: a.clientY };
    var c = r.globals.isRangeBar ? r.globals.minY : r.globals.minX, h = r.globals.isRangeBar ? r.globals.maxY : r.globals.maxX;
    a.panScrolled(c, h);
  } }, { key: "panScrolled", value: function(i, n) {
    var r = this.w, a = this.xyRatios, o = E.clone(r.globals.initialConfig.yaxis), l = a.xRatio, c = r.globals.minX, h = r.globals.maxX;
    r.globals.isRangeBar && (l = a.invertedYRatio, c = r.globals.minY, h = r.globals.maxY), this.moveDirection === "left" ? (i = c + r.globals.gridWidth / 15 * l, n = h + r.globals.gridWidth / 15 * l) : this.moveDirection === "right" && (i = c - r.globals.gridWidth / 15 * l, n = h - r.globals.gridWidth / 15 * l), r.globals.isRangeBar || (i < r.globals.initialMinX || n > r.globals.initialMaxX) && (i = c, n = h);
    var u = { xaxis: { min: i, max: n } };
    r.config.chart.group || (u.yaxis = o), this.updateScrolledChart(u, i, n);
  } }, { key: "updateScrolledChart", value: function(i, n, r) {
    var a = this.w;
    if (this.ctx.updateHelpers._updateOptions(i, !1, !1), typeof a.config.chart.events.scrolled == "function") {
      var o = { xaxis: { min: n, max: r } };
      a.config.chart.events.scrolled(this.ctx, o), this.ctx.events.fireEvent("scrolled", o);
    }
  } }]), t;
}(), Jy = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx;
  }
  return te(s, [{ key: "getNearestValues", value: function(e) {
    var t = e.hoverArea, i = e.elGrid, n = e.clientX, r = e.clientY, a = this.w, o = i.getBoundingClientRect(), l = o.width, c = o.height, h = l / (a.globals.dataPoints - 1), u = c / a.globals.dataPoints, d = this.hasBars();
    !a.globals.comboCharts && !d || a.config.xaxis.convertedCatToNumeric || (h = l / a.globals.dataPoints);
    var f = n - o.left - a.globals.barPadForNumericAxis, p = r - o.top;
    f < 0 || p < 0 || f > l || p > c ? (t.classList.remove("hovering-zoom"), t.classList.remove("hovering-pan")) : a.globals.zoomEnabled ? (t.classList.remove("hovering-pan"), t.classList.add("hovering-zoom")) : a.globals.panEnabled && (t.classList.remove("hovering-zoom"), t.classList.add("hovering-pan"));
    var g = Math.round(f / h), m = Math.floor(p / u);
    d && !a.config.xaxis.convertedCatToNumeric && (g = Math.ceil(f / h), g -= 1);
    var O = null, x = null, b = a.globals.seriesXvalues.map(function(k) {
      return k.filter(function(A) {
        return E.isNumber(A);
      });
    }), v = a.globals.seriesYvalues.map(function(k) {
      return k.filter(function(A) {
        return E.isNumber(A);
      });
    });
    if (a.globals.isXNumeric) {
      var y = this.ttCtx.getElGrid().getBoundingClientRect(), w = f * (y.width / l), S = p * (y.height / c);
      O = (x = this.closestInMultiArray(w, S, b, v)).index, g = x.j, O !== null && a.globals.hasNullValues && (b = a.globals.seriesXvalues[O], g = (x = this.closestInArray(w, b)).j);
    }
    return a.globals.capturedSeriesIndex = O === null ? -1 : O, (!g || g < 1) && (g = 0), a.globals.isBarHorizontal ? a.globals.capturedDataPointIndex = m : a.globals.capturedDataPointIndex = g, { capturedSeries: O, j: a.globals.isBarHorizontal ? m : g, hoverX: f, hoverY: p };
  } }, { key: "getFirstActiveXArray", value: function(e) {
    for (var t = this.w, i = 0, n = e.map(function(a, o) {
      return a.length > 0 ? o : -1;
    }), r = 0; r < n.length; r++) if (n[r] !== -1 && t.globals.collapsedSeriesIndices.indexOf(r) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(r) === -1) {
      i = n[r];
      break;
    }
    return i;
  } }, { key: "closestInMultiArray", value: function(e, t, i, n) {
    for (var r, a = this.w, o = 1 / 0, l = null, c = null, h = 0; h < i.length; h++) if (r = h, a.globals.collapsedSeriesIndices.indexOf(r) === -1 && a.globals.ancillaryCollapsedSeriesIndices.indexOf(r) === -1) for (var u = i[h], d = n[h], f = Math.min(u.length, d.length), p = 0; p < f; p++) {
      var g = e - u[p], m = Math.sqrt(g * g);
      if (!a.globals.allSeriesHasEqualX) {
        var O = t - d[p];
        m = Math.sqrt(g * g + O * O);
      }
      m < o && (o = m, l = h, c = p);
    }
    return { index: l, j: c };
  } }, { key: "closestInArray", value: function(e, t) {
    for (var i = t[0], n = null, r = Math.abs(e - i), a = 0; a < t.length; a++) {
      var o = Math.abs(e - t[a]);
      o < r && (r = o, n = a);
    }
    return { j: n };
  } }, { key: "isXoverlap", value: function(e) {
    var t = [], i = this.w.globals.seriesX.filter(function(r) {
      return r[0] !== void 0;
    });
    if (i.length > 0) for (var n = 0; n < i.length - 1; n++) i[n][e] !== void 0 && i[n + 1][e] !== void 0 && i[n][e] !== i[n + 1][e] && t.push("unEqual");
    return t.length === 0;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var e = !0, t = this.w.globals.initialSeries, i = 0; i < t.length - 1; i++) if (t[i].data.length !== t[i + 1].data.length) {
      e = !1;
      break;
    }
    return e;
  } }, { key: "getBarsHeight", value: function(e) {
    return dt(e).reduce(function(t, i) {
      return t + i.getBBox().height;
    }, 0);
  } }, { key: "getElMarkers", value: function(e) {
    return typeof e == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
  } }, { key: "getAllMarkers", value: function() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], i = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
    i = dt(i), t && (i = i.filter(function(r) {
      var a = Number(r.getAttribute("data:realIndex"));
      return e.w.globals.collapsedSeriesIndices.indexOf(a) === -1;
    })), i.sort(function(r, a) {
      var o = Number(r.getAttribute("data:realIndex")), l = Number(a.getAttribute("data:realIndex"));
      return l < o ? 1 : l > o ? -1 : 0;
    });
    var n = [];
    return i.forEach(function(r) {
      n.push(r.querySelector(".apexcharts-marker"));
    }), n;
  } }, { key: "hasMarkers", value: function(e) {
    return this.getElMarkers(e).length > 0;
  } }, { key: "getPathFromPoint", value: function(e, t) {
    var i = Number(e.getAttribute("cx")), n = Number(e.getAttribute("cy")), r = e.getAttribute("shape");
    return new Z(this.ctx).getMarkerPath(i, n, r, t);
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "getHoverMarkerSize", value: function(e) {
    var t = this.w, i = t.config.markers.hover.size;
    return i === void 0 && (i = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset), i;
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(e) {
    var t = this.w, i = this.ttCtx;
    i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var n = i.allTooltipSeriesGroups, r = 0; r < n.length; r++) e === "enable" ? (n[r].classList.add("apexcharts-active"), n[r].style.display = t.config.tooltip.items.display) : (n[r].classList.remove("apexcharts-active"), n[r].style.display = "none");
  } }]), s;
}(), l$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Jy(e);
  }
  return te(s, [{ key: "drawSeriesTexts", value: function(e) {
    var t = e.shared, i = t === void 0 || t, n = e.ttItems, r = e.i, a = r === void 0 ? 0 : r, o = e.j, l = o === void 0 ? null : o, c = e.y1, h = e.y2, u = e.e, d = this.w;
    d.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: a, j: l, y1: c, y2: h, w: d }) : this.toggleActiveInactiveSeries(i, a);
    var f = this.getValuesToPrint({ i: a, j: l });
    this.printLabels({ i: a, j: l, values: f, ttItems: n, shared: i, e: u });
    var p = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(e) {
    var t, i = this, n = e.i, r = e.j, a = e.values, o = e.ttItems, l = e.shared, c = e.e, h = this.w, u = [], d = function(y) {
      return h.globals.seriesGoals[y] && h.globals.seriesGoals[y][r] && Array.isArray(h.globals.seriesGoals[y][r]);
    }, f = a.xVal, p = a.zVal, g = a.xAxisTTVal, m = "", O = h.globals.colors[n];
    r !== null && h.config.plotOptions.bar.distributed && (O = h.globals.colors[r]);
    for (var x = function(y, w) {
      var S = i.getFormatters(n);
      m = i.getSeriesName({ fn: S.yLbTitleFormatter, index: n, seriesIndex: n, j: r }), h.config.chart.type === "treemap" && (m = S.yLbTitleFormatter(String(h.config.series[n].data[r].x), { series: h.globals.series, seriesIndex: n, dataPointIndex: r, w: h }));
      var k = h.config.tooltip.inverseOrder ? w : y;
      if (h.globals.axisCharts) {
        var A = function(P) {
          var $, R, X, M;
          return h.globals.isRangeData ? S.yLbFormatter(($ = h.globals.seriesRangeStart) === null || $ === void 0 || (R = $[P]) === null || R === void 0 ? void 0 : R[r], { series: h.globals.seriesRangeStart, seriesIndex: P, dataPointIndex: r, w: h }) + " - " + S.yLbFormatter((X = h.globals.seriesRangeEnd) === null || X === void 0 || (M = X[P]) === null || M === void 0 ? void 0 : M[r], { series: h.globals.seriesRangeEnd, seriesIndex: P, dataPointIndex: r, w: h }) : S.yLbFormatter(h.globals.series[P][r], { series: h.globals.series, seriesIndex: P, dataPointIndex: r, w: h });
        };
        if (l) S = i.getFormatters(k), m = i.getSeriesName({ fn: S.yLbTitleFormatter, index: k, seriesIndex: n, j: r }), O = h.globals.colors[k], t = A(k), d(k) && (u = h.globals.seriesGoals[k][r].map(function(P) {
          return { attrs: P, val: S.yLbFormatter(P.value, { seriesIndex: k, dataPointIndex: r, w: h }) };
        }));
        else {
          var T, C = c == null || (T = c.target) === null || T === void 0 ? void 0 : T.getAttribute("fill");
          C && (C.indexOf("url") !== -1 ? C.indexOf("Pattern") !== -1 && (O = h.globals.dom.baseEl.querySelector(C.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : O = C), t = A(n), d(n) && Array.isArray(h.globals.seriesGoals[n][r]) && (u = h.globals.seriesGoals[n][r].map(function(P) {
            return { attrs: P, val: S.yLbFormatter(P.value, { seriesIndex: n, dataPointIndex: r, w: h }) };
          }));
        }
      }
      r === null && (t = S.yLbFormatter(h.globals.series[n], F(F({}, h), {}, { seriesIndex: n, dataPointIndex: n }))), i.DOMHandling({ i: n, t: k, j: r, ttItems: o, values: { val: t, goalVals: u, xVal: f, xAxisTTVal: g, zVal: p }, seriesName: m, shared: l, pColor: O });
    }, b = 0, v = h.globals.series.length - 1; b < h.globals.series.length; b++, v--) x(b, v);
  } }, { key: "getFormatters", value: function(e) {
    var t, i = this.w, n = i.globals.yLabelFormatters[e];
    return i.globals.ttVal !== void 0 ? Array.isArray(i.globals.ttVal) ? (n = i.globals.ttVal[e] && i.globals.ttVal[e].formatter, t = i.globals.ttVal[e] && i.globals.ttVal[e].title && i.globals.ttVal[e].title.formatter) : (n = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter == "function" && (t = i.globals.ttVal.title.formatter)) : t = i.config.tooltip.y.title.formatter, typeof n != "function" && (n = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(r) {
      return r;
    }), typeof t != "function" && (t = function(r) {
      return r ? r + ": " : "";
    }), { yLbFormatter: n, yLbTitleFormatter: t };
  } }, { key: "getSeriesName", value: function(e) {
    var t = e.fn, i = e.index, n = e.seriesIndex, r = e.j, a = this.w;
    return t(String(a.globals.seriesNames[i]), { series: a.globals.series, seriesIndex: n, dataPointIndex: r, w: a });
  } }, { key: "DOMHandling", value: function(e) {
    e.i;
    var t = e.t, i = e.j, n = e.ttItems, r = e.values, a = e.seriesName, o = e.shared, l = e.pColor, c = this.w, h = this.ttCtx, u = r.val, d = r.goalVals, f = r.xVal, p = r.xAxisTTVal, g = r.zVal, m = null;
    m = n[t].children, c.config.tooltip.fillSeriesColor && (n[t].style.backgroundColor = l, m[0].style.display = "none"), h.showTooltipTitle && (h.tooltipTitle === null && (h.tooltipTitle = c.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h.tooltipTitle.innerHTML = f), h.isXAxisTooltipEnabled && (h.xaxisTooltipText.innerHTML = p !== "" ? p : f);
    var O = n[t].querySelector(".apexcharts-tooltip-text-y-label");
    O && (O.innerHTML = a || "");
    var x = n[t].querySelector(".apexcharts-tooltip-text-y-value");
    x && (x.innerHTML = u !== void 0 ? u : ""), m[0] && m[0].classList.contains("apexcharts-tooltip-marker") && (c.config.tooltip.marker.fillColors && Array.isArray(c.config.tooltip.marker.fillColors) && (l = c.config.tooltip.marker.fillColors[t]), c.config.tooltip.fillSeriesColor ? m[0].style.backgroundColor = l : m[0].style.color = l), c.config.tooltip.marker.show || (m[0].style.display = "none");
    var b = n[t].querySelector(".apexcharts-tooltip-text-goals-label"), v = n[t].querySelector(".apexcharts-tooltip-text-goals-value");
    if (d.length && c.globals.seriesGoals[t]) {
      var y = function() {
        var k = "<div>", A = "<div>";
        d.forEach(function(T, C) {
          k += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(T.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(T.attrs.name, "</div>"), A += "<div>".concat(T.val, "</div>");
        }), b.innerHTML = k + "</div>", v.innerHTML = A + "</div>";
      };
      o ? c.globals.seriesGoals[t][i] && Array.isArray(c.globals.seriesGoals[t][i]) ? y() : (b.innerHTML = "", v.innerHTML = "") : y();
    } else b.innerHTML = "", v.innerHTML = "";
    if (g !== null && (n[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = c.config.tooltip.z.title, n[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = g !== void 0 ? g : ""), o && m[0]) {
      if (c.config.tooltip.hideEmptySeries) {
        var w = n[t].querySelector(".apexcharts-tooltip-marker"), S = n[t].querySelector(".apexcharts-tooltip-text");
        parseFloat(u) == 0 ? (w.style.display = "none", S.style.display = "none") : (w.style.display = "block", S.style.display = "block");
      }
      u == null || c.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || c.globals.collapsedSeriesIndices.indexOf(t) > -1 || Array.isArray(h.tConfig.enabledOnSeries) && h.tConfig.enabledOnSeries.indexOf(t) === -1 ? m[0].parentNode.style.display = "none" : m[0].parentNode.style.display = c.config.tooltip.items.display;
    } else Array.isArray(h.tConfig.enabledOnSeries) && h.tConfig.enabledOnSeries.indexOf(t) === -1 && (m[0].parentNode.style.display = "none");
  } }, { key: "toggleActiveInactiveSeries", value: function(e, t) {
    var i = this.w;
    if (e) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var n = i.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(t));
      n && (n.classList.add("apexcharts-active"), n.style.display = i.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(e) {
    var t = e.i, i = e.j, n = this.w, r = this.ctx.series.filteredSeriesX(), a = "", o = "", l = null, c = null, h = { series: n.globals.series, seriesIndex: t, dataPointIndex: i, w: n }, u = n.globals.ttZFormatter;
    i === null ? c = n.globals.series[t] : n.globals.isXNumeric && n.config.chart.type !== "treemap" ? (a = r[t][i], r[t].length === 0 && (a = r[this.tooltipUtil.getFirstActiveXArray(r)][i])) : a = new _p(this.ctx).isFormatXY() ? n.config.series[t].data[i] !== void 0 ? n.config.series[t].data[i].x : "" : n.globals.labels[i] !== void 0 ? n.globals.labels[i] : "";
    var d = a;
    return n.globals.isXNumeric && n.config.xaxis.type === "datetime" ? a = new go(this.ctx).xLabelFormat(n.globals.ttKeyFormatter, d, d, { i: void 0, dateFormatter: new xt(this.ctx).formatDate, w: this.w }) : a = n.globals.isBarHorizontal ? n.globals.yLabelFormatters[0](d, h) : n.globals.xLabelFormatter(d, h), n.config.tooltip.x.formatter !== void 0 && (a = n.globals.ttKeyFormatter(d, h)), n.globals.seriesZ.length > 0 && n.globals.seriesZ[t].length > 0 && (l = u(n.globals.seriesZ[t][i], n)), o = typeof n.config.xaxis.tooltip.formatter == "function" ? n.globals.xaxisTooltipFormatter(d, h) : a, { val: Array.isArray(c) ? c.join(" ") : c, xVal: Array.isArray(a) ? a.join(" ") : a, xAxisTTVal: Array.isArray(o) ? o.join(" ") : o, zVal: l };
  } }, { key: "handleCustomTooltip", value: function(e) {
    var t = e.i, i = e.j, n = e.y1, r = e.y2, a = e.w, o = this.ttCtx.getElTooltip(), l = a.config.tooltip.custom;
    Array.isArray(l) && l[t] && (l = l[t]);
    var c = l({ ctx: this.ctx, series: a.globals.series, seriesIndex: t, dataPointIndex: i, y1: n, y2: r, w: a });
    typeof c == "string" || typeof c == "number" ? o.innerHTML = c : (c instanceof Element || typeof c.nodeName == "string") && (o.innerHTML = "", o.appendChild(c.cloneNode(!0)));
  } }]), s;
}(), ev = function() {
  function s(e) {
    ee(this, s), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w;
  }
  return te(s, [{ key: "moveXCrosshairs", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.ttCtx, n = this.w, r = i.getElXCrosshairs(), a = e - i.xcrosshairsWidth / 2, o = n.globals.labels.slice().length;
    if (t !== null && (a = n.globals.gridWidth / o * t), r === null || n.globals.isBarHorizontal || (r.setAttribute("x", a), r.setAttribute("x1", a), r.setAttribute("x2", a), r.setAttribute("y2", n.globals.gridHeight), r.classList.add("apexcharts-active")), a < 0 && (a = 0), a > n.globals.gridWidth && (a = n.globals.gridWidth), i.isXAxisTooltipEnabled) {
      var l = a;
      n.config.xaxis.crosshairs.width !== "tickWidth" && n.config.xaxis.crosshairs.width !== "barWidth" || (l = a + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(l);
    }
  } }, { key: "moveYCrosshairs", value: function(e) {
    var t = this.ttCtx;
    t.ycrosshairs !== null && Z.setAttrs(t.ycrosshairs, { y1: e, y2: e }), t.ycrosshairsHidden !== null && Z.setAttrs(t.ycrosshairsHidden, { y1: e, y2: e });
  } }, { key: "moveXAxisTooltip", value: function(e) {
    var t = this.w, i = this.ttCtx;
    if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
      i.xaxisTooltip.classList.add("apexcharts-active");
      var n = i.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY;
      if (e -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(e)) {
        e += t.globals.translateX;
        var r;
        r = new Z(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = r.width + "px", i.xaxisTooltip.style.left = e + "px", i.xaxisTooltip.style.top = n + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(e) {
    var t = this.w, i = this.ttCtx;
    i.yaxisTTEls === null && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var n = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), r = t.globals.translateY + n, a = i.yaxisTTEls[e].getBoundingClientRect(), o = a.height, l = t.globals.translateYAxisX[e] - 2;
    t.config.yaxis[e].opposite && (l -= a.width), r -= o / 2, t.globals.ignoreYAxisIndexes.indexOf(e) === -1 && r > 0 && r < t.globals.gridHeight ? (i.yaxisTTEls[e].classList.add("apexcharts-active"), i.yaxisTTEls[e].style.top = r + "px", i.yaxisTTEls[e].style.left = l + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active");
  } }, { key: "moveTooltip", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = this.w, r = this.ttCtx, a = r.getElTooltip(), o = r.tooltipRect, l = i !== null ? parseFloat(i) : 1, c = parseFloat(e) + l + 5, h = parseFloat(t) + l / 2;
    if (c > n.globals.gridWidth / 2 && (c = c - o.ttWidth - l - 10), c > n.globals.gridWidth - o.ttWidth - 10 && (c = n.globals.gridWidth - o.ttWidth), c < -20 && (c = -20), n.config.tooltip.followCursor) {
      var u = r.getElGrid().getBoundingClientRect();
      (c = r.e.clientX - u.left) > n.globals.gridWidth / 2 && (c -= r.tooltipRect.ttWidth), (h = r.e.clientY + n.globals.translateY - u.top) > n.globals.gridHeight / 2 && (h -= r.tooltipRect.ttHeight);
    } else n.globals.isBarHorizontal || o.ttHeight / 2 + h > n.globals.gridHeight && (h = n.globals.gridHeight - o.ttHeight + n.globals.translateY);
    isNaN(c) || (c += n.globals.translateX, a.style.left = c + "px", a.style.top = h + "px");
  } }, { key: "moveMarkers", value: function(e, t) {
    var i = this.w, n = this.ttCtx;
    if (i.globals.markers.size[e] > 0) for (var r = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), a = 0; a < r.length; a++) parseInt(r[a].getAttribute("rel"), 10) === t && (n.marker.resetPointsSize(), n.marker.enlargeCurrentPoint(t, r[a]));
    else n.marker.resetPointsSize(), this.moveDynamicPointOnHover(t, e);
  } }, { key: "moveDynamicPointOnHover", value: function(e, t) {
    var i, n, r, a, o = this.w, l = this.ttCtx, c = new Z(this.ctx), h = o.globals.pointsArray, u = l.tooltipUtil.getHoverMarkerSize(t), d = o.config.series[t].type;
    if (!d || d !== "column" && d !== "candlestick" && d !== "boxPlot") {
      r = (i = h[t][e]) === null || i === void 0 ? void 0 : i[0], a = ((n = h[t][e]) === null || n === void 0 ? void 0 : n[1]) || 0;
      var f = o.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers path"));
      if (f && a < o.globals.gridHeight && a > 0) {
        var p = f.getAttribute("shape"), g = c.getMarkerPath(r, a, p, 1.5 * u);
        f.setAttribute("d", g);
      }
      this.moveXCrosshairs(r), l.fixedTooltip || this.moveTooltip(r, a, u);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(e) {
    var t, i = this.ttCtx, n = i.w, r = 0, a = 0, o = n.globals.pointsArray, l = new pi(this.ctx), c = new Z(this.ctx);
    t = l.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
    var h = i.tooltipUtil.getHoverMarkerSize(t);
    if (o[t] && (r = o[t][e][0], a = o[t][e][1]), !isNaN(r)) {
      var u = i.tooltipUtil.getAllMarkers();
      if (u.length) for (var d = 0; d < n.globals.series.length; d++) {
        var f = o[d];
        if (n.globals.comboCharts && f === void 0 && u.splice(d, 0, null), f && f.length) {
          var p = o[d][e][1], g = void 0;
          u[d].setAttribute("cx", r);
          var m = u[d].getAttribute("shape");
          if (n.config.chart.type === "rangeArea" && !n.globals.comboCharts) {
            var O = e + n.globals.series[d].length;
            g = o[d][O][1], p -= Math.abs(p - g) / 2;
          }
          if (p !== null && !isNaN(p) && p < n.globals.gridHeight + h && p + h > 0) {
            var x = c.getMarkerPath(r, p, m, h);
            u[d].setAttribute("d", x);
          } else u[d].setAttribute("d", "");
        }
      }
      this.moveXCrosshairs(r), i.fixedTooltip || this.moveTooltip(r, a || n.globals.gridHeight, h);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(e, t) {
    var i = this.w, n = this.ttCtx, r = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length;
    i.config.chart.stacked && (r = i.globals.barGroups.length);
    var a = r >= 2 && r % 2 == 0 ? Math.floor(r / 2) : Math.floor(r / 2) + 1;
    i.globals.isBarHorizontal && (a = new pi(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    var o = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(a, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(e, "']"));
    o || typeof t != "number" || (o = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, "']")));
    var l = o ? parseFloat(o.getAttribute("cx")) : 0, c = o ? parseFloat(o.getAttribute("cy")) : 0, h = o ? parseFloat(o.getAttribute("barWidth")) : 0, u = n.getElGrid().getBoundingClientRect(), d = o && (o.classList.contains("apexcharts-candlestick-area") || o.classList.contains("apexcharts-boxPlot-area"));
    i.globals.isXNumeric ? (o && !d && (l -= r % 2 != 0 ? h / 2 : 0), o && d && (l -= h / 2)) : i.globals.isBarHorizontal || (l = n.xAxisTicksPositions[e - 1] + n.dataPointsDividedWidth / 2, isNaN(l) && (l = n.xAxisTicksPositions[e] - n.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? c -= n.tooltipRect.ttHeight : i.config.tooltip.followCursor ? c = n.e.clientY - u.top - n.tooltipRect.ttHeight / 2 : c + n.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (c = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(l), n.fixedTooltip || this.moveTooltip(l, c || i.globals.gridHeight);
  } }]), s;
}(), c$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new ev(e);
  }
  return te(s, [{ key: "drawDynamicPoints", value: function() {
    var e = this.w, t = new Z(this.ctx), i = new Rr(this.ctx), n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    n = dt(n), e.config.chart.stacked && n.sort(function(u, d) {
      return parseFloat(u.getAttribute("data:realIndex")) - parseFloat(d.getAttribute("data:realIndex"));
    });
    for (var r = 0; r < n.length; r++) {
      var a = n[r].querySelector(".apexcharts-series-markers-wrap");
      if (a !== null) {
        var o = void 0, l = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        e.config.chart.type !== "line" && e.config.chart.type !== "area" || e.globals.comboCharts || e.config.tooltip.intersect || (l += " no-pointer-events");
        var c = i.getMarkerConfig({ cssClass: l, seriesIndex: Number(a.getAttribute("data:realIndex")) });
        (o = t.drawMarker(0, 0, c)).node.setAttribute("default-marker-size", 0);
        var h = document.createElementNS(e.globals.SVGNS, "g");
        h.classList.add("apexcharts-series-markers"), h.appendChild(o.node), a.appendChild(h);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, r = this.w;
    r.config.chart.type !== "bubble" && this.newPointSize(e, t);
    var a = t.getAttribute("cx"), o = t.getAttribute("cy");
    if (i !== null && n !== null && (a = i, o = n), this.tooltipPosition.moveXCrosshairs(a), !this.fixedTooltip) {
      if (r.config.chart.type === "radar") {
        var l = this.ttCtx.getElGrid().getBoundingClientRect();
        a = this.ttCtx.e.clientX - l.left;
      }
      this.tooltipPosition.moveTooltip(a, o, r.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(e) {
    for (var t = this.w, i = this, n = this.ttCtx, r = e, a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o = t.config.markers.hover.size, l = 0; l < a.length; l++) {
      var c = a[l].getAttribute("rel"), h = a[l].getAttribute("index");
      if (o === void 0 && (o = t.globals.markers.size[h] + t.config.markers.hover.sizeOffset), r === parseInt(c, 10)) {
        i.newPointSize(r, a[l]);
        var u = a[l].getAttribute("cx"), d = a[l].getAttribute("cy");
        i.tooltipPosition.moveXCrosshairs(u), n.fixedTooltip || i.tooltipPosition.moveTooltip(u, d, o);
      } else i.oldPointSize(a[l]);
    }
  } }, { key: "newPointSize", value: function(e, t) {
    var i = this.w, n = i.config.markers.hover.size, r = e === 0 ? t.parentNode.firstChild : t.parentNode.lastChild;
    if (r.getAttribute("default-marker-size") !== "0") {
      var a = parseInt(r.getAttribute("index"), 10);
      n === void 0 && (n = i.globals.markers.size[a] + i.config.markers.hover.sizeOffset), n < 0 && (n = 0);
      var o = this.ttCtx.tooltipUtil.getPathFromPoint(t, n);
      t.setAttribute("d", o);
    }
  } }, { key: "oldPointSize", value: function(e) {
    var t = parseFloat(e.getAttribute("default-marker-size")), i = this.ttCtx.tooltipUtil.getPathFromPoint(e, t);
    e.setAttribute("d", i);
  } }, { key: "resetPointsSize", value: function() {
    for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
      var i = parseFloat(e[t].getAttribute("default-marker-size"));
      if (E.isNumber(i) && i > 0) {
        var n = this.ttCtx.tooltipUtil.getPathFromPoint(e[t], i);
        e[t].setAttribute("d", n);
      } else e[t].setAttribute("d", "M0,0");
    }
  } }]), s;
}(), h$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w;
    var t = this.w;
    this.ttCtx = e, this.isVerticalGroupedRangeBar = !t.globals.isBarHorizontal && t.config.chart.type === "rangeBar" && t.config.plotOptions.bar.rangeBarGroupRows;
  }
  return te(s, [{ key: "getAttr", value: function(e, t) {
    return parseFloat(e.target.getAttribute(t));
  } }, { key: "handleHeatTreeTooltip", value: function(e) {
    var t = e.e, i = e.opt, n = e.x, r = e.y, a = e.type, o = this.ttCtx, l = this.w;
    if (t.target.classList.contains("apexcharts-".concat(a, "-rect"))) {
      var c = this.getAttr(t, "i"), h = this.getAttr(t, "j"), u = this.getAttr(t, "cx"), d = this.getAttr(t, "cy"), f = this.getAttr(t, "width"), p = this.getAttr(t, "height");
      if (o.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: c, j: h, shared: !1, e: t }), l.globals.capturedSeriesIndex = c, l.globals.capturedDataPointIndex = h, n = u + o.tooltipRect.ttWidth / 2 + f, r = d + o.tooltipRect.ttHeight / 2 - p / 2, o.tooltipPosition.moveXCrosshairs(u + f / 2), n > l.globals.gridWidth / 2 && (n = u - o.tooltipRect.ttWidth / 2 + f), o.w.config.tooltip.followCursor) {
        var g = l.globals.dom.elWrap.getBoundingClientRect();
        n = l.globals.clientX - g.left - (n > l.globals.gridWidth / 2 ? o.tooltipRect.ttWidth : 0), r = l.globals.clientY - g.top - (r > l.globals.gridHeight / 2 ? o.tooltipRect.ttHeight : 0);
      }
    }
    return { x: n, y: r };
  } }, { key: "handleMarkerTooltip", value: function(e) {
    var t, i, n = e.e, r = e.opt, a = e.x, o = e.y, l = this.w, c = this.ttCtx;
    if (n.target.classList.contains("apexcharts-marker")) {
      var h = parseInt(r.paths.getAttribute("cx"), 10), u = parseInt(r.paths.getAttribute("cy"), 10), d = parseFloat(r.paths.getAttribute("val"));
      if (i = parseInt(r.paths.getAttribute("rel"), 10), t = parseInt(r.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, c.intersect) {
        var f = E.findAncestor(r.paths, "apexcharts-series");
        f && (t = parseInt(f.getAttribute("data:realIndex"), 10));
      }
      if (c.tooltipLabels.drawSeriesTexts({ ttItems: r.ttItems, i: t, j: i, shared: !c.showOnIntersect && l.config.tooltip.shared, e: n }), n.type === "mouseup" && c.markerClick(n, t, i), l.globals.capturedSeriesIndex = t, l.globals.capturedDataPointIndex = i, a = h, o = u + l.globals.translateY - 1.4 * c.tooltipRect.ttHeight, c.w.config.tooltip.followCursor) {
        var p = c.getElGrid().getBoundingClientRect();
        o = c.e.clientY + l.globals.translateY - p.top;
      }
      d < 0 && (o = u), c.marker.enlargeCurrentPoint(i, r.paths, a, o);
    }
    return { x: a, y: o };
  } }, { key: "handleBarTooltip", value: function(e) {
    var t, i, n = e.e, r = e.opt, a = this.w, o = this.ttCtx, l = o.getElTooltip(), c = 0, h = 0, u = 0, d = this.getBarTooltipXY({ e: n, opt: r });
    if (d.j !== null || d.barHeight !== 0 || d.barWidth !== 0) {
      t = d.i;
      var f = d.j;
      if (a.globals.capturedSeriesIndex = t, a.globals.capturedDataPointIndex = f, a.globals.isBarHorizontal && o.tooltipUtil.hasBars() || !a.config.tooltip.shared ? (h = d.x, u = d.y, i = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[t] : a.config.stroke.width, c = h) : a.globals.comboCharts || a.config.tooltip.shared || (c /= 2), isNaN(u) && (u = a.globals.svgHeight - o.tooltipRect.ttHeight), parseInt(r.paths.parentNode.getAttribute("data:realIndex"), 10), h + o.tooltipRect.ttWidth > a.globals.gridWidth ? h -= o.tooltipRect.ttWidth : h < 0 && (h = 0), o.w.config.tooltip.followCursor) {
        var p = o.getElGrid().getBoundingClientRect();
        u = o.e.clientY - p.top;
      }
      o.tooltip === null && (o.tooltip = a.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), a.config.tooltip.shared || (a.globals.comboBarCount > 0 ? o.tooltipPosition.moveXCrosshairs(c + i / 2) : o.tooltipPosition.moveXCrosshairs(c)), !o.fixedTooltip && (!a.config.tooltip.shared || a.globals.isBarHorizontal && o.tooltipUtil.hasBars()) && (u = u + a.globals.translateY - o.tooltipRect.ttHeight / 2, l.style.left = h + a.globals.translateX + "px", l.style.top = u + "px");
    }
  } }, { key: "getBarTooltipXY", value: function(e) {
    var t = this, i = e.e, n = e.opt, r = this.w, a = null, o = this.ttCtx, l = 0, c = 0, h = 0, u = 0, d = 0, f = i.target.classList;
    if (f.contains("apexcharts-bar-area") || f.contains("apexcharts-candlestick-area") || f.contains("apexcharts-boxPlot-area") || f.contains("apexcharts-rangebar-area")) {
      var p = i.target, g = p.getBoundingClientRect(), m = n.elGrid.getBoundingClientRect(), O = g.height;
      d = g.height;
      var x = g.width, b = parseInt(p.getAttribute("cx"), 10), v = parseInt(p.getAttribute("cy"), 10);
      u = parseFloat(p.getAttribute("barWidth"));
      var y = i.type === "touchmove" ? i.touches[0].clientX : i.clientX;
      a = parseInt(p.getAttribute("j"), 10), l = parseInt(p.parentNode.getAttribute("rel"), 10) - 1;
      var w = p.getAttribute("data-range-y1"), S = p.getAttribute("data-range-y2");
      r.globals.comboCharts && (l = parseInt(p.parentNode.getAttribute("data:realIndex"), 10));
      var k = function(T) {
        return r.globals.isXNumeric ? b - x / 2 : t.isVerticalGroupedRangeBar ? b + x / 2 : b - o.dataPointsDividedWidth + x / 2;
      }, A = function() {
        return v - o.dataPointsDividedHeight + O / 2 - o.tooltipRect.ttHeight / 2;
      };
      o.tooltipLabels.drawSeriesTexts({ ttItems: n.ttItems, i: l, j: a, y1: w ? parseInt(w, 10) : null, y2: S ? parseInt(S, 10) : null, shared: !o.showOnIntersect && r.config.tooltip.shared, e: i }), r.config.tooltip.followCursor ? r.globals.isBarHorizontal ? (c = y - m.left + 15, h = A()) : (c = k(), h = i.clientY - m.top - o.tooltipRect.ttHeight / 2 - 15) : r.globals.isBarHorizontal ? ((c = b) < o.xyRatios.baseLineInvertedY && (c = b - o.tooltipRect.ttWidth), h = A()) : (c = k(), h = v);
    }
    return { x: c, y: h, barHeight: d, barWidth: u, i: l, j: a };
  } }]), s;
}(), u$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.ttCtx = e;
  }
  return te(s, [{ key: "drawXaxisTooltip", value: function() {
    var e = this.w, t = this.ttCtx, i = e.config.xaxis.position === "bottom";
    t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
    var n = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", r = e.globals.dom.elWrap;
    t.isXAxisTooltipEnabled && e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (t.xaxisTooltip = document.createElement("div"), t.xaxisTooltip.setAttribute("class", n + " apexcharts-theme-" + e.config.tooltip.theme), r.appendChild(t.xaxisTooltip), t.xaxisTooltipText = document.createElement("div"), t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily, t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize, t.xaxisTooltip.appendChild(t.xaxisTooltipText));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var e = this.w, t = this.ttCtx, i = 0; i < e.config.yaxis.length; i++) {
      var n = e.config.yaxis[i].opposite || e.config.yaxis[i].crosshairs.opposite;
      t.yaxisOffX = n ? e.globals.gridWidth + 1 : 1;
      var r = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, n ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), a = e.globals.dom.elWrap;
      e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) === null && (t.yaxisTooltip = document.createElement("div"), t.yaxisTooltip.setAttribute("class", r + " apexcharts-theme-" + e.config.tooltip.theme), a.appendChild(t.yaxisTooltip), i === 0 && (t.yaxisTooltipText = []), t.yaxisTooltipText[i] = document.createElement("div"), t.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), t.yaxisTooltip.appendChild(t.yaxisTooltipText[i]));
    }
  } }, { key: "setXCrosshairWidth", value: function() {
    var e = this.w, t = this.ttCtx, i = t.getElXCrosshairs();
    if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10), e.globals.comboCharts) {
      var n = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (n !== null && e.config.xaxis.crosshairs.width === "barWidth") {
        var r = parseFloat(n.getAttribute("barWidth"));
        t.xcrosshairsWidth = r;
      } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
        var a = e.globals.labels.length;
        t.xcrosshairsWidth = e.globals.gridWidth / a;
      }
    } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
      var o = e.globals.labels.length;
      t.xcrosshairsWidth = e.globals.gridWidth / o;
    } else if (e.config.xaxis.crosshairs.width === "barWidth") {
      var l = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (l !== null) {
        var c = parseFloat(l.getAttribute("barWidth"));
        t.xcrosshairsWidth = c;
      } else t.xcrosshairsWidth = 1;
    }
    e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0), i !== null && t.xcrosshairsWidth > 0 && i.setAttribute("width", t.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var e = this.w, t = this.ttCtx;
    t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(e, t, i) {
    var n = this.ttCtx, r = this.w, a = r.globals, o = a.seriesYAxisMap[e];
    if (n.yaxisTooltips[e] && o.length > 0) {
      var l = a.yLabelFormatters[e], c = n.getElGrid().getBoundingClientRect(), h = o[0], u = 0;
      i.yRatio.length > 1 && (u = h);
      var d = (t - c.top) * i.yRatio[u], f = a.maxYArr[h] - a.minYArr[h], p = a.minYArr[h] + (f - d);
      r.config.yaxis[e].reversed && (p = a.maxYArr[h] - (f - d)), n.tooltipPosition.moveYCrosshairs(t - c.top), n.yaxisTooltipText[e].innerHTML = l(p), n.tooltipPosition.moveYAxisTooltip(e);
    }
  } }]), s;
}(), Em = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.tConfig = t.config.tooltip, this.tooltipUtil = new Jy(this), this.tooltipLabels = new l$(this), this.tooltipPosition = new ev(this), this.marker = new c$(this), this.intersect = new h$(this), this.axesTooltip = new u$(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !t.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return te(s, [{ key: "getElTooltip", value: function(e) {
    return e || (e = this), e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(e) {
    var t = this.w;
    this.xyRatios = e, this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts, this.yaxisTooltips = t.config.yaxis.map(function(a, o) {
      return !!(a.show && a.tooltip.enabled && t.globals.axisCharts);
    }), this.allTooltipSeriesGroups = [], t.globals.axisCharts || (this.showTooltipTitle = !1);
    var i = document.createElement("div");
    if (i.classList.add("apexcharts-tooltip"), t.config.tooltip.cssClass && i.classList.add(t.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme || "light")), t.globals.dom.elWrap.appendChild(i), t.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var n = new Ta(this.ctx);
      this.xAxisTicksPositions = n.getXAxisTicksPositions();
    }
    if (!t.globals.comboCharts && !this.tConfig.intersect && t.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), t.config.markers.size !== 0 && t.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), t.globals.collapsedSeries.length !== t.globals.series.length) {
      this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints, this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
      var r = t.globals.series.length;
      (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (r = this.showOnIntersect ? 1 : t.globals.series.length), this.legendLabels = t.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(r), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(e) {
    for (var t = this, i = this.w, n = [], r = this.getElTooltip(), a = function(l) {
      var c = document.createElement("div");
      c.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(l)), c.style.order = i.config.tooltip.inverseOrder ? e - l : l + 1;
      var h = document.createElement("span");
      h.classList.add("apexcharts-tooltip-marker"), i.config.tooltip.fillSeriesColor ? h.style.backgroundColor = i.globals.colors[l] : h.style.color = i.globals.colors[l];
      var u = i.config.markers.shape, d = u;
      Array.isArray(u) && (d = u[l]), h.setAttribute("shape", d), c.appendChild(h);
      var f = document.createElement("div");
      f.classList.add("apexcharts-tooltip-text"), f.style.fontFamily = t.tConfig.style.fontFamily || i.config.chart.fontFamily, f.style.fontSize = t.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(p) {
        var g = document.createElement("div");
        g.classList.add("apexcharts-tooltip-".concat(p, "-group"));
        var m = document.createElement("span");
        m.classList.add("apexcharts-tooltip-text-".concat(p, "-label")), g.appendChild(m);
        var O = document.createElement("span");
        O.classList.add("apexcharts-tooltip-text-".concat(p, "-value")), g.appendChild(O), f.appendChild(g);
      }), c.appendChild(f), r.appendChild(c), n.push(c);
    }, o = 0; o < e; o++) a(o);
    return n;
  } }, { key: "addSVGEvents", value: function() {
    var e = this.w, t = e.config.chart.type, i = this.getElTooltip(), n = !(t !== "bar" && t !== "candlestick" && t !== "boxPlot" && t !== "rangeBar"), r = t === "area" || t === "line" || t === "scatter" || t === "bubble" || t === "radar", a = e.globals.dom.Paper.node, o = this.getElGrid();
    o && (this.seriesBound = o.getBoundingClientRect());
    var l, c = [], h = [], u = { hoverArea: a, elGrid: o, tooltipEl: i, tooltipY: c, tooltipX: h, ttItems: this.ttItems };
    if (e.globals.axisCharts && (r ? l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : n ? l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : t !== "heatmap" && t !== "treemap" || (l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), l && l.length)) for (var d = 0; d < l.length; d++) c.push(l[d].getAttribute("cy")), h.push(l[d].getAttribute("cx"));
    if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || n && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([a], u);
    else if (n && !e.globals.comboCharts || r && this.showOnIntersect) this.addDatapointEventsListeners(u);
    else if (!e.globals.axisCharts || t === "heatmap" || t === "treemap") {
      var f = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(f, u);
    }
    if (this.showOnIntersect) {
      var p = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
      p.length > 0 && this.addPathsEventListeners(p, u), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(u);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var e = this.w, t = this.getElTooltip(), i = t.getBoundingClientRect(), n = i.width + 10, r = i.height + 10, a = this.tConfig.fixed.offsetX, o = this.tConfig.fixed.offsetY, l = this.tConfig.fixed.position.toLowerCase();
    return l.indexOf("right") > -1 && (a = a + e.globals.svgWidth - n + 10), l.indexOf("bottom") > -1 && (o = o + e.globals.svgHeight - r - 10), t.style.left = a + "px", t.style.top = o + "px", { x: a, y: o, ttWidth: n, ttHeight: r };
  } }, { key: "addDatapointEventsListeners", value: function(e) {
    var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(t, e);
  } }, { key: "addPathsEventListeners", value: function(e, t) {
    for (var i = this, n = function(a) {
      var o = { paths: e[a], tooltipEl: t.tooltipEl, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: t.ttItems };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(l) {
        return e[a].addEventListener(l, i.onSeriesHover.bind(i, o), { capture: !1, passive: !0 });
      });
    }, r = 0; r < e.length; r++) n(r);
  } }, { key: "onSeriesHover", value: function(e, t) {
    var i = this, n = Date.now() - this.lastHoverTime;
    n >= 20 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
      i.seriesHover(e, t);
    }, 20 - n));
  } }, { key: "seriesHover", value: function(e, t) {
    var i = this;
    this.lastHoverTime = Date.now();
    var n = [], r = this.w;
    r.config.chart.group && (n = this.ctx.getGroupedCharts()), r.globals.axisCharts && (r.globals.minX === -1 / 0 && r.globals.maxX === 1 / 0 || r.globals.dataPoints === 0) || (n.length ? n.forEach(function(a) {
      var o = i.getElTooltip(a), l = { paths: e.paths, tooltipEl: o, tooltipY: e.tooltipY, tooltipX: e.tooltipX, elGrid: e.elGrid, hoverArea: e.hoverArea, ttItems: a.w.globals.tooltip.ttItems };
      a.w.globals.minX === i.w.globals.minX && a.w.globals.maxX === i.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({ chartCtx: a, ttCtx: a.w.globals.tooltip, opt: l, e: t });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: e, e: t }));
  } }, { key: "seriesHoverByContext", value: function(e) {
    var t = e.chartCtx, i = e.ttCtx, n = e.opt, r = e.e, a = t.w, o = this.getElTooltip(t);
    o && (i.tooltipRect = { x: 0, y: 0, ttWidth: o.getBoundingClientRect().width, ttHeight: o.getBoundingClientRect().height }, i.e = r, i.tooltipUtil.hasBars() && !a.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new pi(t).toggleSeriesOnHover(r, r.target.parentNode), a.globals.axisCharts ? i.axisChartsTooltips({ e: r, opt: n, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: r, opt: n, tooltipRect: i.tooltipRect }), i.fixedTooltip && i.drawFixedTooltipRect());
  } }, { key: "axisChartsTooltips", value: function(e) {
    var t, i, n = e.e, r = e.opt, a = this.w, o = r.elGrid.getBoundingClientRect(), l = n.type === "touchmove" ? n.touches[0].clientX : n.clientX, c = n.type === "touchmove" ? n.touches[0].clientY : n.clientY;
    if (this.clientY = c, this.clientX = l, a.globals.capturedSeriesIndex = -1, a.globals.capturedDataPointIndex = -1, c < o.top || c > o.top + o.height) this.handleMouseOut(r);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !a.config.tooltip.shared) {
        var h = parseInt(r.paths.getAttribute("index"), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h) < 0) return void this.handleMouseOut(r);
      }
      var u = this.getElTooltip(), d = this.getElXCrosshairs(), f = [];
      a.config.chart.group && (f = this.ctx.getSyncedCharts());
      var p = a.globals.xyCharts || a.config.chart.type === "bar" && !a.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || a.globals.comboCharts && this.tooltipUtil.hasBars();
      if (n.type === "mousemove" || n.type === "touchmove" || n.type === "mouseup") {
        if (a.globals.collapsedSeries.length + a.globals.ancillaryCollapsedSeries.length === a.globals.series.length) return;
        d !== null && d.classList.add("apexcharts-active");
        var g = this.yaxisTooltips.filter(function(x) {
          return x === !0;
        });
        if (this.ycrosshairs !== null && g.length && this.ycrosshairs.classList.add("apexcharts-active"), p && !this.showOnIntersect || f.length > 1) this.handleStickyTooltip(n, l, c, r);
        else if (a.config.chart.type === "heatmap" || a.config.chart.type === "treemap") {
          var m = this.intersect.handleHeatTreeTooltip({ e: n, opt: r, x: t, y: i, type: a.config.chart.type });
          t = m.x, i = m.y, u.style.left = t + "px", u.style.top = i + "px";
        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: n, opt: r }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: n, opt: r, x: t, y: i });
        if (this.yaxisTooltips.length) for (var O = 0; O < a.config.yaxis.length; O++) this.axesTooltip.drawYaxisTooltipText(O, c, this.xyRatios);
        a.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), r.tooltipEl.classList.add("apexcharts-active");
      } else n.type !== "mouseout" && n.type !== "touchend" || this.handleMouseOut(r);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(e) {
    var t = e.e, i = e.opt, n = e.tooltipRect, r = this.w, a = i.paths.getAttribute("rel"), o = this.getElTooltip(), l = r.globals.dom.elWrap.getBoundingClientRect();
    if (t.type === "mousemove" || t.type === "touchmove") {
      r.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), o.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(a, 10) - 1, shared: !1 });
      var c = r.globals.clientX - l.left - n.ttWidth / 2, h = r.globals.clientY - l.top - n.ttHeight - 10;
      if (o.style.left = c + "px", o.style.top = h + "px", r.config.legend.tooltipHoverFormatter) {
        var u = a - 1, d = (0, r.config.legend.tooltipHoverFormatter)(this.legendLabels[u].getAttribute("data:default-text"), { seriesIndex: u, dataPointIndex: u, w: r });
        this.legendLabels[u].innerHTML = d;
      }
    } else t.type !== "mouseout" && t.type !== "touchend" || (o.classList.remove("apexcharts-active"), r.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), r.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(f) {
      var p = f.getAttribute("data:default-text");
      f.innerHTML = decodeURIComponent(p);
    }));
  } }, { key: "handleStickyTooltip", value: function(e, t, i, n) {
    var r = this.w, a = this.tooltipUtil.getNearestValues({ context: this, hoverArea: n.hoverArea, elGrid: n.elGrid, clientX: t, clientY: i }), o = a.j, l = a.capturedSeries;
    r.globals.collapsedSeriesIndices.includes(l) && (l = null);
    var c = n.elGrid.getBoundingClientRect();
    if (a.hoverX < 0 || a.hoverX > c.width) this.handleMouseOut(n);
    else if (l !== null) this.handleStickyCapturedSeries(e, l, n, o);
    else if (this.tooltipUtil.isXoverlap(o) || r.globals.isBarHorizontal) {
      var h = r.globals.series.findIndex(function(u, d) {
        return !r.globals.collapsedSeriesIndices.includes(d);
      });
      this.create(e, this, h, o, n.ttItems);
    }
  } }, { key: "handleStickyCapturedSeries", value: function(e, t, i, n) {
    var r = this.w;
    if (!this.tConfig.shared && r.globals.series[t][n] === null) return void this.handleMouseOut(i);
    if (r.globals.series[t][n] !== void 0) this.tConfig.shared && this.tooltipUtil.isXoverlap(n) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, n, i.ttItems) : this.create(e, this, t, n, i.ttItems, !1);
    else if (this.tooltipUtil.isXoverlap(n)) {
      var a = r.globals.series.findIndex(function(o, l) {
        return !r.globals.collapsedSeriesIndices.includes(l);
      });
      this.create(e, this, a, n, i.ttItems);
    }
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var e = this.w, t = new Z(this.ctx), i = e.globals.dom.Paper.find(".apexcharts-bar-area"), n = 0; n < i.length; n++) t.pathMouseLeave(i[n]);
  } }, { key: "handleMouseOut", value: function(e) {
    var t = this.w, i = this.getElXCrosshairs();
    if (t.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), e.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), t.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      this.yaxisTTEls === null && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var n = 0; n < this.yaxisTTEls.length; n++) this.yaxisTTEls[n].classList.remove("apexcharts-active");
    }
    t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(r) {
      var a = r.getAttribute("data:default-text");
      r.innerHTML = decodeURIComponent(a);
    });
  } }, { key: "markerClick", value: function(e, t, i) {
    var n = this.w;
    typeof n.config.chart.events.markerClick == "function" && n.config.chart.events.markerClick(e, this.ctx, { seriesIndex: t, dataPointIndex: i, w: n }), this.ctx.events.fireEvent("markerClick", [e, this.ctx, { seriesIndex: t, dataPointIndex: i, w: n }]);
  } }, { key: "create", value: function(e, t, i, n, r) {
    var a, o, l, c, h, u, d, f, p, g, m, O, x, b, v, y, w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, S = this.w, k = t;
    e.type === "mouseup" && this.markerClick(e, i, n), w === null && (w = this.tConfig.shared);
    var A = this.tooltipUtil.hasMarkers(i), T = this.tooltipUtil.getElBars(), C = function() {
      S.globals.markers.largestSize > 0 ? k.marker.enlargePoints(n) : k.tooltipPosition.moveDynamicPointsOnHover(n);
    };
    if (S.config.legend.tooltipHoverFormatter) {
      var P = S.config.legend.tooltipHoverFormatter, $ = Array.from(this.legendLabels);
      $.forEach(function(U) {
        var q = U.getAttribute("data:default-text");
        U.innerHTML = decodeURIComponent(q);
      });
      for (var R = 0; R < $.length; R++) {
        var X = $[R], M = parseInt(X.getAttribute("i"), 10), z = decodeURIComponent(X.getAttribute("data:default-text")), I = P(z, { seriesIndex: w ? M : i, dataPointIndex: n, w: S });
        if (w) X.innerHTML = S.globals.collapsedSeriesIndices.indexOf(M) < 0 ? I : z;
        else if (X.innerHTML = M === i ? I : z, i === M) break;
      }
    }
    var Y = F(F({ ttItems: r, i, j: n }, ((a = S.globals.seriesRange) === null || a === void 0 || (o = a[i]) === null || o === void 0 || (l = o[n]) === null || l === void 0 || (c = l.y[0]) === null || c === void 0 ? void 0 : c.y1) !== void 0 && { y1: (h = S.globals.seriesRange) === null || h === void 0 || (u = h[i]) === null || u === void 0 || (d = u[n]) === null || d === void 0 || (f = d.y[0]) === null || f === void 0 ? void 0 : f.y1 }), ((p = S.globals.seriesRange) === null || p === void 0 || (g = p[i]) === null || g === void 0 || (m = g[n]) === null || m === void 0 || (O = m.y[0]) === null || O === void 0 ? void 0 : O.y2) !== void 0 && { y2: (x = S.globals.seriesRange) === null || x === void 0 || (b = x[i]) === null || b === void 0 || (v = b[n]) === null || v === void 0 || (y = v.y[0]) === null || y === void 0 ? void 0 : y.y2 });
    if (w) {
      if (k.tooltipLabels.drawSeriesTexts(F(F({}, Y), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), A) C();
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(T), this.barSeriesHeight > 0)) {
        var V = new Z(this.ctx), N = S.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(n, "']"));
        this.deactivateHoverFilter(), k.tooltipUtil.getAllMarkers(!0).length && !this.barSeriesHeight && C(), k.tooltipPosition.moveStickyTooltipOverBars(n, i);
        for (var _ = 0; _ < N.length; _++) V.pathMouseEnter(N[_]);
      }
    } else k.tooltipLabels.drawSeriesTexts(F({ shared: !1 }, Y)), this.tooltipUtil.hasBars() && k.tooltipPosition.moveStickyTooltipOverBars(n, i), A && k.tooltipPosition.moveMarkers(i, n);
  } }]), s;
}(), d$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.barCtx = e, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return te(s, [{ key: "handleBarDataLabels", value: function(e) {
    var t, i, n = e.x, r = e.y, a = e.y1, o = e.y2, l = e.i, c = e.j, h = e.realIndex, u = e.columnGroupIndex, d = e.series, f = e.barHeight, p = e.barWidth, g = e.barXPosition, m = e.barYPosition, O = e.visibleSeries, x = this.w, b = new Z(this.barCtx.ctx), v = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h] : this.barCtx.strokeWidth;
    x.globals.isXNumeric && !x.globals.isBarHorizontal ? (t = n + parseFloat(p * (O + 1)), i = r + parseFloat(f * (O + 1)) - v) : (t = n + parseFloat(p * O), i = r + parseFloat(f * O));
    var y, w = null, S = n, k = r, A = {}, T = x.config.dataLabels, C = this.barCtx.barOptions.dataLabels, P = this.barCtx.barOptions.dataLabels.total;
    m !== void 0 && this.barCtx.isRangeBar && (i = m, k = m), g !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (t = g, S = g);
    var $ = T.offsetX, R = T.offsetY, X = { width: 0, height: 0 };
    if (x.config.dataLabels.enabled) {
      var M = x.globals.series[l][c];
      X = b.getTextRects(x.config.dataLabels.formatter ? x.config.dataLabels.formatter(M, F(F({}, x), {}, { seriesIndex: l, dataPointIndex: c, w: x })) : x.globals.yLabelFormatters[0](M), parseFloat(T.style.fontSize));
    }
    var z = { x: n, y: r, i: l, j: c, realIndex: h, columnGroupIndex: u, bcx: t, bcy: i, barHeight: f, barWidth: p, textRects: X, strokeWidth: v, dataLabelsX: S, dataLabelsY: k, dataLabelsConfig: T, barDataLabelsConfig: C, barTotalDataLabelsConfig: P, offX: $, offY: R };
    return A = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(z) : this.calculateColumnsDataLabelsPosition(z), y = this.drawCalculatedDataLabels({ x: A.dataLabelsX, y: A.dataLabelsY, val: this.barCtx.isRangeBar ? [a, o] : x.config.chart.stackType === "100%" ? d[h][c] : x.globals.series[h][c], i: h, j: c, barWidth: p, barHeight: f, textRects: X, dataLabelsConfig: T }), x.config.chart.stacked && P.enabled && (w = this.drawTotalDataLabels({ x: A.totalDataLabelsX, y: A.totalDataLabelsY, barWidth: p, barHeight: f, realIndex: h, textAnchor: A.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h, j: c }), dataLabelsConfig: T, barTotalDataLabelsConfig: P })), { dataLabelsPos: A, dataLabels: y, totalDataLabels: w };
  } }, { key: "getStackedTotalDataLabel", value: function(e) {
    var t = e.realIndex, i = e.j, n = this.w, r = this.barCtx.stackedSeriesTotals[i];
    return this.totalFormatter && (r = this.totalFormatter(r, F(F({}, n), {}, { seriesIndex: t, dataPointIndex: i, w: n }))), r;
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(e) {
    var t = this, i = this.w, n = e.i, r = e.j, a = e.realIndex;
    e.columnGroupIndex;
    var o, l, c = e.y, h = e.bcx, u = e.barWidth, d = e.barHeight, f = e.textRects, p = e.dataLabelsX, g = e.dataLabelsY, m = e.dataLabelsConfig, O = e.barDataLabelsConfig, x = e.barTotalDataLabelsConfig, b = e.strokeWidth, v = e.offX, y = e.offY, w = h;
    d = Math.abs(d);
    var S = i.config.plotOptions.bar.dataLabels.orientation === "vertical", k = this.barCtx.barHelpers.getZeroValueEncounters({ i: n, j: r }).zeroEncounters;
    h -= b / 2;
    var A = i.globals.gridWidth / i.globals.dataPoints;
    this.barCtx.isVerticalGroupedRangeBar ? p += u / 2 : (p = i.globals.isXNumeric ? h - u / 2 + v : h - A + u / 2 + v, !i.config.chart.stacked && k > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (p -= u * k)), S && (p = p + f.height / 2 - b / 2 - 2);
    var T = i.globals.series[n][r] < 0, C = c;
    switch (this.barCtx.isReversed && (C = c + (T ? d : -d)), O.position) {
      case "center":
        g = S ? T ? C - d / 2 + y : C + d / 2 - y : T ? C - d / 2 + f.height / 2 + y : C + d / 2 + f.height / 2 - y;
        break;
      case "bottom":
        g = S ? T ? C - d + y : C + d - y : T ? C - d + f.height + b + y : C + d - f.height / 2 + b - y;
        break;
      case "top":
        g = S ? T ? C + y : C - y : T ? C - f.height / 2 - y : C + f.height + y;
    }
    var P = C;
    if (i.globals.seriesGroups.forEach(function(X) {
      var M;
      (M = t.barCtx[X.join(",")]) === null || M === void 0 || M.prevY.forEach(function(z) {
        P = T ? Math.max(z[r], P) : Math.min(z[r], P);
      });
    }), this.barCtx.lastActiveBarSerieIndex === a && x.enabled) {
      var $ = new Z(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: a, j: r }), m.fontSize);
      o = T ? P - $.height / 2 - y - x.offsetY + 18 : P + $.height + y + x.offsetY - 18;
      var R = A;
      l = w + (i.globals.isXNumeric ? -u * i.globals.barGroups.length / 2 : i.globals.barGroups.length * u / 2 - (i.globals.barGroups.length - 1) * u - R) + x.offsetX;
    }
    return i.config.chart.stacked || (g < 0 ? g = 0 + b : g + f.height / 3 > i.globals.gridHeight && (g = i.globals.gridHeight - b)), { bcx: h, bcy: c, dataLabelsX: p, dataLabelsY: g, totalDataLabelsX: l, totalDataLabelsY: o, totalDataLabelsAnchor: "middle" };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(e) {
    var t = this, i = this.w, n = e.x, r = e.i, a = e.j, o = e.realIndex, l = e.bcy, c = e.barHeight, h = e.barWidth, u = e.textRects, d = e.dataLabelsX, f = e.strokeWidth, p = e.dataLabelsConfig, g = e.barDataLabelsConfig, m = e.barTotalDataLabelsConfig, O = e.offX, x = e.offY, b = i.globals.gridHeight / i.globals.dataPoints, v = this.barCtx.barHelpers.getZeroValueEncounters({ i: r, j: a }).zeroEncounters;
    h = Math.abs(h);
    var y, w, S = l - (this.barCtx.isRangeBar ? 0 : b) + c / 2 + u.height / 2 + x - 3;
    !i.config.chart.stacked && v > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (S -= c * v);
    var k = "start", A = i.globals.series[r][a] < 0, T = n;
    switch (this.barCtx.isReversed && (T = n + (A ? -h : h), k = A ? "start" : "end"), g.position) {
      case "center":
        d = A ? T + h / 2 - O : Math.max(u.width / 2, T - h / 2) + O;
        break;
      case "bottom":
        d = A ? T + h - f - O : T - h + f + O;
        break;
      case "top":
        d = A ? T - f - O : T - f + O;
    }
    var C = T;
    if (i.globals.seriesGroups.forEach(function($) {
      var R;
      (R = t.barCtx[$.join(",")]) === null || R === void 0 || R.prevX.forEach(function(X) {
        C = A ? Math.min(X[a], C) : Math.max(X[a], C);
      });
    }), this.barCtx.lastActiveBarSerieIndex === o && m.enabled) {
      var P = new Z(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: o, j: a }), p.fontSize);
      A ? (y = C - f - O - m.offsetX, k = "end") : y = C + O + m.offsetX + (this.barCtx.isReversed ? -(h + f) : f), w = S - u.height / 2 + P.height / 2 + m.offsetY + f, i.globals.barGroups.length > 1 && (w -= i.globals.barGroups.length / 2 * (c / 2));
    }
    return i.config.chart.stacked || (p.textAnchor === "start" ? d - u.width < 0 ? d = A ? u.width + f : f : d + u.width > i.globals.gridWidth && (d = A ? i.globals.gridWidth - f : i.globals.gridWidth - u.width - f) : p.textAnchor === "middle" ? d - u.width / 2 < 0 ? d = u.width / 2 + f : d + u.width / 2 > i.globals.gridWidth && (d = i.globals.gridWidth - u.width / 2 - f) : p.textAnchor === "end" && (d < 1 ? d = u.width + f : d + 1 > i.globals.gridWidth && (d = i.globals.gridWidth - u.width - f))), { bcx: n, bcy: l, dataLabelsX: d, dataLabelsY: S, totalDataLabelsX: y, totalDataLabelsY: w, totalDataLabelsAnchor: k };
  } }, { key: "drawCalculatedDataLabels", value: function(e) {
    var t = e.x, i = e.y, n = e.val, r = e.i, a = e.j, o = e.textRects, l = e.barHeight, c = e.barWidth, h = e.dataLabelsConfig, u = this.w, d = "rotate(0)";
    u.config.plotOptions.bar.dataLabels.orientation === "vertical" && (d = "rotate(-90, ".concat(t, ", ").concat(i, ")"));
    var f = new cr(this.barCtx.ctx), p = new Z(this.barCtx.ctx), g = h.formatter, m = null, O = u.globals.collapsedSeriesIndices.indexOf(r) > -1;
    if (h.enabled && !O) {
      m = p.group({ class: "apexcharts-data-labels", transform: d });
      var x = "";
      n !== void 0 && (x = g(n, F(F({}, u), {}, { seriesIndex: r, dataPointIndex: a, w: u }))), !n && u.config.plotOptions.bar.hideZeroBarsWhenGrouped && (x = "");
      var b = u.globals.series[r][a] < 0, v = u.config.plotOptions.bar.dataLabels.position;
      u.config.plotOptions.bar.dataLabels.orientation === "vertical" && (v === "top" && (h.textAnchor = b ? "end" : "start"), v === "center" && (h.textAnchor = "middle"), v === "bottom" && (h.textAnchor = b ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && c < p.getTextRects(x, parseFloat(h.style.fontSize)).width && (x = ""), u.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? o.width / 1.6 > Math.abs(c) && (x = "") : o.height / 1.6 > Math.abs(l) && (x = ""));
      var y = F({}, h);
      this.barCtx.isHorizontal && n < 0 && (h.textAnchor === "start" ? y.textAnchor = "end" : h.textAnchor === "end" && (y.textAnchor = "start")), f.plotDataLabelsText({ x: t, y: i, text: x, i: r, j: a, parent: m, dataLabelsConfig: y, alwaysDrawDataLabel: !0, offsetCorrection: !0 });
    }
    return m;
  } }, { key: "drawTotalDataLabels", value: function(e) {
    var t = e.x, i = e.y, n = e.val, r = e.realIndex, a = e.textAnchor, o = e.barTotalDataLabelsConfig;
    this.w;
    var l, c = new Z(this.barCtx.ctx);
    return o.enabled && t !== void 0 && i !== void 0 && this.barCtx.lastActiveBarSerieIndex === r && (l = c.drawText({ x: t, y: i, foreColor: o.style.color, text: n, textAnchor: a, fontFamily: o.style.fontFamily, fontSize: o.style.fontSize, fontWeight: o.style.fontWeight })), l;
  } }]), s;
}(), f$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.barCtx = e;
  }
  return te(s, [{ key: "initVariables", value: function(e) {
    var t = this.w;
    this.barCtx.series = e, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i = 0; i < e.length; i++) if (e[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += e[i].length), t.globals.isXNumeric) for (var n = 0; n < e[i].length; n++) t.globals.seriesX[i][n] > t.globals.minX && t.globals.seriesX[i][n] < t.globals.maxX && this.barCtx.visibleItems++;
    else this.barCtx.visibleItems = t.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(t.globals.series), E.isSafari() && (this.arrBorderRadius = this.arrBorderRadius.map(function(r) {
      return r.map(function(a) {
        return "none";
      });
    })), this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], t.globals.comboCharts || this.checkZeroSeries({ series: e });
  } }, { key: "initialPositions", value: function(e) {
    var t, i, n, r, a, o, l, c, h = this.w, u = h.globals.dataPoints;
    this.barCtx.isRangeBar && (u = h.globals.labels.length);
    var d = this.barCtx.seriesLen;
    if (h.config.plotOptions.bar.rangeBarGroupRows && (d = 1), this.barCtx.isHorizontal) a = (n = h.globals.gridHeight / u) / d, h.globals.isXNumeric && (a = (n = h.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), a = a * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (a = parseInt(this.barCtx.barOptions.barHeight, 10)), c = this.barCtx.baseLineInvertedY + h.globals.padHorizontal + (this.barCtx.isReversed ? h.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (c = h.globals.gridWidth / 2), i = (n - a * this.barCtx.seriesLen) / 2;
    else {
      if (r = h.globals.gridWidth / this.barCtx.visibleItems, h.config.xaxis.convertedCatToNumeric && (r = h.globals.gridWidth / h.globals.dataPoints), o = r / d * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h.globals.isXNumeric) {
        var f = this.barCtx.xRatio;
        h.globals.minXDiff && h.globals.minXDiff !== 0.5 && h.globals.minXDiff / f > 0 && (r = h.globals.minXDiff / f), (o = r / d * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (o = 1);
      }
      String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (o = parseInt(this.barCtx.barOptions.columnWidth, 10)), l = h.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h.globals.isXNumeric ? t = this.barCtx.getBarXForNumericXAxis({ x: t, j: 0, realIndex: e, barWidth: o }).x : t = h.globals.padHorizontal + E.noExponents(r - o * this.barCtx.seriesLen) / 2;
    }
    return h.globals.barHeight = a, h.globals.barWidth = o, { x: t, y: i, yDivision: n, xDivision: r, barHeight: a, barWidth: o, zeroH: l, zeroW: c };
  } }, { key: "initializeStackedPrevVars", value: function(e) {
    e.w.globals.seriesGroups.forEach(function(t) {
      e[t] || (e[t] = {}), e[t].prevY = [], e[t].prevX = [], e[t].prevYF = [], e[t].prevXF = [], e[t].prevYVal = [], e[t].prevXVal = [];
    });
  } }, { key: "initializeStackedXYVars", value: function(e) {
    e.w.globals.seriesGroups.forEach(function(t) {
      e[t] || (e[t] = {}), e[t].xArrj = [], e[t].xArrjF = [], e[t].xArrjVal = [], e[t].yArrj = [], e[t].yArrjF = [], e[t].yArrjVal = [];
    });
  } }, { key: "getPathFillColor", value: function(e, t, i, n) {
    var r, a, o, l, c = this.w, h = this.barCtx.ctx.fill, u = null, d = this.barCtx.barOptions.distributed ? i : t, f = !1;
    return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(p) {
      e[t][i] >= p.from && e[t][i] <= p.to && (u = p.color, f = !0);
    }), { color: h.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d : n, dataPointIndex: i, color: u, value: e[t][i], fillConfig: (r = c.config.series[t].data[i]) === null || r === void 0 ? void 0 : r.fill, fillType: (a = c.config.series[t].data[i]) !== null && a !== void 0 && (o = a.fill) !== null && o !== void 0 && o.type ? (l = c.config.series[t].data[i]) === null || l === void 0 ? void 0 : l.fill.type : Array.isArray(c.config.fill.type) ? c.config.fill.type[n] : c.config.fill.type }), useRangeColor: f };
  } }, { key: "getStrokeWidth", value: function(e, t, i) {
    var n = 0, r = this.w;
    return this.barCtx.series[e][t] === void 0 || this.barCtx.series[e][t] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, r.config.stroke.show && (this.barCtx.isNullValue || (n = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), n;
  } }, { key: "createBorderRadiusArr", value: function(e) {
    var t, i = this.w, n = !this.w.config.chart.stacked || i.config.plotOptions.bar.borderRadius <= 0, r = e.length, a = 0 | ((t = e[0]) === null || t === void 0 ? void 0 : t.length), o = Array.from({ length: r }, function() {
      return Array(a).fill(n ? "top" : "none");
    });
    if (n) return o;
    for (var l = 0; l < a; l++) {
      for (var c = [], h = [], u = 0, d = 0; d < r; d++) {
        var f = e[d][l];
        f > 0 ? (c.push(d), u++) : f < 0 && (h.push(d), u++);
      }
      if (c.length > 0 && h.length === 0) if (c.length === 1) o[c[0]][l] = "both";
      else {
        var p, g = c[0], m = c[c.length - 1], O = ia(c);
        try {
          for (O.s(); !(p = O.n()).done; ) {
            var x = p.value;
            o[x][l] = x === g ? "bottom" : x === m ? "top" : "none";
          }
        } catch (M) {
          O.e(M);
        } finally {
          O.f();
        }
      }
      else if (h.length > 0 && c.length === 0) if (h.length === 1) o[h[0]][l] = "both";
      else {
        var b, v = Math.max.apply(Math, h), y = Math.min.apply(Math, h), w = ia(h);
        try {
          for (w.s(); !(b = w.n()).done; ) {
            var S = b.value;
            o[S][l] = S === v ? "bottom" : S === y ? "top" : "none";
          }
        } catch (M) {
          w.e(M);
        } finally {
          w.f();
        }
      }
      else if (c.length > 0 && h.length > 0) {
        var k, A = c[c.length - 1], T = ia(c);
        try {
          for (T.s(); !(k = T.n()).done; ) {
            var C = k.value;
            o[C][l] = C === A ? "top" : "none";
          }
        } catch (M) {
          T.e(M);
        } finally {
          T.f();
        }
        var P, $ = Math.max.apply(Math, h), R = ia(h);
        try {
          for (R.s(); !(P = R.n()).done; ) {
            var X = P.value;
            o[X][l] = X === $ ? "bottom" : "none";
          }
        } catch (M) {
          R.e(M);
        } finally {
          R.f();
        }
      } else u === 1 && (o[c[0] || h[0]][l] = "both");
    }
    return o;
  } }, { key: "barBackground", value: function(e) {
    var t = e.j, i = e.i, n = e.x1, r = e.x2, a = e.y1, o = e.y2, l = e.elSeries, c = this.w, h = new Z(this.barCtx.ctx), u = new pi(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && u === i) {
      t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var d = this.barCtx.barOptions.colors.backgroundBarColors[t], f = h.drawRect(n !== void 0 ? n : 0, a !== void 0 ? a : 0, r !== void 0 ? r : c.globals.gridWidth, o !== void 0 ? o : c.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d, this.barCtx.barOptions.colors.backgroundBarOpacity);
      l.add(f), f.node.classList.add("apexcharts-backgroundBar");
    }
  } }, { key: "getColumnPaths", value: function(e) {
    var t, i = e.barWidth, n = e.barXPosition, r = e.y1, a = e.y2, o = e.strokeWidth, l = e.isReversed, c = e.series, h = e.seriesGroup, u = e.realIndex, d = e.i, f = e.j, p = e.w, g = new Z(this.barCtx.ctx);
    (o = Array.isArray(o) ? o[u] : o) || (o = 0);
    var m = i, O = n;
    (t = p.config.series[u].data[f]) !== null && t !== void 0 && t.columnWidthOffset && (O = n - p.config.series[u].data[f].columnWidthOffset / 2, m = i + p.config.series[u].data[f].columnWidthOffset);
    var x = o / 2, b = O + x, v = O + m - x, y = (c[d][f] >= 0 ? 1 : -1) * (l ? -1 : 1);
    r += 1e-3 - x * y, a += 1e-3 + x * y;
    var w = g.move(b, r), S = g.move(b, r), k = g.line(v, r);
    if (p.globals.previousPaths.length > 0 && (S = this.barCtx.getPreviousPath(u, f, !1)), w = w + g.line(b, a) + g.line(v, a) + k + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[u][f] === "both" ? " Z" : " z"), S = S + g.line(b, r) + k + k + k + k + k + g.line(b, r) + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[u][f] === "both" ? " Z" : " z"), this.arrBorderRadius[u][f] !== "none" && (w = g.roundPathCorners(w, p.config.plotOptions.bar.borderRadius)), p.config.chart.stacked) {
      var A = this.barCtx;
      (A = this.barCtx[h]).yArrj.push(a - x * y), A.yArrjF.push(Math.abs(r - a + o * y)), A.yArrjVal.push(this.barCtx.series[d][f]);
    }
    return { pathTo: w, pathFrom: S };
  } }, { key: "getBarpaths", value: function(e) {
    var t, i = e.barYPosition, n = e.barHeight, r = e.x1, a = e.x2, o = e.strokeWidth, l = e.isReversed, c = e.series, h = e.seriesGroup, u = e.realIndex, d = e.i, f = e.j, p = e.w, g = new Z(this.barCtx.ctx);
    (o = Array.isArray(o) ? o[u] : o) || (o = 0);
    var m = i, O = n;
    (t = p.config.series[u].data[f]) !== null && t !== void 0 && t.barHeightOffset && (m = i - p.config.series[u].data[f].barHeightOffset / 2, O = n + p.config.series[u].data[f].barHeightOffset);
    var x = o / 2, b = m + x, v = m + O - x, y = (c[d][f] >= 0 ? 1 : -1) * (l ? -1 : 1);
    r += 1e-3 + x * y, a += 1e-3 - x * y;
    var w = g.move(r, b), S = g.move(r, b);
    p.globals.previousPaths.length > 0 && (S = this.barCtx.getPreviousPath(u, f, !1));
    var k = g.line(r, v);
    if (w = w + g.line(a, b) + g.line(a, v) + k + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[u][f] === "both" ? " Z" : " z"), S = S + g.line(r, b) + k + k + k + k + k + g.line(r, b) + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[u][f] === "both" ? " Z" : " z"), this.arrBorderRadius[u][f] !== "none" && (w = g.roundPathCorners(w, p.config.plotOptions.bar.borderRadius)), p.config.chart.stacked) {
      var A = this.barCtx;
      (A = this.barCtx[h]).xArrj.push(a + x * y), A.xArrjF.push(Math.abs(r - a - o * y)), A.xArrjVal.push(this.barCtx.series[d][f]);
    }
    return { pathTo: w, pathFrom: S };
  } }, { key: "checkZeroSeries", value: function(e) {
    for (var t = e.series, i = this.w, n = 0; n < t.length; n++) {
      for (var r = 0, a = 0; a < t[i.globals.maxValsInArrayIndex].length; a++) r += t[n][a];
      r === 0 && this.barCtx.zeroSerieses.push(n);
    }
  } }, { key: "getXForValue", value: function(e, t) {
    var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? t : null;
    return e != null && (i = t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0)), i;
  } }, { key: "getYForValue", value: function(e, t, i) {
    var n = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3] ? t : null;
    return e != null && (n = t - e / this.barCtx.yRatio[i] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[i] : 0)), n;
  } }, { key: "getGoalValues", value: function(e, t, i, n, r, a) {
    var o = this, l = this.w, c = [], h = function(f, p) {
      var g;
      c.push((Ul(g = {}, e, e === "x" ? o.getXForValue(f, t, !1) : o.getYForValue(f, i, a, !1)), Ul(g, "attrs", p), g));
    };
    if (l.globals.seriesGoals[n] && l.globals.seriesGoals[n][r] && Array.isArray(l.globals.seriesGoals[n][r]) && l.globals.seriesGoals[n][r].forEach(function(f) {
      h(f.value, f);
    }), this.barCtx.barOptions.isDumbbell && l.globals.seriesRange.length) {
      var u = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l.globals.colors, d = { strokeHeight: e === "x" ? 0 : l.globals.markers.size[n], strokeWidth: e === "x" ? l.globals.markers.size[n] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(u[n]) ? u[n][0] : u[n] };
      h(l.globals.seriesRangeStart[n][r], d), h(l.globals.seriesRangeEnd[n][r], F(F({}, d), {}, { strokeColor: Array.isArray(u[n]) ? u[n][1] : u[n] }));
    }
    return c;
  } }, { key: "drawGoalLine", value: function(e) {
    var t = e.barXPosition, i = e.barYPosition, n = e.goalX, r = e.goalY, a = e.barWidth, o = e.barHeight, l = new Z(this.barCtx.ctx), c = l.group({ className: "apexcharts-bar-goals-groups" });
    c.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: c.node }), c.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
    var h = null;
    return this.barCtx.isHorizontal ? Array.isArray(n) && n.forEach(function(u) {
      if (u.x >= -1 && u.x <= l.w.globals.gridWidth + 1) {
        var d = u.attrs.strokeHeight !== void 0 ? u.attrs.strokeHeight : o / 2, f = i + d + o / 2;
        h = l.drawLine(u.x, f - 2 * d, u.x, f, u.attrs.strokeColor ? u.attrs.strokeColor : void 0, u.attrs.strokeDashArray, u.attrs.strokeWidth ? u.attrs.strokeWidth : 2, u.attrs.strokeLineCap), c.add(h);
      }
    }) : Array.isArray(r) && r.forEach(function(u) {
      if (u.y >= -1 && u.y <= l.w.globals.gridHeight + 1) {
        var d = u.attrs.strokeWidth !== void 0 ? u.attrs.strokeWidth : a / 2, f = t + d + a / 2;
        h = l.drawLine(f - 2 * d, u.y, f, u.y, u.attrs.strokeColor ? u.attrs.strokeColor : void 0, u.attrs.strokeDashArray, u.attrs.strokeHeight ? u.attrs.strokeHeight : 2, u.attrs.strokeLineCap), c.add(h);
      }
    }), c;
  } }, { key: "drawBarShadow", value: function(e) {
    var t = e.prevPaths, i = e.currPaths, n = e.color, r = this.w, a = t.x, o = t.x1, l = t.barYPosition, c = i.x, h = i.x1, u = i.barYPosition, d = l + i.barHeight, f = new Z(this.barCtx.ctx), p = new E(), g = f.move(o, d) + f.line(a, d) + f.line(c, u) + f.line(h, u) + f.line(o, d) + (r.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[realIndex][j] === "both" ? " Z" : " z");
    return f.drawPath({ d: g, fill: p.shadeColor(0.5, E.rgb2hex(n)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadow apexcharts-decoration-element" });
  } }, { key: "getZeroValueEncounters", value: function(e) {
    var t, i = e.i, n = e.j, r = this.w, a = 0, o = 0;
    return (r.config.plotOptions.bar.horizontal ? r.globals.series.map(function(l, c) {
      return c;
    }) : ((t = r.globals.columnSeries) === null || t === void 0 ? void 0 : t.i.map(function(l) {
      return l;
    })) || []).forEach(function(l) {
      var c = r.globals.seriesPercent[l][n];
      c && a++, l < i && c === 0 && o++;
    }), { nonZeroColumns: a, zeroEncounters: o };
  } }, { key: "getGroupIndex", value: function(e) {
    var t = this.w, i = t.globals.seriesGroups.findIndex(function(a) {
      return a.indexOf(t.globals.seriesNames[e]) > -1;
    }), n = this.barCtx.columnGroupIndices, r = n.indexOf(i);
    return r < 0 && (n.push(i), r = n.length - 1), { groupIndex: i, columnGroupIndex: r };
  } }]), s;
}(), hr = function() {
  function s(e, t) {
    ee(this, s), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = t, this.xyRatios !== null && (this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.invertedXRatio = t.invertedXRatio, this.invertedYRatio = t.invertedYRatio, this.baseLineY = t.baseLineY, this.baseLineInvertedY = t.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var n = new pi(this.ctx);
    this.lastActiveBarSerieIndex = n.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
    var r = n.getBarSeriesIndices(), a = new st(this.ctx);
    this.stackedSeriesTotals = a.getStackedSeriesTotals(this.w.config.series.map(function(o, l) {
      return r.indexOf(l) === -1 ? l : -1;
    }).filter(function(o) {
      return o !== -1;
    })), this.barHelpers = new f$(this);
  }
  return te(s, [{ key: "draw", value: function(e, t) {
    var i = this.w, n = new Z(this.ctx), r = new st(this.ctx, i);
    e = r.getLogSeries(e), this.series = e, this.yRatio = r.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e);
    var a = n.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
    for (var o = 0, l = 0; o < e.length; o++, l++) {
      var c, h, u, d, f = void 0, p = void 0, g = [], m = [], O = i.globals.comboCharts ? t[o] : o, x = this.barHelpers.getGroupIndex(O).columnGroupIndex, b = n.group({ class: "apexcharts-series", rel: o + 1, seriesName: E.escapeString(i.globals.seriesNames[O]), "data:realIndex": O });
      this.ctx.series.addCollapsedClassToSeries(b, O), e[o].length > 0 && (this.visibleI = this.visibleI + 1);
      var v = 0, y = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[O], this.translationsIndex = O);
      var w = this.translationsIndex;
      this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      var S = this.barHelpers.initialPositions(O);
      p = S.y, v = S.barHeight, h = S.yDivision, d = S.zeroW, f = S.x, y = S.barWidth, c = S.xDivision, u = S.zeroH, this.isHorizontal || m.push(f + y / 2);
      var k = n.group({ class: "apexcharts-datalabels", "data:realIndex": O });
      i.globals.delayedElements.push({ el: k.node }), k.node.classList.add("apexcharts-element-hidden");
      var A = n.group({ class: "apexcharts-bar-goals-markers" }), T = n.group({ class: "apexcharts-bar-shadows" });
      i.globals.delayedElements.push({ el: T.node }), T.node.classList.add("apexcharts-element-hidden");
      for (var C = 0; C < e[o].length; C++) {
        var P = this.barHelpers.getStrokeWidth(o, C, O), $ = null, R = { indexes: { i: o, j: C, realIndex: O, translationsIndex: w, bc: l }, x: f, y: p, strokeWidth: P, elSeries: b };
        this.isHorizontal ? ($ = this.drawBarPaths(F(F({}, R), {}, { barHeight: v, zeroW: d, yDivision: h })), y = this.series[o][C] / this.invertedYRatio) : ($ = this.drawColumnPaths(F(F({}, R), {}, { xDivision: c, barWidth: y, zeroH: u })), v = this.series[o][C] / this.yRatio[w]);
        var X = this.barHelpers.getPathFillColor(e, o, C, O);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && C > 0) {
          var M, z = this.barHelpers.drawBarShadow({ color: typeof X.color == "string" && ((M = X.color) === null || M === void 0 ? void 0 : M.indexOf("url")) === -1 ? X.color : E.hexToRgba(i.globals.colors[o]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: $ });
          T.add(z), i.config.chart.dropShadow.enabled && new vt(this.ctx).dropShadow(z, i.config.chart.dropShadow, O);
        }
        this.pathArr.push($);
        var I = this.barHelpers.drawGoalLine({ barXPosition: $.barXPosition, barYPosition: $.barYPosition, goalX: $.goalX, goalY: $.goalY, barHeight: v, barWidth: y });
        I && A.add(I), p = $.y, f = $.x, C > 0 && m.push(f + y / 2), g.push(p), this.renderSeries(F(F({ realIndex: O, pathFill: X.color }, X.useRangeColor ? { lineFill: X.color } : {}), {}, { j: C, i: o, columnGroupIndex: x, pathFrom: $.pathFrom, pathTo: $.pathTo, strokeWidth: P, elSeries: b, x: f, y: p, series: e, barHeight: Math.abs($.barHeight ? $.barHeight : v), barWidth: Math.abs($.barWidth ? $.barWidth : y), elDataLabelsWrap: k, elGoalsMarkers: A, elBarShadows: T, visibleSeries: this.visibleI, type: "bar" }));
      }
      i.globals.seriesXvalues[O] = m, i.globals.seriesYvalues[O] = g, a.add(b);
    }
    return a;
  } }, { key: "renderSeries", value: function(e) {
    var t = e.realIndex, i = e.pathFill, n = e.lineFill, r = e.j, a = e.i, o = e.columnGroupIndex, l = e.pathFrom, c = e.pathTo, h = e.strokeWidth, u = e.elSeries, d = e.x, f = e.y, p = e.y1, g = e.y2, m = e.series, O = e.barHeight, x = e.barWidth, b = e.barXPosition, v = e.barYPosition, y = e.elDataLabelsWrap, w = e.elGoalsMarkers, S = e.elBarShadows, k = e.visibleSeries, A = e.type, T = e.classes, C = this.w, P = new Z(this.ctx), $ = !1;
    if (!n) {
      var R = typeof C.globals.stroke.colors[t] == "function" ? function(Y) {
        var V, N = C.config.stroke.colors;
        return Array.isArray(N) && N.length > 0 && ((V = N[Y]) || (V = ""), typeof V == "function") ? V({ value: C.globals.series[Y][r], dataPointIndex: r, w: C }) : V;
      }(t) : C.globals.stroke.colors[t];
      n = this.barOptions.distributed ? C.globals.stroke.colors[r] : R;
    }
    var X = new d$(this).handleBarDataLabels({ x: d, y: f, y1: p, y2: g, i: a, j: r, series: m, realIndex: t, columnGroupIndex: o, barHeight: O, barWidth: x, barXPosition: b, barYPosition: v, visibleSeries: k });
    C.globals.isBarHorizontal || (X.dataLabelsPos.dataLabelsX + x < 0 || X.dataLabelsPos.dataLabelsX - x > C.globals.gridWidth) && ($ = !0), C.config.series[a].data[r] && C.config.series[a].data[r].strokeColor && (n = C.config.series[a].data[r].strokeColor), this.isNullValue && (i = "none");
    var M = r / C.config.chart.animations.animateGradually.delay * (C.config.chart.animations.speed / C.globals.dataPoints) / 2.4;
    if (!$) {
      var z = P.renderPaths({ i: a, j: r, realIndex: t, pathFrom: l, pathTo: c, stroke: n, strokeWidth: h, strokeLineCap: C.config.stroke.lineCap, fill: i, animationDelay: M, initialSpeed: C.config.chart.animations.speed, dataChangeSpeed: C.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(A, "-area ").concat(T), chartType: A });
      z.attr("clip-path", "url(#gridRectBarMask".concat(C.globals.cuid, ")"));
      var I = C.config.forecastDataPoints;
      I.count > 0 && r >= C.globals.dataPoints - I.count && (z.node.setAttribute("stroke-dasharray", I.dashArray), z.node.setAttribute("stroke-width", I.strokeWidth), z.node.setAttribute("fill-opacity", I.fillOpacity)), p !== void 0 && g !== void 0 && (z.attr("data-range-y1", p), z.attr("data-range-y2", g)), new vt(this.ctx).setSelectionFilter(z, t, r), u.add(z), z.attr({ cy: X.dataLabelsPos.bcy, cx: X.dataLabelsPos.bcx, j: r, val: C.globals.series[a][r], barHeight: O, barWidth: x }), X.dataLabels !== null && y.add(X.dataLabels), X.totalDataLabels && y.add(X.totalDataLabels), u.add(y), w && u.add(w), S && u.add(S);
    }
    return u;
  } }, { key: "drawBarPaths", value: function(e) {
    var t, i = e.indexes, n = e.barHeight, r = e.strokeWidth, a = e.zeroW, o = e.x, l = e.y, c = e.yDivision, h = e.elSeries, u = this.w, d = i.i, f = i.j;
    if (u.globals.isXNumeric) t = (l = (u.globals.seriesX[d][f] - u.globals.minX) / this.invertedXRatio - n) + n * this.visibleI;
    else if (u.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var p = this.barHelpers.getZeroValueEncounters({ i: d, j: f }), g = p.nonZeroColumns, m = p.zeroEncounters;
      g > 0 && (n = this.seriesLen * n / g), t = l + n * this.visibleI, t -= n * m;
    } else t = l + n * this.visibleI;
    this.isFunnel && (a -= (this.barHelpers.getXForValue(this.series[d][f], a) - a) / 2), o = this.barHelpers.getXForValue(this.series[d][f], a);
    var O = this.barHelpers.getBarpaths({ barYPosition: t, barHeight: n, x1: a, x2: o, strokeWidth: r, isReversed: this.isReversed, series: this.series, realIndex: i.realIndex, i: d, j: f, w: u });
    return u.globals.isXNumeric || (l += c), this.barHelpers.barBackground({ j: f, i: d, y1: t - n * this.visibleI, y2: n * this.seriesLen, elSeries: h }), { pathTo: O.pathTo, pathFrom: O.pathFrom, x1: a, x: o, y: l, goalX: this.barHelpers.getGoalValues("x", a, null, d, f), barYPosition: t, barHeight: n };
  } }, { key: "drawColumnPaths", value: function(e) {
    var t, i = e.indexes, n = e.x, r = e.y, a = e.xDivision, o = e.barWidth, l = e.zeroH, c = e.strokeWidth, h = e.elSeries, u = this.w, d = i.realIndex, f = i.translationsIndex, p = i.i, g = i.j, m = i.bc;
    if (u.globals.isXNumeric) {
      var O = this.getBarXForNumericXAxis({ x: n, j: g, realIndex: d, barWidth: o });
      n = O.x, t = O.barXPosition;
    } else if (u.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var x = this.barHelpers.getZeroValueEncounters({ i: p, j: g }), b = x.nonZeroColumns, v = x.zeroEncounters;
      b > 0 && (o = this.seriesLen * o / b), t = n + o * this.visibleI, t -= o * v;
    } else t = n + o * this.visibleI;
    r = this.barHelpers.getYForValue(this.series[p][g], l, f);
    var y = this.barHelpers.getColumnPaths({ barXPosition: t, barWidth: o, y1: l, y2: r, strokeWidth: c, isReversed: this.isReversed, series: this.series, realIndex: d, i: p, j: g, w: u });
    return u.globals.isXNumeric || (n += a), this.barHelpers.barBackground({ bc: m, j: g, i: p, x1: t - c / 2 - o * this.visibleI, x2: o * this.seriesLen + c / 2, elSeries: h }), { pathTo: y.pathTo, pathFrom: y.pathFrom, x: n, y: r, goalY: this.barHelpers.getGoalValues("y", null, l, p, g, f), barXPosition: t, barWidth: o };
  } }, { key: "getBarXForNumericXAxis", value: function(e) {
    var t = e.x, i = e.barWidth, n = e.realIndex, r = e.j, a = this.w, o = n;
    return a.globals.seriesX[n].length || (o = a.globals.maxValsInArrayIndex), E.isNumber(a.globals.seriesX[o][r]) && (t = (a.globals.seriesX[o][r] - a.globals.minX) / this.xRatio - i * this.seriesLen / 2), { barXPosition: t + i * this.visibleI, x: t };
  } }, { key: "getPreviousPath", value: function(e, t) {
    for (var i = this.w, n = "M 0 0", r = 0; r < i.globals.previousPaths.length; r++) {
      var a = i.globals.previousPaths[r];
      a.paths && a.paths.length > 0 && parseInt(a.realIndex, 10) === parseInt(e, 10) && i.globals.previousPaths[r].paths[t] !== void 0 && (n = i.globals.previousPaths[r].paths[t].d);
    }
    return n;
  } }]), s;
}(), Xm = function(s) {
  ho(t, hr);
  var e = co(t);
  function t() {
    return ee(this, t), e.apply(this, arguments);
  }
  return te(t, [{ key: "draw", value: function(i, n) {
    var r = this, a = this.w;
    this.graphics = new Z(this.ctx), this.bar = new hr(this.ctx, this.xyRatios);
    var o = new st(this.ctx, a);
    i = o.getLogSeries(i), this.yRatio = o.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), a.config.chart.stackType === "100%" && (i = a.globals.comboCharts ? n.map(function(p) {
      return a.globals.seriesPercent[p];
    }) : a.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
    for (var l = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), c = 0, h = 0, u = function(p, g) {
      var m = void 0, O = void 0, x = void 0, b = void 0, v = a.globals.comboCharts ? n[p] : p, y = r.barHelpers.getGroupIndex(v), w = y.groupIndex, S = y.columnGroupIndex;
      r.groupCtx = r[a.globals.seriesGroups[w]];
      var k = [], A = [], T = 0;
      r.yRatio.length > 1 && (r.yaxisIndex = a.globals.seriesYAxisReverseMap[v][0], T = v), r.isReversed = a.config.yaxis[r.yaxisIndex] && a.config.yaxis[r.yaxisIndex].reversed;
      var C = r.graphics.group({ class: "apexcharts-series", seriesName: E.escapeString(a.globals.seriesNames[v]), rel: p + 1, "data:realIndex": v });
      r.ctx.series.addCollapsedClassToSeries(C, v);
      var P = r.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": v }), $ = r.graphics.group({ class: "apexcharts-bar-goals-markers" }), R = 0, X = 0, M = r.initialPositions(c, h, m, O, x, b, T);
      h = M.y, R = M.barHeight, O = M.yDivision, b = M.zeroW, c = M.x, X = M.barWidth, m = M.xDivision, x = M.zeroH, a.globals.barHeight = R, a.globals.barWidth = X, r.barHelpers.initializeStackedXYVars(r), r.groupCtx.prevY.length === 1 && r.groupCtx.prevY[0].every(function(oe) {
        return isNaN(oe);
      }) && (r.groupCtx.prevY[0] = r.groupCtx.prevY[0].map(function() {
        return x;
      }), r.groupCtx.prevYF[0] = r.groupCtx.prevYF[0].map(function() {
        return 0;
      }));
      for (var z = 0; z < a.globals.dataPoints; z++) {
        var I = r.barHelpers.getStrokeWidth(p, z, v), Y = { indexes: { i: p, j: z, realIndex: v, translationsIndex: T, bc: g }, strokeWidth: I, x: c, y: h, elSeries: C, columnGroupIndex: S, seriesGroup: a.globals.seriesGroups[w] }, V = null;
        r.isHorizontal ? (V = r.drawStackedBarPaths(F(F({}, Y), {}, { zeroW: b, barHeight: R, yDivision: O })), X = r.series[p][z] / r.invertedYRatio) : (V = r.drawStackedColumnPaths(F(F({}, Y), {}, { xDivision: m, barWidth: X, zeroH: x })), R = r.series[p][z] / r.yRatio[T]);
        var N = r.barHelpers.drawGoalLine({ barXPosition: V.barXPosition, barYPosition: V.barYPosition, goalX: V.goalX, goalY: V.goalY, barHeight: R, barWidth: X });
        N && $.add(N), h = V.y, c = V.x, k.push(c), A.push(h);
        var _ = r.barHelpers.getPathFillColor(i, p, z, v), U = "", q = a.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
        (r.barHelpers.arrBorderRadius[v][z] === "bottom" && a.globals.series[v][z] > 0 || r.barHelpers.arrBorderRadius[v][z] === "top" && a.globals.series[v][z] < 0) && (U = q), C = r.renderSeries(F(F({ realIndex: v, pathFill: _.color }, _.useRangeColor ? { lineFill: _.color } : {}), {}, { j: z, i: p, columnGroupIndex: S, pathFrom: V.pathFrom, pathTo: V.pathTo, strokeWidth: I, elSeries: C, x: c, y: h, series: i, barHeight: R, barWidth: X, elDataLabelsWrap: P, elGoalsMarkers: $, type: "bar", visibleSeries: S, classes: U }));
      }
      a.globals.seriesXvalues[v] = k, a.globals.seriesYvalues[v] = A, r.groupCtx.prevY.push(r.groupCtx.yArrj), r.groupCtx.prevYF.push(r.groupCtx.yArrjF), r.groupCtx.prevYVal.push(r.groupCtx.yArrjVal), r.groupCtx.prevX.push(r.groupCtx.xArrj), r.groupCtx.prevXF.push(r.groupCtx.xArrjF), r.groupCtx.prevXVal.push(r.groupCtx.xArrjVal), l.add(C);
    }, d = 0, f = 0; d < i.length; d++, f++) u(d, f);
    return l;
  } }, { key: "initialPositions", value: function(i, n, r, a, o, l, c) {
    var h, u, d = this.w;
    if (this.isHorizontal) {
      a = d.globals.gridHeight / d.globals.dataPoints;
      var f = d.config.plotOptions.bar.barHeight;
      h = String(f).indexOf("%") === -1 ? parseInt(f, 10) : a * parseInt(f, 10) / 100, l = d.globals.padHorizontal + (this.isReversed ? d.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), n = (a - h) / 2;
    } else {
      u = r = d.globals.gridWidth / d.globals.dataPoints;
      var p = d.config.plotOptions.bar.columnWidth;
      d.globals.isXNumeric && d.globals.dataPoints > 1 ? u = (r = d.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : String(p).indexOf("%") === -1 ? u = parseInt(p, 10) : u *= parseInt(p, 10) / 100, o = this.isReversed ? this.baseLineY[c] : d.globals.gridHeight - this.baseLineY[c], i = d.globals.padHorizontal + (r - u) / 2;
    }
    var g = d.globals.barGroups.length || 1;
    return { x: i, y: n, yDivision: a, xDivision: r, barHeight: h / g, barWidth: u / g, zeroH: o, zeroW: l };
  } }, { key: "drawStackedBarPaths", value: function(i) {
    for (var n, r = i.indexes, a = i.barHeight, o = i.strokeWidth, l = i.zeroW, c = i.x, h = i.y, u = i.columnGroupIndex, d = i.seriesGroup, f = i.yDivision, p = i.elSeries, g = this.w, m = h + u * a, O = r.i, x = r.j, b = r.realIndex, v = r.translationsIndex, y = 0, w = 0; w < this.groupCtx.prevXF.length; w++) y += this.groupCtx.prevXF[w][x];
    var S = O;
    if (g.config.series[b].name && (S = d.indexOf(g.config.series[b].name)), S > 0) {
      var k = l;
      this.groupCtx.prevXVal[S - 1][x] < 0 ? k = this.series[O][x] >= 0 ? this.groupCtx.prevX[S - 1][x] + y - 2 * (this.isReversed ? y : 0) : this.groupCtx.prevX[S - 1][x] : this.groupCtx.prevXVal[S - 1][x] >= 0 && (k = this.series[O][x] >= 0 ? this.groupCtx.prevX[S - 1][x] : this.groupCtx.prevX[S - 1][x] - y + 2 * (this.isReversed ? y : 0)), n = k;
    } else n = l;
    c = this.series[O][x] === null ? n : n + this.series[O][x] / this.invertedYRatio - 2 * (this.isReversed ? this.series[O][x] / this.invertedYRatio : 0);
    var A = this.barHelpers.getBarpaths({ barYPosition: m, barHeight: a, x1: n, x2: c, strokeWidth: o, isReversed: this.isReversed, series: this.series, realIndex: r.realIndex, seriesGroup: d, i: O, j: x, w: g });
    return this.barHelpers.barBackground({ j: x, i: O, y1: m, y2: a, elSeries: p }), h += f, { pathTo: A.pathTo, pathFrom: A.pathFrom, goalX: this.barHelpers.getGoalValues("x", l, null, O, x, v), barXPosition: n, barYPosition: m, x: c, y: h };
  } }, { key: "drawStackedColumnPaths", value: function(i) {
    var n = i.indexes, r = i.x, a = i.y, o = i.xDivision, l = i.barWidth, c = i.zeroH, h = i.columnGroupIndex, u = i.seriesGroup, d = i.elSeries, f = this.w, p = n.i, g = n.j, m = n.bc, O = n.realIndex, x = n.translationsIndex;
    if (f.globals.isXNumeric) {
      var b = f.globals.seriesX[O][g];
      b || (b = 0), r = (b - f.globals.minX) / this.xRatio - l / 2 * f.globals.barGroups.length;
    }
    for (var v, y = r + h * l, w = 0, S = 0; S < this.groupCtx.prevYF.length; S++) w += isNaN(this.groupCtx.prevYF[S][g]) ? 0 : this.groupCtx.prevYF[S][g];
    var k = p;
    if (u && (k = u.indexOf(f.globals.seriesNames[O])), k > 0 && !f.globals.isXNumeric || k > 0 && f.globals.isXNumeric && f.globals.seriesX[O - 1][g] === f.globals.seriesX[O][g]) {
      var A, T, C, P = Math.min(this.yRatio.length + 1, O + 1);
      if (this.groupCtx.prevY[k - 1] !== void 0 && this.groupCtx.prevY[k - 1].length) for (var $ = 1; $ < P; $++) {
        var R;
        if (!isNaN((R = this.groupCtx.prevY[k - $]) === null || R === void 0 ? void 0 : R[g])) {
          C = this.groupCtx.prevY[k - $][g];
          break;
        }
      }
      for (var X = 1; X < P; X++) {
        var M, z;
        if (((M = this.groupCtx.prevYVal[k - X]) === null || M === void 0 ? void 0 : M[g]) < 0) {
          T = this.series[p][g] >= 0 ? C - w + 2 * (this.isReversed ? w : 0) : C;
          break;
        }
        if (((z = this.groupCtx.prevYVal[k - X]) === null || z === void 0 ? void 0 : z[g]) >= 0) {
          T = this.series[p][g] >= 0 ? C : C + w - 2 * (this.isReversed ? w : 0);
          break;
        }
      }
      T === void 0 && (T = f.globals.gridHeight), v = (A = this.groupCtx.prevYF[0]) !== null && A !== void 0 && A.every(function(Y) {
        return Y === 0;
      }) && this.groupCtx.prevYF.slice(1, k).every(function(Y) {
        return Y.every(function(V) {
          return isNaN(V);
        });
      }) ? c : T;
    } else v = c;
    a = this.series[p][g] ? v - this.series[p][g] / this.yRatio[x] + 2 * (this.isReversed ? this.series[p][g] / this.yRatio[x] : 0) : v;
    var I = this.barHelpers.getColumnPaths({ barXPosition: y, barWidth: l, y1: v, y2: a, yRatio: this.yRatio[x], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: u, realIndex: n.realIndex, i: p, j: g, w: f });
    return this.barHelpers.barBackground({ bc: m, j: g, i: p, x1: y, x2: l, elSeries: d }), { pathTo: I.pathTo, pathFrom: I.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, c, p, g), barXPosition: y, x: f.globals.isXNumeric ? r : r + o, y: a };
  } }]), t;
}(), Yh = function(s) {
  ho(t, hr);
  var e = co(t);
  function t() {
    return ee(this, t), e.apply(this, arguments);
  }
  return te(t, [{ key: "draw", value: function(i, n, r) {
    var a = this, o = this.w, l = new Z(this.ctx), c = o.globals.comboCharts ? n : o.config.chart.type, h = new Ci(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = o.config.plotOptions.bar.horizontal, this.isOHLC = this.candlestickOptions && this.candlestickOptions.type === "ohlc";
    var u = new st(this.ctx, o);
    i = u.getLogSeries(i), this.series = i, this.yRatio = u.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
    for (var d = l.group({ class: "apexcharts-".concat(c, "-series apexcharts-plot-series") }), f = function(g) {
      a.isBoxPlot = o.config.chart.type === "boxPlot" || o.config.series[g].type === "boxPlot";
      var m, O, x, b, v = void 0, y = void 0, w = [], S = [], k = o.globals.comboCharts ? r[g] : g, A = a.barHelpers.getGroupIndex(k).columnGroupIndex, T = l.group({ class: "apexcharts-series", seriesName: E.escapeString(o.globals.seriesNames[k]), rel: g + 1, "data:realIndex": k });
      a.ctx.series.addCollapsedClassToSeries(T, k), i[g].length > 0 && (a.visibleI = a.visibleI + 1);
      var C, P, $ = 0;
      a.yRatio.length > 1 && (a.yaxisIndex = o.globals.seriesYAxisReverseMap[k][0], $ = k);
      var R = a.barHelpers.initialPositions(k);
      y = R.y, C = R.barHeight, O = R.yDivision, b = R.zeroW, v = R.x, P = R.barWidth, m = R.xDivision, x = R.zeroH, S.push(v + P / 2);
      for (var X = l.group({ class: "apexcharts-datalabels", "data:realIndex": k }), M = l.group({ class: "apexcharts-bar-goals-markers" }), z = function(Y) {
        var V = a.barHelpers.getStrokeWidth(g, Y, k), N = null, _ = { indexes: { i: g, j: Y, realIndex: k, translationsIndex: $ }, x: v, y, strokeWidth: V, elSeries: T };
        N = a.isHorizontal ? a.drawHorizontalBoxPaths(F(F({}, _), {}, { yDivision: O, barHeight: C, zeroW: b })) : a.drawVerticalBoxPaths(F(F({}, _), {}, { xDivision: m, barWidth: P, zeroH: x })), y = N.y, v = N.x;
        var U = a.barHelpers.drawGoalLine({ barXPosition: N.barXPosition, barYPosition: N.barYPosition, goalX: N.goalX, goalY: N.goalY, barHeight: C, barWidth: P });
        U && M.add(U), Y > 0 && S.push(v + P / 2), w.push(y), N.pathTo.forEach(function(q, oe) {
          var ae = !a.isBoxPlot && a.candlestickOptions.wick.useFillColor ? N.color[oe] : o.globals.stroke.colors[g], ue = h.fillPath({ seriesNumber: k, dataPointIndex: Y, color: N.color[oe], value: i[g][Y] });
          a.renderSeries({ realIndex: k, pathFill: ue, lineFill: ae, j: Y, i: g, pathFrom: N.pathFrom, pathTo: q, strokeWidth: V, elSeries: T, x: v, y, series: i, columnGroupIndex: A, barHeight: C, barWidth: P, elDataLabelsWrap: X, elGoalsMarkers: M, visibleSeries: a.visibleI, type: o.config.chart.type });
        });
      }, I = 0; I < o.globals.dataPoints; I++) z(I);
      o.globals.seriesXvalues[k] = S, o.globals.seriesYvalues[k] = w, d.add(T);
    }, p = 0; p < i.length; p++) f(p);
    return d;
  } }, { key: "drawVerticalBoxPaths", value: function(i) {
    var n = i.indexes, r = i.x;
    i.y;
    var a = i.xDivision, o = i.barWidth, l = i.zeroH, c = i.strokeWidth, h = this.w, u = new Z(this.ctx), d = n.i, f = n.j, p = h.config.plotOptions.candlestick.colors, g = this.boxOptions.colors, m = n.realIndex, O = function(I) {
      return Array.isArray(I) ? I[m] : I;
    }, x = O(p.upward), b = O(p.downward), v = this.yRatio[n.translationsIndex], y = this.getOHLCValue(m, f), w = l, S = l, k = y.o < y.c ? [x] : [b];
    this.isBoxPlot && (k = [O(g.lower), O(g.upper)]);
    var A = Math.min(y.o, y.c), T = Math.max(y.o, y.c), C = y.m;
    h.globals.isXNumeric && (r = (h.globals.seriesX[m][f] - h.globals.minX) / this.xRatio - o / 2);
    var P = r + o * this.visibleI;
    this.series[d][f] === void 0 || this.series[d][f] === null ? (A = l, T = l) : (A = l - A / v, T = l - T / v, w = l - y.h / v, S = l - y.l / v, C = l - y.m / v);
    var $ = u.move(P, l), R = u.move(P + o / 2, A);
    if (h.globals.previousPaths.length > 0 && (R = this.getPreviousPath(m, f, !0)), this.isOHLC) {
      var X = P + o / 2, M = l - y.o / v, z = l - y.c / v;
      $ = [u.move(X, w) + u.line(X, S) + u.move(X, M) + u.line(P, M) + u.move(X, z) + u.line(P + o, z)];
    } else $ = this.isBoxPlot ? [u.move(P, A) + u.line(P + o / 2, A) + u.line(P + o / 2, w) + u.line(P + o / 4, w) + u.line(P + o - o / 4, w) + u.line(P + o / 2, w) + u.line(P + o / 2, A) + u.line(P + o, A) + u.line(P + o, C) + u.line(P, C) + u.line(P, A + c / 2), u.move(P, C) + u.line(P + o, C) + u.line(P + o, T) + u.line(P + o / 2, T) + u.line(P + o / 2, S) + u.line(P + o - o / 4, S) + u.line(P + o / 4, S) + u.line(P + o / 2, S) + u.line(P + o / 2, T) + u.line(P, T) + u.line(P, C) + "z"] : [u.move(P, T) + u.line(P + o / 2, T) + u.line(P + o / 2, w) + u.line(P + o / 2, T) + u.line(P + o, T) + u.line(P + o, A) + u.line(P + o / 2, A) + u.line(P + o / 2, S) + u.line(P + o / 2, A) + u.line(P, A) + u.line(P, T - c / 2)];
    return R += u.move(P, A), h.globals.isXNumeric || (r += a), { pathTo: $, pathFrom: R, x: r, y: T, goalY: this.barHelpers.getGoalValues("y", null, l, d, f, n.translationsIndex), barXPosition: P, color: k };
  } }, { key: "drawHorizontalBoxPaths", value: function(i) {
    var n = i.indexes;
    i.x;
    var r = i.y, a = i.yDivision, o = i.barHeight, l = i.zeroW, c = i.strokeWidth, h = this.w, u = new Z(this.ctx), d = n.i, f = n.j, p = this.boxOptions.colors.lower;
    this.isBoxPlot && (p = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var g = this.invertedYRatio, m = n.realIndex, O = this.getOHLCValue(m, f), x = l, b = l, v = Math.min(O.o, O.c), y = Math.max(O.o, O.c), w = O.m;
    h.globals.isXNumeric && (r = (h.globals.seriesX[m][f] - h.globals.minX) / this.invertedXRatio - o / 2);
    var S = r + o * this.visibleI;
    this.series[d][f] === void 0 || this.series[d][f] === null ? (v = l, y = l) : (v = l + v / g, y = l + y / g, x = l + O.h / g, b = l + O.l / g, w = l + O.m / g);
    var k = u.move(l, S), A = u.move(v, S + o / 2);
    return h.globals.previousPaths.length > 0 && (A = this.getPreviousPath(m, f, !0)), k = [u.move(v, S) + u.line(v, S + o / 2) + u.line(x, S + o / 2) + u.line(x, S + o / 2 - o / 4) + u.line(x, S + o / 2 + o / 4) + u.line(x, S + o / 2) + u.line(v, S + o / 2) + u.line(v, S + o) + u.line(w, S + o) + u.line(w, S) + u.line(v + c / 2, S), u.move(w, S) + u.line(w, S + o) + u.line(y, S + o) + u.line(y, S + o / 2) + u.line(b, S + o / 2) + u.line(b, S + o - o / 4) + u.line(b, S + o / 4) + u.line(b, S + o / 2) + u.line(y, S + o / 2) + u.line(y, S) + u.line(w, S) + "z"], A += u.move(v, S), h.globals.isXNumeric || (r += a), { pathTo: k, pathFrom: A, x: y, y: r, goalX: this.barHelpers.getGoalValues("x", l, null, d, f), barYPosition: S, color: p };
  } }, { key: "getOHLCValue", value: function(i, n) {
    var r = this.w, a = new st(this.ctx, r), o = a.getLogValAtSeriesIndex(r.globals.seriesCandleH[i][n], i), l = a.getLogValAtSeriesIndex(r.globals.seriesCandleO[i][n], i), c = a.getLogValAtSeriesIndex(r.globals.seriesCandleM[i][n], i), h = a.getLogValAtSeriesIndex(r.globals.seriesCandleC[i][n], i), u = a.getLogValAtSeriesIndex(r.globals.seriesCandleL[i][n], i);
    return { o: this.isBoxPlot ? o : l, h: this.isBoxPlot ? l : o, m: c, l: this.isBoxPlot ? h : u, c: this.isBoxPlot ? u : h };
  } }]), t;
}(), tv = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "checkColorRange", value: function() {
    var e = this.w, t = !1, i = e.config.plotOptions[e.config.chart.type];
    return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(n, r) {
      n.from <= 0 && (t = !0);
    }), t;
  } }, { key: "getShadeColor", value: function(e, t, i, n) {
    var r = this.w, a = 1, o = r.config.plotOptions[e].shadeIntensity, l = this.determineColor(e, t, i);
    r.globals.hasNegs || n ? a = r.config.plotOptions[e].reverseNegativeShade ? l.percent < 0 ? l.percent / 100 * (1.25 * o) : (1 - l.percent / 100) * (1.25 * o) : l.percent <= 0 ? 1 - (1 + l.percent / 100) * o : (1 - l.percent / 100) * o : (a = 1 - l.percent / 100, e === "treemap" && (a = (1 - l.percent / 100) * (1.25 * o)));
    var c = l.color, h = new E();
    if (r.config.plotOptions[e].enableShades) if (this.w.config.theme.mode === "dark") {
      var u = h.shadeColor(-1 * a, l.color);
      c = E.hexToRgba(E.isColorHex(u) ? u : E.rgb2hex(u), r.config.fill.opacity);
    } else {
      var d = h.shadeColor(a, l.color);
      c = E.hexToRgba(E.isColorHex(d) ? d : E.rgb2hex(d), r.config.fill.opacity);
    }
    return { color: c, colorProps: l };
  } }, { key: "determineColor", value: function(e, t, i) {
    var n = this.w, r = n.globals.series[t][i], a = n.config.plotOptions[e], o = a.colorScale.inverse ? i : t;
    a.distributed && n.config.chart.type === "treemap" && (o = i);
    var l = n.globals.colors[o], c = null, h = Math.min.apply(Math, dt(n.globals.series[t])), u = Math.max.apply(Math, dt(n.globals.series[t]));
    a.distributed || e !== "heatmap" || (h = n.globals.minY, u = n.globals.maxY), a.colorScale.min !== void 0 && (h = a.colorScale.min < n.globals.minY ? a.colorScale.min : n.globals.minY, u = a.colorScale.max > n.globals.maxY ? a.colorScale.max : n.globals.maxY);
    var d = Math.abs(u) + Math.abs(h), f = 100 * r / (d === 0 ? d - 1e-6 : d);
    return a.colorScale.ranges.length > 0 && a.colorScale.ranges.map(function(p, g) {
      if (r >= p.from && r <= p.to) {
        l = p.color, c = p.foreColor ? p.foreColor : null, h = p.from, u = p.to;
        var m = Math.abs(u) + Math.abs(h);
        f = 100 * r / (m === 0 ? m - 1e-6 : m);
      }
    }), { color: l, foreColor: c, percent: f };
  } }, { key: "calculateDataLabels", value: function(e) {
    var t = e.text, i = e.x, n = e.y, r = e.i, a = e.j, o = e.colorProps, l = e.fontSize, c = this.w.config.dataLabels, h = new Z(this.ctx), u = new cr(this.ctx), d = null;
    if (c.enabled) {
      d = h.group({ class: "apexcharts-data-labels" });
      var f = c.offsetX, p = c.offsetY, g = i + f, m = n + parseFloat(c.style.fontSize) / 3 + p;
      u.plotDataLabelsText({ x: g, y: m, text: t, i: r, j: a, color: o.foreColor, parent: d, fontSize: l, dataLabelsConfig: c });
    }
    return d;
  } }, { key: "addListeners", value: function(e) {
    var t = new Z(this.ctx);
    e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)), e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e));
  } }]), s;
}(), p$ = function() {
  function s(e, t) {
    ee(this, s), this.ctx = e, this.w = e.w, this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new tv(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return te(s, [{ key: "draw", value: function(e) {
    var t = this.w, i = new Z(this.ctx), n = i.group({ class: "apexcharts-heatmap" });
    n.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")"));
    var r = t.globals.gridWidth / t.globals.dataPoints, a = t.globals.gridHeight / t.globals.series.length, o = 0, l = !1;
    this.negRange = this.helpers.checkColorRange();
    var c = e.slice();
    t.config.yaxis[0].reversed && (l = !0, c.reverse());
    for (var h = l ? 0 : c.length - 1; l ? h < c.length : h >= 0; l ? h++ : h--) {
      var u = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: E.escapeString(t.globals.seriesNames[h]), rel: h + 1, "data:realIndex": h });
      if (this.ctx.series.addCollapsedClassToSeries(u, h), t.config.chart.dropShadow.enabled) {
        var d = t.config.chart.dropShadow;
        new vt(this.ctx).dropShadow(u, d, h);
      }
      for (var f = 0, p = t.config.plotOptions.heatmap.shadeIntensity, g = 0, m = 0; m < t.globals.dataPoints; m++) if (t.globals.seriesX.length && !t.globals.allSeriesHasEqualX && t.globals.minX + t.globals.minXDiff * m < t.globals.seriesX[h][g]) f += r;
      else {
        if (g >= c[h].length) break;
        var O = this.helpers.getShadeColor(t.config.chart.type, h, g, this.negRange), x = O.color, b = O.colorProps;
        t.config.fill.type === "image" && (x = new Ci(this.ctx).fillPath({ seriesNumber: h, dataPointIndex: g, opacity: t.globals.hasNegs ? b.percent < 0 ? 1 - (1 + b.percent / 100) : p + b.percent / 100 : b.percent / 100, patternID: E.randomId(), width: t.config.fill.image.width ? t.config.fill.image.width : r, height: t.config.fill.image.height ? t.config.fill.image.height : a }));
        var v = this.rectRadius, y = i.drawRect(f, o, r, a, v);
        if (y.attr({ cx: f, cy: o }), y.node.classList.add("apexcharts-heatmap-rect"), u.add(y), y.attr({ fill: x, i: h, index: h, j: g, val: e[h][g], "stroke-width": this.strokeWidth, stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? x : t.globals.stroke.colors[0], color: x }), this.helpers.addListeners(y), t.config.chart.animations.enabled && !t.globals.dataChanged) {
          var w = 1;
          t.globals.resized || (w = t.config.chart.animations.speed), this.animateHeatMap(y, f, o, r, a, w);
        }
        if (t.globals.dataChanged) {
          var S = 1;
          if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
            S = this.dynamicAnim.speed;
            var k = t.globals.previousPaths[h] && t.globals.previousPaths[h][g] && t.globals.previousPaths[h][g].color;
            k || (k = "rgba(255, 255, 255, 0)"), this.animateHeatColor(y, E.isColorHex(k) ? k : E.rgb2hex(k), E.isColorHex(x) ? x : E.rgb2hex(x), S);
          }
        }
        var A = (0, t.config.dataLabels.formatter)(t.globals.series[h][g], { value: t.globals.series[h][g], seriesIndex: h, dataPointIndex: g, w: t }), T = this.helpers.calculateDataLabels({ text: A, x: f + r / 2, y: o + a / 2, i: h, j: g, colorProps: b, series: c });
        T !== null && u.add(T), f += r, g++;
      }
      o += a, n.add(u);
    }
    var C = t.globals.yAxisScale[0].result.slice();
    return t.config.yaxis[0].reversed ? C.unshift("") : C.push(""), t.globals.yAxisScale[0].result = C, n;
  } }, { key: "animateHeatMap", value: function(e, t, i, n, r, a) {
    var o = new Cr(this.ctx);
    o.animateRect(e, { x: t + n / 2, y: i + r / 2, width: 0, height: 0 }, { x: t, y: i, width: n, height: r }, a, function() {
      o.animationCompleted(e);
    });
  } }, { key: "animateHeatColor", value: function(e, t, i, n) {
    e.attr({ fill: t }).animate(n).attr({ fill: i });
  } }]), s;
}(), iv = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "drawYAxisTexts", value: function(e, t, i, n) {
    var r = this.w, a = r.config.yaxis[0], o = r.globals.yLabelFormatters[0];
    return new Z(this.ctx).drawText({ x: e + a.labels.offsetX, y: t + a.labels.offsetY, text: o(n, i), textAnchor: "middle", fontSize: a.labels.style.fontSize, fontFamily: a.labels.style.fontFamily, foreColor: Array.isArray(a.labels.style.colors) ? a.labels.style.colors[i] : a.labels.style.colors });
  } }]), s;
}(), sv = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = Math.min(t.globals.gridWidth, t.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = t.globals.gridWidth / 2, t.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(t.config.plotOptions.pie.endAngle - t.config.plotOptions.pie.startAngle), this.initialAngle = t.config.plotOptions.pie.startAngle % this.fullAngle, t.globals.radialSize = this.defaultSize / 2.05 - t.config.stroke.width - (t.config.chart.sparkline.enabled ? 0 : t.config.chart.dropShadow.blur), this.donutSize = t.globals.radialSize * parseInt(t.config.plotOptions.pie.donut.size, 10) / 100;
    var i = t.config.plotOptions.pie.customScale, n = t.globals.gridWidth / 2, r = t.globals.gridHeight / 2;
    this.translateX = n - n * i, this.translateY = r - r * i, this.dataLabelsGroup = new Z(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return te(s, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, n = new Z(this.ctx), r = n.group({ class: "apexcharts-pie" });
    if (i.globals.noData) return r;
    for (var a = 0, o = 0; o < e.length; o++) a += E.negToZero(e[o]);
    var l = [], c = n.group();
    a === 0 && (a = 1e-5), e.forEach(function(b) {
      t.maxY = Math.max(t.maxY, b);
    }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(r);
    for (var h = 0; h < e.length; h++) {
      var u = this.fullAngle * E.negToZero(e[h]) / a;
      l.push(u), this.chartType === "polarArea" ? (l[h] = this.fullAngle / e.length, this.sliceSizes.push(i.globals.radialSize * e[h] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
    }
    if (i.globals.dataChanged) {
      for (var d, f = 0, p = 0; p < i.globals.previousPaths.length; p++) f += E.negToZero(i.globals.previousPaths[p]);
      for (var g = 0; g < i.globals.previousPaths.length; g++) d = this.fullAngle * E.negToZero(i.globals.previousPaths[g]) / f, this.prevSectorAngleArr.push(d);
    }
    if (this.donutSize < 0 && (this.donutSize = 0), this.chartType === "donut") {
      var m = n.drawCircle(this.donutSize);
      m.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), c.add(m);
    }
    var O = this.drawArcs(l, e);
    if (this.sliceLabels.forEach(function(b) {
      O.add(b);
    }), c.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), c.add(O), r.add(c), this.donutDataLabels.show) {
      var x = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      r.add(x);
    }
    return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(r), r;
  } }, { key: "drawArcs", value: function(e, t) {
    var i = this.w, n = new vt(this.ctx), r = new Z(this.ctx), a = new Ci(this.ctx), o = r.group({ class: "apexcharts-slices" }), l = this.initialAngle, c = this.initialAngle, h = this.initialAngle, u = this.initialAngle;
    this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
    for (var d = 0; d < e.length; d++) {
      var f = r.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: E.escapeString(i.globals.seriesNames[d]), rel: d + 1, "data:realIndex": d });
      o.add(f), c = u, h = (l = h) + e[d], u = c + this.prevSectorAngleArr[d];
      var p = h < l ? this.fullAngle + h - l : h - l, g = a.fillPath({ seriesNumber: d, size: this.sliceSizes[d], value: t[d] }), m = this.getChangedPath(c, u), O = r.drawPath({ d: m, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d] : this.lineColorArr, strokeWidth: 0, fill: g, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d) });
      if (O.attr({ index: 0, j: d }), n.setSelectionFilter(O, 0, d), i.config.chart.dropShadow.enabled) {
        var x = i.config.chart.dropShadow;
        n.dropShadow(O, x, d);
      }
      this.addListeners(O, this.donutDataLabels), Z.setAttrs(O.node, { "data:angle": p, "data:startAngle": l, "data:strokeWidth": this.strokeWidth, "data:value": t[d] });
      var b = { x: 0, y: 0 };
      this.chartType === "pie" || this.chartType === "polarArea" ? b = E.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (l + p / 2) % this.fullAngle) : this.chartType === "donut" && (b = E.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (l + p / 2) % this.fullAngle)), f.add(O);
      var v = 0;
      if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((v = p / this.fullAngle * i.config.chart.animations.speed) === 0 && (v = 1), this.animDur = v + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(O, { size: this.sliceSizes[d], endAngle: h, startAngle: l, prevStartAngle: c, prevEndAngle: u, animateStartingPos: !0, i: d, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(O, { size: this.sliceSizes[d], endAngle: h, startAngle: l, i: d, totalItems: e.length - 1, animBeginArr: this.animBeginArr, dur: v }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && O.node.addEventListener("mouseup", this.pieClicked.bind(this, d)), i.globals.selectedDataPoints[0] !== void 0 && i.globals.selectedDataPoints[0].indexOf(d) > -1 && this.pieClicked(d), i.config.dataLabels.enabled) {
        var y = b.x, w = b.y, S = 100 * p / this.fullAngle + "%";
        if (p !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[d]) {
          var k = i.config.dataLabels.formatter;
          k !== void 0 && (S = k(i.globals.seriesPercent[d][0], { seriesIndex: d, w: i }));
          var A = i.globals.dataLabels.style.colors[d], T = r.group({ class: "apexcharts-datalabels" }), C = r.drawText({ x: y, y: w, text: S, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: A });
          if (T.add(C), i.config.dataLabels.dropShadow.enabled) {
            var P = i.config.dataLabels.dropShadow;
            n.dropShadow(C, P);
          }
          C.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === !1 && (C.node.classList.add("apexcharts-pie-label-delay"), C.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(T);
        }
      }
    }
    return o;
  } }, { key: "addListeners", value: function(e, t) {
    var i = new Z(this.ctx);
    e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e)), e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e)), this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)));
  } }, { key: "animatePaths", value: function(e, t) {
    var i = this.w, n = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle, r = n, a = t.startAngle, o = t.startAngle;
    t.prevStartAngle !== void 0 && t.prevEndAngle !== void 0 && (a = t.prevEndAngle, r = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle), t.i === i.config.series.length - 1 && (n + o > this.fullAngle ? t.endAngle = t.endAngle - (n + o) : n + o < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (n + o)))), n === this.fullAngle && (n = this.fullAngle - 0.01), this.animateArc(e, a, o, n, r, t);
  } }, { key: "animateArc", value: function(e, t, i, n, r, a) {
    var o, l = this, c = this.w, h = new Cr(this.ctx), u = a.size;
    (isNaN(t) || isNaN(r)) && (t = i, r = n, a.dur = 0);
    var d = n, f = i, p = t < i ? this.fullAngle + t - i : t - i;
    c.globals.dataChanged && a.shouldSetPrevPaths && a.prevEndAngle && (o = l.getPiePath({ me: l, startAngle: a.prevStartAngle, angle: a.prevEndAngle < a.prevStartAngle ? this.fullAngle + a.prevEndAngle - a.prevStartAngle : a.prevEndAngle - a.prevStartAngle, size: u }), e.attr({ d: o })), a.dur !== 0 ? e.animate(a.dur, a.animBeginArr[a.i]).after(function() {
      l.chartType !== "pie" && l.chartType !== "donut" && l.chartType !== "polarArea" || this.animate(c.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": l.strokeWidth }), a.i === c.config.series.length - 1 && h.animationCompleted(e);
    }).during(function(g) {
      d = p + (n - p) * g, a.animateStartingPos && (d = r + (n - r) * g, f = t - r + (i - (t - r)) * g), o = l.getPiePath({ me: l, startAngle: f, angle: d, size: u }), e.node.setAttribute("data:pathOrig", o), e.attr({ d: o });
    }) : (o = l.getPiePath({ me: l, startAngle: f, angle: n, size: u }), a.isTrack || (c.globals.animationEnded = !0), e.node.setAttribute("data:pathOrig", o), e.attr({ d: o, "stroke-width": l.strokeWidth }));
  } }, { key: "pieClicked", value: function(e) {
    var t, i = this.w, n = this, r = n.sliceSizes[e] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), a = i.globals.dom.Paper.findOne(".apexcharts-".concat(n.chartType.toLowerCase(), "-slice-").concat(e));
    if (a.attr("data:pieClicked") !== "true") {
      var o = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
      Array.prototype.forEach.call(o, function(u) {
        u.setAttribute("data:pieClicked", "false");
        var d = u.getAttribute("data:pathOrig");
        d && u.setAttribute("d", d);
      }), i.globals.capturedDataPointIndex = e, a.attr("data:pieClicked", "true");
      var l = parseInt(a.attr("data:startAngle"), 10), c = parseInt(a.attr("data:angle"), 10);
      t = n.getPiePath({ me: n, startAngle: l, angle: c, size: r }), c !== 360 && a.plot(t);
    } else {
      a.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(a.node, this.donutDataLabels);
      var h = a.attr("data:pathOrig");
      a.attr({ d: h });
    }
  } }, { key: "getChangedPath", value: function(e, t) {
    var i = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: e, angle: t - e, size: this.size })), i;
  } }, { key: "getPiePath", value: function(e) {
    var t, i = e.me, n = e.startAngle, r = e.angle, a = e.size, o = new Z(this.ctx), l = n, c = Math.PI * (l - 90) / 180, h = r + n;
    Math.ceil(h) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h) > this.fullAngle && (h -= this.fullAngle);
    var u = Math.PI * (h - 90) / 180, d = i.centerX + a * Math.cos(c), f = i.centerY + a * Math.sin(c), p = i.centerX + a * Math.cos(u), g = i.centerY + a * Math.sin(u), m = E.polarToCartesian(i.centerX, i.centerY, i.donutSize, h), O = E.polarToCartesian(i.centerX, i.centerY, i.donutSize, l), x = r > 180 ? 1 : 0, b = ["M", d, f, "A", a, a, 0, x, 1, p, g];
    return t = i.chartType === "donut" ? [].concat(b, ["L", m.x, m.y, "A", i.donutSize, i.donutSize, 0, x, 0, O.x, O.y, "L", d, f, "z"]).join(" ") : i.chartType === "pie" || i.chartType === "polarArea" ? [].concat(b, ["L", i.centerX, i.centerY, "L", d, f]).join(" ") : [].concat(b).join(" "), o.roundPathCorners(t, 2 * this.strokeWidth);
  } }, { key: "drawPolarElements", value: function(e) {
    var t = this.w, i = new Uy(this.ctx), n = new Z(this.ctx), r = new iv(this.ctx), a = n.group(), o = n.group(), l = i.niceScale(0, Math.ceil(this.maxY), 0), c = l.result.reverse(), h = l.result.length;
    this.maxY = l.niceMax;
    for (var u = t.globals.radialSize, d = u / (h - 1), f = 0; f < h - 1; f++) {
      var p = n.drawCircle(u);
      if (p.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth, stroke: t.config.plotOptions.polarArea.rings.strokeColor }), t.config.yaxis[0].show) {
        var g = r.drawYAxisTexts(this.centerX, this.centerY - u + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, f, c[f]);
        o.add(g);
      }
      a.add(p), u -= d;
    }
    this.drawSpokes(e), e.add(a), e.add(o);
  } }, { key: "renderInnerDataLabels", value: function(e, t, i) {
    var n = this.w, r = new Z(this.ctx), a = t.total.show;
    e.node.innerHTML = "", e.node.style.opacity = i.opacity;
    var o, l, c = i.centerX, h = this.donutDataLabels.total.label ? i.centerY : i.centerY - i.centerY / 6;
    o = t.name.color === void 0 ? n.globals.colors[0] : t.name.color;
    var u = t.name.fontSize, d = t.name.fontFamily, f = t.name.fontWeight;
    l = t.value.color === void 0 ? n.config.chart.foreColor : t.value.color;
    var p = t.value.formatter, g = "", m = "";
    if (a ? (o = t.total.color, u = t.total.fontSize, d = t.total.fontFamily, f = t.total.fontWeight, m = this.donutDataLabels.total.label ? t.total.label : "", g = t.total.formatter(n)) : n.globals.series.length === 1 && (g = p(n.globals.series[0], n), m = n.globals.seriesNames[0]), m && (m = t.name.formatter(m, t.total.show, n)), t.name.show) {
      var O = r.drawText({ x: c, y: h + parseFloat(t.name.offsetY), text: m, textAnchor: "middle", foreColor: o, fontSize: u, fontWeight: f, fontFamily: d });
      O.node.classList.add("apexcharts-datalabel-label"), e.add(O);
    }
    if (t.value.show) {
      var x = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, b = r.drawText({ x: c, y: h + x, text: g, textAnchor: "middle", foreColor: l, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily });
      b.node.classList.add("apexcharts-datalabel-value"), e.add(b);
    }
    return e;
  } }, { key: "printInnerLabels", value: function(e, t, i, n) {
    var r, a = this.w;
    n ? r = e.name.color === void 0 ? a.globals.colors[parseInt(n.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : a.globals.series.length > 1 && e.total.show && (r = e.total.color);
    var o = a.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), l = a.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i = (0, e.value.formatter)(i, a), n || typeof e.total.formatter != "function" || (i = e.total.formatter(a));
    var c = t === e.total.label;
    t = this.donutDataLabels.total.label ? e.name.formatter(t, c, a) : "", o !== null && (o.textContent = t), l !== null && (l.textContent = i), o !== null && (o.style.fill = r);
  } }, { key: "printDataLabelsInner", value: function(e, t) {
    var i = this.w, n = e.getAttribute("data:value"), r = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
    i.globals.series.length > 1 && this.printInnerLabels(t, r, n, e);
    var a = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    a !== null && (a.style.opacity = 1);
  } }, { key: "drawSpokes", value: function(e) {
    var t = this, i = this.w, n = new Z(this.ctx), r = i.config.plotOptions.polarArea.spokes;
    if (r.strokeWidth !== 0) {
      for (var a = [], o = 360 / i.globals.series.length, l = 0; l < i.globals.series.length; l++) a.push(E.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + o * l));
      a.forEach(function(c, h) {
        var u = n.drawLine(c.x, c.y, t.centerX, t.centerY, Array.isArray(r.connectorColors) ? r.connectorColors[h] : r.connectorColors);
        e.add(u);
      });
    }
  } }, { key: "revertDataLabelsInner", value: function() {
    var e = this.w;
    if (this.donutDataLabels.show) {
      var t = e.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i = this.renderInnerDataLabels(t, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      e.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i);
    }
  } }]), s;
}(), g$ = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var t = this.w;
    this.graphics = new Z(this.ctx), this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = t.globals.svgHeight < t.globals.svgWidth ? t.globals.gridHeight : t.globals.gridWidth, this.isLog = t.config.yaxis[0].logarithmic, this.logBase = t.config.yaxis[0].logBase, this.coreUtils = new st(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, t.globals.maxY, 0) : t.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : t.globals.minY, this.polygons = t.config.plotOptions.radar.polygons, this.strokeWidth = t.config.stroke.show ? t.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - t.config.chart.dropShadow.blur, t.config.xaxis.labels.show && (this.size = this.size - t.globals.xAxisLabelsWidth / 1.75), t.config.plotOptions.radar.size !== void 0 && (this.size = t.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return te(s, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, n = new Ci(this.ctx), r = [], a = new cr(this.ctx);
    e.length && (this.dataPointsLen = e[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var o = i.globals.gridWidth / 2, l = i.globals.gridHeight / 2, c = o + i.config.plotOptions.radar.offsetX, h = l + i.config.plotOptions.radar.offsetY, u = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(c || 0, ", ").concat(h || 0, ")") }), d = [], f = null, p = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), e.forEach(function(m, O) {
      var x = m.length === i.globals.dataPoints, b = t.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": x, seriesName: E.escapeString(i.globals.seriesNames[O]), rel: O + 1, "data:realIndex": O });
      t.dataRadiusOfPercent[O] = [], t.dataRadius[O] = [], t.angleArr[O] = [], m.forEach(function($, R) {
        var X = Math.abs(t.maxValue - t.minValue);
        $ -= t.minValue, t.isLog && ($ = t.coreUtils.getLogVal(t.logBase, $, 0)), t.dataRadiusOfPercent[O][R] = $ / X, t.dataRadius[O][R] = t.dataRadiusOfPercent[O][R] * t.size, t.angleArr[O][R] = R * t.disAngle;
      }), d = t.getDataPointsPos(t.dataRadius[O], t.angleArr[O]);
      var v = t.createPaths(d, { x: 0, y: 0 });
      f = t.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p = t.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": O }), i.globals.delayedElements.push({ el: f.node, index: O });
      var y = { i: O, realIndex: O, animationDelay: O, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[O], strokeLineCap: i.config.stroke.lineCap }, w = null;
      i.globals.previousPaths.length > 0 && (w = t.getPreviousPath(O));
      for (var S = 0; S < v.linePathsTo.length; S++) {
        var k = t.graphics.renderPaths(F(F({}, y), {}, { pathFrom: w === null ? v.linePathsFrom[S] : w, pathTo: v.linePathsTo[S], strokeWidth: Array.isArray(t.strokeWidth) ? t.strokeWidth[O] : t.strokeWidth, fill: "none", drawShadow: !1 }));
        b.add(k);
        var A = n.fillPath({ seriesNumber: O }), T = t.graphics.renderPaths(F(F({}, y), {}, { pathFrom: w === null ? v.areaPathsFrom[S] : w, pathTo: v.areaPathsTo[S], strokeWidth: 0, fill: A, drawShadow: !1 }));
        if (i.config.chart.dropShadow.enabled) {
          var C = new vt(t.ctx), P = i.config.chart.dropShadow;
          C.dropShadow(T, Object.assign({}, P, { noUserSpaceOnUse: !0 }), O);
        }
        b.add(T);
      }
      m.forEach(function($, R) {
        var X = new Rr(t.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: O, dataPointIndex: R }), M = t.graphics.drawMarker(d[R].x, d[R].y, X);
        M.attr("rel", R), M.attr("j", R), M.attr("index", O), M.node.setAttribute("default-marker-size", X.pSize);
        var z = t.graphics.group({ class: "apexcharts-series-markers" });
        z && z.add(M), f.add(z), b.add(f);
        var I = i.config.dataLabels;
        if (I.enabled) {
          var Y = I.formatter(i.globals.series[O][R], { seriesIndex: O, dataPointIndex: R, w: i });
          a.plotDataLabelsText({ x: d[R].x, y: d[R].y, text: Y, textAnchor: "middle", i: O, j: O, parent: p, offsetCorrection: !1, dataLabelsConfig: F({}, I) });
        }
        b.add(p);
      }), r.push(b);
    }), this.drawPolygons({ parent: u }), i.config.xaxis.labels.show) {
      var g = this.drawXAxisTexts();
      u.add(g);
    }
    return r.forEach(function(m) {
      u.add(m);
    }), u.add(this.yaxisLabels), u;
  } }, { key: "drawPolygons", value: function(e) {
    for (var t = this, i = this.w, n = e.parent, r = new iv(this.ctx), a = i.globals.yAxisScale[0].result.reverse(), o = a.length, l = [], c = this.size / (o - 1), h = 0; h < o; h++) l[h] = c * h;
    l.reverse();
    var u = [], d = [];
    l.forEach(function(f, p) {
      var g = E.getPolygonPos(f, t.dataPointsLen), m = "";
      g.forEach(function(O, x) {
        if (p === 0) {
          var b = t.graphics.drawLine(O.x, O.y, 0, 0, Array.isArray(t.polygons.connectorColors) ? t.polygons.connectorColors[x] : t.polygons.connectorColors);
          d.push(b);
        }
        x === 0 && t.yaxisLabelsTextsPos.push({ x: O.x, y: O.y }), m += O.x + "," + O.y + " ";
      }), u.push(m);
    }), u.forEach(function(f, p) {
      var g = t.polygons.strokeColors, m = t.polygons.strokeWidth, O = t.graphics.drawPolygon(f, Array.isArray(g) ? g[p] : g, Array.isArray(m) ? m[p] : m, i.globals.radarPolygons.fill.colors[p]);
      n.add(O);
    }), d.forEach(function(f) {
      n.add(f);
    }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(f, p) {
      var g = r.drawYAxisTexts(f.x, f.y, p, a[p]);
      t.yaxisLabels.add(g);
    });
  } }, { key: "drawXAxisTexts", value: function() {
    var e = this, t = this.w, i = t.config.xaxis.labels, n = this.graphics.group({ class: "apexcharts-xaxis" }), r = E.getPolygonPos(this.size, this.dataPointsLen);
    return t.globals.labels.forEach(function(a, o) {
      var l = t.config.xaxis.labels.formatter, c = new cr(e.ctx);
      if (r[o]) {
        var h = e.getTextPos(r[o], e.size), u = l(a, { seriesIndex: -1, dataPointIndex: o, w: t });
        c.plotDataLabelsText({ x: h.newX, y: h.newY, text: u, textAnchor: h.textAnchor, i: o, j: o, parent: n, className: "apexcharts-xaxis-label", color: Array.isArray(i.style.colors) && i.style.colors[o] ? i.style.colors[o] : "#a8a8a8", dataLabelsConfig: F({ textAnchor: h.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1 }).on("click", function(d) {
          if (typeof t.config.chart.events.xAxisLabelClick == "function") {
            var f = Object.assign({}, t, { labelIndex: o });
            t.config.chart.events.xAxisLabelClick(d, e.ctx, f);
          }
        });
      }
    }), n;
  } }, { key: "createPaths", value: function(e, t) {
    var i = this, n = [], r = [], a = [], o = [];
    if (e.length) {
      r = [this.graphics.move(t.x, t.y)], o = [this.graphics.move(t.x, t.y)];
      var l = this.graphics.move(e[0].x, e[0].y), c = this.graphics.move(e[0].x, e[0].y);
      e.forEach(function(h, u) {
        l += i.graphics.line(h.x, h.y), c += i.graphics.line(h.x, h.y), u === e.length - 1 && (l += "Z", c += "Z");
      }), n.push(l), a.push(c);
    }
    return { linePathsFrom: r, linePathsTo: n, areaPathsFrom: o, areaPathsTo: a };
  } }, { key: "getTextPos", value: function(e, t) {
    var i = "middle", n = e.x, r = e.y;
    return Math.abs(e.x) >= 10 ? e.x > 0 ? (i = "start", n += 10) : e.x < 0 && (i = "end", n -= 10) : i = "middle", Math.abs(e.y) >= t - 10 && (e.y < 0 ? r -= 10 : e.y > 0 && (r += 10)), { textAnchor: i, newX: n, newY: r };
  } }, { key: "getPreviousPath", value: function(e) {
    for (var t = this.w, i = null, n = 0; n < t.globals.previousPaths.length; n++) {
      var r = t.globals.previousPaths[n];
      r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(e, 10) && t.globals.previousPaths[n].paths[0] !== void 0 && (i = t.globals.previousPaths[n].paths[0].d);
    }
    return i;
  } }, { key: "getDataPointsPos", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
    e = e || [], t = t || [];
    for (var n = [], r = 0; r < i; r++) {
      var a = {};
      a.x = e[r] * Math.sin(t[r]), a.y = -e[r] * Math.cos(t[r]), n.push(a);
    }
    return n;
  } }]), s;
}(), m$ = function(s) {
  ho(t, sv);
  var e = co(t);
  function t(i) {
    var n;
    ee(this, t), (n = e.call(this, i)).ctx = i, n.w = i.w, n.animBeginArr = [0], n.animDur = 0;
    var r = n.w;
    return n.startAngle = r.config.plotOptions.radialBar.startAngle, n.endAngle = r.config.plotOptions.radialBar.endAngle, n.totalAngle = Math.abs(r.config.plotOptions.radialBar.endAngle - r.config.plotOptions.radialBar.startAngle), n.trackStartAngle = r.config.plotOptions.radialBar.track.startAngle, n.trackEndAngle = r.config.plotOptions.radialBar.track.endAngle, n.barLabels = n.w.config.plotOptions.radialBar.barLabels, n.donutDataLabels = n.w.config.plotOptions.radialBar.dataLabels, n.radialDataLabels = n.donutDataLabels, n.trackStartAngle || (n.trackStartAngle = n.startAngle), n.trackEndAngle || (n.trackEndAngle = n.endAngle), n.endAngle === 360 && (n.endAngle = 359.99), n.margin = parseInt(r.config.plotOptions.radialBar.track.margin, 10), n.onBarLabelClick = n.onBarLabelClick.bind(my(n)), n;
  }
  return te(t, [{ key: "draw", value: function(i) {
    var n = this.w, r = new Z(this.ctx), a = r.group({ class: "apexcharts-radialbar" });
    if (n.globals.noData) return a;
    var o = r.group(), l = this.defaultSize / 2, c = n.globals.gridWidth / 2, h = this.defaultSize / 2.05;
    n.config.chart.sparkline.enabled || (h = h - n.config.stroke.width - n.config.chart.dropShadow.blur);
    var u = n.globals.fill.colors;
    if (n.config.plotOptions.radialBar.track.show) {
      var d = this.drawTracks({ size: h, centerX: c, centerY: l, colorArr: u, series: i });
      o.add(d);
    }
    var f = this.drawArcs({ size: h, centerX: c, centerY: l, colorArr: u, series: i }), p = 360;
    n.config.plotOptions.radialBar.startAngle < 0 && (p = this.totalAngle);
    var g = (360 - p) / 360;
    if (n.globals.radialSize = h - h * g, this.radialDataLabels.value.show) {
      var m = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      n.globals.radialSize += m * g;
    }
    return o.add(f.g), n.config.plotOptions.radialBar.hollow.position === "front" && (f.g.add(f.elHollow), f.dataLabels && f.g.add(f.dataLabels)), a.add(o), a;
  } }, { key: "drawTracks", value: function(i) {
    var n = this.w, r = new Z(this.ctx), a = r.group({ class: "apexcharts-tracks" }), o = new vt(this.ctx), l = new Ci(this.ctx), c = this.getStrokeWidth(i);
    i.size = i.size - c / 2;
    for (var h = 0; h < i.series.length; h++) {
      var u = r.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      a.add(u), u.attr({ rel: h + 1 }), i.size = i.size - c - this.margin;
      var d = n.config.plotOptions.radialBar.track, f = l.fillPath({ seriesNumber: 0, size: i.size, fillColors: Array.isArray(d.background) ? d.background[h] : d.background, solid: !0 }), p = this.trackStartAngle, g = this.trackEndAngle;
      Math.abs(g) + Math.abs(p) >= 360 && (g = 360 - Math.abs(this.startAngle) - 0.1);
      var m = r.drawPath({ d: "", stroke: f, strokeWidth: c * parseInt(d.strokeWidth, 10) / 100, fill: "none", strokeOpacity: d.opacity, classes: "apexcharts-radialbar-area" });
      if (d.dropShadow.enabled) {
        var O = d.dropShadow;
        o.dropShadow(m, O);
      }
      u.add(m), m.attr("id", "apexcharts-radialbarTrack-" + h), this.animatePaths(m, { centerX: i.centerX, centerY: i.centerY, endAngle: g, startAngle: p, size: i.size, i: h, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0 });
    }
    return a;
  } }, { key: "drawArcs", value: function(i) {
    var n = this.w, r = new Z(this.ctx), a = new Ci(this.ctx), o = new vt(this.ctx), l = r.group(), c = this.getStrokeWidth(i);
    i.size = i.size - c / 2;
    var h = n.config.plotOptions.radialBar.hollow.background, u = i.size - c * i.series.length - this.margin * i.series.length - c * parseInt(n.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, d = u - n.config.plotOptions.radialBar.hollow.margin;
    n.config.plotOptions.radialBar.hollow.image !== void 0 && (h = this.drawHollowImage(i, l, u, h));
    var f = this.drawHollow({ size: d, centerX: i.centerX, centerY: i.centerY, fill: h || "transparent" });
    if (n.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var p = n.config.plotOptions.radialBar.hollow.dropShadow;
      o.dropShadow(f, p);
    }
    var g = 1;
    !this.radialDataLabels.total.show && n.globals.series.length > 1 && (g = 0);
    var m = null;
    if (this.radialDataLabels.show) {
      var O = n.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
      m = this.renderInnerDataLabels(O, this.radialDataLabels, { hollowSize: u, centerX: i.centerX, centerY: i.centerY, opacity: g });
    }
    n.config.plotOptions.radialBar.hollow.position === "back" && (l.add(f), m && l.add(m));
    var x = !1;
    n.config.plotOptions.radialBar.inverseOrder && (x = !0);
    for (var b = x ? i.series.length - 1 : 0; x ? b >= 0 : b < i.series.length; x ? b-- : b++) {
      var v = r.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: E.escapeString(n.globals.seriesNames[b]) });
      l.add(v), v.attr({ rel: b + 1, "data:realIndex": b }), this.ctx.series.addCollapsedClassToSeries(v, b), i.size = i.size - c - this.margin;
      var y = a.fillPath({ seriesNumber: b, size: i.size, value: i.series[b] }), w = this.startAngle, S = void 0, k = E.negToZero(i.series[b] > 100 ? 100 : i.series[b]) / 100, A = Math.round(this.totalAngle * k) + this.startAngle, T = void 0;
      n.globals.dataChanged && (S = this.startAngle, T = Math.round(this.totalAngle * E.negToZero(n.globals.previousPaths[b]) / 100) + S), Math.abs(A) + Math.abs(w) > 360 && (A -= 0.01), Math.abs(T) + Math.abs(S) > 360 && (T -= 0.01);
      var C = A - w, P = Array.isArray(n.config.stroke.dashArray) ? n.config.stroke.dashArray[b] : n.config.stroke.dashArray, $ = r.drawPath({ d: "", stroke: y, strokeWidth: c, fill: "none", fillOpacity: n.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + b, strokeDashArray: P });
      if (Z.setAttrs($.node, { "data:angle": C, "data:value": i.series[b] }), n.config.chart.dropShadow.enabled) {
        var R = n.config.chart.dropShadow;
        o.dropShadow($, R, b);
      }
      if (o.setSelectionFilter($, 0, b), this.addListeners($, this.radialDataLabels), v.add($), $.attr({ index: 0, j: b }), this.barLabels.enabled) {
        var X = E.polarToCartesian(i.centerX, i.centerY, i.size, w), M = this.barLabels.formatter(n.globals.seriesNames[b], { seriesIndex: b, w: n }), z = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || z.push("apexcharts-no-click");
        var I = this.barLabels.useSeriesColors ? n.globals.colors[b] : n.config.chart.foreColor;
        I || (I = n.config.chart.foreColor);
        var Y = X.x + this.barLabels.offsetX, V = X.y + this.barLabels.offsetY, N = r.drawText({ x: Y, y: V, text: M, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: I, cssClass: z.join(" ") });
        N.on("click", this.onBarLabelClick), N.attr({ rel: b + 1 }), w !== 0 && N.attr({ "transform-origin": "".concat(Y, " ").concat(V), transform: "rotate(".concat(w, " 0 0)") }), v.add(N);
      }
      var _ = 0;
      !this.initialAnim || n.globals.resized || n.globals.dataChanged || (_ = n.config.chart.animations.speed), n.globals.dataChanged && (_ = n.config.chart.animations.dynamicAnimation.speed), this.animDur = _ / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths($, { centerX: i.centerX, centerY: i.centerY, endAngle: A, startAngle: w, prevEndAngle: T, prevStartAngle: S, size: i.size, i: b, totalItems: 2, animBeginArr: this.animBeginArr, dur: _, shouldSetPrevPaths: !0 });
    }
    return { g: l, elHollow: f, dataLabels: m };
  } }, { key: "drawHollow", value: function(i) {
    var n = new Z(this.ctx).drawCircle(2 * i.size);
    return n.attr({ class: "apexcharts-radialbar-hollow", cx: i.centerX, cy: i.centerY, r: i.size, fill: i.fill }), n;
  } }, { key: "drawHollowImage", value: function(i, n, r, a) {
    var o = this.w, l = new Ci(this.ctx), c = E.randomId(), h = o.config.plotOptions.radialBar.hollow.image;
    if (o.config.plotOptions.radialBar.hollow.imageClipped) l.clippedImgArea({ width: r, height: r, image: h, patternID: "pattern".concat(o.globals.cuid).concat(c) }), a = "url(#pattern".concat(o.globals.cuid).concat(c, ")");
    else {
      var u = o.config.plotOptions.radialBar.hollow.imageWidth, d = o.config.plotOptions.radialBar.hollow.imageHeight;
      if (u === void 0 && d === void 0) {
        var f = o.globals.dom.Paper.image(h, function(g) {
          this.move(i.centerX - g.width / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - g.height / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        n.add(f);
      } else {
        var p = o.globals.dom.Paper.image(h, function(g) {
          this.move(i.centerX - u / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - d / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(u, d);
        });
        n.add(p);
      }
    }
    return a;
  } }, { key: "getStrokeWidth", value: function(i) {
    var n = this.w;
    return i.size * (100 - parseInt(n.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin;
  } }, { key: "onBarLabelClick", value: function(i) {
    var n = parseInt(i.target.getAttribute("rel"), 10) - 1, r = this.barLabels.onClick, a = this.w;
    r && r(a.globals.seriesNames[n], { w: a, seriesIndex: n });
  } }]), t;
}(), O$ = function(s) {
  ho(t, hr);
  var e = co(t);
  function t() {
    return ee(this, t), e.apply(this, arguments);
  }
  return te(t, [{ key: "draw", value: function(i, n) {
    var r = this.w, a = new Z(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = r.globals.seriesRangeStart, this.seriesRangeEnd = r.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
    for (var o = a.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), l = 0; l < i.length; l++) {
      var c, h, u, d, f = void 0, p = void 0, g = r.globals.comboCharts ? n[l] : l, m = this.barHelpers.getGroupIndex(g).columnGroupIndex, O = a.group({ class: "apexcharts-series", seriesName: E.escapeString(r.globals.seriesNames[g]), rel: l + 1, "data:realIndex": g });
      this.ctx.series.addCollapsedClassToSeries(O, g), i[l].length > 0 && (this.visibleI = this.visibleI + 1);
      var x = 0, b = 0, v = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = r.globals.seriesYAxisReverseMap[g][0], v = g);
      var y = this.barHelpers.initialPositions(g);
      p = y.y, d = y.zeroW, f = y.x, b = y.barWidth, x = y.barHeight, c = y.xDivision, h = y.yDivision, u = y.zeroH;
      for (var w = a.group({ class: "apexcharts-datalabels", "data:realIndex": g }), S = a.group({ class: "apexcharts-rangebar-goals-markers" }), k = 0; k < r.globals.dataPoints; k++) {
        var A = this.barHelpers.getStrokeWidth(l, k, g), T = this.seriesRangeStart[l][k], C = this.seriesRangeEnd[l][k], P = null, $ = null, R = null, X = { x: f, y: p, strokeWidth: A, elSeries: O }, M = this.seriesLen;
        if (r.config.plotOptions.bar.rangeBarGroupRows && (M = 1), r.config.series[l].data[k] === void 0) break;
        if (this.isHorizontal) {
          R = p + x * this.visibleI;
          var z = (h - x * M) / 2;
          if (r.config.series[l].data[k].x) {
            var I = this.detectOverlappingBars({ i: l, j: k, barYPosition: R, srty: z, barHeight: x, yDivision: h, initPositions: y });
            x = I.barHeight, R = I.barYPosition;
          }
          b = (P = this.drawRangeBarPaths(F({ indexes: { i: l, j: k, realIndex: g }, barHeight: x, barYPosition: R, zeroW: d, yDivision: h, y1: T, y2: C }, X))).barWidth;
        } else {
          r.globals.isXNumeric && (f = (r.globals.seriesX[l][k] - r.globals.minX) / this.xRatio - b / 2), $ = f + b * this.visibleI;
          var Y = (c - b * M) / 2;
          if (r.config.series[l].data[k].x) {
            var V = this.detectOverlappingBars({ i: l, j: k, barXPosition: $, srtx: Y, barWidth: b, xDivision: c, initPositions: y });
            b = V.barWidth, $ = V.barXPosition;
          }
          x = (P = this.drawRangeColumnPaths(F({ indexes: { i: l, j: k, realIndex: g, translationsIndex: v }, barWidth: b, barXPosition: $, zeroH: u, xDivision: c }, X))).barHeight;
        }
        var N = this.barHelpers.drawGoalLine({ barXPosition: P.barXPosition, barYPosition: R, goalX: P.goalX, goalY: P.goalY, barHeight: x, barWidth: b });
        N && S.add(N), p = P.y, f = P.x;
        var _ = this.barHelpers.getPathFillColor(i, l, k, g);
        this.renderSeries({ realIndex: g, pathFill: _.color, lineFill: _.useRangeColor ? _.color : r.globals.stroke.colors[g], j: k, i: l, x: f, y: p, y1: T, y2: C, pathFrom: P.pathFrom, pathTo: P.pathTo, strokeWidth: A, elSeries: O, series: i, barHeight: x, barWidth: b, barXPosition: $, barYPosition: R, columnGroupIndex: m, elDataLabelsWrap: w, elGoalsMarkers: S, visibleSeries: this.visibleI, type: "rangebar" });
      }
      o.add(O);
    }
    return o;
  } }, { key: "detectOverlappingBars", value: function(i) {
    var n = i.i, r = i.j, a = i.barYPosition, o = i.barXPosition, l = i.srty, c = i.srtx, h = i.barHeight, u = i.barWidth, d = i.yDivision, f = i.xDivision, p = i.initPositions, g = this.w, m = [], O = g.config.series[n].data[r].rangeName, x = g.config.series[n].data[r].x, b = Array.isArray(x) ? x.join(" ") : x, v = g.globals.labels.map(function(w) {
      return Array.isArray(w) ? w.join(" ") : w;
    }).indexOf(b), y = g.globals.seriesRange[n].findIndex(function(w) {
      return w.x === b && w.overlaps.length > 0;
    });
    return this.isHorizontal ? (a = g.config.plotOptions.bar.rangeBarGroupRows ? l + d * v : l + h * this.visibleI + d * v, y > -1 && !g.config.plotOptions.bar.rangeBarOverlap && (m = g.globals.seriesRange[n][y].overlaps).indexOf(O) > -1 && (a = (h = p.barHeight / m.length) * this.visibleI + d * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + h * (this.visibleI + m.indexOf(O)) + d * v)) : (v > -1 && !g.globals.timescaleLabels.length && (o = g.config.plotOptions.bar.rangeBarGroupRows ? c + f * v : c + u * this.visibleI + f * v), y > -1 && !g.config.plotOptions.bar.rangeBarOverlap && (m = g.globals.seriesRange[n][y].overlaps).indexOf(O) > -1 && (o = (u = p.barWidth / m.length) * this.visibleI + f * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + u * (this.visibleI + m.indexOf(O)) + f * v)), { barYPosition: a, barXPosition: o, barHeight: h, barWidth: u };
  } }, { key: "drawRangeColumnPaths", value: function(i) {
    var n = i.indexes, r = i.x, a = i.xDivision, o = i.barWidth, l = i.barXPosition, c = i.zeroH, h = this.w, u = n.i, d = n.j, f = n.realIndex, p = n.translationsIndex, g = this.yRatio[p], m = this.getRangeValue(f, d), O = Math.min(m.start, m.end), x = Math.max(m.start, m.end);
    this.series[u][d] === void 0 || this.series[u][d] === null ? O = c : (O = c - O / g, x = c - x / g);
    var b = Math.abs(x - O), v = this.barHelpers.getColumnPaths({ barXPosition: l, barWidth: o, y1: O, y2: x, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: f, i: f, j: d, w: h });
    if (h.globals.isXNumeric) {
      var y = this.getBarXForNumericXAxis({ x: r, j: d, realIndex: f, barWidth: o });
      r = y.x, l = y.barXPosition;
    } else r += a;
    return { pathTo: v.pathTo, pathFrom: v.pathFrom, barHeight: b, x: r, y: m.start < 0 && m.end < 0 ? O : x, goalY: this.barHelpers.getGoalValues("y", null, c, u, d, p), barXPosition: l };
  } }, { key: "preventBarOverflow", value: function(i) {
    var n = this.w;
    return i < 0 && (i = 0), i > n.globals.gridWidth && (i = n.globals.gridWidth), i;
  } }, { key: "drawRangeBarPaths", value: function(i) {
    var n = i.indexes, r = i.y, a = i.y1, o = i.y2, l = i.yDivision, c = i.barHeight, h = i.barYPosition, u = i.zeroW, d = this.w, f = n.realIndex, p = n.j, g = this.preventBarOverflow(u + a / this.invertedYRatio), m = this.preventBarOverflow(u + o / this.invertedYRatio), O = this.getRangeValue(f, p), x = Math.abs(m - g), b = this.barHelpers.getBarpaths({ barYPosition: h, barHeight: c, x1: g, x2: m, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: f, realIndex: f, j: p, w: d });
    return d.globals.isXNumeric || (r += l), { pathTo: b.pathTo, pathFrom: b.pathFrom, barWidth: x, x: O.start < 0 && O.end < 0 ? g : m, goalX: this.barHelpers.getGoalValues("x", u, null, f, p), y: r };
  } }, { key: "getRangeValue", value: function(i, n) {
    var r = this.w;
    return { start: r.globals.seriesRangeStart[i][n], end: r.globals.seriesRangeEnd[i][n] };
  } }]), t;
}(), x$ = function() {
  function s(e) {
    ee(this, s), this.w = e.w, this.lineCtx = e;
  }
  return te(s, [{ key: "sameValueSeriesFix", value: function(e, t) {
    var i = this.w;
    if ((i.config.fill.type === "gradient" || i.config.fill.type[e] === "gradient") && new st(this.lineCtx.ctx, i).seriesHaveSameValues(e)) {
      var n = t[e].slice();
      n[n.length - 1] = n[n.length - 1] + 1e-6, t[e] = n;
    }
    return t;
  } }, { key: "calculatePoints", value: function(e) {
    var t = e.series, i = e.realIndex, n = e.x, r = e.y, a = e.i, o = e.j, l = e.prevY, c = this.w, h = [], u = [], d = this.lineCtx.categoryAxisCorrection + c.config.markers.offsetX;
    return c.globals.isXNumeric && (d = (c.globals.seriesX[i][0] - c.globals.minX) / this.lineCtx.xRatio + c.config.markers.offsetX), o === 0 && (h.push(d), u.push(E.isNumber(t[a][0]) ? l + c.config.markers.offsetY : null)), h.push(n + c.config.markers.offsetX), u.push(E.isNumber(t[a][o + 1]) ? r + c.config.markers.offsetY : null), { x: h, y: u };
  } }, { key: "checkPreviousPaths", value: function(e) {
    for (var t = e.pathFromLine, i = e.pathFromArea, n = e.realIndex, r = this.w, a = 0; a < r.globals.previousPaths.length; a++) {
      var o = r.globals.previousPaths[a];
      (o.type === "line" || o.type === "area") && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(n, 10) && (o.type === "line" ? (this.lineCtx.appendPathFrom = !1, t = r.globals.previousPaths[a].paths[0].d) : o.type === "area" && (this.lineCtx.appendPathFrom = !1, i = r.globals.previousPaths[a].paths[0].d, r.config.stroke.show && r.globals.previousPaths[a].paths[1] && (t = r.globals.previousPaths[a].paths[1].d)));
    }
    return { pathFromLine: t, pathFromArea: i };
  } }, { key: "determineFirstPrevY", value: function(e) {
    var t, i, n, r = e.i, a = e.realIndex, o = e.series, l = e.prevY, c = e.lineYPosition, h = e.translationsIndex, u = this.w, d = u.config.chart.stacked && !u.globals.comboCharts || u.config.chart.stacked && u.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t = this.w.config.series[a]) === null || t === void 0 ? void 0 : t.type) === "bar" || ((i = this.w.config.series[a]) === null || i === void 0 ? void 0 : i.type) === "column");
    if (((n = o[r]) === null || n === void 0 ? void 0 : n[0]) !== void 0) l = (c = d && r > 0 ? this.lineCtx.prevSeriesY[r - 1][0] : this.lineCtx.zeroY) - o[r][0] / this.lineCtx.yRatio[h] + 2 * (this.lineCtx.isReversed ? o[r][0] / this.lineCtx.yRatio[h] : 0);
    else if (d && r > 0 && o[r][0] === void 0) {
      for (var f = r - 1; f >= 0; f--) if (o[f][0] !== null && o[f][0] !== void 0) {
        l = c = this.lineCtx.prevSeriesY[f][0];
        break;
      }
    }
    return { prevY: l, lineYPosition: c };
  } }]), s;
}(), b$ = function(s) {
  for (var e, t, i, n, r = function(h) {
    for (var u = [], d = h[0], f = h[1], p = u[0] = Zh(d, f), g = 1, m = h.length - 1; g < m; g++) d = f, f = h[g + 1], u[g] = 0.5 * (p + (p = Zh(d, f)));
    return u[g] = p, u;
  }(s), a = s.length - 1, o = [], l = 0; l < a; l++) i = Zh(s[l], s[l + 1]), Math.abs(i) < 1e-6 ? r[l] = r[l + 1] = 0 : (n = (e = r[l] / i) * e + (t = r[l + 1] / i) * t) > 9 && (n = 3 * i / Math.sqrt(n), r[l] = n * e, r[l + 1] = n * t);
  for (var c = 0; c <= a; c++) n = (s[Math.min(a, c + 1)][0] - s[Math.max(0, c - 1)][0]) / (6 * (1 + r[c] * r[c])), o.push([n || 0, r[c] * n || 0]);
  return o;
}, y$ = function(s) {
  var e = b$(s), t = s[1], i = s[0], n = [], r = e[1], a = e[0];
  n.push(i, [i[0] + a[0], i[1] + a[1], t[0] - r[0], t[1] - r[1], t[0], t[1]]);
  for (var o = 2, l = e.length; o < l; o++) {
    var c = s[o], h = e[o];
    n.push([c[0] - h[0], c[1] - h[1], c[0], c[1]]);
  }
  return n;
}, v$ = function(s, e, t) {
  var i = s.slice(e, t);
  if (e) {
    if (t - e > 1 && i[1].length < 6) {
      var n = i[0].length;
      i[1] = [2 * i[0][n - 2] - i[0][n - 4], 2 * i[0][n - 1] - i[0][n - 3]].concat(i[1]);
    }
    i[0] = i[0].slice(-2);
  }
  return i;
};
function Zh(s, e) {
  return (e[1] - s[1]) / (e[0] - s[0]);
}
var Nh = function() {
  function s(e, t, i) {
    ee(this, s), this.ctx = e, this.w = e.w, this.xyRatios = t, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new jy(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new x$(this), this.markers = new Rr(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return te(s, [{ key: "draw", value: function(e, t, i, n) {
    var r, a = this.w, o = new Z(this.ctx), l = a.globals.comboCharts ? t : a.config.chart.type, c = o.group({ class: "apexcharts-".concat(l, "-series apexcharts-plot-series") }), h = new st(this.ctx, a);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, e = h.getLogSeries(e), this.yRatio = h.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var u = [], d = 0; d < e.length; d++) {
      e = this.lineHelpers.sameValueSeriesFix(d, e);
      var f = a.globals.comboCharts ? i[d] : d, p = this.yRatio.length > 1 ? f : 0;
      this._initSerieVariables(e, d, f);
      var g = [], m = [], O = [], x = a.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, f), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (x = (a.globals.seriesX[f][0] - a.globals.minX) / this.xRatio), O.push(x);
      var b, v = x, y = void 0, w = v, S = this.zeroY, k = this.zeroY;
      S = this.lineHelpers.determineFirstPrevY({ i: d, realIndex: f, series: e, prevY: S, lineYPosition: 0, translationsIndex: p }).prevY, a.config.stroke.curve === "monotoneCubic" && e[d][0] === null ? g.push(null) : g.push(S), b = S, l === "rangeArea" && (y = k = this.lineHelpers.determineFirstPrevY({ i: d, realIndex: f, series: n, prevY: k, lineYPosition: 0, translationsIndex: p }).prevY, m.push(g[0] !== null ? k : null));
      var A = this._calculatePathsFrom({ type: l, series: e, i: d, realIndex: f, translationsIndex: p, prevX: w, prevY: S, prevY2: k }), T = [g[0]], C = [m[0]], P = { type: l, series: e, realIndex: f, translationsIndex: p, i: d, x, y: 1, pX: v, pY: b, pathsFrom: A, linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: O, yArrj: g, y2Arrj: m, seriesRangeEnd: n }, $ = this._iterateOverDataPoints(F(F({}, P), {}, { iterations: l === "rangeArea" ? e[d].length - 1 : void 0, isRangeStart: !0 }));
      if (l === "rangeArea") {
        for (var R = this._calculatePathsFrom({ series: n, i: d, realIndex: f, prevX: w, prevY: k }), X = this._iterateOverDataPoints(F(F({}, P), {}, { series: n, xArrj: [x], yArrj: T, y2Arrj: C, pY: y, areaPaths: $.areaPaths, pathsFrom: R, iterations: n[d].length - 1, isRangeStart: !1 })), M = $.linePaths.length / 2, z = 0; z < M; z++) $.linePaths[z] = X.linePaths[z + M] + $.linePaths[z];
        $.linePaths.splice(M), $.pathFromLine = X.pathFromLine + $.pathFromLine;
      } else $.pathFromArea += "z";
      this._handlePaths({ type: l, realIndex: f, i: d, paths: $ }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), u.push(this.elSeries);
    }
    if (((r = a.config.series[0]) === null || r === void 0 ? void 0 : r.zIndex) !== void 0 && u.sort(function(V, N) {
      return Number(V.node.getAttribute("zIndex")) - Number(N.node.getAttribute("zIndex"));
    }), a.config.chart.stacked) for (var I = u.length - 1; I >= 0; I--) c.add(u[I]);
    else for (var Y = 0; Y < u.length; Y++) c.add(u[Y]);
    return c;
  } }, { key: "_initSerieVariables", value: function(e, t, i) {
    var n = this.w, r = new Z(this.ctx);
    this.xDivision = n.globals.gridWidth / (n.globals.dataPoints - (n.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(n.config.stroke.width) ? n.config.stroke.width[i] : n.config.stroke.width;
    var a = 0;
    if (this.yRatio.length > 1 && (this.yaxisIndex = n.globals.seriesYAxisReverseMap[i], a = i), this.isReversed = n.config.yaxis[this.yaxisIndex] && n.config.yaxis[this.yaxisIndex].reversed, this.zeroY = n.globals.gridHeight - this.baseLineY[a] - (this.isReversed ? n.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[a] : 0), this.areaBottomY = this.zeroY, (this.zeroY > n.globals.gridHeight || n.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = n.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = r.group({ class: "apexcharts-series", zIndex: n.config.series[i].zIndex !== void 0 ? n.config.series[i].zIndex : i, seriesName: E.escapeString(n.globals.seriesNames[i]) }), this.elPointsMain = r.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), n.globals.hasNullValues) {
      var o = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [n.globals.gridHeight + n.globals.markers.largestSize] }, seriesIndex: t, j: 0, pSize: 0.1, alwaysDrawMarker: !0, isVirtualPoint: !0 });
      o !== null && this.elPointsMain.add(o);
    }
    this.elDataLabelsWrap = r.group({ class: "apexcharts-datalabels", "data:realIndex": i });
    var l = e[t].length === n.globals.dataPoints;
    this.elSeries.attr({ "data:longestSeries": l, rel: t + 1, "data:realIndex": i }), this.appendPathFrom = !0;
  } }, { key: "_calculatePathsFrom", value: function(e) {
    var t, i, n, r, a = e.type, o = e.series, l = e.i, c = e.realIndex, h = e.translationsIndex, u = e.prevX, d = e.prevY, f = e.prevY2, p = this.w, g = new Z(this.ctx);
    if (o[l][0] === null) {
      for (var m = 0; m < o[l].length; m++) if (o[l][m] !== null) {
        u = this.xDivision * m, d = this.zeroY - o[l][m] / this.yRatio[h], t = g.move(u, d), i = g.move(u, this.areaBottomY);
        break;
      }
    } else t = g.move(u, d), a === "rangeArea" && (t = g.move(u, f) + g.line(u, d)), i = g.move(u, this.areaBottomY) + g.line(u, d);
    if (n = g.move(0, this.areaBottomY) + g.line(0, this.areaBottomY), r = g.move(0, this.areaBottomY) + g.line(0, this.areaBottomY), p.globals.previousPaths.length > 0) {
      var O = this.lineHelpers.checkPreviousPaths({ pathFromLine: n, pathFromArea: r, realIndex: c });
      n = O.pathFromLine, r = O.pathFromArea;
    }
    return { prevX: u, prevY: d, linePath: t, areaPath: i, pathFromLine: n, pathFromArea: r };
  } }, { key: "_handlePaths", value: function(e) {
    var t = e.type, i = e.realIndex, n = e.i, r = e.paths, a = this.w, o = new Z(this.ctx), l = new Ci(this.ctx);
    this.prevSeriesY.push(r.yArrj), a.globals.seriesXvalues[i] = r.xArrj, a.globals.seriesYvalues[i] = r.yArrj;
    var c = a.config.forecastDataPoints;
    if (c.count > 0 && t !== "rangeArea") {
      var h = a.globals.seriesXvalues[i][a.globals.seriesXvalues[i].length - c.count - 1], u = o.drawRect(h, 0, a.globals.gridWidth, a.globals.gridHeight, 0);
      a.globals.dom.elForecastMask.appendChild(u.node);
      var d = o.drawRect(0, 0, h, a.globals.gridHeight, 0);
      a.globals.dom.elNonForecastMask.appendChild(d.node);
    }
    this.pointsChart || a.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
    var f = { i: n, realIndex: i, animationDelay: n, initialSpeed: a.config.chart.animations.speed, dataChangeSpeed: a.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(t) };
    if (t === "area") for (var p = l.fillPath({ seriesNumber: i }), g = 0; g < r.areaPaths.length; g++) {
      var m = o.renderPaths(F(F({}, f), {}, { pathFrom: r.pathFromArea, pathTo: r.areaPaths[g], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p }));
      this.elSeries.add(m);
    }
    if (a.config.stroke.show && !this.pointsChart) {
      var O = null;
      if (t === "line") O = l.fillPath({ seriesNumber: i, i: n });
      else if (a.config.stroke.fill.type === "solid") O = a.globals.stroke.colors[i];
      else {
        var x = a.config.fill;
        a.config.fill = a.config.stroke.fill, O = l.fillPath({ seriesNumber: i, i: n }), a.config.fill = x;
      }
      for (var b = 0; b < r.linePaths.length; b++) {
        var v = O;
        t === "rangeArea" && (v = l.fillPath({ seriesNumber: i }));
        var y = F(F({}, f), {}, { pathFrom: r.pathFromLine, pathTo: r.linePaths[b], stroke: O, strokeWidth: this.strokeWidth, strokeLineCap: a.config.stroke.lineCap, fill: t === "rangeArea" ? v : "none" }), w = o.renderPaths(y);
        if (this.elSeries.add(w), w.attr("fill-rule", "evenodd"), c.count > 0 && t !== "rangeArea") {
          var S = o.renderPaths(y);
          S.node.setAttribute("stroke-dasharray", c.dashArray), c.strokeWidth && S.node.setAttribute("stroke-width", c.strokeWidth), this.elSeries.add(S), S.attr("clip-path", "url(#forecastMask".concat(a.globals.cuid, ")")), w.attr("clip-path", "url(#nonForecastMask".concat(a.globals.cuid, ")"));
        }
      }
    }
  } }, { key: "_iterateOverDataPoints", value: function(e) {
    var t, i, n = this, r = e.type, a = e.series, o = e.iterations, l = e.realIndex, c = e.translationsIndex, h = e.i, u = e.x, d = e.y, f = e.pX, p = e.pY, g = e.pathsFrom, m = e.linePaths, O = e.areaPaths, x = e.seriesIndex, b = e.lineYPosition, v = e.xArrj, y = e.yArrj, w = e.y2Arrj, S = e.isRangeStart, k = e.seriesRangeEnd, A = this.w, T = new Z(this.ctx), C = this.yRatio, P = g.prevY, $ = g.linePath, R = g.areaPath, X = g.pathFromLine, M = g.pathFromArea, z = E.isNumber(A.globals.minYArr[l]) ? A.globals.minYArr[l] : A.globals.minY;
    o || (o = A.globals.dataPoints > 1 ? A.globals.dataPoints - 1 : A.globals.dataPoints);
    var I = function(be, Ee) {
      return Ee - be / C[c] + 2 * (n.isReversed ? be / C[c] : 0);
    }, Y = d, V = A.config.chart.stacked && !A.globals.comboCharts || A.config.chart.stacked && A.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t = this.w.config.series[l]) === null || t === void 0 ? void 0 : t.type) === "bar" || ((i = this.w.config.series[l]) === null || i === void 0 ? void 0 : i.type) === "column"), N = A.config.stroke.curve;
    Array.isArray(N) && (N = Array.isArray(x) ? N[x[h]] : N[h]);
    for (var _, U = 0, q = 0; q < o && a[h].length !== 0; q++) {
      var oe = a[h][q + 1] === void 0 || a[h][q + 1] === null;
      if (A.globals.isXNumeric) {
        var ae = A.globals.seriesX[l][q + 1];
        A.globals.seriesX[l][q + 1] === void 0 && (ae = A.globals.seriesX[l][o - 1]), u = (ae - A.globals.minX) / this.xRatio;
      } else u += this.xDivision;
      V ? h > 0 && A.globals.collapsedSeries.length < A.config.series.length - 1 ? b = this.prevSeriesY[function(be) {
        for (var Ee = be; Ee > 0; Ee--) {
          if (!(A.globals.collapsedSeriesIndices.indexOf(x?.[Ee] || Ee) > -1)) return Ee;
          Ee--;
        }
        return 0;
      }(h - 1)][q + 1] : b = this.zeroY : b = this.zeroY, oe ? d = I(z, b) : (d = I(a[h][q + 1], b), r === "rangeArea" && (Y = I(k[h][q + 1], b))), v.push(a[h][q + 1] === null ? null : u), !oe || A.config.stroke.curve !== "smooth" && A.config.stroke.curve !== "monotoneCubic" ? (y.push(d), w.push(Y)) : (y.push(null), w.push(null));
      var ue = this.lineHelpers.calculatePoints({ series: a, x: u, y: d, realIndex: l, i: h, j: q, prevY: P }), pe = this._createPaths({ type: r, series: a, i: h, realIndex: l, j: q, x: u, y: d, y2: Y, xArrj: v, yArrj: y, y2Arrj: w, pX: f, pY: p, pathState: U, segmentStartX: _, linePath: $, areaPath: R, linePaths: m, areaPaths: O, curve: N, isRangeStart: S });
      O = pe.areaPaths, m = pe.linePaths, f = pe.pX, p = pe.pY, U = pe.pathState, _ = pe.segmentStartX, R = pe.areaPath, $ = pe.linePath, !this.appendPathFrom || A.globals.hasNullValues || N === "monotoneCubic" && r === "rangeArea" || (X += T.line(u, this.areaBottomY), M += T.line(u, this.areaBottomY)), this.handleNullDataPoints(a, ue, h, q, l), this._handleMarkersAndLabels({ type: r, pointsPos: ue, i: h, j: q, realIndex: l, isRangeStart: S });
    }
    return { yArrj: y, xArrj: v, pathFromArea: M, areaPaths: O, pathFromLine: X, linePaths: m, linePath: $, areaPath: R };
  } }, { key: "_handleMarkersAndLabels", value: function(e) {
    var t = e.type, i = e.pointsPos, n = e.isRangeStart, r = e.i, a = e.j, o = e.realIndex, l = this.w, c = new cr(this.ctx);
    if (this.pointsChart) this.scatter.draw(this.elSeries, a, { realIndex: o, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      l.globals.series[r].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      var h = this.markers.plotChartMarkers({ pointsPos: i, seriesIndex: o, j: a + 1 });
      h !== null && this.elPointsMain.add(h);
    }
    var u = c.drawDataLabel({ type: t, isRangeStart: n, pos: i, i: o, j: a + 1 });
    u !== null && this.elDataLabelsWrap.add(u);
  } }, { key: "_createPaths", value: function(e) {
    var t = e.type, i = e.series, n = e.i;
    e.realIndex;
    var r, a = e.j, o = e.x, l = e.y, c = e.xArrj, h = e.yArrj, u = e.y2, d = e.y2Arrj, f = e.pX, p = e.pY, g = e.pathState, m = e.segmentStartX, O = e.linePath, x = e.areaPath, b = e.linePaths, v = e.areaPaths, y = e.curve, w = e.isRangeStart, S = new Z(this.ctx), k = this.areaBottomY, A = t === "rangeArea", T = t === "rangeArea" && w;
    switch (y) {
      case "monotoneCubic":
        var C = w ? h : d;
        switch (g) {
          case 0:
            if (C[a + 1] === null) break;
            g = 1;
          case 1:
            if (!(A ? c.length === i[n].length : a === i[n].length - 2)) break;
          case 2:
            var P = w ? c : c.slice().reverse(), $ = w ? C : C.slice().reverse(), R = (r = $, P.map(function(ae, ue) {
              return [ae, r[ue]];
            }).filter(function(ae) {
              return ae[1] !== null;
            })), X = R.length > 1 ? y$(R) : R, M = [];
            A && (T ? v = R : M = v.reverse());
            var z = 0, I = 0;
            if (function(ae, ue) {
              for (var pe = function(Vt) {
                var Je = [], ge = 0;
                return Vt.forEach(function(mt) {
                  mt !== null ? ge++ : ge > 0 && (Je.push(ge), ge = 0);
                }), ge > 0 && Je.push(ge), Je;
              }(ae), be = [], Ee = 0, He = 0; Ee < pe.length; He += pe[Ee++]) be[Ee] = v$(ue, He, He + pe[Ee]);
              return be;
            }($, X).forEach(function(ae) {
              z++;
              var ue = function(Ee) {
                for (var He = "", Vt = 0; Vt < Ee.length; Vt++) {
                  var Je = Ee[Vt], ge = Je.length;
                  ge > 4 ? (He += "C".concat(Je[0], ", ").concat(Je[1]), He += ", ".concat(Je[2], ", ").concat(Je[3]), He += ", ".concat(Je[4], ", ").concat(Je[5])) : ge > 2 && (He += "S".concat(Je[0], ", ").concat(Je[1]), He += ", ".concat(Je[2], ", ").concat(Je[3]));
                }
                return He;
              }(ae), pe = I, be = (I += ae.length) - 1;
              T ? O = S.move(R[pe][0], R[pe][1]) + ue : A ? O = S.move(M[pe][0], M[pe][1]) + S.line(R[pe][0], R[pe][1]) + ue + S.line(M[be][0], M[be][1]) : (O = S.move(R[pe][0], R[pe][1]) + ue, x = O + S.line(R[be][0], k) + S.line(R[pe][0], k) + "z", v.push(x)), b.push(O);
            }), A && z > 1 && !T) {
              var Y = b.slice(z).reverse();
              b.splice(z), Y.forEach(function(ae) {
                return b.push(ae);
              });
            }
            g = 0;
        }
        break;
      case "smooth":
        var V = 0.35 * (o - f);
        if (i[n][a] === null) g = 0;
        else switch (g) {
          case 0:
            if (m = f, O = T ? S.move(f, d[a]) + S.line(f, p) : S.move(f, p), x = S.move(f, p), i[n][a + 1] === null || i[n][a + 1] === void 0) {
              b.push(O), v.push(x);
              break;
            }
            if (g = 1, a < i[n].length - 2) {
              var N = S.curve(f + V, p, o - V, l, o, l);
              O += N, x += N;
              break;
            }
          case 1:
            if (i[n][a + 1] === null) O += T ? S.line(f, u) : S.move(f, p), x += S.line(f, k) + S.line(m, k) + "z", b.push(O), v.push(x), g = -1;
            else {
              var _ = S.curve(f + V, p, o - V, l, o, l);
              O += _, x += _, a >= i[n].length - 2 && (T && (O += S.curve(o, l, o, l, o, u) + S.move(o, u)), x += S.curve(o, l, o, l, o, k) + S.line(m, k) + "z", b.push(O), v.push(x), g = -1);
            }
        }
        f = o, p = l;
        break;
      default:
        var U = function(ae, ue, pe) {
          var be = [];
          switch (ae) {
            case "stepline":
              be = S.line(ue, null, "H") + S.line(null, pe, "V");
              break;
            case "linestep":
              be = S.line(null, pe, "V") + S.line(ue, null, "H");
              break;
            case "straight":
              be = S.line(ue, pe);
          }
          return be;
        };
        if (i[n][a] === null) g = 0;
        else switch (g) {
          case 0:
            if (m = f, O = T ? S.move(f, d[a]) + S.line(f, p) : S.move(f, p), x = S.move(f, p), i[n][a + 1] === null || i[n][a + 1] === void 0) {
              b.push(O), v.push(x);
              break;
            }
            if (g = 1, a < i[n].length - 2) {
              var q = U(y, o, l);
              O += q, x += q;
              break;
            }
          case 1:
            if (i[n][a + 1] === null) O += T ? S.line(f, u) : S.move(f, p), x += S.line(f, k) + S.line(m, k) + "z", b.push(O), v.push(x), g = -1;
            else {
              var oe = U(y, o, l);
              O += oe, x += oe, a >= i[n].length - 2 && (T && (O += S.line(o, u)), x += S.line(o, k) + S.line(m, k) + "z", b.push(O), v.push(x), g = -1);
            }
        }
        f = o, p = l;
    }
    return { linePaths: b, areaPaths: v, pX: f, pY: p, pathState: g, segmentStartX: m, linePath: O, areaPath: x };
  } }, { key: "handleNullDataPoints", value: function(e, t, i, n, r) {
    var a = this.w;
    if (e[i][n] === null && a.config.markers.showNullDataPoints || e[i].length === 1) {
      var o = this.strokeWidth - a.config.markers.strokeWidth / 2;
      o > 0 || (o = 0);
      var l = this.markers.plotChartMarkers({ pointsPos: t, seriesIndex: r, j: n + 1, pSize: o, alwaysDrawMarker: !0 });
      l !== null && this.elPointsMain.add(l);
    }
  } }]), s;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ function() {
  function s(o, l, c, h) {
    this.xoffset = o, this.yoffset = l, this.height = h, this.width = c, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(u) {
      var d, f = [], p = this.xoffset, g = this.yoffset, m = r(u) / this.height, O = r(u) / this.width;
      if (this.width >= this.height) for (d = 0; d < u.length; d++) f.push([p, g, p + m, g + u[d] / m]), g += u[d] / m;
      else for (d = 0; d < u.length; d++) f.push([p, g, p + u[d] / O, g + O]), p += u[d] / O;
      return f;
    }, this.cutArea = function(u) {
      var d;
      if (this.width >= this.height) {
        var f = u / this.height, p = this.width - f;
        d = new s(this.xoffset + f, this.yoffset, p, this.height);
      } else {
        var g = u / this.width, m = this.height - g;
        d = new s(this.xoffset, this.yoffset + g, this.width, m);
      }
      return d;
    };
  }
  function e(o, l, c, h, u) {
    h = h === void 0 ? 0 : h, u = u === void 0 ? 0 : u;
    var d = t(function(f, p) {
      var g, m = [], O = p / r(f);
      for (g = 0; g < f.length; g++) m[g] = f[g] * O;
      return m;
    }(o, l * c), [], new s(h, u, l, c), []);
    return function(f) {
      var p, g, m = [];
      for (p = 0; p < f.length; p++) for (g = 0; g < f[p].length; g++) m.push(f[p][g]);
      return m;
    }(d);
  }
  function t(o, l, c, h) {
    var u, d, f;
    if (o.length !== 0) return u = c.shortestEdge(), function(p, g, m) {
      var O;
      if (p.length === 0) return !0;
      (O = p.slice()).push(g);
      var x = i(p, m), b = i(O, m);
      return x >= b;
    }(l, d = o[0], u) ? (l.push(d), t(o.slice(1), l, c, h)) : (f = c.cutArea(r(l), h), h.push(c.getCoordinates(l)), t(o, [], f, h)), h;
    h.push(c.getCoordinates(l));
  }
  function i(o, l) {
    var c = Math.min.apply(Math, o), h = Math.max.apply(Math, o), u = r(o);
    return Math.max(Math.pow(l, 2) * h / Math.pow(u, 2), Math.pow(u, 2) / (Math.pow(l, 2) * c));
  }
  function n(o) {
    return o && o.constructor === Array;
  }
  function r(o) {
    var l, c = 0;
    for (l = 0; l < o.length; l++) c += o[l];
    return c;
  }
  function a(o) {
    var l, c = 0;
    if (n(o[0])) for (l = 0; l < o.length; l++) c += a(o[l]);
    else c = r(o);
    return c;
  }
  return function o(l, c, h, u, d) {
    u = u === void 0 ? 0 : u, d = d === void 0 ? 0 : d;
    var f, p, g = [], m = [];
    if (n(l[0])) {
      for (p = 0; p < l.length; p++) g[p] = a(l[p]);
      for (f = e(g, c, h, u, d), p = 0; p < l.length; p++) m.push(o(l[p], f[p][2] - f[p][0], f[p][3] - f[p][1], f[p][0], f[p][1]));
    } else m = e(l, c, h, u, d);
    return m;
  };
}();
var w$ = function() {
  function s(e, t) {
    ee(this, s), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new tv(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return te(s, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, n = new Z(this.ctx), r = new Ci(this.ctx), a = n.group({ class: "apexcharts-treemap" });
    if (i.globals.noData) return a;
    var o = [];
    return e.forEach(function(l) {
      var c = l.map(function(h) {
        return Math.abs(h);
      });
      o.push(c);
    }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(l, c) {
      l.data.forEach(function(h) {
        Array.isArray(t.labels[c]) || (t.labels[c] = []), t.labels[c].push(h.x);
      });
    }), window.TreemapSquared.generate(o, i.globals.gridWidth, i.globals.gridHeight).forEach(function(l, c) {
      var h = n.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: E.escapeString(i.globals.seriesNames[c]), rel: c + 1, "data:realIndex": c });
      if (i.config.chart.dropShadow.enabled) {
        var u = i.config.chart.dropShadow;
        new vt(t.ctx).dropShadow(a, u, c);
      }
      var d = n.group({ class: "apexcharts-data-labels" }), f = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      l.forEach(function(X, M) {
        var z = X[0], I = X[1], Y = X[2], V = X[3];
        f.xMin = Math.min(f.xMin, z), f.yMin = Math.min(f.yMin, I), f.xMax = Math.max(f.xMax, Y), f.yMax = Math.max(f.yMax, V);
        var N = t.helpers.getShadeColor(i.config.chart.type, c, M, t.negRange), _ = N.color, U = r.fillPath({ color: _, seriesNumber: c, dataPointIndex: M }), q = n.drawRect(z, I, Y - z, V - I, i.config.plotOptions.treemap.borderRadius, "#fff", 1, t.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? _ : i.globals.stroke.colors[c]);
        q.attr({ cx: z, cy: I, index: c, i: c, j: M, width: Y - z, height: V - I, fill: U }), q.node.classList.add("apexcharts-treemap-rect"), t.helpers.addListeners(q);
        var oe = { x: z + (Y - z) / 2, y: I + (V - I) / 2, width: 0, height: 0 }, ae = { x: z, y: I, width: Y - z, height: V - I };
        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
          var ue = 1;
          i.globals.resized || (ue = i.config.chart.animations.speed), t.animateTreemap(q, oe, ae, ue);
        }
        if (i.globals.dataChanged) {
          var pe = 1;
          t.dynamicAnim.enabled && i.globals.shouldAnimate && (pe = t.dynamicAnim.speed, i.globals.previousPaths[c] && i.globals.previousPaths[c][M] && i.globals.previousPaths[c][M].rect && (oe = i.globals.previousPaths[c][M].rect), t.animateTreemap(q, oe, ae, pe));
        }
        var be = t.getFontSize(X), Ee = i.config.dataLabels.formatter(t.labels[c][M], { value: i.globals.series[c][M], seriesIndex: c, dataPointIndex: M, w: i });
        i.config.plotOptions.treemap.dataLabels.format === "truncate" && (be = parseInt(i.config.dataLabels.style.fontSize, 10), Ee = t.truncateLabels(Ee, be, z, I, Y, V));
        var He = null;
        i.globals.series[c][M] && (He = t.helpers.calculateDataLabels({ text: Ee, x: (z + Y) / 2, y: (I + V) / 2 + t.strokeWidth / 2 + be / 3, i: c, j: M, colorProps: N, fontSize: be, series: e })), i.config.dataLabels.enabled && He && t.rotateToFitLabel(He, be, Ee, z, I, Y, V), h.add(q), He !== null && h.add(He);
      });
      var p = i.config.plotOptions.treemap.seriesTitle;
      if (i.config.series.length > 1 && p && p.show) {
        var g = i.config.series[c].name || "";
        if (g && f.xMin < 1 / 0 && f.yMin < 1 / 0) {
          var m = p.offsetX, O = p.offsetY, x = p.borderColor, b = p.borderWidth, v = p.borderRadius, y = p.style, w = y.color || i.config.chart.foreColor, S = { left: y.padding.left, right: y.padding.right, top: y.padding.top, bottom: y.padding.bottom }, k = n.getTextRects(g, y.fontSize, y.fontFamily), A = k.width + S.left + S.right, T = k.height + S.top + S.bottom, C = f.xMin + (m || 0), P = f.yMin + (O || 0), $ = n.drawRect(C, P, A, T, v, y.background, 1, b, x), R = n.drawText({ x: C + S.left, y: P + S.top + 0.75 * k.height, text: g, fontSize: y.fontSize, fontFamily: y.fontFamily, fontWeight: y.fontWeight, foreColor: w, cssClass: y.cssClass || "" });
          h.add($), h.add(R);
        }
      }
      h.add(d), a.add(h);
    }), a;
  } }, { key: "getFontSize", value: function(e) {
    var t = this.w, i = function n(r) {
      var a, o = 0;
      if (Array.isArray(r[0])) for (a = 0; a < r.length; a++) o += n(r[a]);
      else for (a = 0; a < r.length; a++) o += r[a].length;
      return o;
    }(this.labels) / function n(r) {
      var a, o = 0;
      if (Array.isArray(r[0])) for (a = 0; a < r.length; a++) o += n(r[a]);
      else for (a = 0; a < r.length; a++) o += 1;
      return o;
    }(this.labels);
    return function(n, r) {
      var a = n * r, o = Math.pow(a, 0.5);
      return Math.min(o / i, parseInt(t.config.dataLabels.style.fontSize, 10));
    }(e[2] - e[0], e[3] - e[1]);
  } }, { key: "rotateToFitLabel", value: function(e, t, i, n, r, a, o) {
    var l = new Z(this.ctx), c = l.getTextRects(i, t);
    if (c.width + this.w.config.stroke.width + 5 > a - n && c.width <= o - r) {
      var h = l.rotateAroundCenter(e.node);
      e.node.setAttribute("transform", "rotate(-90 ".concat(h.x, " ").concat(h.y, ") translate(").concat(c.height / 3, ")"));
    }
  } }, { key: "truncateLabels", value: function(e, t, i, n, r, a) {
    var o = new Z(this.ctx), l = o.getTextRects(e, t).width + this.w.config.stroke.width + 5 > r - i && a - n > r - i ? a - n : r - i, c = o.getTextBasedOnMaxWidth({ text: e, maxWidth: l, fontSize: t });
    return e.length !== c.length && l / t < 5 ? "" : c;
  } }, { key: "animateTreemap", value: function(e, t, i, n) {
    var r = new Cr(this.ctx);
    r.animateRect(e, t, i, n, function() {
      r.animationCompleted(e);
    });
  } }]), s;
}(), nv = 86400, S$ = 10 / nv, k$ = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return te(s, [{ key: "calculateTimeScaleTicks", value: function(e, t) {
    var i = this, n = this.w;
    if (n.globals.allSeriesCollapsed) return n.globals.labels = [], n.globals.timescaleLabels = [], [];
    var r = new xt(this.ctx), a = (t - e) / 864e5;
    this.determineInterval(a), n.globals.disableZoomIn = !1, n.globals.disableZoomOut = !1, a < S$ ? n.globals.disableZoomIn = !0 : a > 5e4 && (n.globals.disableZoomOut = !0);
    var o = r.getTimeUnitsfromTimestamp(e, t, this.utc), l = n.globals.gridWidth / a, c = l / 24, h = c / 60, u = h / 60, d = Math.floor(24 * a), f = Math.floor(1440 * a), p = Math.floor(a * nv), g = Math.floor(a), m = Math.floor(a / 30), O = Math.floor(a / 365), x = { minMillisecond: o.minMillisecond, minSecond: o.minSecond, minMinute: o.minMinute, minHour: o.minHour, minDate: o.minDate, minMonth: o.minMonth, minYear: o.minYear }, b = { firstVal: x, currentMillisecond: x.minMillisecond, currentSecond: x.minSecond, currentMinute: x.minMinute, currentHour: x.minHour, currentMonthDate: x.minDate, currentDate: x.minDate, currentMonth: x.minMonth, currentYear: x.minYear, daysWidthOnXAxis: l, hoursWidthOnXAxis: c, minutesWidthOnXAxis: h, secondsWidthOnXAxis: u, numberOfSeconds: p, numberOfMinutes: f, numberOfHours: d, numberOfDays: g, numberOfMonths: m, numberOfYears: O };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(b);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(b);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(b);
        break;
      case "hours":
        this.generateHourScale(b);
        break;
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(b);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(b);
    }
    var v = this.timeScaleArray.map(function(y) {
      var w = { position: y.position, unit: y.unit, year: y.year, day: y.day ? y.day : 1, hour: y.hour ? y.hour : 0, month: y.month + 1 };
      return y.unit === "month" ? F(F({}, w), {}, { day: 1, value: y.value + 1 }) : y.unit === "day" || y.unit === "hour" ? F(F({}, w), {}, { value: y.value }) : y.unit === "minute" ? F(F({}, w), {}, { value: y.value, minute: y.value }) : y.unit === "second" ? F(F({}, w), {}, { value: y.value, minute: y.minute, second: y.second }) : y;
    });
    return v.filter(function(y) {
      var w = 1, S = Math.ceil(n.globals.gridWidth / 120), k = y.value;
      n.config.xaxis.tickAmount !== void 0 && (S = n.config.xaxis.tickAmount), v.length > S && (w = Math.floor(v.length / S));
      var A = !1, T = !1;
      switch (i.tickInterval) {
        case "years":
          y.unit === "year" && (A = !0);
          break;
        case "half_year":
          w = 7, y.unit === "year" && (A = !0);
          break;
        case "months":
          w = 1, y.unit === "year" && (A = !0);
          break;
        case "months_fortnight":
          w = 15, y.unit !== "year" && y.unit !== "month" || (A = !0), k === 30 && (T = !0);
          break;
        case "months_days":
          w = 10, y.unit === "month" && (A = !0), k === 30 && (T = !0);
          break;
        case "week_days":
          w = 8, y.unit === "month" && (A = !0);
          break;
        case "days":
          w = 1, y.unit === "month" && (A = !0);
          break;
        case "hours":
          y.unit === "day" && (A = !0);
          break;
        case "minutes_fives":
        case "seconds_fives":
          k % 5 != 0 && (T = !0);
          break;
        case "seconds_tens":
          k % 10 != 0 && (T = !0);
      }
      if (i.tickInterval === "hours" || i.tickInterval === "minutes_fives" || i.tickInterval === "seconds_tens" || i.tickInterval === "seconds_fives") {
        if (!T) return !0;
      } else if ((k % w == 0 || A) && !T) return !0;
    });
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(e, t) {
    var i = this.w, n = this.formatDates(e), r = this.removeOverlappingTS(n);
    i.globals.timescaleLabels = r.slice(), new ec(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(e) {
    var t = 24 * e, i = 60 * t;
    switch (!0) {
      case e / 365 > 5:
        this.tickInterval = "years";
        break;
      case e > 800:
        this.tickInterval = "half_year";
        break;
      case e > 180:
        this.tickInterval = "months";
        break;
      case e > 90:
        this.tickInterval = "months_fortnight";
        break;
      case e > 60:
        this.tickInterval = "months_days";
        break;
      case e > 30:
        this.tickInterval = "week_days";
        break;
      case e > 2:
        this.tickInterval = "days";
        break;
      case t > 2.4:
        this.tickInterval = "hours";
        break;
      case i > 15:
        this.tickInterval = "minutes_fives";
        break;
      case i > 5:
        this.tickInterval = "minutes";
        break;
      case i > 1:
        this.tickInterval = "seconds_tens";
        break;
      case 60 * i > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
    }
  } }, { key: "generateYearScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonth, n = e.currentYear, r = e.daysWidthOnXAxis, a = e.numberOfYears, o = t.minYear, l = 0, c = new xt(this.ctx), h = "year";
    if (t.minDate > 1 || t.minMonth > 0) {
      var u = c.determineRemainingDaysOfYear(t.minYear, t.minMonth, t.minDate);
      l = (c.determineDaysOfYear(t.minYear) - u + 1) * r, o = t.minYear + 1, this.timeScaleArray.push({ position: l, value: o, unit: h, year: o, month: E.monthMod(i + 1) });
    } else t.minDate === 1 && t.minMonth === 0 && this.timeScaleArray.push({ position: l, value: o, unit: h, year: n, month: E.monthMod(i + 1) });
    for (var d = o, f = l, p = 0; p < a; p++) d++, f = c.determineDaysOfYear(d - 1) * r + f, this.timeScaleArray.push({ position: f, value: d, unit: h, year: d, month: 1 });
  } }, { key: "generateMonthScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonthDate, n = e.currentMonth, r = e.currentYear, a = e.daysWidthOnXAxis, o = e.numberOfMonths, l = n, c = 0, h = new xt(this.ctx), u = "month", d = 0;
    if (t.minDate > 1) {
      c = (h.determineDaysOfMonths(n + 1, t.minYear) - i + 1) * a, l = E.monthMod(n + 1);
      var f = r + d, p = E.monthMod(l), g = l;
      l === 0 && (u = "year", g = f, p = 1, f += d += 1), this.timeScaleArray.push({ position: c, value: g, unit: u, year: f, month: p });
    } else this.timeScaleArray.push({ position: c, value: l, unit: u, year: r, month: E.monthMod(n) });
    for (var m = l + 1, O = c, x = 0, b = 1; x < o; x++, b++) {
      (m = E.monthMod(m)) === 0 ? (u = "year", d += 1) : u = "month";
      var v = this._getYear(r, m, d);
      O = h.determineDaysOfMonths(m, v) * a + O;
      var y = m === 0 ? v : m;
      this.timeScaleArray.push({ position: O, value: y, unit: u, year: v, month: m === 0 ? 1 : m }), m++;
    }
  } }, { key: "generateDayScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonth, n = e.currentYear, r = e.hoursWidthOnXAxis, a = e.numberOfDays, o = new xt(this.ctx), l = "day", c = t.minDate + 1, h = c, u = function(b, v, y) {
      return b > o.determineDaysOfMonths(v + 1, y) && (h = 1, l = "month", f = v += 1), v;
    }, d = (24 - t.minHour) * r, f = c, p = u(h, i, n);
    t.minHour === 0 && t.minDate === 1 ? (d = 0, f = E.monthMod(t.minMonth), l = "month", h = t.minDate) : t.minDate !== 1 && t.minHour === 0 && t.minMinute === 0 && (d = 0, c = t.minDate, f = c, p = u(h = c, i, n), f !== 1 && (l = "day")), this.timeScaleArray.push({ position: d, value: f, unit: l, year: this._getYear(n, p, 0), month: E.monthMod(p), day: h });
    for (var g = d, m = 0; m < a; m++) {
      l = "day", p = u(h += 1, p, this._getYear(n, p, 0));
      var O = this._getYear(n, p, 0);
      g = 24 * r + g;
      var x = h === 1 ? E.monthMod(p) : h;
      this.timeScaleArray.push({ position: g, value: x, unit: l, year: O, month: E.monthMod(p), day: x });
    }
  } }, { key: "generateHourScale", value: function(e) {
    var t = e.firstVal, i = e.currentDate, n = e.currentMonth, r = e.currentYear, a = e.minutesWidthOnXAxis, o = e.numberOfHours, l = new xt(this.ctx), c = "hour", h = function(w, S) {
      return w > l.determineDaysOfMonths(S + 1, r) && (m = 1, S += 1), { month: S, date: m };
    }, u = function(w, S) {
      return w > l.determineDaysOfMonths(S + 1, r) ? S += 1 : S;
    }, d = 60 - (t.minMinute + t.minSecond / 60), f = d * a, p = t.minHour + 1, g = p;
    d === 60 && (f = 0, g = p = t.minHour);
    var m = i;
    g >= 24 && (g = 0, c = "day", p = m += 1);
    var O = h(m, n).month;
    O = u(m, O), p > 31 && (p = m = 1), this.timeScaleArray.push({ position: f, value: p, unit: c, day: m, hour: g, year: r, month: E.monthMod(O) }), g++;
    for (var x = f, b = 0; b < o; b++) {
      c = "hour", g >= 24 && (g = 0, c = "day", O = h(m += 1, O).month, O = u(m, O));
      var v = this._getYear(r, O, 0);
      x = 60 * a + x;
      var y = g === 0 ? m : g;
      this.timeScaleArray.push({ position: x, value: y, unit: c, hour: g, day: m, year: v, month: E.monthMod(O) }), g++;
    }
  } }, { key: "generateMinuteScale", value: function(e) {
    for (var t = e.currentMillisecond, i = e.currentSecond, n = e.currentMinute, r = e.currentHour, a = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.minutesWidthOnXAxis, h = e.secondsWidthOnXAxis, u = e.numberOfMinutes, d = n + 1, f = a, p = o, g = l, m = r, O = (60 - i - t / 1e3) * h, x = 0; x < u; x++) d >= 60 && (d = 0, (m += 1) === 24 && (m = 0)), this.timeScaleArray.push({ position: O, value: d, unit: "minute", hour: m, minute: d, day: f, year: this._getYear(g, p, 0), month: E.monthMod(p) }), O += c, d++;
  } }, { key: "generateSecondScale", value: function(e) {
    for (var t = e.currentMillisecond, i = e.currentSecond, n = e.currentMinute, r = e.currentHour, a = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.secondsWidthOnXAxis, h = e.numberOfSeconds, u = i + 1, d = n, f = a, p = o, g = l, m = r, O = (1e3 - t) / 1e3 * c, x = 0; x < h; x++) u >= 60 && (u = 0, ++d >= 60 && (d = 0, ++m === 24 && (m = 0))), this.timeScaleArray.push({ position: O, value: u, unit: "second", hour: m, minute: d, second: u, day: f, year: this._getYear(g, p, 0), month: E.monthMod(p) }), O += c, u++;
  } }, { key: "createRawDateString", value: function(e, t) {
    var i = e.year;
    return e.month === 0 && (e.month = 1), i += "-" + ("0" + e.month.toString()).slice(-2), e.unit === "day" ? i += e.unit === "day" ? "-" + ("0" + t).slice(-2) : "-01" : i += "-" + ("0" + (e.day ? e.day : "1")).slice(-2), e.unit === "hour" ? i += e.unit === "hour" ? "T" + ("0" + t).slice(-2) : "T00" : i += "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2), e.unit === "minute" ? i += ":" + ("0" + t).slice(-2) : i += ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"), e.unit === "second" ? i += ":" + ("0" + t).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
  } }, { key: "formatDates", value: function(e) {
    var t = this, i = this.w;
    return e.map(function(n) {
      var r = n.value.toString(), a = new xt(t.ctx), o = t.createRawDateString(n, r), l = a.getDate(a.parseDate(o));
      if (t.utc || (l = a.getDate(a.parseDateWithTimezone(o))), i.config.xaxis.labels.format === void 0) {
        var c = "dd MMM", h = i.config.xaxis.labels.datetimeFormatter;
        n.unit === "year" && (c = h.year), n.unit === "month" && (c = h.month), n.unit === "day" && (c = h.day), n.unit === "hour" && (c = h.hour), n.unit === "minute" && (c = h.minute), n.unit === "second" && (c = h.second), r = a.formatDate(l, c);
      } else r = a.formatDate(l, i.config.xaxis.labels.format);
      return { dateString: o, position: n.position, value: r, unit: n.unit, year: n.year, month: n.month };
    });
  } }, { key: "removeOverlappingTS", value: function(e) {
    var t, i = this, n = new Z(this.ctx), r = !1;
    e.length > 0 && e[0].value && e.every(function(l) {
      return l.value.length === e[0].value.length;
    }) && (r = !0, t = n.getTextRects(e[0].value).width);
    var a = 0, o = e.map(function(l, c) {
      if (c > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
        var h = r ? t : n.getTextRects(e[a].value).width, u = e[a].position;
        return l.position > u + h + 10 ? (a = c, l) : null;
      }
      return l;
    });
    return o = o.filter(function(l) {
      return l !== null;
    });
  } }, { key: "_getYear", value: function(e, t, i) {
    return e + Math.floor(t / 12) + i;
  } }]), s;
}(), P$ = function() {
  function s(e, t) {
    ee(this, s), this.ctx = t, this.w = t.w, this.el = e;
  }
  return te(s, [{ key: "setupElements", value: function() {
    var e = this.w, t = e.globals, i = e.config, n = i.chart.type;
    t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(n), t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(n), t.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(n) && i.plotOptions.bar.horizontal, t.chartClass = ".apexcharts".concat(t.chartID), t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), Z.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: "apexcharts-canvas ".concat(t.chartClass.substring(1)) }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = window.SVG().addTo(t.dom.elWrap), t.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i.chart.offsetX, ", ").concat(i.chart.offsetY, ")") }), t.dom.Paper.node.style.background = i.theme.mode !== "dark" || i.chart.background ? i.theme.mode !== "light" || i.chart.background ? i.chart.background : "#fff" : "#343A3F", this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), Z.setAttrs(t.dom.elLegendForeign, { x: 0, y: 0, width: t.svgWidth, height: t.svgHeight }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
  } }, { key: "plotChartType", value: function(e, t) {
    var i = this.w, n = this.ctx, r = i.config, a = i.globals, o = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, l = r.chart.type || "line", c = null, h = 0;
    a.series.forEach(function(w, S) {
      var k = e[S].type === "column" ? "bar" : e[S].type || (l === "column" ? "bar" : l);
      o[k] ? (k === "rangeArea" ? (o[k].series.push(a.seriesRangeStart[S]), o[k].seriesRangeEnd.push(a.seriesRangeEnd[S])) : o[k].series.push(w), o[k].i.push(S), k === "bar" && (i.globals.columnSeries = o.bar)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(k) ? c = k : console.warn("You have specified an unrecognized series type (".concat(k, ").")), l !== k && k !== "scatter" && h++;
    }), h > 0 && (c && console.warn("Chart or series type ".concat(c, " cannot appear with other chart or series types.")), o.bar.series.length > 0 && r.plotOptions.bar.horizontal && (h -= o.bar.series.length, o.bar = { series: [], i: [] }, i.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), a.comboCharts || (a.comboCharts = h > 0);
    var u = new Nh(n, t), d = new Yh(n, t);
    n.pie = new sv(n);
    var f = new m$(n);
    n.rangeBar = new O$(n, t);
    var p = new g$(n), g = [];
    if (a.comboCharts) {
      var m, O, x = new st(n);
      if (o.area.series.length > 0 && (m = g).push.apply(m, dt(x.drawSeriesByGroup(o.area, a.areaGroups, "area", u))), o.bar.series.length > 0) if (r.chart.stacked) {
        var b = new Xm(n, t);
        g.push(b.draw(o.bar.series, o.bar.i));
      } else n.bar = new hr(n, t), g.push(n.bar.draw(o.bar.series, o.bar.i));
      if (o.rangeArea.series.length > 0 && g.push(u.draw(o.rangeArea.series, "rangeArea", o.rangeArea.i, o.rangeArea.seriesRangeEnd)), o.line.series.length > 0 && (O = g).push.apply(O, dt(x.drawSeriesByGroup(o.line, a.lineGroups, "line", u))), o.candlestick.series.length > 0 && g.push(d.draw(o.candlestick.series, "candlestick", o.candlestick.i)), o.boxPlot.series.length > 0 && g.push(d.draw(o.boxPlot.series, "boxPlot", o.boxPlot.i)), o.rangeBar.series.length > 0 && g.push(n.rangeBar.draw(o.rangeBar.series, o.rangeBar.i)), o.scatter.series.length > 0) {
        var v = new Nh(n, t, !0);
        g.push(v.draw(o.scatter.series, "scatter", o.scatter.i));
      }
      if (o.bubble.series.length > 0) {
        var y = new Nh(n, t, !0);
        g.push(y.draw(o.bubble.series, "bubble", o.bubble.i));
      }
    } else switch (r.chart.type) {
      case "line":
        g = u.draw(a.series, "line");
        break;
      case "area":
        g = u.draw(a.series, "area");
        break;
      case "bar":
        r.chart.stacked ? g = new Xm(n, t).draw(a.series) : (n.bar = new hr(n, t), g = n.bar.draw(a.series));
        break;
      case "candlestick":
        g = new Yh(n, t).draw(a.series, "candlestick");
        break;
      case "boxPlot":
        g = new Yh(n, t).draw(a.series, r.chart.type);
        break;
      case "rangeBar":
        g = n.rangeBar.draw(a.series);
        break;
      case "rangeArea":
        g = u.draw(a.seriesRangeStart, "rangeArea", void 0, a.seriesRangeEnd);
        break;
      case "heatmap":
        g = new p$(n, t).draw(a.series);
        break;
      case "treemap":
        g = new w$(n, t).draw(a.series);
        break;
      case "pie":
      case "donut":
      case "polarArea":
        g = n.pie.draw(a.series);
        break;
      case "radialBar":
        g = f.draw(a.series);
        break;
      case "radar":
        g = p.draw(a.series);
        break;
      default:
        g = u.draw(a.series);
    }
    return g;
  } }, { key: "setSVGDimensions", value: function() {
    var e = this.w, t = e.globals, i = e.config;
    i.chart.width = i.chart.width || "100%", i.chart.height = i.chart.height || "auto", t.svgWidth = i.chart.width, t.svgHeight = i.chart.height;
    var n = E.getDimensions(this.el), r = i.chart.width.toString().split(/[0-9]+/g).pop();
    r === "%" ? E.isNumber(n[0]) && (n[0].width === 0 && (n = E.getDimensions(this.el.parentNode)), t.svgWidth = n[0] * parseInt(i.chart.width, 10) / 100) : r !== "px" && r !== "" || (t.svgWidth = parseInt(i.chart.width, 10));
    var a = String(i.chart.height).toString().split(/[0-9]+/g).pop();
    if (t.svgHeight !== "auto" && t.svgHeight !== "") if (a === "%") {
      var o = E.getDimensions(this.el.parentNode);
      t.svgHeight = o[1] * parseInt(i.chart.height, 10) / 100;
    } else t.svgHeight = parseInt(i.chart.height, 10);
    else t.svgHeight = t.axisCharts ? t.svgWidth / 1.61 : t.svgWidth / 1.2;
    if (t.svgWidth = Math.max(t.svgWidth, 0), t.svgHeight = Math.max(t.svgHeight, 0), Z.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }), a !== "%") {
      var l = i.chart.sparkline.enabled ? 0 : t.axisCharts ? i.chart.parentHeightOffset : 0;
      t.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(t.svgHeight + l, "px");
    }
    t.dom.elWrap.style.width = "".concat(t.svgWidth, "px"), t.dom.elWrap.style.height = "".concat(t.svgHeight, "px");
  } }, { key: "shiftGraphPosition", value: function() {
    var e = this.w.globals, t = e.translateY, i = e.translateX;
    Z.setAttrs(e.dom.elGraphical.node, { transform: "translate(".concat(i, ", ").concat(t, ")") });
  } }, { key: "resizeNonAxisCharts", value: function() {
    var e = this.w, t = e.globals, i = 0, n = e.config.chart.sparkline.enabled ? 1 : 15;
    n += e.config.grid.padding.bottom, ["top", "bottom"].includes(e.config.legend.position) && e.config.legend.show && !e.config.legend.floating && (i = new Gy(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var r = e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), a = 2.05 * e.globals.radialSize;
    if (r && !e.config.chart.sparkline.enabled && e.config.plotOptions.radialBar.startAngle !== 0) {
      var o = E.getBoundingClientRect(r);
      a = o.bottom;
      var l = o.bottom - o.top;
      a = Math.max(2.05 * e.globals.radialSize, l);
    }
    var c = Math.ceil(a + t.translateY + i + n);
    t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", c), e.config.chart.height && String(e.config.chart.height).includes("%") || (t.dom.elWrap.style.height = "".concat(c, "px"), Z.setAttrs(t.dom.Paper.node, { height: c }), t.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(c, "px"));
  } }, { key: "coreCalculations", value: function() {
    new Cd(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var e = this, t = function() {
      return e.w.config.series.map(function() {
        return [];
      });
    }, i = new Fy(), n = this.w.globals;
    i.initGlobalVars(n), n.seriesXvalues = t(), n.seriesYvalues = t();
  } }, { key: "isMultipleY", value: function() {
    return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = !0, !0);
  } }, { key: "xySettings", value: function() {
    var e = this.w, t = null;
    if (e.globals.axisCharts) {
      if (e.config.xaxis.crosshairs.position === "back" && new Ad(this.ctx).drawXCrosshairs(), e.config.yaxis[0].crosshairs.position === "back" && new Ad(this.ctx).drawYCrosshairs(), e.config.xaxis.type === "datetime" && e.config.xaxis.labels.formatter === void 0) {
        this.ctx.timeScale = new k$(this.ctx);
        var i = [];
        isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
      }
      t = new st(this.ctx).getCalculatedRatios();
    }
    return t;
  } }, { key: "updateSourceChart", value: function(e) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: e.w.globals.minX, max: e.w.globals.maxX } } } }, !1, !1);
  } }, { key: "setupBrushHandler", value: function() {
    var e = this, t = this.ctx, i = this.w;
    if (i.config.chart.brush.enabled && typeof i.config.chart.events.selection != "function") {
      var n = Array.isArray(i.config.chart.brush.targets) ? i.config.chart.brush.targets : [i.config.chart.brush.target];
      n.forEach(function(r) {
        var a = t.constructor.getChartByID(r);
        a.w.globals.brushSource = e.ctx, typeof a.w.config.chart.events.zoomed != "function" && (a.w.config.chart.events.zoomed = function() {
          return e.updateSourceChart(a);
        }), typeof a.w.config.chart.events.scrolled != "function" && (a.w.config.chart.events.scrolled = function() {
          return e.updateSourceChart(a);
        });
      }), i.config.chart.events.selection = function(r, a) {
        n.forEach(function(o) {
          t.constructor.getChartByID(o).ctx.updateHelpers._updateOptions({ xaxis: { min: a.xaxis.min, max: a.xaxis.max } }, !1, !1, !1, !1);
        });
      };
    }
  } }]), s;
}(), Q$ = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "_updateOptions", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], n = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], r = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], a = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
    return new Promise(function(o) {
      var l = [t.ctx];
      r && (l = t.ctx.getSyncedCharts()), t.ctx.w.globals.isExecCalled && (l = [t.ctx], t.ctx.w.globals.isExecCalled = !1), l.forEach(function(c, h) {
        var u = c.w;
        if (u.globals.shouldAnimate = n, i || (u.globals.resized = !0, u.globals.dataChanged = !0, n && c.series.getPreviousPaths()), e && lr(e) === "object" && (c.config = new Aa(e), e = st.extendArrayProps(c.config, e, u), c.w.globals.chartID !== t.ctx.w.globals.chartID && delete e.series, u.config = E.extend(u.config, e), a && (u.globals.lastXAxis = e.xaxis ? E.clone(e.xaxis) : [], u.globals.lastYAxis = e.yaxis ? E.clone(e.yaxis) : [], u.globals.initialConfig = E.extend({}, u.config), u.globals.initialSeries = E.clone(u.config.series), e.series))) {
          for (var d = 0; d < u.globals.collapsedSeriesIndices.length; d++) {
            var f = u.config.series[u.globals.collapsedSeriesIndices[d]];
            u.globals.collapsedSeries[d].data = u.globals.axisCharts ? f.data.slice() : f;
          }
          for (var p = 0; p < u.globals.ancillaryCollapsedSeriesIndices.length; p++) {
            var g = u.config.series[u.globals.ancillaryCollapsedSeriesIndices[p]];
            u.globals.ancillaryCollapsedSeries[p].data = u.globals.axisCharts ? g.data.slice() : g;
          }
          c.series.emptyCollapsedSeries(u.config.series);
        }
        return c.update(e).then(function() {
          h === l.length - 1 && o(c);
        });
      });
    });
  } }, { key: "_updateSeries", value: function(e, t) {
    var i = this, n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    return new Promise(function(r) {
      var a, o = i.w;
      return o.globals.shouldAnimate = t, o.globals.dataChanged = !0, t && i.ctx.series.getPreviousPaths(), o.globals.axisCharts ? ((a = e.map(function(l, c) {
        return i._extendSeries(l, c);
      })).length === 0 && (a = [{ data: [] }]), o.config.series = a) : o.config.series = e.slice(), n && (o.globals.initialConfig.series = E.clone(o.config.series), o.globals.initialSeries = E.clone(o.config.series)), i.ctx.update().then(function() {
        r(i.ctx);
      });
    });
  } }, { key: "_extendSeries", value: function(e, t) {
    var i = this.w, n = i.config.series[t];
    return F(F({}, i.config.series[t]), {}, { name: e.name ? e.name : n?.name, color: e.color ? e.color : n?.color, type: e.type ? e.type : n?.type, group: e.group ? e.group : n?.group, hidden: e.hidden !== void 0 ? e.hidden : n?.hidden, data: e.data ? e.data : n?.data, zIndex: e.zIndex !== void 0 ? e.zIndex : t });
  } }, { key: "toggleDataPointSelection", value: function(e, t) {
    var i = this.w, n = null, r = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
    return i.globals.axisCharts ? n = i.globals.dom.Paper.findOne("".concat(r, " path[j='").concat(t, "'], ").concat(r, " circle[j='").concat(t, "'], ").concat(r, " rect[j='").concat(t, "']")) : t === void 0 && (n = i.globals.dom.Paper.findOne("".concat(r, " path[j='").concat(e, "']")), i.config.chart.type !== "pie" && i.config.chart.type !== "polarArea" && i.config.chart.type !== "donut" || this.ctx.pie.pieClicked(e)), n ? (new Z(this.ctx).pathMouseDown(n, null), n.node ? n.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
  } }, { key: "forceXAxisUpdate", value: function(e) {
    var t = this.w;
    if (["min", "max"].forEach(function(n) {
      e.xaxis[n] !== void 0 && (t.config.xaxis[n] = e.xaxis[n], t.globals.lastXAxis[n] = e.xaxis[n]);
    }), e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories), t.config.xaxis.convertedCatToNumeric) {
      var i = new Ca(e);
      e = i.convertCatToNumericXaxis(e, this.ctx);
    }
    return e;
  } }, { key: "forceYAxisUpdate", value: function(e) {
    return e.chart && e.chart.stacked && e.chart.stackType === "100%" && (Array.isArray(e.yaxis) ? e.yaxis.forEach(function(t, i) {
      e.yaxis[i].min = 0, e.yaxis[i].max = 100;
    }) : (e.yaxis.min = 0, e.yaxis.max = 100)), e;
  } }, { key: "revertDefaultAxisMinMax", value: function(e) {
    var t = this, i = this.w, n = i.globals.lastXAxis, r = i.globals.lastYAxis;
    e && e.xaxis && (n = e.xaxis), e && e.yaxis && (r = e.yaxis), i.config.xaxis.min = n.min, i.config.xaxis.max = n.max;
    var a = function(o) {
      r[o] !== void 0 && (i.config.yaxis[o].min = r[o].min, i.config.yaxis[o].max = r[o].max);
    };
    i.config.yaxis.map(function(o, l) {
      i.globals.zoomed || r[l] !== void 0 ? a(l) : t.ctx.opts.yaxis[l] !== void 0 && (o.min = t.ctx.opts.yaxis[l].min, o.max = t.ctx.opts.yaxis[l].max);
    });
  } }]), s;
}();
(function() {
  function s() {
    for (var r = arguments.length > 0 && arguments[0] !== u ? arguments[0] : [], a = arguments.length > 1 ? arguments[1] : u, o = arguments.length > 2 ? arguments[2] : u, l = arguments.length > 3 ? arguments[3] : u, c = arguments.length > 4 ? arguments[4] : u, h = arguments.length > 5 ? arguments[5] : u, u = arguments.length > 6 ? arguments[6] : u, d = r.slice(a, o || u), f = l.slice(c, h || u), p = 0, g = { pos: [0, 0], start: [0, 0] }, m = { pos: [0, 0], start: [0, 0] }; d[p] = e.call(g, d[p]), f[p] = e.call(m, f[p]), d[p][0] != f[p][0] || d[p][0] == "M" || d[p][0] == "A" && (d[p][4] != f[p][4] || d[p][5] != f[p][5]) ? (Array.prototype.splice.apply(d, [p, 1].concat(i.call(g, d[p]))), Array.prototype.splice.apply(f, [p, 1].concat(i.call(m, f[p])))) : (d[p] = t.call(g, d[p]), f[p] = t.call(m, f[p])), !(++p == d.length && p == f.length); )
      p == d.length && d.push(["C", g.pos[0], g.pos[1], g.pos[0], g.pos[1], g.pos[0], g.pos[1]]), p == f.length && f.push(["C", m.pos[0], m.pos[1], m.pos[0], m.pos[1], m.pos[0], m.pos[1]]);
    return { start: d, dest: f };
  }
  function e(r) {
    switch (r[0]) {
      case "z":
      case "Z":
        r[0] = "L", r[1] = this.start[0], r[2] = this.start[1];
        break;
      case "H":
        r[0] = "L", r[2] = this.pos[1];
        break;
      case "V":
        r[0] = "L", r[2] = r[1], r[1] = this.pos[0];
        break;
      case "T":
        r[0] = "Q", r[3] = r[1], r[4] = r[2], r[1] = this.reflection[1], r[2] = this.reflection[0];
        break;
      case "S":
        r[0] = "C", r[6] = r[4], r[5] = r[3], r[4] = r[2], r[3] = r[1], r[2] = this.reflection[1], r[1] = this.reflection[0];
    }
    return r;
  }
  function t(r) {
    var a = r.length;
    return this.pos = [r[a - 2], r[a - 1]], "SCQT".indexOf(r[0]) != -1 && (this.reflection = [2 * this.pos[0] - r[a - 4], 2 * this.pos[1] - r[a - 3]]), r;
  }
  function i(r) {
    var a = [r];
    switch (r[0]) {
      case "M":
        return this.pos = this.start = [r[1], r[2]], a;
      case "L":
        r[5] = r[3] = r[1], r[6] = r[4] = r[2], r[1] = this.pos[0], r[2] = this.pos[1];
        break;
      case "Q":
        r[6] = r[4], r[5] = r[3], r[4] = 1 * r[4] / 3 + 2 * r[2] / 3, r[3] = 1 * r[3] / 3 + 2 * r[1] / 3, r[2] = 1 * this.pos[1] / 3 + 2 * r[2] / 3, r[1] = 1 * this.pos[0] / 3 + 2 * r[1] / 3;
        break;
      case "A":
        a = function(o, l) {
          var c, h, u, d, f, p, g, m, O, x, b, v, y, w, S, k, A, T, C, P, $, R, X, M, z, I, Y = Math.abs(l[1]), V = Math.abs(l[2]), N = l[3] % 360, _ = l[4], U = l[5], q = l[6], oe = l[7], ae = new Me(o), ue = new Me(q, oe), pe = [];
          if (Y === 0 || V === 0 || ae.x === ue.x && ae.y === ue.y) return [["C", ae.x, ae.y, ue.x, ue.y, ue.x, ue.y]];
          for (c = new Me((ae.x - ue.x) / 2, (ae.y - ue.y) / 2).transform(new ce().rotate(N)), h = c.x * c.x / (Y * Y) + c.y * c.y / (V * V), h > 1 && (Y *= h = Math.sqrt(h), V *= h), u = new ce().rotate(N).scale(1 / Y, 1 / V).rotate(-N), ae = ae.transform(u), ue = ue.transform(u), d = [ue.x - ae.x, ue.y - ae.y], p = d[0] * d[0] + d[1] * d[1], f = Math.sqrt(p), d[0] /= f, d[1] /= f, g = p < 4 ? Math.sqrt(1 - p / 4) : 0, _ === U && (g *= -1), m = new Me((ue.x + ae.x) / 2 + g * -d[1], (ue.y + ae.y) / 2 + g * d[0]), O = new Me(ae.x - m.x, ae.y - m.y), x = new Me(ue.x - m.x, ue.y - m.y), b = Math.acos(O.x / Math.sqrt(O.x * O.x + O.y * O.y)), O.y < 0 && (b *= -1), v = Math.acos(x.x / Math.sqrt(x.x * x.x + x.y * x.y)), x.y < 0 && (v *= -1), U && b > v && (v += 2 * Math.PI), !U && b < v && (v -= 2 * Math.PI), w = Math.ceil(2 * Math.abs(b - v) / Math.PI), k = [], A = b, y = (v - b) / w, S = 4 * Math.tan(y / 4) / 3, $ = 0; $ <= w; $++) C = Math.cos(A), T = Math.sin(A), P = new Me(m.x + C, m.y + T), k[$] = [new Me(P.x + S * T, P.y - S * C), P, new Me(P.x - S * T, P.y + S * C)], A += y;
          for (k[0][0] = k[0][1].clone(), k[k.length - 1][2] = k[k.length - 1][1].clone(), u = new ce().rotate(N).scale(Y, V).rotate(-N), $ = 0, R = k.length; $ < R; $++) k[$][0] = k[$][0].transform(u), k[$][1] = k[$][1].transform(u), k[$][2] = k[$][2].transform(u);
          for ($ = 1, R = k.length; $ < R; $++) X = (P = k[$ - 1][2]).x, M = P.y, z = (P = k[$][0]).x, I = P.y, q = (P = k[$][1]).x, oe = P.y, pe.push(["C", X, M, z, I, q, oe]);
          return pe;
        }(this.pos, r), r = a[0];
    }
    return r[0] = "C", this.pos = [r[5], r[6]], this.reflection = [2 * r[5] - r[3], 2 * r[6] - r[4]], a;
  }
  function n() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], a = arguments.length > 1 ? arguments[1] : void 0;
    if (a === !1) return !1;
    for (var o = a, l = r.length; o < l; ++o) if (r[o][0] == "M") return o;
    return !1;
  }
  fe(Si, { morph: function(r, a, o, l, c) {
    for (var h = this.parse(r), u = this.parse(a), d = 0, f = 0, p = !1, g = !1; d !== !1 || f !== !1; ) {
      var m;
      p = n(h, d !== !1 && d + 1), g = n(u, f !== !1 && f + 1), d === !1 && (d = (m = new Si(O.start).bbox()).height == 0 || m.width == 0 ? h.push(h[0]) - 1 : h.push(["M", m.x + m.width / 2, m.y + m.height / 2]) - 1), f === !1 && (f = (m = new Si(O.dest).bbox()).height == 0 || m.width == 0 ? u.push(u[0]) - 1 : u.push(["M", m.x + m.width / 2, m.y + m.height / 2]) - 1);
      var O = s(h, d, p, u, f, g);
      h = h.slice(0, d).concat(O.start, p === !1 ? [] : h.slice(p)), u = u.slice(0, f).concat(O.dest, g === !1 ? [] : u.slice(g)), d = p !== !1 && d + O.start.length, f = g !== !1 && f + O.dest.length;
    }
    this._array = h, this.destination = new Si(), this.destination._array = u;
    var x = this.fromArray(h.map(function(b, v) {
      var y = u[v].map(function(w, S) {
        return S === 0 ? w : l.step(b[S], u[v][S], o, c[v], c);
      });
      return y;
    }));
    return x;
  } });
})();
const Mm = (s) => (s.changedTouches && (s = s.changedTouches[0]), { x: s.clientX, y: s.clientY });
class C$ {
  constructor(e) {
    e.remember("_draggable", this), this.el = e, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(e) {
    e ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: !1 })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
  }
  startDrag(e) {
    const t = !e.type.indexOf("mouse");
    if (t && e.which !== 1 && e.buttons !== 0 || this.el.dispatch("beforedrag", { event: e, handler: this }).defaultPrevented) return;
    e.preventDefault(), e.stopPropagation(), this.init(!1), this.box = this.el.bbox(), this.lastClick = this.el.point(Mm(e));
    const i = (t ? "mouseup" : "touchend") + ".drag";
    gs(window, (t ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: !1 }), gs(window, i, this.endDrag, this, { passive: !1 }), this.el.fire("dragstart", { event: e, handler: this, box: this.box });
  }
  drag(e) {
    const { box: t, lastClick: i } = this, n = this.el.point(Mm(e)), r = n.x - i.x, a = n.y - i.y;
    if (!r && !a) return t;
    const o = t.x + r, l = t.y + a;
    this.box = new it(o, l, t.w, t.h), this.lastClick = n, this.el.dispatch("dragmove", { event: e, handler: this, box: this.box }).defaultPrevented || this.move(o, l);
  }
  move(e, t) {
    this.el.type === "svg" ? zs.prototype.move.call(this.el, e, t) : this.el.move(e, t);
  }
  endDrag(e) {
    this.drag(e), this.el.fire("dragend", { event: e, handler: this, box: this.box }), ci(window, "mousemove.drag"), ci(window, "touchmove.drag"), ci(window, "mouseup.drag"), ci(window, "touchend.drag"), this.init(!0);
  }
}
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Td(s, e, t, i = null) {
  return function(n) {
    n.preventDefault(), n.stopPropagation();
    var r = n.pageX || n.touches[0].pageX, a = n.pageY || n.touches[0].pageY;
    e.fire(s, { x: r, y: a, event: n, index: i, points: t });
  };
}
function $d([s, e], { a: t, b: i, c: n, d: r, e: a, f: o }) {
  return [s * t + e * n + a, s * i + e * r + o];
}
fe(kt, { draggable(s = !0) {
  return (this.remember("_draggable") || new C$(this)).init(s), this;
} });
let rv = class {
  constructor(s) {
    this.el = s, s.remember("_selectHandler", this), this.selection = new zs(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = uo();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(s) {
    this.createHandle = s.createHandle || this.createHandleFn, this.createRot = s.createRot || this.createRotFn, this.updateHandle = s.updateHandle || this.updateHandleFn, this.updateRot = s.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(s, e) {
    if (!s) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((s, e, t) => {
      const i = this.order[e];
      this.createHandle.call(this, this.selection, s, e, t, i), this.selection.get(e + 1).addClass("svg_select_handle svg_select_handle_" + i).on("mousedown.selection touchstart.selection", Td(i, this.el, this.handlePoints, e));
    });
  }
  createHandleFn(s) {
    s.polyline();
  }
  updateHandleFn(s, e, t, i) {
    const n = i.at(t - 1), r = i[(t + 1) % i.length], a = e, o = [a[0] - n[0], a[1] - n[1]], l = [a[0] - r[0], a[1] - r[1]], c = Math.sqrt(o[0] * o[0] + o[1] * o[1]), h = Math.sqrt(l[0] * l[0] + l[1] * l[1]), u = [o[0] / c, o[1] / c], d = [l[0] / h, l[1] / h], f = [a[0] - 10 * u[0], a[1] - 10 * u[1]], p = [a[0] - 10 * d[0], a[1] - 10 * d[1]];
    s.plot([f, a, p]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((s, e, t) => {
      const i = this.order[e];
      this.updateHandle.call(this, this.selection.get(e + 1), s, e, t, i);
    });
  }
  createRotFn(s) {
    s.line(), s.circle(5);
  }
  getPoint(s) {
    return this.handlePoints[this.order.indexOf(s)];
  }
  getPointHandle(s) {
    return this.selection.get(this.order.indexOf(s) + 1);
  }
  updateRotFn(s, e) {
    const t = this.getPoint("t");
    s.get(0).plot(t[0], t[1], e[0], e[1]), s.get(1).center(e[0], e[1]);
  }
  createRotationHandle() {
    const s = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Td("rot", this.el, this.handlePoints));
    this.createRot.call(this, s);
  }
  updateRotationHandle() {
    const s = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(s, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const s = this.el.bbox(), e = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(s).map((t) => $d(t, e)), this.rotationPoint = $d(this.getRotationPoint(s), e);
  }
  getHandlePoints({ x: s, x2: e, y: t, y2: i, cx: n, cy: r } = this.el.bbox()) {
    return [[s, t], [n, t], [e, t], [e, r], [e, i], [n, i], [s, i], [s, r]];
  }
  getRotationPoint({ y: s, cx: e } = this.el.bbox()) {
    return [e, s - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
const _m = (s) => function(e = !0, t = {}) {
  typeof e == "object" && (t = e, e = !0);
  let i = this.remember("_" + s.name);
  return i || (e.prototype instanceof rv ? (i = new e(this), e = !0) : i = new s(this), this.remember("_" + s.name, i)), i.active(e, t), this;
};
/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Rd(s, e, t, i = null) {
  return function(n) {
    n.preventDefault(), n.stopPropagation();
    var r = n.pageX || n.touches[0].pageX, a = n.pageY || n.touches[0].pageY;
    e.fire(s, { x: r, y: a, event: n, index: i, points: t });
  };
}
function Ed([s, e], { a: t, b: i, c: n, d: r, e: a, f: o }) {
  return [s * t + e * n + a, s * i + e * r + o];
}
fe(kt, { select: _m(rv) }), fe([ln, cn, on], { pointSelect: _m(class {
  constructor(s) {
    this.el = s, s.remember("_pointSelectHandler", this), this.selection = new zs(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = uo();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(s) {
    this.createHandle = s.createHandle || this.createHandleFn, this.updateHandle = s.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(s, e) {
    if (!s) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((s, e, t) => {
      this.createHandle.call(this, this.selection, s, e, t), this.selection.get(e + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Td("point", this.el, this.points, e));
    });
  }
  createHandleFn(s) {
    s.circle(5);
  }
  updateHandleFn(s, e) {
    s.center(e[0], e[1]);
  }
  updatePointHandles() {
    this.points.forEach((s, e, t) => {
      this.updateHandle.call(this, this.selection.get(e + 1), s, e, t);
    });
  }
  updatePoints() {
    const s = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e) => $d(e, s));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
class av {
  constructor(e) {
    this.el = e, e.remember("_selectHandler", this), this.selection = new zs(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const t = uo();
    this.observer = new t.MutationObserver(this.mutationHandler);
  }
  init(e) {
    this.createHandle = e.createHandle || this.createHandleFn, this.createRot = e.createRot || this.createRotFn, this.updateHandle = e.updateHandle || this.updateHandleFn, this.updateRot = e.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(e, t) {
    if (!e) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(t);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((e, t, i) => {
      const n = this.order[t];
      this.createHandle.call(this, this.selection, e, t, i, n), this.selection.get(t + 1).addClass("svg_select_handle svg_select_handle_" + n).on("mousedown.selection touchstart.selection", Rd(n, this.el, this.handlePoints, t));
    });
  }
  createHandleFn(e) {
    e.polyline();
  }
  updateHandleFn(e, t, i, n) {
    const r = n.at(i - 1), a = n[(i + 1) % n.length], o = t, l = [o[0] - r[0], o[1] - r[1]], c = [o[0] - a[0], o[1] - a[1]], h = Math.sqrt(l[0] * l[0] + l[1] * l[1]), u = Math.sqrt(c[0] * c[0] + c[1] * c[1]), d = [l[0] / h, l[1] / h], f = [c[0] / u, c[1] / u], p = [o[0] - 10 * d[0], o[1] - 10 * d[1]], g = [o[0] - 10 * f[0], o[1] - 10 * f[1]];
    e.plot([p, o, g]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((e, t, i) => {
      const n = this.order[t];
      this.updateHandle.call(this, this.selection.get(t + 1), e, t, i, n);
    });
  }
  createRotFn(e) {
    e.line(), e.circle(5);
  }
  getPoint(e) {
    return this.handlePoints[this.order.indexOf(e)];
  }
  getPointHandle(e) {
    return this.selection.get(this.order.indexOf(e) + 1);
  }
  updateRotFn(e, t) {
    const i = this.getPoint("t");
    e.get(0).plot(i[0], i[1], t[0], t[1]), e.get(1).center(t[0], t[1]);
  }
  createRotationHandle() {
    const e = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Rd("rot", this.el, this.handlePoints));
    this.createRot.call(this, e);
  }
  updateRotationHandle() {
    const e = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(e, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const e = this.el.bbox(), t = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(e).map((i) => Ed(i, t)), this.rotationPoint = Ed(this.getRotationPoint(e), t);
  }
  getHandlePoints({ x: e, x2: t, y: i, y2: n, cx: r, cy: a } = this.el.bbox()) {
    return [[e, i], [r, i], [t, i], [t, a], [t, n], [r, n], [e, n], [e, a]];
  }
  getRotationPoint({ y: e, cx: t } = this.el.bbox()) {
    return [t, e - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
}
const Lm = (s) => function(e = !0, t = {}) {
  typeof e == "object" && (t = e, e = !0);
  let i = this.remember("_" + s.name);
  return i || (e.prototype instanceof av ? (i = new e(this), e = !0) : i = new s(this), this.remember("_" + s.name, i)), i.active(e, t), this;
};
fe(kt, { select: Lm(av) }), fe([ln, cn, on], { pointSelect: Lm(class {
  constructor(s) {
    this.el = s, s.remember("_pointSelectHandler", this), this.selection = new zs(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = uo();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(s) {
    this.createHandle = s.createHandle || this.createHandleFn, this.updateHandle = s.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(s, e) {
    if (!s) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((s, e, t) => {
      this.createHandle.call(this, this.selection, s, e, t), this.selection.get(e + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Rd("point", this.el, this.points, e));
    });
  }
  createHandleFn(s) {
    s.circle(5);
  }
  updateHandleFn(s, e) {
    s.center(e[0], e[1]);
  }
  updatePointHandles() {
    this.points.forEach((s, e, t) => {
      this.updateHandle.call(this, this.selection.get(e + 1), s, e, t);
    });
  }
  updatePoints() {
    const s = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e) => Ed(e, s));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
const Lo = (s) => (s.changedTouches && (s = s.changedTouches[0]), { x: s.clientX, y: s.clientY }), zm = (s) => {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0;
  for (let r = 0; r < s.length; r++) {
    const a = s[r];
    e = Math.min(e, a[0]), t = Math.min(t, a[1]), i = Math.max(i, a[0]), n = Math.max(n, a[1]);
  }
  return new it(e, t, i - e, n - t);
};
class Im {
  constructor(e) {
    this.el = e, e.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(e, t) {
    this.preserveAspectRatio = t.preserveAspectRatio ?? !1, this.aroundCenter = t.aroundCenter ?? !1, this.grid = t.grid ?? 0, this.degree = t.degree ?? 0, this.el.off(".resize"), e && (this.el.on(["lt.resize", "rt.resize", "rb.resize", "lb.resize", "t.resize", "r.resize", "b.resize", "l.resize", "rot.resize", "point.resize"], this.handleResize), this.lastEvent && (this.eventType === "rot" ? this.rotate(this.lastEvent) : this.eventType === "point" ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(e) {
    this.eventType = e.type;
    const { event: t, index: i, points: n } = e.detail, r = !t.type.indexOf("mouse");
    if (r && (t.which || t.buttons) !== 1 || this.el.dispatch("beforeresize", { event: e, handler: this }).defaultPrevented) return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(Lo(t)), this.index = i, this.points = n.slice();
    const a = (r ? "mousemove" : "touchmove") + ".resize", o = (r ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    e.type === "point" ? gs(window, a, this.movePoint) : e.type === "rot" ? gs(window, a, this.rotate) : gs(window, a, this.resize), gs(window, o, this.endResize);
  }
  resize(e) {
    this.lastEvent = e;
    const t = this.snapToGrid(this.el.point(Lo(e)));
    let i = t.x - this.startPoint.x, n = t.y - this.startPoint.y;
    this.preserveAspectRatio && this.aroundCenter && (i *= 2, n *= 2);
    const r = this.box.x + i, a = this.box.y + n, o = this.box.x2 + i, l = this.box.y2 + n;
    let c = new it(this.box);
    if (this.eventType.includes("l") && (c.x = Math.min(r, this.box.x2), c.x2 = Math.max(r, this.box.x2)), this.eventType.includes("r") && (c.x = Math.min(o, this.box.x), c.x2 = Math.max(o, this.box.x)), this.eventType.includes("t") && (c.y = Math.min(a, this.box.y2), c.y2 = Math.max(a, this.box.y2)), this.eventType.includes("b") && (c.y = Math.min(l, this.box.y), c.y2 = Math.max(l, this.box.y)), c.width = c.x2 - c.x, c.height = c.y2 - c.y, this.preserveAspectRatio) {
      const h = c.width / this.box.width, u = c.height / this.box.height, d = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"], f = (d.indexOf(this.eventType) + 4) % d.length, p = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[f];
      let g = this.eventType.includes("t") || this.eventType.includes("b") ? u : h;
      g = this.eventType.length === 2 ? Math.max(h, u) : g, c = function(m, O, x) {
        const b = [[m.x, m.y], [m.x + m.width, m.y], [m.x + m.width, m.y + m.height], [m.x, m.y + m.height]].map(([v, y]) => {
          const w = v - O[0], S = (y - O[1]) * x;
          return [w * x + O[0], S + O[1]];
        });
        return zm(b);
      }(this.box, p, g);
    }
    this.el.dispatch("resize", { box: new it(c), angle: 0, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.size(c.width, c.height).move(c.x, c.y);
  }
  movePoint(e) {
    this.lastEvent = e;
    const { x: t, y: i } = this.snapToGrid(this.el.point(Lo(e))), n = this.el.array().slice();
    n[this.index] = [t, i], this.el.dispatch("resize", { box: zm(n), angle: 0, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.plot(n);
  }
  rotate(e) {
    this.lastEvent = e;
    const t = this.startPoint, i = this.el.point(Lo(e)), { cx: n, cy: r } = this.box, a = t.x - n, o = t.y - r, l = i.x - n, c = i.y - r, h = Math.sqrt(a * a + o * o) * Math.sqrt(l * l + c * c);
    if (h === 0) return;
    let u = Math.acos((a * l + o * c) / h) / Math.PI * 180;
    if (!u) return;
    i.x < t.x && (u = -u);
    const d = new ce(this.el), { x: f, y: p } = new Me(n, r).transformO(d), { rotate: g } = d.decompose(), m = this.snapToAngle(g + u) - g;
    this.el.dispatch("resize", { box: this.box, angle: m, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.transform(d.rotateO(m, f, p));
  }
  endResize(e) {
    this.eventType !== "rot" && this.eventType !== "point" && this.resize(e), this.lastEvent = null, this.eventType = "", ci(window, "mousemove.resize touchmove.resize"), ci(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(e) {
    return this.grid && (e.x = Math.round(e.x / this.grid) * this.grid, e.y = Math.round(e.y / this.grid) * this.grid), e;
  }
  snapToAngle(e) {
    return this.degree && (e = Math.round(e / this.degree) * this.degree), e;
  }
}
fe(kt, { resize: function(s = !0, e = {}) {
  typeof s == "object" && (e = s, s = !0);
  let t = this.remember("_ResizeHandler");
  return t || (s.prototype instanceof Im ? (t = new s(this), s = !0) : t = new Im(this), this.remember("_resizeHandler", t)), t.active(s, e), this;
} }), window.SVG === void 0 && (window.SVG = WT), window.Apex === void 0 && (window.Apex = {});
var qm = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "initModules", value: function() {
    this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new Cr(this.ctx), this.ctx.axes = new KT(this.ctx), this.ctx.core = new P$(this.ctx.el, this.ctx), this.ctx.config = new Aa({}), this.ctx.data = new _p(this.ctx), this.ctx.grid = new Hy(this.ctx), this.ctx.graphics = new Z(this.ctx), this.ctx.coreUtils = new st(this.ctx), this.ctx.crosshairs = new Ad(this.ctx), this.ctx.events = new UT(this.ctx), this.ctx.exports = new ha(this.ctx), this.ctx.fill = new Ci(this.ctx), this.ctx.localization = new GT(this.ctx), this.ctx.options = new sn(), this.ctx.responsive = new JT(this.ctx), this.ctx.series = new pi(this.ctx), this.ctx.theme = new e$(this.ctx), this.ctx.formatters = new go(this.ctx), this.ctx.titleSubtitle = new t$(this.ctx), this.ctx.legend = new Gy(this.ctx), this.ctx.toolbar = new Ky(this.ctx), this.ctx.tooltip = new Em(this.ctx), this.ctx.dimensions = new ec(this.ctx), this.ctx.updateHelpers = new Q$(this.ctx), this.ctx.zoomPanSelection = new o$(this.ctx), this.ctx.w.globals.tooltip = new Em(this.ctx);
  } }]), s;
}(), Dm = function() {
  function s(e) {
    ee(this, s), this.ctx = e, this.w = e.w;
  }
  return te(s, [{ key: "clear", value: function(e) {
    var t = e.isUpdating;
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: t });
  } }, { key: "killSVG", value: function(e) {
    e.each(function() {
      this.removeClass("*"), this.off();
    }, !0), e.clear();
  } }, { key: "clearDomElements", value: function(e) {
    var t = this, i = e.isUpdating, n = this.w.globals.dom.Paper.node;
    n.parentNode && n.parentNode.parentNode && !i && (n.parentNode.parentNode.style.minHeight = "unset");
    var r = this.w.globals.dom.baseEl;
    r && this.ctx.eventList.forEach(function(o) {
      r.removeEventListener(o, t.ctx.events.documentEvent);
    });
    var a = this.w.globals.dom;
    if (this.ctx.el !== null) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(a.Paper), a.Paper.remove(), a.elWrap = null, a.elGraphical = null, a.elLegendWrap = null, a.elLegendForeign = null, a.baseEl = null, a.elGridRect = null, a.elGridRectMask = null, a.elGridRectBarMask = null, a.elGridRectMarkerMask = null, a.elForecastMask = null, a.elNonForecastMask = null, a.elDefs = null;
  } }]), s;
}(), Vh = /* @__PURE__ */ new WeakMap(), A$ = function() {
  function s(e, t) {
    ee(this, s), this.opts = t, this.ctx = this, this.w = new HT(t).init(), this.el = e, this.w.globals.cuid = E.randomId(), this.w.globals.chartID = this.w.config.chart.id ? E.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new qm(this).initModules(), this.lastUpdateOptions = null, this.create = E.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return te(s, [{ key: "render", value: function() {
    var e = this;
    return new Promise(function(t, i) {
      if (E.elementExists(e.el)) {
        Apex._chartInstances === void 0 && (Apex._chartInstances = []), e.w.config.chart.id && Apex._chartInstances.push({ id: e.w.globals.chartID, group: e.w.config.chart.group, chart: e }), e.setLocale(e.w.config.chart.defaultLocale);
        var n = e.w.config.chart.events.beforeMount;
        typeof n == "function" && n(e, e.w), e.events.fireEvent("beforeMount", [e, e.w]), window.addEventListener("resize", e.windowResizeHandler), function(d, f) {
          var p = !1;
          if (d.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var g = d.getBoundingClientRect();
            d.style.display !== "none" && g.width !== 0 || (p = !0);
          }
          var m = new ResizeObserver(function(O) {
            p && f.call(d, O), p = !0;
          });
          d.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(d.children).forEach(function(O) {
            return m.observe(O);
          }) : m.observe(d), Vh.set(f, m);
        }(e.el.parentNode, e.parentResizeHandler);
        var r = e.el.getRootNode && e.el.getRootNode(), a = E.is("ShadowRoot", r), o = e.el.ownerDocument, l = a ? r.getElementById("apexcharts-css") : o.getElementById("apexcharts-css");
        if (!l) {
          var c;
          (l = document.createElement("style")).id = "apexcharts-css", l.textContent = `@keyframes opaque {
  0% {
    opacity: 0
  }

  to {
    opacity: 1
  }
}

@keyframes resizeanim {

  0%,
  to {
    opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  direction: ltr !important;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0, 0, 0, .5);
  box-shadow: 0 0 1px rgba(255, 255, 255, .5);
  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

rect.legend-mouseover-inactive,
.legend-mouseover-inactive rect,
.legend-mouseover-inactive path,
.legend-mouseover-inactive circle,
.legend-mouseover-inactive line,
.legend-mouseover-inactive text.apexcharts-yaxis-title-text,
.legend-mouseover-inactive text.apexcharts-yaxis-label {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255, 255, 255, .96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30, 30, 30, .8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0, 0, 0, .7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,
.apexcharts-tooltip-text-y-value,
.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,
.apexcharts-tooltip-text-goals-value:empty,
.apexcharts-tooltip-text-y-label:empty,
.apexcharts-tooltip-text-y-value:empty,
.apexcharts-tooltip-text-z-value:empty,
.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,
.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,
.apexcharts-tooltip-text-goals-label,
.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),
.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  display: inline-block;
  position: relative;
  width: 16px;
  height: 16px;
  font-size: 16px;
  line-height: 16px;
  margin-right: 4px;
  text-align: center;
  vertical-align: middle;
  color: inherit;
}

.apexcharts-tooltip-marker::before {
  content: "";
  display: inline-block;
  width: 100%;
  text-align: center;
  color: currentcolor;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  font-size: 26px;
  font-family: Arial, Helvetica, sans-serif;
  line-height: 14px;
  font-weight: 900;
}

.apexcharts-tooltip-marker[shape="circle"]::before {
  content: "\\25CF";
}

.apexcharts-tooltip-marker[shape="square"]::before,
.apexcharts-tooltip-marker[shape="rect"]::before {
  content: "\\25A0";
  transform: translate(-1px, -2px);
}

.apexcharts-tooltip-marker[shape="line"]::before {
  content: "\\2500";
}

.apexcharts-tooltip-marker[shape="diamond"]::before {
  content: "\\25C6";
  font-size: 28px;
}

.apexcharts-tooltip-marker[shape="triangle"]::before {
  content: "\\25B2";
  font-size: 22px;
}

.apexcharts-tooltip-marker[shape="cross"]::before {
  content: "\\2715";
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="plus"]::before {
  content: "\\2715";
  transform: rotate(45deg) translate(-1px, -1px);
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="star"]::before {
  content: "\\2605";
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="sparkle"]::before {
  content: "\\2726";
  font-size: 20px;
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,
.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,
.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,
.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0, 0, 0, .7);
  border: 1px solid rgba(0, 0, 0, .5);
  color: #fff
}

.apexcharts-xaxistooltip:after,
.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,
.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,
.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,
.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0, 0, 0, .5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,
.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0, 0, 0, .5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0, 0, 0, .7);
  border: 1px solid rgba(0, 0, 0, .5);
  color: #fff
}

.apexcharts-yaxistooltip:after,
.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,
.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,
.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,
.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0, 0, 0, .5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,
.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0, 0, 0, .5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,
.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,
.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_shape {
  stroke-width: 1;
  stroke-dasharray: 10 10;
  stroke: black;
  stroke-opacity: 0.1;
  pointer-events: none;
  fill: none;
}

.svg_select_handle {
  stroke-width: 3;
  stroke: black;
  fill: none;
}

.svg_select_handle_r {
  cursor: e-resize;
}

.svg_select_handle_l {
  cursor: w-resize;
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,
.apexcharts-pan-icon,
.apexcharts-reset-icon,
.apexcharts-selection-icon,
.apexcharts-toolbar-custom-icon,
.apexcharts-zoom-icon,
.apexcharts-zoomin-icon,
.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,
.apexcharts-reset-icon svg,
.apexcharts-zoom-icon svg,
.apexcharts-zoomin-icon svg,
.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,
.apexcharts-theme-dark .apexcharts-pan-icon svg,
.apexcharts-theme-dark .apexcharts-reset-icon svg,
.apexcharts-theme-dark .apexcharts-selection-icon svg,
.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,
.apexcharts-theme-dark .apexcharts-zoom-icon svg,
.apexcharts-theme-dark .apexcharts-zoomin-icon svg,
.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,
.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,
.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,
.apexcharts-theme-light .apexcharts-reset-icon:hover svg,
.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,
.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,
.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,
.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,
.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,
.apexcharts-reset-icon,
.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,
.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0, 0, 0, .7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
    opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,
.apexcharts-datalabel.apexcharts-element-hidden,
.apexcharts-hide .apexcharts-series-points {
  opacity: 0;
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}

.apexcharts-datalabel,
.apexcharts-datalabel-label,
.apexcharts-datalabel-value,
.apexcharts-datalabels,
.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-radialbar-label {
  cursor: pointer;
}

.apexcharts-annotation-rect,
.apexcharts-area-series .apexcharts-area,
.apexcharts-gridline,
.apexcharts-line,
.apexcharts-point-annotation-label,
.apexcharts-radar-series path:not(.apexcharts-marker),
.apexcharts-radar-series polygon,
.apexcharts-toolbar svg,
.apexcharts-tooltip .apexcharts-marker,
.apexcharts-xaxis-annotation-label,
.apexcharts-yaxis-annotation-label,
.apexcharts-zoom-rect,
.no-pointer-events {
  pointer-events: none
}

.apexcharts-tooltip-active .apexcharts-marker {
  transition: .15s ease all
}

.apexcharts-radar-series .apexcharts-yaxis {
  pointer-events: none;
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,
.resize-triggers,
.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers {
  pointer-events: none
}

.apexcharts-bar-shadows {
  pointer-events: none
}

.apexcharts-rangebar-goals-markers {
  pointer-events: none
}

.apexcharts-disable-transitions * {
  transition: none !important;
}`;
          var h = ((c = e.opts.chart) === null || c === void 0 ? void 0 : c.nonce) || e.w.config.chart.nonce;
          h && l.setAttribute("nonce", h), a ? r.prepend(l) : o.head.appendChild(l);
        }
        var u = e.create(e.w.config.series, {});
        if (!u) return t(e);
        e.mount(u).then(function() {
          typeof e.w.config.chart.events.mounted == "function" && e.w.config.chart.events.mounted(e, e.w), e.events.fireEvent("mounted", [e, e.w]), t(u);
        }).catch(function(d) {
          i(d);
        });
      } else i(new Error("Element not found"));
    });
  } }, { key: "create", value: function(e, t) {
    var i = this, n = this.w;
    new qm(this).initModules();
    var r = this.w.globals;
    if (r.noData = !1, r.animationEnded = !1, !E.elementExists(this.el) || (this.responsive.checkResponsiveConfig(t), n.config.xaxis.convertedCatToNumeric && new Ca(n.config).convertCatToNumericXaxis(n.config, this.ctx), this.core.setupElements(), n.config.chart.type === "treemap" && (n.config.grid.show = !1, n.config.yaxis[0].show = !1), r.svgWidth === 0)) return r.animationEnded = !0, null;
    var a = e;
    e.forEach(function(d, f) {
      d.hidden && (a = i.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: f }));
    });
    var o = st.checkComboSeries(a, n.config.chart.type);
    r.comboCharts = o.comboCharts, r.comboBarCount = o.comboBarCount;
    var l = a.every(function(d) {
      return d.data && d.data.length === 0;
    });
    (a.length === 0 || l && r.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(a), this.theme.init(), new Rr(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), r.noData && r.collapsedSeries.length !== r.series.length && !n.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), r.axisCharts && (this.core.coreCalculations(), n.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = n.globals.minX, this.ctx.toolbar.maxX = n.globals.maxX), this.formatters.heatmapLabelFormatters(), new st(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var c = this.core.xySettings();
    this.grid.createGridMask();
    var h = this.core.plotChartType(a, c), u = new cr(this);
    return u.bringForward(), n.config.dataLabels.background.enabled && u.dataLabelsBackground(), this.core.shiftGraphPosition(), n.globals.dataPoints > 50 && n.globals.dom.elWrap.classList.add("apexcharts-disable-transitions"), { elGraph: h, xyRatios: c, dimensions: { plot: { left: n.globals.translateX, top: n.globals.translateY, width: n.globals.gridWidth, height: n.globals.gridHeight } } };
  } }, { key: "mount", value: function() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i = this, n = i.w;
    return new Promise(function(r, a) {
      if (i.el === null) return a(new Error("Not enough data to display or target element not found"));
      (t === null || n.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new Hy(i);
      var o, l, c = i.grid.drawGrid();
      if (i.annotations = new jT(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), n.config.grid.position === "back" && (c && n.globals.dom.elGraphical.add(c.el), c != null && (o = c.elGridBorders) !== null && o !== void 0 && o.node && n.globals.dom.elGraphical.add(c.elGridBorders)), Array.isArray(t.elGraph)) for (var h = 0; h < t.elGraph.length; h++) n.globals.dom.elGraphical.add(t.elGraph[h]);
      else n.globals.dom.elGraphical.add(t.elGraph);
      n.config.grid.position === "front" && (c && n.globals.dom.elGraphical.add(c.el), c != null && (l = c.elGridBorders) !== null && l !== void 0 && l.node && n.globals.dom.elGraphical.add(c.elGridBorders)), n.config.xaxis.crosshairs.position === "front" && i.crosshairs.drawXCrosshairs(), n.config.yaxis[0].crosshairs.position === "front" && i.crosshairs.drawYCrosshairs(), n.config.chart.type !== "treemap" && i.axes.drawAxis(n.config.chart.type, c);
      var u = new Ta(e.ctx, c), d = new Lp(e.ctx, c);
      if (c !== null && (u.xAxisLabelCorrections(c.xAxisTickWidth), d.setYAxisTextAlignments(), n.config.yaxis.map(function(p, g) {
        n.globals.ignoreYAxisIndexes.indexOf(g) === -1 && d.yAxisTitleRotate(g, p.opposite);
      })), i.annotations.drawAxesAnnotations(), !n.globals.noData) {
        if (n.config.tooltip.enabled && !n.globals.noData && i.w.globals.tooltip.drawTooltip(t.xyRatios), n.globals.axisCharts && (n.globals.isXNumeric || n.config.xaxis.convertedCatToNumeric || n.globals.isRangeBar)) (n.config.chart.zoom.enabled || n.config.chart.selection && n.config.chart.selection.enabled || n.config.chart.pan && n.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: t.xyRatios });
        else {
          var f = n.config.chart.toolbar.tools;
          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(p) {
            f[p] = !1;
          });
        }
        n.config.chart.toolbar.show && !n.globals.allSeriesCollapsed && i.toolbar.createToolbar();
      }
      n.globals.memory.methodsToExec.length > 0 && n.globals.memory.methodsToExec.forEach(function(p) {
        p.method(p.params, !1, p.context);
      }), n.globals.axisCharts || n.globals.noData || i.core.resizeNonAxisCharts(), r(i);
    });
  } }, { key: "destroy", value: function() {
    window.removeEventListener("resize", this.windowResizeHandler), function(t, i) {
      var n = Vh.get(i);
      n && (n.disconnect(), Vh.delete(i));
    }(this.el.parentNode, this.parentResizeHandler);
    var e = this.w.config.chart.id;
    e && Apex._chartInstances.forEach(function(t, i) {
      t.id === E.escapeString(e) && Apex._chartInstances.splice(i, 1);
    }), new Dm(this.ctx).clear({ isUpdating: !1 });
  } }, { key: "updateOptions", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], n = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], r = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], a = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], o = this.w;
    return o.globals.selection = void 0, this.lastUpdateOptions && JSON.stringify(this.lastUpdateOptions) === JSON.stringify(e) ? this : (this.lastUpdateOptions = E.clone(e), e.series && (this.series.resetSeries(!1, !0, !1), e.series.length && e.series[0].data && (e.series = e.series.map(function(l, c) {
      return t.updateHelpers._extendSeries(l, c);
    })), this.updateHelpers.revertDefaultAxisMinMax()), e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)), e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)), o.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), e.theme && (e = this.theme.updateThemeOptions(e)), this.updateHelpers._updateOptions(e, i, n, r, a));
  } }, { key: "updateSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
    return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(e, t, i);
  } }, { key: "appendSeries", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], n = this.w.config.series.slice();
    return n.push(e), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(n, t, i);
  } }, { key: "appendData", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this;
    i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
    for (var n = i.w.config.series.slice(), r = 0; r < n.length; r++) if (e[r] !== null && e[r] !== void 0) for (var a = 0; a < e[r].data.length; a++) n[r].data.push(e[r].data[a]);
    return i.w.config.series = n, t && (i.w.globals.initialSeries = E.clone(i.w.config.series)), this.update();
  } }, { key: "update", value: function(e) {
    var t = this;
    return new Promise(function(i, n) {
      if (t.lastUpdateOptions && JSON.stringify(t.lastUpdateOptions) === JSON.stringify(e)) return i(t);
      t.lastUpdateOptions = E.clone(e), new Dm(t.ctx).clear({ isUpdating: !0 });
      var r = t.create(t.w.config.series, e);
      if (!r) return i(t);
      t.mount(r).then(function() {
        typeof t.w.config.chart.events.updated == "function" && t.w.config.chart.events.updated(t, t.w), t.events.fireEvent("updated", [t, t.w]), t.w.globals.isDirty = !0, i(t);
      }).catch(function(a) {
        n(a);
      });
    });
  } }, { key: "getSyncedCharts", value: function() {
    var e = this.getGroupedCharts(), t = [this];
    return e.length && (t = [], e.forEach(function(i) {
      t.push(i);
    })), t;
  } }, { key: "getGroupedCharts", value: function() {
    var e = this;
    return Apex._chartInstances.filter(function(t) {
      if (t.group) return !0;
    }).map(function(t) {
      return e.w.config.chart.group === t.group ? t.chart : e;
    });
  } }, { key: "toggleSeries", value: function(e) {
    return this.series.toggleSeries(e);
  } }, { key: "highlightSeriesOnLegendHover", value: function(e, t) {
    return this.series.toggleSeriesOnHover(e, t);
  } }, { key: "showSeries", value: function(e) {
    this.series.showSeries(e);
  } }, { key: "hideSeries", value: function(e) {
    this.series.hideSeries(e);
  } }, { key: "highlightSeries", value: function(e) {
    this.series.highlightSeries(e);
  } }, { key: "isSeriesHidden", value: function(e) {
    this.series.isSeriesHidden(e);
  } }, { key: "resetSeries", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    this.series.resetSeries(e, t);
  } }, { key: "addEventListener", value: function(e, t) {
    this.events.addEventListener(e, t);
  } }, { key: "removeEventListener", value: function(e, t) {
    this.events.removeEventListener(e, t);
  } }, { key: "addXaxisAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, n = this;
    i && (n = i), n.annotations.addXaxisAnnotationExternal(e, t, n);
  } }, { key: "addYaxisAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, n = this;
    i && (n = i), n.annotations.addYaxisAnnotationExternal(e, t, n);
  } }, { key: "addPointAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, n = this;
    i && (n = i), n.annotations.addPointAnnotationExternal(e, t, n);
  } }, { key: "clearAnnotations", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, t = this;
    e && (t = e), t.annotations.clearAnnotations(t);
  } }, { key: "removeAnnotation", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i = this;
    t && (i = t), i.annotations.removeAnnotation(i, e);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(e, t) {
    return this.coreUtils.getSeriesTotalsXRange(e, t);
  } }, { key: "getHighestValueInSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new Cd(this.ctx).getMinYMaxY(e).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new Cd(this.ctx).getMinYMaxY(e).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "toggleDataPointSelection", value: function(e, t) {
    return this.updateHelpers.toggleDataPointSelection(e, t);
  } }, { key: "zoomX", value: function(e, t) {
    this.ctx.toolbar.zoomUpdateOptions(e, t);
  } }, { key: "setLocale", value: function(e) {
    this.localization.setCurrentLocaleValues(e);
  } }, { key: "dataURI", value: function(e) {
    return new ha(this.ctx).dataURI(e);
  } }, { key: "getSvgString", value: function(e) {
    return new ha(this.ctx).getSvgString(e);
  } }, { key: "exportToCSV", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new ha(this.ctx).exportToCSV(e);
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "_parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  } }, { key: "_windowResize", value: function() {
    var e = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      e.w.globals.resized = !0, e.w.globals.dataChanged = !1, e.ctx.update();
    }, 150);
  } }, { key: "_windowResizeHandler", value: function() {
    var e = this.w.config.chart.redrawOnWindowResize;
    typeof e == "function" && (e = e()), e && this._windowResize();
  } }], [{ key: "getChartByID", value: function(e) {
    var t = E.escapeString(e);
    if (Apex._chartInstances) {
      var i = Apex._chartInstances.filter(function(n) {
        return n.id === t;
      })[0];
      return i && i.chart;
    }
  } }, { key: "initOnLoad", value: function() {
    for (var e = document.querySelectorAll("[data-apexcharts]"), t = 0; t < e.length; t++)
      new s(e[t], JSON.parse(e[t].getAttribute("data-options"))).render();
  } }, { key: "exec", value: function(e, t) {
    var i = this.getChartByID(e);
    if (i) {
      i.w.globals.isExecCalled = !0;
      var n = null;
      if (i.publicMethods.indexOf(t) !== -1) {
        for (var r = arguments.length, a = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++) a[o - 2] = arguments[o];
        n = i[t].apply(i, a);
      }
      return n;
    }
  } }, { key: "merge", value: function(e, t) {
    return E.extend(e, t);
  } }]), s;
}();
function Fh(s) {
  if (s === null || typeof s != "object")
    return !1;
  const e = Object.getPrototypeOf(s);
  return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in s ? !1 : Symbol.toStringTag in s ? Object.prototype.toString.call(s) === "[object Module]" : !0;
}
function Xd(s, e, t = ".", i) {
  if (!Fh(e))
    return Xd(s, {}, t, i);
  const n = Object.assign({}, e);
  for (const r in s) {
    if (r === "__proto__" || r === "constructor")
      continue;
    const a = s[r];
    a != null && (i && i(n, r, a, t) || (Array.isArray(a) && Array.isArray(n[r]) ? n[r] = [...a, ...n[r]] : Fh(a) && Fh(n[r]) ? n[r] = Xd(
      a,
      n[r],
      (t ? `${t}.` : "") + r.toString(),
      i
    ) : n[r] = a));
  }
  return n;
}
function T$(s) {
  return (...e) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    e.reduce((t, i) => Xd(t, i, "", s), {})
  );
}
const $$ = T$();
var R$ = /* @__PURE__ */ K("<div>"), E$ = (s) => {
  let e, t;
  const i = wn({
    height: "auto",
    width: "100%",
    series: [],
    type: "line"
  }, s), n = () => {
    const r = {
      chart: {
        type: i.type,
        height: i.height,
        width: i.width,
        events: {}
      },
      series: Fl(i.series)
    };
    for (const o in s)
      if (o.startsWith("on")) {
        const l = o.charAt(2).toLowerCase() + o.slice(3);
        r.chart.events[l] = s[o];
      }
    const a = $$(Fl(i.options), r);
    t = new A$(e, a), s.ref?.(t), t.render();
  };
  return wr(() => {
    n();
  }), Jt(ms(() => i.series, (r) => {
    t.updateSeries(r);
  }, {
    defer: !0
  })), Jt(ms(() => i.options, (r) => {
    t.updateOptions(r);
  }, {
    defer: !0
  })), Jt(ms(() => [i.type, i.height, i.width], () => {
    t.destroy(), n();
  }, {
    defer: !0
  })), ii(() => {
    t.destroy();
  }), (() => {
    var r = R$(), a = e;
    return typeof a == "function" ? wi(a, r) : e = r, r;
  })();
}, jh = E$;
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 3.0.0
*/
const ov = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), tc = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), mo = Object.freeze({
  ...ov,
  ...tc
}), Md = Object.freeze({
  ...mo,
  body: "",
  hidden: !1
}), X$ = Object.freeze({
  width: null,
  height: null
}), lv = Object.freeze({
  // Dimensions
  ...X$,
  // Transformations
  ...tc
});
function M$(s, e = 0) {
  const t = s.replace(/^-?[0-9.]*/, "");
  function i(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (t === "") {
    const n = parseInt(s);
    return isNaN(n) ? 0 : i(n);
  } else if (t !== s) {
    let n = 0;
    switch (t) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(s.slice(0, s.length - t.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? i(r) : 0);
    }
  }
  return e;
}
const _$ = /[\s,]+/;
function L$(s, e) {
  e.split(_$).forEach((t) => {
    switch (t.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
const cv = {
  ...lv,
  preserveAspectRatio: ""
};
function Bm(s) {
  const e = {
    ...cv
  }, t = (i, n) => s.getAttribute(i) || n;
  return e.width = t("width", null), e.height = t("height", null), e.rotate = M$(t("rotate", "")), L$(e, t("flip", "")), e.preserveAspectRatio = t("preserveAspectRatio", t("preserveaspectratio", "")), e;
}
function z$(s, e) {
  for (const t in cv)
    if (s[t] !== e[t])
      return !0;
  return !1;
}
const hv = /^[a-z0-9]+(-[a-z0-9]+)*$/, Oo = (s, e, t, i = "") => {
  const n = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    i = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const o = n.pop(), l = n.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : i,
      prefix: l,
      name: o
    };
    return e && !vl(c) ? null : c;
  }
  const r = n[0], a = r.split("-");
  if (a.length > 1) {
    const o = {
      provider: i,
      prefix: a.shift(),
      name: a.join("-")
    };
    return e && !vl(o) ? null : o;
  }
  if (t && i === "") {
    const o = {
      provider: i,
      prefix: "",
      name: r
    };
    return e && !vl(o, t) ? null : o;
  }
  return null;
}, vl = (s, e) => s ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((e && s.prefix === "" || s.prefix) && s.name) : !1;
function I$(s, e) {
  const t = {};
  !s.hFlip != !e.hFlip && (t.hFlip = !0), !s.vFlip != !e.vFlip && (t.vFlip = !0);
  const i = ((s.rotate || 0) + (e.rotate || 0)) % 4;
  return i && (t.rotate = i), t;
}
function Wm(s, e) {
  const t = I$(s, e);
  for (const i in Md)
    i in tc ? i in s && !(i in t) && (t[i] = tc[i]) : i in e ? t[i] = e[i] : i in s && (t[i] = s[i]);
  return t;
}
function q$(s, e) {
  const t = s.icons, i = s.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(a) {
    if (t[a])
      return n[a] = [];
    if (!(a in n)) {
      n[a] = null;
      const o = i[a] && i[a].parent, l = o && r(o);
      l && (n[a] = [o].concat(l));
    }
    return n[a];
  }
  return Object.keys(t).concat(Object.keys(i)).forEach(r), n;
}
function D$(s, e, t) {
  const i = s.icons, n = s.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function a(o) {
    r = Wm(
      i[o] || n[o],
      r
    );
  }
  return a(e), t.forEach(a), Wm(s, r);
}
function uv(s, e) {
  const t = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return t;
  s.not_found instanceof Array && s.not_found.forEach((n) => {
    e(n, null), t.push(n);
  });
  const i = q$(s);
  for (const n in i) {
    const r = i[n];
    r && (e(n, D$(s, n, r)), t.push(n));
  }
  return t;
}
const B$ = {
  provider: "",
  aliases: {},
  not_found: {},
  ...ov
};
function Hh(s, e) {
  for (const t in e)
    if (t in s && typeof s[t] != typeof e[t])
      return !1;
  return !0;
}
function dv(s) {
  if (typeof s != "object" || s === null)
    return null;
  const e = s;
  if (typeof e.prefix != "string" || !s.icons || typeof s.icons != "object" || !Hh(s, B$))
    return null;
  const t = e.icons;
  for (const n in t) {
    const r = t[n];
    if (
      // Name cannot be empty
      !n || // Must have body
      typeof r.body != "string" || // Check other props
      !Hh(
        r,
        Md
      )
    )
      return null;
  }
  const i = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in i) {
    const r = i[n], a = r.parent;
    if (
      // Name cannot be empty
      !n || // Parent must be set and point to existing icon
      typeof a != "string" || !t[a] && !i[a] || // Check other props
      !Hh(
        r,
        Md
      )
    )
      return null;
  }
  return e;
}
const ic = /* @__PURE__ */ Object.create(null);
function W$(s, e) {
  return {
    provider: s,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function ys(s, e) {
  const t = ic[s] || (ic[s] = /* @__PURE__ */ Object.create(null));
  return t[e] || (t[e] = W$(s, e));
}
function fv(s, e) {
  return dv(e) ? uv(e, (t, i) => {
    i ? s.icons[t] = i : s.missing.add(t);
  }) : [];
}
function Y$(s, e, t) {
  try {
    if (typeof t.body == "string")
      return s.icons[e] = { ...t }, !0;
  } catch {
  }
  return !1;
}
function Z$(s, e) {
  let t = [];
  return (typeof s == "string" ? [s] : Object.keys(ic)).forEach((n) => {
    (typeof n == "string" && typeof e == "string" ? [e] : Object.keys(ic[n] || {})).forEach((a) => {
      const o = ys(n, a);
      t = t.concat(
        Object.keys(o.icons).map(
          (l) => (n !== "" ? "@" + n + ":" : "") + a + ":" + l
        )
      );
    });
  }), t;
}
let $a = !1;
function pv(s) {
  return typeof s == "boolean" && ($a = s), $a;
}
function Ra(s) {
  const e = typeof s == "string" ? Oo(s, !0, $a) : s;
  if (e) {
    const t = ys(e.provider, e.prefix), i = e.name;
    return t.icons[i] || (t.missing.has(i) ? null : void 0);
  }
}
function gv(s, e) {
  const t = Oo(s, !0, $a);
  if (!t)
    return !1;
  const i = ys(t.provider, t.prefix);
  return e ? Y$(i, t.name, e) : (i.missing.add(t.name), !0);
}
function Ym(s, e) {
  if (typeof s != "object")
    return !1;
  if (typeof e != "string" && (e = s.provider || ""), $a && !e && !s.prefix) {
    let n = !1;
    return dv(s) && (s.prefix = "", uv(s, (r, a) => {
      gv(r, a) && (n = !0);
    })), n;
  }
  const t = s.prefix;
  if (!vl({
    prefix: t,
    name: "a"
  }))
    return !1;
  const i = ys(e, t);
  return !!fv(i, s);
}
function N$(s) {
  return !!Ra(s);
}
function V$(s) {
  const e = Ra(s);
  return e && {
    ...mo,
    ...e
  };
}
function F$(s) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, t = /* @__PURE__ */ Object.create(null);
  s.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let i = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((n) => {
    if (i.name === n.name && i.prefix === n.prefix && i.provider === n.provider)
      return;
    i = n;
    const r = n.provider, a = n.prefix, o = n.name, l = t[r] || (t[r] = /* @__PURE__ */ Object.create(null)), c = l[a] || (l[a] = ys(r, a));
    let h;
    o in c.icons ? h = e.loaded : a === "" || c.missing.has(o) ? h = e.missing : h = e.pending;
    const u = {
      provider: r,
      prefix: a,
      name: o
    };
    h.push(u);
  }), e;
}
function mv(s, e) {
  s.forEach((t) => {
    const i = t.loaderCallbacks;
    i && (t.loaderCallbacks = i.filter((n) => n.id !== e));
  });
}
function j$(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const e = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let t = !1;
    const i = s.provider, n = s.prefix;
    e.forEach((r) => {
      const a = r.icons, o = a.pending.length;
      a.pending = a.pending.filter((l) => {
        if (l.prefix !== n)
          return !0;
        const c = l.name;
        if (s.icons[c])
          a.loaded.push({
            provider: i,
            prefix: n,
            name: c
          });
        else if (s.missing.has(c))
          a.missing.push({
            provider: i,
            prefix: n,
            name: c
          });
        else
          return t = !0, !0;
        return !1;
      }), a.pending.length !== o && (t || mv([s], r.id), r.callback(
        a.loaded.slice(0),
        a.missing.slice(0),
        a.pending.slice(0),
        r.abort
      ));
    });
  }));
}
let H$ = 0;
function U$(s, e, t) {
  const i = H$++, n = mv.bind(null, t, i);
  if (!e.pending.length)
    return n;
  const r = {
    id: i,
    icons: e,
    callback: s,
    abort: n
  };
  return t.forEach((a) => {
    (a.loaderCallbacks || (a.loaderCallbacks = [])).push(r);
  }), n;
}
const _d = /* @__PURE__ */ Object.create(null);
function Zm(s, e) {
  _d[s] = e;
}
function Ld(s) {
  return _d[s] || _d[""];
}
function G$(s, e = !0, t = !1) {
  const i = [];
  return s.forEach((n) => {
    const r = typeof n == "string" ? Oo(n, e, t) : n;
    r && i.push(r);
  }), i;
}
var K$ = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function J$(s, e, t, i) {
  const n = s.resources.length, r = s.random ? Math.floor(Math.random() * n) : s.index;
  let a;
  if (s.random) {
    let w = s.resources.slice(0);
    for (a = []; w.length > 1; ) {
      const S = Math.floor(Math.random() * w.length);
      a.push(w[S]), w = w.slice(0, S).concat(w.slice(S + 1));
    }
    a = a.concat(w);
  } else
    a = s.resources.slice(r).concat(s.resources.slice(0, r));
  const o = Date.now();
  let l = "pending", c = 0, h, u = null, d = [], f = [];
  typeof i == "function" && f.push(i);
  function p() {
    u && (clearTimeout(u), u = null);
  }
  function g() {
    l === "pending" && (l = "aborted"), p(), d.forEach((w) => {
      w.status === "pending" && (w.status = "aborted");
    }), d = [];
  }
  function m(w, S) {
    S && (f = []), typeof w == "function" && f.push(w);
  }
  function O() {
    return {
      startTime: o,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: d.length,
      subscribe: m,
      abort: g
    };
  }
  function x() {
    l = "failed", f.forEach((w) => {
      w(void 0, h);
    });
  }
  function b() {
    d.forEach((w) => {
      w.status === "pending" && (w.status = "aborted");
    }), d = [];
  }
  function v(w, S, k) {
    const A = S !== "success";
    switch (d = d.filter((T) => T !== w), l) {
      case "pending":
        break;
      case "failed":
        if (A || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (S === "abort") {
      h = k, x();
      return;
    }
    if (A) {
      h = k, d.length || (a.length ? y() : x());
      return;
    }
    if (p(), b(), !s.random) {
      const T = s.resources.indexOf(w.resource);
      T !== -1 && T !== s.index && (s.index = T);
    }
    l = "completed", f.forEach((T) => {
      T(k);
    });
  }
  function y() {
    if (l !== "pending")
      return;
    p();
    const w = a.shift();
    if (w === void 0) {
      if (d.length) {
        u = setTimeout(() => {
          p(), l === "pending" && (b(), x());
        }, s.timeout);
        return;
      }
      x();
      return;
    }
    const S = {
      status: "pending",
      resource: w,
      callback: (k, A) => {
        v(S, k, A);
      }
    };
    d.push(S), c++, u = setTimeout(y, s.rotate), t(w, e, S.callback);
  }
  return setTimeout(y), O;
}
function Ov(s) {
  const e = {
    ...K$,
    ...s
  };
  let t = [];
  function i() {
    t = t.filter((o) => o().status === "pending");
  }
  function n(o, l, c) {
    const h = J$(
      e,
      o,
      l,
      (u, d) => {
        i(), c && c(u, d);
      }
    );
    return t.push(h), h;
  }
  function r(o) {
    return t.find((l) => o(l)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (o) => {
      e.index = o;
    },
    getIndex: () => e.index,
    cleanup: i
  };
}
function zp(s) {
  let e;
  if (typeof s.resources == "string")
    e = [s.resources];
  else if (e = s.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const Hc = /* @__PURE__ */ Object.create(null), Br = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], wl = [];
for (; Br.length > 0; )
  Br.length === 1 || Math.random() > 0.5 ? wl.push(Br.shift()) : wl.push(Br.pop());
Hc[""] = zp({
  resources: ["https://api.iconify.design"].concat(wl)
});
function Nm(s, e) {
  const t = zp(e);
  return t === null ? !1 : (Hc[s] = t, !0);
}
function Uc(s) {
  return Hc[s];
}
function e2() {
  return Object.keys(Hc);
}
function Vm() {
}
const Uh = /* @__PURE__ */ Object.create(null);
function t2(s) {
  if (!Uh[s]) {
    const e = Uc(s);
    if (!e)
      return;
    const t = Ov(e), i = {
      config: e,
      redundancy: t
    };
    Uh[s] = i;
  }
  return Uh[s];
}
function xv(s, e, t) {
  let i, n;
  if (typeof s == "string") {
    const r = Ld(s);
    if (!r)
      return t(void 0, 424), Vm;
    n = r.send;
    const a = t2(s);
    a && (i = a.redundancy);
  } else {
    const r = zp(s);
    if (r) {
      i = Ov(r);
      const a = s.resources ? s.resources[0] : "", o = Ld(a);
      o && (n = o.send);
    }
  }
  return !i || !n ? (t(void 0, 424), Vm) : i.query(e, n, t)().abort;
}
function Fm() {
}
function i2(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, j$(s);
  }));
}
function s2(s) {
  const e = [], t = [];
  return s.forEach((i) => {
    (i.match(hv) ? e : t).push(i);
  }), {
    valid: e,
    invalid: t
  };
}
function Wr(s, e, t) {
  function i() {
    const n = s.pendingIcons;
    e.forEach((r) => {
      n && n.delete(r), s.icons[r] || s.missing.add(r);
    });
  }
  if (t && typeof t == "object")
    try {
      if (!fv(s, t).length) {
        i();
        return;
      }
    } catch (n) {
      console.error(n);
    }
  i(), i2(s);
}
function jm(s, e) {
  s instanceof Promise ? s.then((t) => {
    e(t);
  }).catch(() => {
    e(null);
  }) : e(s);
}
function n2(s, e) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(e).sort() : s.iconsToLoad = e, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: t, prefix: i } = s, n = s.iconsToLoad;
    if (delete s.iconsToLoad, !n || !n.length)
      return;
    const r = s.loadIcon;
    if (s.loadIcons && (n.length > 1 || !r)) {
      jm(
        s.loadIcons(n, i, t),
        (h) => {
          Wr(s, n, h);
        }
      );
      return;
    }
    if (r) {
      n.forEach((h) => {
        const u = r(h, i, t);
        jm(u, (d) => {
          const f = d ? {
            prefix: i,
            icons: {
              [h]: d
            }
          } : null;
          Wr(s, [h], f);
        });
      });
      return;
    }
    const { valid: a, invalid: o } = s2(n);
    if (o.length && Wr(s, o, null), !a.length)
      return;
    const l = i.match(hv) ? Ld(t) : null;
    if (!l) {
      Wr(s, a, null);
      return;
    }
    l.prepare(t, i, a).forEach((h) => {
      xv(t, h, (u) => {
        Wr(s, h.icons, u);
      });
    });
  }));
}
const Ip = (s, e) => {
  const t = G$(s, !0, pv()), i = F$(t);
  if (!i.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        i.loaded,
        i.missing,
        i.pending,
        Fm
      );
    }), () => {
      l = !1;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let a, o;
  return i.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === o && c === a)
      return;
    a = c, o = h, r.push(ys(c, h));
    const u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
    u[h] || (u[h] = []);
  }), i.pending.forEach((l) => {
    const { provider: c, prefix: h, name: u } = l, d = ys(c, h), f = d.pendingIcons || (d.pendingIcons = /* @__PURE__ */ new Set());
    f.has(u) || (f.add(u), n[c][h].push(u));
  }), r.forEach((l) => {
    const c = n[l.provider][l.prefix];
    c.length && n2(l, c);
  }), e ? U$(e, i, r) : Fm;
}, r2 = (s) => new Promise((e, t) => {
  const i = typeof s == "string" ? Oo(s, !0) : s;
  if (!i) {
    t(s);
    return;
  }
  Ip([i || s], (n) => {
    if (n.length && i) {
      const r = Ra(i);
      if (r) {
        e({
          ...mo,
          ...r
        });
        return;
      }
    }
    t(s);
  });
});
function Hm(s) {
  try {
    const e = typeof s == "string" ? JSON.parse(s) : s;
    if (typeof e.body == "string")
      return {
        ...e
      };
  } catch {
  }
}
function a2(s, e) {
  if (typeof s == "object")
    return {
      data: Hm(s),
      value: s
    };
  if (typeof s != "string")
    return {
      value: s
    };
  if (s.includes("{")) {
    const r = Hm(s);
    if (r)
      return {
        data: r,
        value: s
      };
  }
  const t = Oo(s, !0, !0);
  if (!t)
    return {
      value: s
    };
  const i = Ra(t);
  if (i !== void 0 || !t.prefix)
    return {
      value: s,
      name: t,
      data: i
      // could be 'null' -> icon is missing
    };
  const n = Ip([t], () => e(s, t, Ra(t)));
  return {
    value: s,
    name: t,
    loading: n
  };
}
let bv = !1;
try {
  bv = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function o2(s, e) {
  switch (e) {
    // Force mode
    case "svg":
    case "bg":
    case "mask":
      return e;
  }
  return e !== "style" && (bv || s.indexOf("<a") === -1) ? "svg" : s.indexOf("currentColor") === -1 ? "bg" : "mask";
}
const l2 = /(-?[0-9.]*[0-9]+[0-9.]*)/g, c2 = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function zd(s, e, t) {
  if (e === 1)
    return s;
  if (t = t || 100, typeof s == "number")
    return Math.ceil(s * e * t) / t;
  if (typeof s != "string")
    return s;
  const i = s.split(l2);
  if (i === null || !i.length)
    return s;
  const n = [];
  let r = i.shift(), a = c2.test(r);
  for (; ; ) {
    if (a) {
      const o = parseFloat(r);
      isNaN(o) ? n.push(r) : n.push(Math.ceil(o * e * t) / t);
    } else
      n.push(r);
    if (r = i.shift(), r === void 0)
      return n.join("");
    a = !a;
  }
}
function h2(s, e = "defs") {
  let t = "";
  const i = s.indexOf("<" + e);
  for (; i >= 0; ) {
    const n = s.indexOf(">", i), r = s.indexOf("</" + e);
    if (n === -1 || r === -1)
      break;
    const a = s.indexOf(">", r);
    if (a === -1)
      break;
    t += s.slice(n + 1, r).trim(), s = s.slice(0, i).trim() + s.slice(a + 1);
  }
  return {
    defs: t,
    content: s
  };
}
function u2(s, e) {
  return s ? "<defs>" + s + "</defs>" + e : e;
}
function d2(s, e, t) {
  const i = h2(s);
  return u2(i.defs, e + i.content + t);
}
const f2 = (s) => s === "unset" || s === "undefined" || s === "none";
function yv(s, e) {
  const t = {
    ...mo,
    ...s
  }, i = {
    ...lv,
    ...e
  }, n = {
    left: t.left,
    top: t.top,
    width: t.width,
    height: t.height
  };
  let r = t.body;
  [t, i].forEach((g) => {
    const m = [], O = g.hFlip, x = g.vFlip;
    let b = g.rotate;
    O ? x ? b += 2 : (m.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), m.push("scale(-1 1)"), n.top = n.left = 0) : x && (m.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), m.push("scale(1 -1)"), n.top = n.left = 0);
    let v;
    switch (b < 0 && (b -= Math.floor(b / 4) * 4), b = b % 4, b) {
      case 1:
        v = n.height / 2 + n.top, m.unshift(
          "rotate(90 " + v.toString() + " " + v.toString() + ")"
        );
        break;
      case 2:
        m.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        v = n.width / 2 + n.left, m.unshift(
          "rotate(-90 " + v.toString() + " " + v.toString() + ")"
        );
        break;
    }
    b % 2 === 1 && (n.left !== n.top && (v = n.left, n.left = n.top, n.top = v), n.width !== n.height && (v = n.width, n.width = n.height, n.height = v)), m.length && (r = d2(
      r,
      '<g transform="' + m.join(" ") + '">',
      "</g>"
    ));
  });
  const a = i.width, o = i.height, l = n.width, c = n.height;
  let h, u;
  a === null ? (u = o === null ? "1em" : o === "auto" ? c : o, h = zd(u, l / c)) : (h = a === "auto" ? l : a, u = o === null ? zd(h, c / l) : o === "auto" ? c : o);
  const d = {}, f = (g, m) => {
    f2(m) || (d[g] = m.toString());
  };
  f("width", h), f("height", u);
  const p = [n.left, n.top, l, c];
  return d.viewBox = p.join(" "), {
    attributes: d,
    viewBox: p,
    body: r
  };
}
function qp(s, e) {
  let t = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const i in e)
    t += " " + i + '="' + e[i] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + t + ">" + s + "</svg>";
}
function p2(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function g2(s) {
  return "data:image/svg+xml," + p2(s);
}
function vv(s) {
  return 'url("' + g2(s) + '")';
}
const m2 = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let sc = m2();
function O2(s) {
  sc = s;
}
function x2() {
  return sc;
}
function b2(s, e) {
  const t = Uc(s);
  if (!t)
    return 0;
  let i;
  if (!t.maxURL)
    i = 0;
  else {
    let n = 0;
    t.resources.forEach((a) => {
      n = Math.max(n, a.length);
    });
    const r = e + ".json?icons=";
    i = t.maxURL - n - t.path.length - r.length;
  }
  return i;
}
function y2(s) {
  return s === 404;
}
const v2 = (s, e, t) => {
  const i = [], n = b2(s, e), r = "icons";
  let a = {
    type: r,
    provider: s,
    prefix: e,
    icons: []
  }, o = 0;
  return t.forEach((l, c) => {
    o += l.length + 1, o >= n && c > 0 && (i.push(a), a = {
      type: r,
      provider: s,
      prefix: e,
      icons: []
    }, o = l.length), a.icons.push(l);
  }), i.push(a), i;
};
function w2(s) {
  if (typeof s == "string") {
    const e = Uc(s);
    if (e)
      return e.path;
  }
  return "/";
}
const S2 = (s, e, t) => {
  if (!sc) {
    t("abort", 424);
    return;
  }
  let i = w2(e.provider);
  switch (e.type) {
    case "icons": {
      const r = e.prefix, o = e.icons.join(","), l = new URLSearchParams({
        icons: o
      });
      i += r + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const r = e.uri;
      i += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      t("abort", 400);
      return;
  }
  let n = 503;
  sc(s + i).then((r) => {
    const a = r.status;
    if (a !== 200) {
      setTimeout(() => {
        t(y2(a) ? "abort" : "next", a);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? t("abort", r) : t("next", n);
      });
      return;
    }
    setTimeout(() => {
      t("success", r);
    });
  }).catch(() => {
    t("next", n);
  });
}, k2 = {
  prepare: v2,
  send: S2
};
function P2(s, e, t) {
  ys(t || "", e).loadIcons = s;
}
function Q2(s, e, t) {
  ys(t || "", e).loadIcon = s;
}
const Gh = "data-style";
let wv = "";
function C2(s) {
  wv = s;
}
function Um(s, e) {
  let t = Array.from(s.childNodes).find((i) => i.hasAttribute && i.hasAttribute(Gh));
  t || (t = document.createElement("style"), t.setAttribute(Gh, Gh), s.appendChild(t)), t.textContent = ":host{display:inline-block;vertical-align:" + (e ? "-0.125em" : "0") + "}span,svg{display:block;margin:auto}" + wv;
}
function Sv() {
  Zm("", k2), pv(!0);
  let s;
  try {
    s = window;
  } catch {
  }
  if (s) {
    if (s.IconifyPreload !== void 0) {
      const t = s.IconifyPreload, i = "Invalid IconifyPreload syntax.";
      typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((n) => {
        try {
          // Check if item is an object and not null/array
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !Ym(n)) && console.error(i);
        } catch {
          console.error(i);
        }
      });
    }
    if (s.IconifyProviders !== void 0) {
      const t = s.IconifyProviders;
      if (typeof t == "object" && t !== null)
        for (const i in t) {
          const n = "IconifyProviders[" + i + "] is invalid.";
          try {
            const r = t[i];
            if (typeof r != "object" || !r || r.resources === void 0)
              continue;
            Nm(i, r) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    iconLoaded: N$,
    getIcon: V$,
    listIcons: Z$,
    addIcon: gv,
    addCollection: Ym,
    calculateSize: zd,
    buildIcon: yv,
    iconToHTML: qp,
    svgToURL: vv,
    loadIcons: Ip,
    loadIcon: r2,
    addAPIProvider: Nm,
    setCustomIconLoader: Q2,
    setCustomIconsLoader: P2,
    appendCustomStyle: C2,
    _api: {
      getAPIConfig: Uc,
      setAPIModule: Zm,
      sendAPIQuery: xv,
      setFetch: O2,
      getFetch: x2,
      listAPIProviders: e2
    }
  };
}
const Id = {
  "background-color": "currentColor"
}, kv = {
  "background-color": "transparent"
}, Gm = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
}, Km = {
  "-webkit-mask": Id,
  mask: Id,
  background: kv
};
for (const s in Km) {
  const e = Km[s];
  for (const t in Gm)
    e[s + "-" + t] = Gm[t];
}
function Jm(s) {
  return s ? s + (s.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function A2(s, e, t) {
  const i = document.createElement("span");
  let n = s.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = s.attributes, a = qp(n, {
    ...r,
    width: e.width + "",
    height: e.height + ""
  }), o = vv(a), l = i.style, c = {
    "--svg": o,
    width: Jm(r.width),
    height: Jm(r.height),
    ...t ? Id : kv
  };
  for (const h in c)
    l.setProperty(h, c[h]);
  return i;
}
let ua;
function T2() {
  try {
    ua = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    ua = null;
  }
}
function $2(s) {
  return ua === void 0 && T2(), ua ? ua.createHTML(s) : s;
}
function R2(s) {
  const e = document.createElement("span"), t = s.attributes;
  let i = "";
  t.width || (i = "width: inherit;"), t.height || (i += "height: inherit;"), i && (t.style = i);
  const n = qp(s.body, t);
  return e.innerHTML = $2(n), e.firstChild;
}
function qd(s) {
  return Array.from(s.childNodes).find((e) => {
    const t = e.tagName && e.tagName.toUpperCase();
    return t === "SPAN" || t === "SVG";
  });
}
function eO(s, e) {
  const t = e.icon.data, i = e.customisations, n = yv(t, i);
  i.preserveAspectRatio && (n.attributes.preserveAspectRatio = i.preserveAspectRatio);
  const r = e.renderedMode;
  let a;
  switch (r) {
    case "svg":
      a = R2(n);
      break;
    default:
      a = A2(n, {
        ...mo,
        ...t
      }, r === "mask");
  }
  const o = qd(s);
  o ? a.tagName === "SPAN" && o.tagName === a.tagName ? o.setAttribute("style", a.getAttribute("style")) : s.replaceChild(a, o) : s.appendChild(a);
}
function tO(s, e, t) {
  const i = t && (t.rendered ? t : t.lastRender);
  return {
    rendered: !1,
    inline: e,
    icon: s,
    lastRender: i
  };
}
function E2(s = "iconify-icon") {
  let e, t;
  try {
    e = window.customElements, t = window.HTMLElement;
  } catch {
    return;
  }
  if (!e || !t)
    return;
  const i = e.get(s);
  if (i)
    return i;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "noobserver",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends t {
    // Root
    _shadowRoot;
    // Initialised
    _initialised = !1;
    // Icon state
    _state;
    // Attributes check queued
    _checkQueued = !1;
    // Connected
    _connected = !1;
    // Observer
    _observer = null;
    _visible = !0;
    /**
     * Constructor
     */
    constructor() {
      super();
      const o = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), l = this.hasAttribute("inline");
      Um(o, l), this._state = tO({
        value: ""
      }, l), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = !0, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = !1, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(o) {
      switch (o) {
        case "inline": {
          const l = this.hasAttribute("inline"), c = this._state;
          l !== c.inline && (c.inline = l, Um(this._shadowRoot, l));
          break;
        }
        case "noobserver": {
          this.hasAttribute("noobserver") ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const o = this.getAttribute("icon");
      if (o && o.slice(0, 1) === "{")
        try {
          return JSON.parse(o);
        } catch {
        }
      return o;
    }
    set icon(o) {
      typeof o == "object" && (o = JSON.stringify(o)), this.setAttribute("icon", o);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return this.hasAttribute("inline");
    }
    set inline(o) {
      o ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(o) {
      o ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const o = this._state;
      if (o.rendered) {
        const l = this._shadowRoot;
        if (o.renderedMode === "svg")
          try {
            l.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        eO(l, o);
      }
    }
    /**
     * Get status
     */
    get status() {
      const o = this._state;
      return o.rendered ? "rendered" : o.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = !1;
      const o = this._state, l = this.getAttribute("icon");
      if (l !== o.icon.value) {
        this._iconChanged(l);
        return;
      }
      if (!o.rendered || !this._visible)
        return;
      const c = this.getAttribute("mode"), h = Bm(this);
      (o.attrMode !== c || z$(o.customisations, h) || !qd(this._shadowRoot)) && this._renderIcon(o.icon, h, c);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(o) {
      const l = a2(o, (c, h, u) => {
        const d = this._state;
        if (d.rendered || this.getAttribute("icon") !== c)
          return;
        const f = {
          value: c,
          name: h,
          data: u
        };
        f.data ? this._gotIconData(f) : d.icon = f;
      });
      l.data ? this._gotIconData(l) : this._state = tO(l, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const o = qd(this._shadowRoot);
        o && this._shadowRoot.removeChild(o);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(o) {
      this._checkQueued = !1, this._renderIcon(o, Bm(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(o, l, c) {
      const h = o2(o.data.body, c), u = this._state.inline;
      eO(this._shadowRoot, this._state = {
        rendered: !0,
        icon: o,
        inline: u,
        customisations: l,
        attrMode: c,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer && !this.hasAttribute("noobserver"))
        try {
          this._observer = new IntersectionObserver((o) => {
            const l = o.some((c) => c.isIntersecting);
            l !== this._visible && (this._visible = l, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());
    }
  };
  n.forEach((o) => {
    o in r.prototype || Object.defineProperty(r.prototype, o, {
      get: function() {
        return this.getAttribute(o);
      },
      set: function(l) {
        l !== null ? this.setAttribute(o, l) : this.removeAttribute(o);
      }
    });
  });
  const a = Sv();
  for (const o in a)
    r[o] = r.prototype[o] = a[o];
  return e.define(s, r), r;
}
const X2 = E2() || Sv(), { iconLoaded: $Z, getIcon: RZ, listIcons: EZ, addIcon: XZ, addCollection: MZ, calculateSize: _Z, buildIcon: LZ, iconToHTML: zZ, svgToURL: IZ, loadIcons: qZ, loadIcon: DZ, setCustomIconLoader: BZ, setCustomIconsLoader: WZ, addAPIProvider: YZ, _api: ZZ } = X2;
var M2 = /* @__PURE__ */ K("<iconify-icon>", !0, !1, !1);
function Pi(s) {
  let {
    icon: e,
    mode: t,
    inline: i,
    rotate: n,
    flip: r,
    width: a,
    height: o,
    preserveAspectRatio: l,
    noobserver: c
  } = s;
  return typeof e == "object" && (e = JSON.stringify(e)), // @ts-ignore
  (() => {
    var h = M2();
    return Fe(h, "icon", e), Fe(h, "mode", t), Fe(h, "inline", i), Fe(h, "rotate", n), Fe(h, "flip", r), Fe(h, "width", a), Fe(h, "height", o), Fe(h, "preserveaspectratio", l), Fe(h, "noobserver", c), Wc(h, s, !1, !1), h._$owner = qc(), h;
  })();
}
var _2 = /* @__PURE__ */ K('<div class="flex h-screen flex-col bg-white dark:bg-neutral-900 dark:text-white"><div class="flex-1 overflow-auto scroll-smooth px-4 py-4 space-y-4 mt-2 mb-6"><h1 class="leading-0 uppercase tracking-widest text-2xl mt-6 mb-10 px-4"><b>Dash</b>board</h1><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 px-4 mt-4"></div><div class="grid grid-cols-1 gap-4 px-4 mt-4"><div class="bg-neutral-100 dark:bg-neutral-800 p-6 rounded-2xl shadow-md"><h2 class="font-semibold text-lg mb-4">Bar Activity Chart</h2></div></div><div class="grid grid-cols-1 lg:grid-cols-2 gap-4 px-4 mt-4"><div class="bg-neutral-100 dark:bg-neutral-800 p-6 rounded-2xl shadow-md"><h2 class="font-semibold text-lg mb-4">Weekly Active Users</h2></div><div class="bg-neutral-100 dark:bg-neutral-800 p-6 rounded-2xl shadow-md"><h2 class="font-semibold text-lg mb-4">Quarterly Sales</h2></div></div><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 px-4 mt-4"></div><div class="grid grid-cols-1 px-4 mt-4"><h2 class="leading-0 uppercase tracking-widest text-xl mt-6 mb-10 "><b>App</b>lications</h2><div class="flex space-x-6"><button class="flex flex-col items-center justify-center bg-neutral-100 dark:bg-neutral-800 p-4 rounded-2xl shadow-md w-32 hover:bg-neutral-700 hover:text-white transition"aria-label="Open Editor">Editor</button><button class="flex flex-col items-center justify-center bg-neutral-100 dark:bg-neutral-800 p-4 rounded-2xl shadow-md w-32 hover:bg-neutral-700 hover:text-white transition"aria-label="Open Text To Speech">TTS</button><button class="flex flex-col items-center justify-center bg-neutral-100 dark:bg-neutral-800 p-4 rounded-2xl shadow-md w-32 hover:bg-neutral-700 hover:text-white transition"aria-label="Open Terminal">Terminal'), L2 = /* @__PURE__ */ K('<div class="rounded-2xl bg-neutral-100 dark:bg-neutral-800 p-4 shadow-md flex items-center space-x-4"><div class="flex flex-col"><span class="text-lg text-neutral-500"></span><span class="text-4xl font-semibold">'), z2 = /* @__PURE__ */ K('<div class="rounded-xl border dark:border-neutral-700 p-4 mt-2 shadow-sm bg-neutral-100 dark:bg-neutral-800"><div class="flex justify-between items-center mb-2"><h2 class="font-semibold text-xl"></h2><span class="text-xs text-neutral-500"></span></div><p class="text-neutral-700 dark:text-neutral-300">');
function I2() {
  lo(), Mi(), Pr(), ss();
  const [s, e] = re([{
    label: "Users Online",
    value: 23,
    icon: "mdi:account"
  }, {
    label: "Server Load",
    value: "47%",
    icon: "mdi:server"
  }, {
    label: "Active Jobs",
    value: 12,
    icon: "tabler:briefcase"
  }, {
    label: "Errors Today",
    value: 0,
    icon: "ic:baseline-error-outline"
  }]), [t, i] = re([{
    id: 1,
    title: "System Status",
    content: "All systems operational.",
    timestamp: "2025-05-30 09:00"
  }, {
    id: 2,
    title: "User Activity",
    content: "15 users logged in within the last hour.",
    timestamp: "2025-05-30 08:45"
  }, {
    id: 3,
    title: "Error Logs",
    content: "0 critical errors reported today.",
    timestamp: "2025-05-30 08:30"
  }]), n = {
    chart: {
      type: "line",
      toolbar: {
        show: !1
      },
      zoom: {
        enabled: !1
      },
      background: "#171717"
      // bg-neutral-900 hex value
    },
    xaxis: {
      categories: ["Mon", "Tue", "Wed", "Thu", "Fri"],
      labels: {
        style: {
          colors: "#9CA3AF"
        }
      }
      // Tailwind text-neutral-400 for axis labels
    },
    yaxis: {
      labels: {
        style: {
          colors: "#9CA3AF"
        }
      }
    },
    stroke: {
      curve: "smooth",
      colors: ["#3B82F6"]
      // Tailwind blue-500 for line color
    },
    theme: {
      mode: "dark"
    },
    grid: {
      borderColor: "#374151"
      // Tailwind neutral-700 for grid lines
    }
  }, r = [{
    name: "Active Users",
    data: [10, 41, 35, 51, 49]
  }], a = {
    chart: {
      id: "line-chart",
      toolbar: {
        show: !1
      },
      background: "#171717"
      // bg-neutral-900 hex value
    },
    xaxis: {
      categories: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
    },
    stroke: {
      curve: "smooth",
      width: 3
    },
    theme: {
      mode: "dark"
    },
    colors: ["#4F46E5"],
    // Indigo-600
    tooltip: {
      enabled: !0
    }
  }, o = [{
    name: "Active Users",
    data: [30, 40, 35, 50, 49, 60, 70]
  }], l = {
    chart: {
      id: "bar-chart",
      toolbar: {
        show: !1
      }
    },
    xaxis: {
      categories: ["Q1", "Q2", "Q3", "Q4"]
    },
    colors: ["#22C55E"],
    // Green-500
    plotOptions: {
      bar: {
        borderRadius: 6,
        columnWidth: "45%"
      }
    },
    tooltip: {
      enabled: !0
    }
  }, c = [{
    name: "Sales",
    data: [15e3, 2e4, 18e3, 22e3]
  }];
  return (() => {
    var h = _2(), u = h.firstChild, d = u.firstChild, f = d.nextSibling, p = f.nextSibling, g = p.firstChild;
    g.firstChild;
    var m = p.nextSibling, O = m.firstChild;
    O.firstChild;
    var x = O.nextSibling;
    x.firstChild;
    var b = m.nextSibling, v = b.nextSibling, y = v.firstChild, w = y.nextSibling, S = w.firstChild, k = S.firstChild, A = S.nextSibling, T = A.firstChild, C = A.nextSibling, P = C.firstChild;
    return W(h, B(Mn, {}), u), W(f, B(Gi, {
      get each() {
        return s();
      },
      children: ($) => (() => {
        var R = L2(), X = R.firstChild, M = X.firstChild, z = M.nextSibling;
        return W(R, B(Pi, {
          get icon() {
            return $.icon;
          },
          width: "50",
          height: "50",
          class: "text-yellow-500 shrink-0"
        }), X), W(M, () => $.label), W(z, () => $.value), R;
      })()
    })), W(g, B(jh, {
      options: n,
      series: r,
      type: "bar",
      height: 250,
      class: "rounded-2xl"
    }), null), W(O, B(jh, {
      options: a,
      series: o,
      type: "line",
      height: 250,
      class: "rounded-2xl"
    }), null), W(x, B(jh, {
      options: l,
      series: c,
      type: "bar",
      height: 250,
      class: "rounded-2xl"
    }), null), W(b, B(Gi, {
      get each() {
        return t();
      },
      children: ($) => (() => {
        var R = z2(), X = R.firstChild, M = X.firstChild, z = M.nextSibling, I = X.nextSibling;
        return W(M, () => $.title), W(z, () => $.timestamp), W(I, () => $.content), R;
      })()
    })), S.$$click = () => window.location.href = "/editor", W(S, B(Pi, {
      icon: "mdi:xml",
      width: "50",
      height: "50",
      class: "text-yellow-500 shrink-0"
    }), k), A.$$click = () => window.location.href = "/tts", W(A, B(Pi, {
      icon: "mdi:microphone-message",
      width: "50",
      height: "50",
      class: "text-yellow-500 shrink-0"
    }), T), C.$$click = () => window.location.href = "/terminal", W(C, B(Pi, {
      icon: "mdi:console",
      width: "50",
      height: "50",
      class: "text-yellow-500 shrink-0"
    }), P), h;
  })();
}
_t(["click"]);
var q2 = /* @__PURE__ */ K('<div class="flex h-screen flex-col bg-white dark:bg-neutral-900 dark:text-white"><h1 class="leading-0 uppercase tracking-widest text-lg mt-6 px-4"><b>Manage</b> Settings</h1><div class="flex-1 overflow-auto scroll-smooth px-4 py-2 text-sm">');
function D2() {
  return lo(), Mi(), Pr(), ss(), Jt(() => {
  }), (() => {
    var s = q2(), e = s.firstChild, t = e.nextSibling;
    return W(s, B(Mn, {}), e), t.style.setProperty("scroll-behavior", "smooth"), s;
  })();
}
var B2 = /* @__PURE__ */ K('<div class="flex h-screen flex-col bg-white dark:bg-neutral-900 dark:text-white"><h1 class="leading-0 uppercase tracking-widest text-lg mt-6 px-4"><b>Manage</b> Profile</h1><div class="flex-1 overflow-auto scroll-smooth px-4 py-2 text-sm">');
function W2() {
  return lo(), Mi(), Pr(), ss(), (() => {
    var s = B2(), e = s.firstChild, t = e.nextSibling;
    return W(s, B(Mn, {}), e), t.style.setProperty("scroll-behavior", "smooth"), s;
  })();
}
var Y2 = /* @__PURE__ */ K('<div class="flex h-screen flex-col bg-white dark:bg-neutral-900 dark:text-white"><main class="flex-1 overflow-auto px-6 py-12 md:px-12 lg:px-24"><section class="max-w-4xl mx-auto text-center"><h1 class="text-4xl sm:text-5xl font-extrabold leading-tight mb-4 ">Welcome to <span class="text-blue-600 dark:text-yellow-800 text-light italic text-7xl">Project</span> <span class=text-light>Board</span></h1><p class="text-lg sm:text-xl text-gray-700 dark:text-gray-300 mb-8">The best solution to manage your projects efficiently and effortlessly.</p><div class="flex justify-center gap-4"></div></section><section class="mt-16 max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></section><section class="mt-20 max-w-3xl mx-auto"><h2 class="text-3xl font-bold text-center mb-8">What Our Users Say</h2><div class="relative bg-gray-100 dark:bg-neutral-800 rounded-lg p-8 shadow-md"><blockquote class="italic text-gray-800 dark:text-gray-200 mb-4">&ldquo;<!>&rdquo;</blockquote><p class="font-semibold text-blue-600 dark:text-blue-400"></p><p class="text-sm text-gray-600 dark:text-gray-400"></p><div class="absolute bottom-2 right-4 flex space-x-2"></div></div></section><section class="mt-20 max-w-5xl mx-auto text-center"><h2 class="text-3xl font-bold mb-8">Choose Your Plan</h2><div class="flex flex-col md:flex-row justify-center gap-8"></div></section></main><footer class="bg-gray-100 dark:bg-neutral-900 py-6 mt-auto"><div class="max-w-6xl mx-auto px-6 flex flex-col md:flex-row justify-between items-center text-gray-600 dark:text-gray-400 text-sm"><p>© 2025 YourAppName. All rights reserved.</p><div class="flex space-x-6 mt-4 md:mt-0">'), Z2 = /* @__PURE__ */ K('<p class="mb-6 text-green-600 dark:text-green-400">Hello, <!>! Glad to have you back.'), N2 = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg class="mx-auto h-12 w-12"fill=none viewBox="0 0 24 24"stroke=currentColor stroke-width=2><path stroke-linecap=round stroke-linejoin=round d="M9 12l2 2 4-4M7 12v6a2 2 0 002 2h6a2 2 0 002-2v-6">'), V2 = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg class="mx-auto h-12 w-12"fill=none viewBox="0 0 24 24"stroke=currentColor stroke-width=2><path stroke-linecap=round stroke-linejoin=round d="M12 8c-1.105 0-2 .895-2 2v4a2 2 0 004 0v-4c0-1.105-.895-2-2-2z"></path><path stroke-linecap=round stroke-linejoin=round d="M12 12v2m0-8v2m0 4v2">'), F2 = /* @__PURE__ */ K('<svg xmlns=http://www.w3.org/2000/svg class="mx-auto h-12 w-12"fill=none viewBox="0 0 24 24"stroke=currentColor stroke-width=2><path stroke-linecap=round stroke-linejoin=round d="M3 10h18M3 6h18M3 14h18M3 18h18">'), j2 = /* @__PURE__ */ K("<button>"), H2 = /* @__PURE__ */ K('<div><h3 class="text-2xl font-semibold mb-2"></h3><p class="text-xl mb-4"></p><ul class="mb-6 text-gray-700 dark:text-gray-300 text-left list-disc list-inside">'), U2 = /* @__PURE__ */ K("<li>"), G2 = /* @__PURE__ */ K('<button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 rounded-md transition">Select '), K2 = /* @__PURE__ */ K('<div class="p-6 border rounded-lg hover:shadow-lg transition cursor-default"><div class="mb-4 text-blue-600 dark:text-blue-400"></div><h3 class="text-xl font-semibold mb-2"></h3><p class="text-gray-600 dark:text-gray-400">');
const Yr = [{
  name: "Alice Johnson",
  title: "Product Manager",
  quote: "YourAppName transformed how our team collaborates and delivered fantastic results!"
}, {
  name: "Mark Lee",
  title: "Software Engineer",
  quote: "The ease of use and customization saved us weeks of development time."
}, {
  name: "Sandra Kim",
  title: "CTO",
  quote: "Reliable and secure, it’s the backbone of our daily operations."
}], iO = [{
  name: "Basic",
  price: "$9/mo",
  features: ["Up to 5 projects", "Basic support", "Community access"]
}, {
  name: "Pro",
  price: "$29/mo",
  features: ["Unlimited projects", "Priority support", "Advanced analytics"]
}, {
  name: "Enterprise",
  price: "Contact us",
  features: ["Custom solutions", "Dedicated support", "Onboarding assistance"]
}];
function J2() {
  const [s, e] = re(null), [t, i] = re(0);
  Jt(() => {
    const a = setInterval(() => {
      i((o) => (o + 1) % Yr.length);
    }, 7e3);
    ii(() => clearInterval(a));
  });
  const [n, r] = re(iO[0].name);
  return (() => {
    var a = Y2(), o = a.firstChild, l = o.firstChild, c = l.firstChild, h = c.nextSibling, u = h.nextSibling, d = l.nextSibling, f = d.nextSibling, p = f.firstChild, g = p.nextSibling, m = g.firstChild, O = m.firstChild, x = O.nextSibling;
    x.nextSibling;
    var b = m.nextSibling, v = b.nextSibling, y = v.nextSibling, w = f.nextSibling, S = w.firstChild, k = S.nextSibling, A = o.nextSibling, T = A.firstChild, C = T.firstChild, P = C.nextSibling;
    return W(a, B(Mn, {}), o), W(l, (() => {
      var $ = Yt(() => !!s());
      return () => $() ? (() => {
        var R = Z2(), X = R.firstChild, M = X.nextSibling;
        return M.nextSibling, W(R, () => s().name, M), R;
      })() : null;
    })(), u), W(u, (() => {
      var $ = Yt(() => !!s());
      return () => $() ? B(zn, {
        href: "/dashboard",
        class: "rounded-md bg-green-600 px-6 py-3 text-white font-semibold hover:bg-green-700 transition",
        children: "Go to Dashboard"
      }) : B(zn, {
        href: "/signup",
        class: "rounded-md bg-blue-600 px-6 py-3 text-white font-semibold hover:bg-blue-700 transition",
        children: "Get Started"
      });
    })(), null), W(u, B(zn, {
      href: "/learn-more",
      class: "rounded-md border border-blue-600 px-6 py-3 text-blue-600 font-semibold hover:bg-blue-50 dark:hover:bg-neutral-800 transition",
      children: "Learn More"
    }), null), W(d, B(Kh, {
      get icon() {
        return N2();
      },
      title: "Easy to Use",
      description: "Intuitive UI that helps you get started quickly without any hassle."
    }), null), W(d, B(Kh, {
      get icon() {
        return V2();
      },
      title: "Secure & Reliable",
      description: "Your data is protected with industry-leading security measures."
    }), null), W(d, B(Kh, {
      get icon() {
        return F2();
      },
      title: "Customizable",
      description: "Tailor the platform to your specific needs with flexible options."
    }), null), W(m, () => Yr[t()].quote, x), W(b, () => Yr[t()].name), W(v, () => Yr[t()].title), W(y, () => Yr.map(($, R) => (() => {
      var X = j2();
      return X.$$click = () => i(R), Fe(X, "aria-label", `Show testimonial ${R + 1}`), Ae(() => Os(X, `w-3 h-3 rounded-full transition-colors ${t() === R ? "bg-blue-600 dark:bg-blue-400" : "bg-gray-400 dark:bg-gray-600"}`)), X;
    })())), W(k, () => iO.map(($) => (() => {
      var R = H2(), X = R.firstChild, M = X.nextSibling, z = M.nextSibling;
      return R.$$click = () => r($.name), W(X, () => $.name), W(M, () => $.price), W(z, () => $.features.map((I) => (() => {
        var Y = U2();
        return W(Y, I), Y;
      })())), W(R, (() => {
        var I = Yt(() => n() === $.name);
        return () => I() && (() => {
          var Y = G2();
          return Y.firstChild, W(Y, () => $.name, null), Y;
        })();
      })(), null), Ae(() => Os(R, `flex-1 border rounded-lg p-6 cursor-pointer transition-shadow ${n() === $.name ? "border-blue-600 shadow-lg dark:border-blue-400" : "border-gray-300 dark:border-neutral-700"}`)), R;
    })())), W(P, B(zn, {
      href: "/privacy",
      class: "hover:text-blue-600 dark:hover:text-blue-400",
      children: "Privacy Policy"
    }), null), W(P, B(zn, {
      href: "/terms",
      class: "hover:text-blue-600 dark:hover:text-blue-400",
      children: "Terms of Service"
    }), null), W(P, B(zn, {
      href: "/contact",
      class: "hover:text-blue-600 dark:hover:text-blue-400",
      children: "Contact"
    }), null), a;
  })();
}
function Kh(s) {
  return (() => {
    var e = K2(), t = e.firstChild, i = t.nextSibling, n = i.nextSibling;
    return W(t, () => s.icon), W(i, () => s.title), W(n, () => s.description), e;
  })();
}
_t(["click"]);
var eR = /* @__PURE__ */ K('<button class="w-full flex items-center gap-2 justify-center p-3 text-white bg-neutral-900 rounded-md hover:bg-neutral-800 mt-4"> Sign in with Google');
const tR = "http://localhost:5000/api/auth/google/callback";
function Pv() {
  const [s, e] = re("");
  return wr(() => {
    e(`${tR}`);
  }), (() => {
    var t = eR(), i = t.firstChild;
    return t.$$click = () => s() && (window.location.href = s()), W(t, B(Pi, {
      icon: "flat-color-icons:google",
      width: "20",
      height: "20"
    }), i), t;
  })();
}
_t(["click"]);
var iR = /* @__PURE__ */ K('<button class="w-full flex gap-2 items-center justify-center p-3 text-white bg-gray-700 rounded-md hover:bg-gray-600 mt-4"> Sign in with Github');
const sR = "http://localhost:5000/api/auth/github/callback";
function Qv() {
  const [s, e] = re("");
  return wr(() => {
    e(`${sR}`);
  }), (() => {
    var t = iR(), i = t.firstChild;
    return t.$$click = () => s() && (window.location.href = s()), W(t, B(Pi, {
      icon: "mdi:github",
      width: "24",
      class: "text-gray-900",
      height: "24"
    }), i), t;
  })();
}
_t(["click"]);
var nR = /* @__PURE__ */ K('<div class="dark:bg-neutral-900 bg-neutral-200 fixed inset-0 flex items-center justify-center"><svg class="m-auto h-12 w-12 animate-spin text-neutral-800 dark:text-neutral-100"xmlns=http://www.w3.org/2000/svg fill=none viewBox="0 0 24 24"><circle class=opacity-25 cx=12 cy=12 r=10 stroke=currentColor stroke-width=4></circle><path class=opacity-75 fill=currentColor d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">');
const Dp = () => nR();
var rR = /* @__PURE__ */ K('<div class="bg-white dark:bg-neutral-900 h-screen w-full"><div class="flex min-h-screen items-center justify-center"><div class="w-full max-w-md rounded-lg bg-neutral-950 p-8 border border-neutral-300 dark:border-neutral-600 shadow-lg"><h2 class="text-center text-2xl font-bold text-white">Welcome Back 👋</h2><form class=space-y-4><div><label class="block text-gray-400">Email</label><input type=email placeholder="Enter email"class="mt-1 w-full rounded-md border border-neutral-300 dark:border-neutral-600 bg-neutral-200 dark:bg-neutral-800 p-3 text-neutral-900 dark:text-neutral-100 placeholder-neutral-400 focus:ring-2 focus:ring-blue-500"></div><div><label class="block text-gray-400">Password</label><input type=password placeholder=•••••••• class="mt-1 w-full rounded-md border border-neutral-300 dark:border-neutral-600 bg-neutral-200 dark:bg-neutral-800 p-3 text-neutral-900 dark:text-neutral-100 placeholder-neutral-400 focus:ring-2 focus:ring-blue-500"></div><button type=submit class="w-full rounded-md bg-blue-600 p-3 text-white hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-400">Sign In'), aR = /* @__PURE__ */ K('<p class="text-center text-sm text-red-400">'), oR = /* @__PURE__ */ K('<div class="dark:bg-solid-darkbg fixed inset-0 flex items-center justify-center">');
const lR = () => {
  const [s, e] = re(""), [t, i] = re(""), [n, r] = re(""), [a, o] = re(!1), l = Mi();
  ss();
  const c = async (h) => {
    h.preventDefault(), r(""), o(!0);
    try {
      const u = await fetch(`${Sn}/auth/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        credentials: "include",
        body: JSON.stringify({
          email: s(),
          password: t()
        })
      });
      if (!u.ok) {
        const f = await u.text();
        throw r(f || u.statusText), new Error(f || u.statusText);
      }
      const d = await u.json();
      if (d)
        localStorage.setItem("token", d.accessToken), location.reload(), l("/dashboard");
      else
        throw new Error("AccessToken not found in response");
    } catch (u) {
      r(u.message || "Login failed");
    } finally {
      o(!1);
    }
  };
  return B(vi, {
    get when() {
      return !a();
    },
    get fallback() {
      return B(Dp, {});
    },
    get children() {
      var h = rR(), u = h.firstChild, d = u.firstChild, f = d.firstChild, p = f.nextSibling, g = p.firstChild, m = g.firstChild, O = m.nextSibling, x = g.nextSibling, b = x.firstChild, v = b.nextSibling;
      return W(d, (() => {
        var y = Yt(() => !!n());
        return () => y() && (() => {
          var w = aR();
          return W(w, n), w;
        })();
      })(), p), p.addEventListener("submit", c), O.$$input = (y) => e(y.currentTarget.value), v.$$input = (y) => i(y.currentTarget.value), W(d, B(Pv, {}), null), W(d, B(Qv, {}), null), Ae(() => O.value = s()), Ae(() => v.value = t()), h;
    }
  });
}, cR = () => (Mi(), localStorage.getItem("user"), ss(), Jt(() => {
}), (() => {
  var s = oR();
  return W(s, B(lR, {})), s;
})());
_t(["input"]);
var hR = /* @__PURE__ */ K('<div class="bg-white dark:bg-neutral-900 h-screen w-full"><div class="flex min-h-screen items-center justify-center"><div class="w-full max-w-md rounded-lg bg-neutral-950 p-8 border border-neutral-300 dark:border-neutral-600 shadow-lg"><h2 class="text-center text-2xl font-bold text-white">Welcome Back 👋</h2><form class=space-y-4><div><label class="block text-gray-400">Email</label><input type=email placeholder="Enter email"class="mt-1 w-full rounded-md border border-neutral-300 dark:border-neutral-600 bg-neutral-200 dark:bg-neutral-800 p-3 text-neutral-900 dark:text-neutral-100 placeholder-neutral-400 focus:ring-2 focus:ring-blue-500"></div><div><label class="block text-gray-400">Password</label><input type=password placeholder=•••••••• class="mt-1 w-full rounded-md border border-neutral-300 dark:border-neutral-600 bg-neutral-200 dark:bg-neutral-800 p-3 text-neutral-900 dark:text-neutral-100 placeholder-neutral-400 focus:ring-2 focus:ring-blue-500"></div><button type=submit class="w-full rounded-md bg-blue-600 p-3 text-white hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-400">Sign In'), uR = /* @__PURE__ */ K('<p class="text-center text-sm text-red-400">'), dR = /* @__PURE__ */ K('<div class="dark:bg-solid-darkbg fixed inset-0 flex items-center justify-center">');
const fR = () => {
  const [s, e] = re(""), [t, i] = re(""), [n, r] = re(""), [a, o] = re(!1), l = Mi();
  ss();
  const c = async (h) => {
    h.preventDefault(), r(""), o(!0);
    try {
      const u = await fetch(`${Sn}/auth/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        credentials: "include",
        body: JSON.stringify({
          email: s(),
          password: t()
        })
      });
      if (!u.ok) {
        const f = await u.text();
        throw r(f || u.statusText), new Error(f || u.statusText);
      }
      const d = await u.json();
      if (d)
        localStorage.setItem("token", d.accessToken), location.reload(), l("/dashboard");
      else
        throw new Error("AccessToken not found in response");
    } catch (u) {
      r(u.message || "Login failed");
    } finally {
      o(!1);
    }
  };
  return B(vi, {
    get when() {
      return !a();
    },
    get fallback() {
      return B(Dp, {});
    },
    get children() {
      var h = hR(), u = h.firstChild, d = u.firstChild, f = d.firstChild, p = f.nextSibling, g = p.firstChild, m = g.firstChild, O = m.nextSibling, x = g.nextSibling, b = x.firstChild, v = b.nextSibling;
      return W(d, (() => {
        var y = Yt(() => !!n());
        return () => y() && (() => {
          var w = uR();
          return W(w, n), w;
        })();
      })(), p), p.addEventListener("submit", c), O.$$input = (y) => e(y.currentTarget.value), v.$$input = (y) => i(y.currentTarget.value), W(d, B(Pv, {}), null), W(d, B(Qv, {}), null), Ae(() => O.value = s()), Ae(() => v.value = t()), h;
    }
  });
}, pR = () => {
  Mi();
  const s = localStorage.getItem("user");
  return ss(), Jt(() => {
    s && localStorage.removeItem("user");
  }), (() => {
    var e = dR();
    return W(e, B(fR, {})), e;
  })();
};
_t(["input"]);
let Dd = [], Cv = [];
(() => {
  let s = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < s.length; e++)
    (e % 2 ? Cv : Dd).push(t = t + s[e]);
})();
function gR(s) {
  if (s < 768) return !1;
  for (let e = 0, t = Dd.length; ; ) {
    let i = e + t >> 1;
    if (s < Dd[i]) t = i;
    else if (s >= Cv[i]) e = i + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function sO(s) {
  return s >= 127462 && s <= 127487;
}
const nO = 8205;
function mR(s, e, t = !0, i = !0) {
  return (t ? Av : OR)(s, e, i);
}
function Av(s, e, t) {
  if (e == s.length) return e;
  e && Tv(s.charCodeAt(e)) && $v(s.charCodeAt(e - 1)) && e--;
  let i = Jh(s, e);
  for (e += rO(i); e < s.length; ) {
    let n = Jh(s, e);
    if (i == nO || n == nO || t && gR(n))
      e += rO(n), i = n;
    else if (sO(n)) {
      let r = 0, a = e - 2;
      for (; a >= 0 && sO(Jh(s, a)); )
        r++, a -= 2;
      if (r % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function OR(s, e, t) {
  for (; e > 0; ) {
    let i = Av(s, e - 2, t);
    if (i < e) return i;
    e--;
  }
  return 0;
}
function Jh(s, e) {
  let t = s.charCodeAt(e);
  if (!$v(t) || e + 1 == s.length) return t;
  let i = s.charCodeAt(e + 1);
  return Tv(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function Tv(s) {
  return s >= 56320 && s < 57344;
}
function $v(s) {
  return s >= 55296 && s < 56320;
}
function rO(s) {
  return s < 65536 ? 1 : 2;
}
class $e {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    [e, t] = ur(this, e, t);
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      n,
      1
      /* Open.From */
    ), Ni.from(n, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = ur(this, e, t);
    let i = [];
    return this.decompose(e, t, i, 0), Ni.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new da(this), r = new da(e);
    for (let a = t, o = t; ; ) {
      if (n.next(a), r.next(a), a = 0, n.lineBreak != r.lineBreak || n.done != r.done || n.value != r.value)
        return !1;
      if (o += n.value.length, n.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new da(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new Rv(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new Ev(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? $e.empty : e.length <= 32 ? new nt(e) : Ni.from(nt.split(e, []));
  }
}
class nt extends $e {
  constructor(e, t = xR(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, n) {
    for (let r = 0; ; r++) {
      let a = this.text[r], o = n + a.length;
      if ((t ? i : o) >= e)
        return new bR(n, o, i, a);
      n = o + 1, i++;
    }
  }
  decompose(e, t, i, n) {
    let r = e <= 0 && t >= this.length ? this : new nt(aO(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (n & 1) {
      let a = i.pop(), o = Sl(r.text, a.text.slice(), 0, r.length);
      if (o.length <= 32)
        i.push(new nt(o, a.length + r.length));
      else {
        let l = o.length >> 1;
        i.push(new nt(o.slice(0, l)), new nt(o.slice(l)));
      }
    } else
      i.push(r);
  }
  replace(e, t, i) {
    if (!(i instanceof nt))
      return super.replace(e, t, i);
    [e, t] = ur(this, e, t);
    let n = Sl(this.text, Sl(i.text, aO(this.text, 0, e)), t), r = this.length + i.length - (t - e);
    return n.length <= 32 ? new nt(n, r) : Ni.from(nt.split(n, []), r);
  }
  sliceString(e, t = this.length, i = `
`) {
    [e, t] = ur(this, e, t);
    let n = "";
    for (let r = 0, a = 0; r <= t && a < this.text.length; a++) {
      let o = this.text[a], l = r + o.length;
      r > e && a && (n += i), e < l && t > r && (n += o.slice(Math.max(0, e - r), t - r)), r = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], n = -1;
    for (let r of e)
      i.push(r), n += r.length + 1, i.length == 32 && (t.push(new nt(i, n)), i = [], n = -1);
    return n > -1 && t.push(new nt(i, n)), t;
  }
}
class Ni extends $e {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, n) {
    for (let r = 0; ; r++) {
      let a = this.children[r], o = n + a.length, l = i + a.lines - 1;
      if ((t ? l : o) >= e)
        return a.lineInner(e, t, i, n);
      n = o + 1, i = l + 1;
    }
  }
  decompose(e, t, i, n) {
    for (let r = 0, a = 0; a <= t && r < this.children.length; r++) {
      let o = this.children[r], l = a + o.length;
      if (e <= l && t >= a) {
        let c = n & ((a <= e ? 1 : 0) | (l >= t ? 2 : 0));
        a >= e && l <= t && !c ? i.push(o) : o.decompose(e - a, t - a, i, c);
      }
      a = l + 1;
    }
  }
  replace(e, t, i) {
    if ([e, t] = ur(this, e, t), i.lines < this.lines)
      for (let n = 0, r = 0; n < this.children.length; n++) {
        let a = this.children[n], o = r + a.length;
        if (e >= r && t <= o) {
          let l = a.replace(e - r, t - r, i), c = this.lines - a.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let h = this.children.slice();
            return h[n] = l, new Ni(h, this.length - (t - e) + i.length);
          }
          return super.replace(r, o, l);
        }
        r = o + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    [e, t] = ur(this, e, t);
    let n = "";
    for (let r = 0, a = 0; r < this.children.length && a <= t; r++) {
      let o = this.children[r], l = a + o.length;
      a > e && r && (n += i), e < l && t > a && (n += o.sliceString(e - a, t - a, i)), a = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Ni))
      return 0;
    let i = 0, [n, r, a, o] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += t, r += t) {
      if (n == a || r == o)
        return i;
      let l = this.children[n], c = e.children[r];
      if (l != c)
        return i + l.scanIdentical(c, t);
      i += l.length + 1;
    }
  }
  static from(e, t = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let f of e)
      i += f.lines;
    if (i < 32) {
      let f = [];
      for (let p of e)
        p.flatten(f);
      return new nt(f, t);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), r = n << 1, a = n >> 1, o = [], l = 0, c = -1, h = [];
    function u(f) {
      let p;
      if (f.lines > r && f instanceof Ni)
        for (let g of f.children)
          u(g);
      else f.lines > a && (l > a || !l) ? (d(), o.push(f)) : f instanceof nt && l && (p = h[h.length - 1]) instanceof nt && f.lines + p.lines <= 32 ? (l += f.lines, c += f.length + 1, h[h.length - 1] = new nt(p.text.concat(f.text), p.length + 1 + f.length)) : (l + f.lines > n && d(), l += f.lines, c += f.length + 1, h.push(f));
    }
    function d() {
      l != 0 && (o.push(h.length == 1 ? h[0] : Ni.from(h, c)), c = -1, l = h.length = 0);
    }
    for (let f of e)
      u(f);
    return d(), o.length == 1 ? o[0] : new Ni(o, t);
  }
}
$e.empty = /* @__PURE__ */ new nt([""], 0);
function xR(s) {
  let e = -1;
  for (let t of s)
    e += t.length + 1;
  return e;
}
function Sl(s, e, t = 0, i = 1e9) {
  for (let n = 0, r = 0, a = !0; r < s.length && n <= i; r++) {
    let o = s[r], l = n + o.length;
    l >= t && (l > i && (o = o.slice(0, i - n)), n < t && (o = o.slice(t - n)), a ? (e[e.length - 1] += o, a = !1) : e.push(o)), n = l + 1;
  }
  return e;
}
function aO(s, e, t) {
  return Sl(s, [""], e, t);
}
class da {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof nt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], r = this.offsets[i], a = r >> 1, o = n instanceof nt ? n.text.length : n.children.length;
      if (a == (t > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof nt) {
        let l = n.text[a + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = n.children[a + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof nt ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Rv {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new da(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * t, this.value = n.length <= i ? n : t < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Ev {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: n } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && ($e.prototype[Symbol.iterator] = function() {
  return this.iter();
}, da.prototype[Symbol.iterator] = Rv.prototype[Symbol.iterator] = Ev.prototype[Symbol.iterator] = function() {
  return this;
});
let bR = class {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function ur(s, e, t) {
  return e = Math.max(0, Math.min(s.length, e)), [e, Math.max(e, Math.min(s.length, t))];
}
function wt(s, e, t = !0, i = !0) {
  return mR(s, e, t, i);
}
function yR(s) {
  return s >= 56320 && s < 57344;
}
function vR(s) {
  return s >= 55296 && s < 56320;
}
function It(s, e) {
  let t = s.charCodeAt(e);
  if (!vR(t) || e + 1 == s.length)
    return t;
  let i = s.charCodeAt(e + 1);
  return yR(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function Bp(s) {
  return s <= 65535 ? String.fromCharCode(s) : (s -= 65536, String.fromCharCode((s >> 10) + 55296, (s & 1023) + 56320));
}
function Vi(s) {
  return s < 65536 ? 1 : 2;
}
const Bd = /\r\n?|\n/;
var yt = /* @__PURE__ */ function(s) {
  return s[s.Simple = 0] = "Simple", s[s.TrackDel = 1] = "TrackDel", s[s.TrackBefore = 2] = "TrackBefore", s[s.TrackAfter = 3] = "TrackAfter", s;
}(yt || (yt = {}));
class Ki {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, n = 0; t < this.sections.length; ) {
      let r = this.sections[t++], a = this.sections[t++];
      a < 0 ? (e(i, n, r), n += r) : n += a, i += r;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    Wd(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new Ki(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Xv(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : Yd(this, e, t);
  }
  mapPos(e, t = -1, i = yt.Simple) {
    let n = 0, r = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], l = this.sections[a++], c = n + o;
      if (l < 0) {
        if (c > e)
          return r + (e - n);
        r += o;
      } else {
        if (i != yt.Simple && c >= e && (i == yt.TrackDel && n < e && c > e || i == yt.TrackBefore && n < e || i == yt.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !o)
          return e == n || t < 0 ? r : r + l;
        r += l;
      }
      n = c;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return r;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= t; ) {
      let r = this.sections[i++], a = this.sections[i++], o = n + r;
      if (a >= 0 && n <= t && o >= e)
        return n < e && o > t ? "cover" : !0;
      n = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ki(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Ki(e);
  }
}
class ut extends Ki {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Wd(this, (t, i, n, r, a) => e = e.replace(n, n + (i - t), a), !1), e;
  }
  mapDesc(e, t = !1) {
    return Yd(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let n = 0, r = 0; n < t.length; n += 2) {
      let a = t[n], o = t[n + 1];
      if (o >= 0) {
        t[n] = o, t[n + 1] = a;
        let l = n >> 1;
        for (; i.length < l; )
          i.push($e.empty);
        i.push(a ? e.slice(r, r + a) : $e.empty);
      }
      r += a;
    }
    return new ut(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Xv(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : Yd(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    Wd(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Ki.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], n = [], r = new Ea(this);
    e: for (let a = 0, o = 0; ; ) {
      let l = a == e.length ? 1e9 : e[a++];
      for (; o < l || o == l && r.len == 0; ) {
        if (r.done)
          break e;
        let h = Math.min(r.len, l - o);
        Qt(n, h, -1);
        let u = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
        Qt(t, h, u), u > 0 && Xs(i, t, r.text), r.forward(h), o += h;
      }
      let c = e[a++];
      for (; o < c; ) {
        if (r.done)
          break e;
        let h = Math.min(r.len, c - o);
        Qt(t, h, -1), Qt(n, h, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(h), o += h;
      }
    }
    return {
      changes: new ut(t, i),
      filtered: Ki.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], n = this.sections[t + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let n = [], r = [], a = 0, o = null;
    function l(h = !1) {
      if (!h && !n.length)
        return;
      a < t && Qt(n, t - a, -1);
      let u = new ut(n, r);
      o = o ? o.compose(u.map(o)) : u, n = [], r = [], a = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let u of h)
          c(u);
      else if (h instanceof ut) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), o = o ? o.compose(h.map(o)) : h;
      } else {
        let { from: u, to: d = u, insert: f } = h;
        if (u > d || u < 0 || d > t)
          throw new RangeError(`Invalid change range ${u} to ${d} (in doc of length ${t})`);
        let p = f ? typeof f == "string" ? $e.of(f.split(i || Bd)) : f : $e.empty, g = p.length;
        if (u == d && g == 0)
          return;
        u < a && l(), u > a && Qt(n, u - a, -1), Qt(n, d - u, g), Xs(r, n, p), a = d;
      }
    }
    return c(e), l(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new ut(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      if (typeof r == "number")
        t.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          t.push(r[0], 0);
        else {
          for (; i.length < n; )
            i.push($e.empty);
          i[n] = $e.of(r.slice(1)), t.push(r[0], i[n].length);
        }
      }
    }
    return new ut(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new ut(e, t);
  }
}
function Qt(s, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let n = s.length - 2;
  n >= 0 && t <= 0 && t == s[n + 1] ? s[n] += e : n >= 0 && e == 0 && s[n] == 0 ? s[n + 1] += t : i ? (s[n] += e, s[n + 1] += t) : s.push(e, t);
}
function Xs(s, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < s.length)
    s[s.length - 1] = s[s.length - 1].append(t);
  else {
    for (; s.length < i; )
      s.push($e.empty);
    s.push(t);
  }
}
function Wd(s, e, t) {
  let i = s.inserted;
  for (let n = 0, r = 0, a = 0; a < s.sections.length; ) {
    let o = s.sections[a++], l = s.sections[a++];
    if (l < 0)
      n += o, r += o;
    else {
      let c = n, h = r, u = $e.empty;
      for (; c += o, h += l, l && i && (u = u.append(i[a - 2 >> 1])), !(t || a == s.sections.length || s.sections[a + 1] < 0); )
        o = s.sections[a++], l = s.sections[a++];
      e(n, c, r, h, u), n = c, r = h;
    }
  }
}
function Yd(s, e, t, i = !1) {
  let n = [], r = i ? [] : null, a = new Ea(s), o = new Ea(e);
  for (let l = -1; ; ) {
    if (a.done && o.len || o.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && o.ins == -1) {
      let c = Math.min(a.len, o.len);
      Qt(n, c, -1), a.forward(c), o.forward(c);
    } else if (o.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !t))) {
      let c = o.len;
      for (Qt(n, o.ins, -1); c; ) {
        let h = Math.min(a.len, c);
        a.ins >= 0 && l < a.i && a.len <= h && (Qt(n, 0, a.ins), r && Xs(r, n, a.text), l = a.i), a.forward(h), c -= h;
      }
      o.next();
    } else if (a.ins >= 0) {
      let c = 0, h = a.len;
      for (; h; )
        if (o.ins == -1) {
          let u = Math.min(h, o.len);
          c += u, h -= u, o.forward(u);
        } else if (o.ins == 0 && o.len < h)
          h -= o.len, o.next();
        else
          break;
      Qt(n, c, l < a.i ? a.ins : 0), r && l < a.i && Xs(r, n, a.text), l = a.i, a.forward(a.len - h);
    } else {
      if (a.done && o.done)
        return r ? ut.createSet(n, r) : Ki.create(n);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function Xv(s, e, t = !1) {
  let i = [], n = t ? [] : null, r = new Ea(s), a = new Ea(e);
  for (let o = !1; ; ) {
    if (r.done && a.done)
      return n ? ut.createSet(i, n) : Ki.create(i);
    if (r.ins == 0)
      Qt(i, r.len, 0, o), r.next();
    else if (a.len == 0 && !a.done)
      Qt(i, 0, a.ins, o), n && Xs(n, i, a.text), a.next();
    else {
      if (r.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(r.len2, a.len), c = i.length;
        if (r.ins == -1) {
          let h = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Qt(i, l, h, o), n && h && Xs(n, i, a.text);
        } else a.ins == -1 ? (Qt(i, r.off ? 0 : r.len, l, o), n && Xs(n, i, r.textBit(l))) : (Qt(i, r.off ? 0 : r.len, a.off ? 0 : a.ins, o), n && !a.off && Xs(n, i, a.text));
        o = (r.ins > l || a.ins >= 0 && a.len > l) && (o || i.length > c), r.forward2(l), a.forward(l);
      }
    }
  }
}
class Ea {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? $e.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? $e.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class hn {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new hn(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return D.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return D.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return D.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new hn(e, t, i);
  }
}
class D {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : D.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new D([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return D.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, D.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new D(e.ranges.map((t) => hn.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new D([D.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let r = e[n];
      if (r.empty ? r.from <= i : r.from < i)
        return D.normalized(e.slice(), t);
      i = r.to;
    }
    return new D(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, n) {
    return hn.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (n ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, n) {
    let r = (i ?? 16777215) << 6 | (n == null ? 7 : Math.min(6, n));
    return t < e ? hn.create(t, e, 48 | r) : hn.create(e, t, (t > e ? 8 : 0) | r);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((n, r) => n.from - r.from), t = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let r = e[n], a = e[n - 1];
      if (r.empty ? r.from <= a.to : r.from < a.to) {
        let o = a.from, l = Math.max(r.to, a.to);
        n <= t && t--, e.splice(--n, 2, r.anchor > r.head ? D.range(l, o) : D.range(o, l));
      }
    }
    return new D(e, t);
  }
}
function Mv(s, e) {
  for (let t of s.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Wp = 0;
class se {
  constructor(e, t, i, n, r) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = n, this.id = Wp++, this.default = e([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new se(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : Yp), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new kl([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new kl(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new kl(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function Yp(s, e) {
  return s == e || s.length == e.length && s.every((t, i) => t === e[i]);
}
class kl {
  constructor(e, t, i, n) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = n, this.id = Wp++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, n = this.facet.compareInput, r = this.id, a = e[r] >> 1, o = this.type == 2, l = !1, c = !1, h = [];
    for (let u of this.dependencies)
      u == "doc" ? l = !0 : u == "selection" ? c = !0 : (((t = e[u.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && h.push(e[u.id]);
    return {
      create(u) {
        return u.values[a] = i(u), 1;
      },
      update(u, d) {
        if (l && d.docChanged || c && (d.docChanged || d.selection) || Zd(u, h)) {
          let f = i(u);
          if (o ? !oO(f, u.values[a], n) : !n(f, u.values[a]))
            return u.values[a] = f, 1;
        }
        return 0;
      },
      reconfigure: (u, d) => {
        let f, p = d.config.address[r];
        if (p != null) {
          let g = rc(d, p);
          if (this.dependencies.every((m) => m instanceof se ? d.facet(m) === u.facet(m) : m instanceof gt ? d.field(m, !1) == u.field(m, !1) : !0) || (o ? oO(f = i(u), g, n) : n(f = i(u), g)))
            return u.values[a] = g, 0;
        } else
          f = i(u);
        return u.values[a] = f, 1;
      }
    };
  }
}
function oO(s, e, t) {
  if (s.length != e.length)
    return !1;
  for (let i = 0; i < s.length; i++)
    if (!t(s[i], e[i]))
      return !1;
  return !0;
}
function Zd(s, e) {
  let t = !1;
  for (let i of e)
    fa(s, i) & 1 && (t = !0);
  return t;
}
function wR(s, e, t) {
  let i = t.map((l) => s[l.id]), n = t.map((l) => l.type), r = i.filter((l) => !(l & 1)), a = s[e.id] >> 1;
  function o(l) {
    let c = [];
    for (let h = 0; h < i.length; h++) {
      let u = rc(l, i[h]);
      if (n[h] == 2)
        for (let d of u)
          c.push(d);
      else
        c.push(u);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of i)
        fa(l, c);
      return l.values[a] = o(l), 1;
    },
    update(l, c) {
      if (!Zd(l, r))
        return 0;
      let h = o(l);
      return e.compare(h, l.values[a]) ? 0 : (l.values[a] = h, 1);
    },
    reconfigure(l, c) {
      let h = Zd(l, i), u = c.config.facets[e.id], d = c.facet(e);
      if (u && !h && Yp(t, u))
        return l.values[a] = d, 0;
      let f = o(l);
      return e.compare(f, d) ? (l.values[a] = d, 0) : (l.values[a] = f, 1);
    }
  };
}
const zo = /* @__PURE__ */ se.define({ static: !0 });
class gt {
  constructor(e, t, i, n, r) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = n, this.spec = r, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new gt(Wp++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(zo).find((i) => i.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, n) => {
        let r = i.values[t], a = this.updateF(r, n);
        return this.compareF(r, a) ? 0 : (i.values[t] = a, 1);
      },
      reconfigure: (i, n) => {
        let r = i.facet(zo), a = n.facet(zo), o;
        return (o = r.find((l) => l.field == this)) && o != a.find((l) => l.field == this) ? (i.values[t] = o.create(i), 1) : n.config.address[this.id] != null ? (i.values[t] = n.field(this), 0) : (i.values[t] = this.create(i), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, zo.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const nn = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Zr(s) {
  return (e) => new _v(e, s);
}
const Qs = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Zr(nn.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Zr(nn.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Zr(nn.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Zr(nn.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Zr(nn.lowest)
};
class _v {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Gc {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Nd(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Gc.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Nd {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class nc {
  constructor(e, t, i, n, r, a) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = n, this.staticValues = r, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let n = [], r = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let d of SR(e, t, a))
      d instanceof gt ? n.push(d) : (r[d.facet.id] || (r[d.facet.id] = [])).push(d);
    let o = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let d of n)
      o[d.id] = c.length << 1, c.push((f) => d.slot(f));
    let h = i?.config.facets;
    for (let d in r) {
      let f = r[d], p = f[0].facet, g = h && h[d] || [];
      if (f.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (o[p.id] = l.length << 1 | 1, Yp(g, f))
          l.push(i.facet(p));
        else {
          let m = p.combine(f.map((O) => O.value));
          l.push(i && p.compare(m, i.facet(p)) ? i.facet(p) : m);
        }
      else {
        for (let m of f)
          m.type == 0 ? (o[m.id] = l.length << 1 | 1, l.push(m.value)) : (o[m.id] = c.length << 1, c.push((O) => m.dynamicSlot(O)));
        o[p.id] = c.length << 1, c.push((m) => wR(m, p, f));
      }
    }
    let u = c.map((d) => d(o));
    return new nc(e, a, u, o, l, r);
  }
}
function SR(s, e, t) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function r(a, o) {
    let l = n.get(a);
    if (l != null) {
      if (l <= o)
        return;
      let c = i[l].indexOf(a);
      c > -1 && i[l].splice(c, 1), a instanceof Nd && t.delete(a.compartment);
    }
    if (n.set(a, o), Array.isArray(a))
      for (let c of a)
        r(c, o);
    else if (a instanceof Nd) {
      if (t.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(a.compartment) || a.inner;
      t.set(a.compartment, c), r(c, o);
    } else if (a instanceof _v)
      r(a.inner, a.prec);
    else if (a instanceof gt)
      i[o].push(a), a.provides && r(a.provides, o);
    else if (a instanceof kl)
      i[o].push(a), a.facet.extensions && r(a.facet.extensions, nn.default);
    else {
      let c = a.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(c, o);
    }
  }
  return r(s, nn.default), i.reduce((a, o) => a.concat(o));
}
function fa(s, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = s.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  s.status[t] = 4;
  let n = s.computeSlot(s, s.config.dynamicSlots[t]);
  return s.status[t] = 2 | n;
}
function rc(s, e) {
  return e & 1 ? s.config.staticValues[e >> 1] : s.values[e >> 1];
}
const Lv = /* @__PURE__ */ se.define(), Vd = /* @__PURE__ */ se.define({
  combine: (s) => s.some((e) => e),
  static: !0
}), zv = /* @__PURE__ */ se.define({
  combine: (s) => s.length ? s[0] : void 0,
  static: !0
}), Iv = /* @__PURE__ */ se.define(), qv = /* @__PURE__ */ se.define(), Dv = /* @__PURE__ */ se.define(), Bv = /* @__PURE__ */ se.define({
  combine: (s) => s.length ? s[0] : !1
});
class Cs {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new kR();
  }
}
class kR {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Cs(this, e);
  }
}
class PR {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new xe(this, e);
  }
}
class xe {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new xe(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new PR(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let r = n.map(t);
      r && i.push(r);
    }
    return i;
  }
}
xe.reconfigure = /* @__PURE__ */ xe.define();
xe.appendConfig = /* @__PURE__ */ xe.define();
class lt {
  constructor(e, t, i, n, r, a) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = n, this.annotations = r, this.scrollIntoView = a, this._doc = null, this._state = null, i && Mv(i, t.newLength), r.some((o) => o.type == lt.time) || (this.annotations = r.concat(lt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, n, r, a) {
    return new lt(e, t, i, n, r, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(lt.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
lt.time = /* @__PURE__ */ Cs.define();
lt.userEvent = /* @__PURE__ */ Cs.define();
lt.addToHistory = /* @__PURE__ */ Cs.define();
lt.remote = /* @__PURE__ */ Cs.define();
function QR(s, e) {
  let t = [];
  for (let i = 0, n = 0; ; ) {
    let r, a;
    if (i < s.length && (n == e.length || e[n] >= s[i]))
      r = s[i++], a = s[i++];
    else if (n < e.length)
      r = e[n++], a = e[n++];
    else
      return t;
    !t.length || t[t.length - 1] < r ? t.push(r, a) : t[t.length - 1] < a && (t[t.length - 1] = a);
  }
}
function Wv(s, e, t) {
  var i;
  let n, r, a;
  return t ? (n = e.changes, r = ut.empty(e.changes.length), a = s.changes.compose(e.changes)) : (n = e.changes.map(s.changes), r = s.changes.mapDesc(e.changes, !0), a = s.changes.compose(n)), {
    changes: a,
    selection: e.selection ? e.selection.map(r) : (i = s.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: xe.mapEffects(s.effects, n).concat(xe.mapEffects(e.effects, r)),
    annotations: s.annotations.length ? s.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: s.scrollIntoView || e.scrollIntoView
  };
}
function Fd(s, e, t) {
  let i = e.selection, n = tr(e.annotations);
  return e.userEvent && (n = n.concat(lt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof ut ? e.changes : ut.of(e.changes || [], t, s.facet(zv)),
    selection: i && (i instanceof D ? i : D.single(i.anchor, i.head)),
    effects: tr(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function Yv(s, e, t) {
  let i = Fd(s, e.length ? e[0] : {}, s.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let r = 1; r < e.length; r++) {
    e[r].filter === !1 && (t = !1);
    let a = !!e[r].sequential;
    i = Wv(i, Fd(s, e[r], a ? i.changes.newLength : s.doc.length), a);
  }
  let n = lt.create(s, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return AR(t ? CR(n) : n);
}
function CR(s) {
  let e = s.startState, t = !0;
  for (let n of e.facet(Iv)) {
    let r = n(s);
    if (r === !1) {
      t = !1;
      break;
    }
    Array.isArray(r) && (t = t === !0 ? r : QR(t, r));
  }
  if (t !== !0) {
    let n, r;
    if (t === !1)
      r = s.changes.invertedDesc, n = ut.empty(e.doc.length);
    else {
      let a = s.changes.filter(t);
      n = a.changes, r = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    s = lt.create(e, n, s.selection && s.selection.map(r), xe.mapEffects(s.effects, r), s.annotations, s.scrollIntoView);
  }
  let i = e.facet(qv);
  for (let n = i.length - 1; n >= 0; n--) {
    let r = i[n](s);
    r instanceof lt ? s = r : Array.isArray(r) && r.length == 1 && r[0] instanceof lt ? s = r[0] : s = Yv(e, tr(r), !1);
  }
  return s;
}
function AR(s) {
  let e = s.startState, t = e.facet(Dv), i = s;
  for (let n = t.length - 1; n >= 0; n--) {
    let r = t[n](s);
    r && Object.keys(r).length && (i = Wv(i, Fd(e, r, s.changes.newLength), !0));
  }
  return i == s ? s : lt.create(e, s.changes, s.selection, i.effects, i.annotations, i.scrollIntoView);
}
const TR = [];
function tr(s) {
  return s == null ? TR : Array.isArray(s) ? s : [s];
}
var Ke = /* @__PURE__ */ function(s) {
  return s[s.Word = 0] = "Word", s[s.Space = 1] = "Space", s[s.Other = 2] = "Other", s;
}(Ke || (Ke = {}));
const $R = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let jd;
try {
  jd = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function RR(s) {
  if (jd)
    return jd.test(s);
  for (let e = 0; e < s.length; e++) {
    let t = s[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || $R.test(t)))
      return !0;
  }
  return !1;
}
function ER(s) {
  return (e) => {
    if (!/\S/.test(e))
      return Ke.Space;
    if (RR(e))
      return Ke.Word;
    for (let t = 0; t < s.length; t++)
      if (e.indexOf(s[t]) > -1)
        return Ke.Word;
    return Ke.Other;
  };
}
class Ce {
  constructor(e, t, i, n, r, a) {
    this.config = e, this.doc = t, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = r, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      fa(this, o << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return fa(this, i), rc(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return Yv(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: n } = t;
    for (let o of e.effects)
      o.is(Gc.reconfigure) ? (t && (n = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => n.set(c, l)), t = null), n.set(o.value.compartment, o.value.extension)) : o.is(xe.reconfigure) ? (t = null, i = o.value) : o.is(xe.appendConfig) && (t = null, i = tr(i).concat(o.value));
    let r;
    t ? r = e.startState.values.slice() : (t = nc.resolve(i, n, this), r = new Ce(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let a = e.startState.facet(Vd) ? e.newSelection : e.newSelection.asSingle();
    new Ce(t, e.newDoc, a, r, (o, l) => l.update(o, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: D.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), n = this.changes(i.changes), r = [i.range], a = tr(i.effects);
    for (let o = 1; o < t.ranges.length; o++) {
      let l = e(t.ranges[o]), c = this.changes(l.changes), h = c.map(n);
      for (let d = 0; d < o; d++)
        r[d] = r[d].map(h);
      let u = n.mapDesc(c, !0);
      r.push(l.range.map(u)), n = n.compose(h), a = xe.mapEffects(a, h).concat(xe.mapEffects(tr(l.effects), u));
    }
    return {
      changes: n,
      selection: D.create(r, t.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof ut ? e : ut.of(e, this.doc.length, this.facet(Ce.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return $e.of(e.split(this.facet(Ce.lineSeparator) || Bd));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (fa(this, t), rc(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof gt && this.config.address[n.id] != null && (t[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let r in i)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          let a = i[r], o = e[r];
          n.push(a.init((l) => a.spec.fromJSON(o, l)));
        }
    }
    return Ce.create({
      doc: e.doc,
      selection: D.fromJSON(e.selection),
      extensions: t.extensions ? n.concat([t.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = nc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof $e ? e.doc : $e.of((e.doc || "").split(t.staticFacet(Ce.lineSeparator) || Bd)), n = e.selection ? e.selection instanceof D ? e.selection : D.single(e.selection.anchor, e.selection.head) : D.single(0);
    return Mv(n, i.length), t.staticFacet(Vd) || (n = n.asSingle()), new Ce(t, i, n, t.dynamicSlots.map(() => null), (r, a) => a.create(r), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Ce.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Ce.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Bv);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(Ce.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let r = +(n || 1);
      return !r || r > t.length ? i : t[r - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let n = [];
    for (let r of this.facet(Lv))
      for (let a of r(this, t, i))
        Object.prototype.hasOwnProperty.call(a, e) && n.push(a[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return ER(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: n } = this.doc.lineAt(e), r = this.charCategorizer(e), a = e - i, o = e - i;
    for (; a > 0; ) {
      let l = wt(t, a, !1);
      if (r(t.slice(l, a)) != Ke.Word)
        break;
      a = l;
    }
    for (; o < n; ) {
      let l = wt(t, o);
      if (r(t.slice(o, l)) != Ke.Word)
        break;
      o = l;
    }
    return a == o ? null : D.range(a + i, o + i);
  }
}
Ce.allowMultipleSelections = Vd;
Ce.tabSize = /* @__PURE__ */ se.define({
  combine: (s) => s.length ? s[0] : 4
});
Ce.lineSeparator = zv;
Ce.readOnly = Bv;
Ce.phrases = /* @__PURE__ */ se.define({
  compare(s, e) {
    let t = Object.keys(s), i = Object.keys(e);
    return t.length == i.length && t.every((n) => s[n] == e[n]);
  }
});
Ce.languageData = Lv;
Ce.changeFilter = Iv;
Ce.transactionFilter = qv;
Ce.transactionExtender = Dv;
Gc.reconfigure = /* @__PURE__ */ xe.define();
function ns(s, e, t = {}) {
  let i = {};
  for (let n of s)
    for (let r of Object.keys(n)) {
      let a = n[r], o = i[r];
      if (o === void 0)
        i[r] = a;
      else if (!(o === a || a === void 0)) if (Object.hasOwnProperty.call(t, r))
        i[r] = t[r](o, a);
      else
        throw new Error("Config merge conflict for field " + r);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
class Qn {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Hd.create(e, t, this);
  }
}
Qn.prototype.startSide = Qn.prototype.endSide = 0;
Qn.prototype.point = !1;
Qn.prototype.mapMode = yt.TrackDel;
let Hd = class Zv {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Zv(e, t, i);
  }
};
function Ud(s, e) {
  return s.from - e.from || s.value.startSide - e.value.startSide;
}
class Zp {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, n = 0) {
    let r = i ? this.to : this.from;
    for (let a = n, o = r.length; ; ) {
      if (a == o)
        return a;
      let l = a + o >> 1, c = r[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == a)
        return c >= 0 ? a : o;
      c >= 0 ? o = l : a = l + 1;
    }
  }
  between(e, t, i, n) {
    for (let r = this.findIndex(t, -1e9, !0), a = this.findIndex(i, 1e9, !1, r); r < a; r++)
      if (n(this.from[r] + e, this.to[r] + e, this.value[r]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], n = [], r = [], a = -1, o = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], h = this.from[l] + e, u = this.to[l] + e, d, f;
      if (h == u) {
        let p = t.mapPos(h, c.startSide, c.mapMode);
        if (p == null || (d = f = p, c.startSide != c.endSide && (f = t.mapPos(h, c.endSide), f < d)))
          continue;
      } else if (d = t.mapPos(h, c.startSide), f = t.mapPos(u, c.endSide), d > f || d == f && c.startSide > 0 && c.endSide <= 0)
        continue;
      (f - d || c.endSide - c.startSide) < 0 || (a < 0 && (a = d), c.point && (o = Math.max(o, f - d)), i.push(c), n.push(d - a), r.push(f - a));
    }
    return { mapped: i.length ? new Zp(n, r, i, o) : null, pos: a };
  }
}
class Xe {
  constructor(e, t, i, n) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, t, i, n) {
    return new Xe(e, t, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: n = 0, filterTo: r = this.length } = e, a = e.filter;
    if (t.length == 0 && !a)
      return this;
    if (i && (t = t.slice().sort(Ud)), this.isEmpty)
      return t.length ? Xe.of(t) : this;
    let o = new Nv(this, null, -1).goto(0), l = 0, c = [], h = new vs();
    for (; o.value || l < t.length; )
      if (l < t.length && (o.from - t[l].from || o.startSide - t[l].value.startSide) >= 0) {
        let u = t[l++];
        h.addInner(u.from, u.to, u.value) || c.push(u);
      } else o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(o.chunkIndex) < t[l].from) && (!a || n > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && h.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || n > o.to || r < o.from || a(o.from, o.to, o.value)) && (h.addInner(o.from, o.to, o.value) || c.push(Hd.create(o.from, o.to, o.value))), o.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? Xe.empty : this.nextLayer.update({ add: c, filter: a, filterFrom: n, filterTo: r }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], n = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], l = this.chunk[a], c = e.touchesRange(o, o + l.length);
      if (c === !1)
        n = Math.max(n, l.maxPoint), t.push(l), i.push(e.mapPos(o));
      else if (c === !0) {
        let { mapped: h, pos: u } = l.map(o, e);
        h && (n = Math.max(n, h.maxPoint), t.push(h), i.push(u));
      }
    }
    let r = this.nextLayer.map(e);
    return t.length == 0 ? r : new Xe(i, t, r || Xe.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let r = this.chunkPos[n], a = this.chunk[n];
        if (t >= r && e <= r + a.length && a.between(r, e - r, t - r, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Xa.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Xa.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, n, r = -1) {
    let a = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= r), o = t.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= r), l = lO(a, o, i), c = new Nr(a, l, r), h = new Nr(o, l, r);
    i.iterGaps((u, d, f) => cO(c, u, h, d, f, n)), i.empty && i.length == 0 && cO(c, 0, h, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, n) {
    n == null && (n = 999999999);
    let r = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), a = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (r.length != a.length)
      return !1;
    if (!r.length)
      return !0;
    let o = lO(r, a), l = new Nr(r, o, 0).goto(i), c = new Nr(a, o, 0).goto(i);
    for (; ; ) {
      if (l.to != c.to || !Gd(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > n)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, n, r = -1) {
    let a = new Nr(e, null, r).goto(t), o = t, l = a.openStart;
    for (; ; ) {
      let c = Math.min(a.to, i);
      if (a.point) {
        let h = a.activeForPoint(a.to), u = a.pointFrom < t ? h.length + 1 : a.point.startSide < 0 ? h.length : Math.min(h.length, l);
        n.point(o, c, a.point, h, u, a.pointRank), l = Math.min(a.openEnd(c), h.length);
      } else c > o && (n.span(o, c, a.active, l), l = a.openEnd(c));
      if (a.to > i)
        return l + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new vs();
    for (let n of e instanceof Hd ? [e] : t ? XR(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Xe.empty;
    let t = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let n = e[i]; n != Xe.empty; n = n.nextLayer)
        t = new Xe(n.chunkPos, n.chunk, t, Math.max(n.maxPoint, t.maxPoint));
    return t;
  }
}
Xe.empty = /* @__PURE__ */ new Xe([], [], null, -1);
function XR(s) {
  if (s.length > 1)
    for (let e = s[0], t = 1; t < s.length; t++) {
      let i = s[t];
      if (Ud(e, i) > 0)
        return s.slice().sort(Ud);
      e = i;
    }
  return s;
}
Xe.empty.nextLayer = Xe.empty;
class vs {
  finishChunk(e) {
    this.chunks.push(new Zp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new vs())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Xe.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Xe.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function lO(s, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let r of s)
    for (let a = 0; a < r.chunk.length; a++)
      r.chunk[a].maxPoint <= 0 && i.set(r.chunk[a], r.chunkPos[a]);
  let n = /* @__PURE__ */ new Set();
  for (let r of e)
    for (let a = 0; a < r.chunk.length; a++) {
      let o = i.get(r.chunk[a]);
      o != null && (t ? t.mapPos(o) : o) == r.chunkPos[a] && !t?.touchesRange(o, o + r.chunk[a].length) && n.add(r.chunk[a]);
    }
  return n;
}
class Nv {
  constructor(e, t, i, n = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Xa {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let n = [];
    for (let r = 0; r < e.length; r++)
      for (let a = e[r]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && n.push(new Nv(a, t, i, r));
    return n.length == 1 ? n[0] : new Xa(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      eu(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      eu(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), eu(this.heap, 0);
    }
  }
}
function eu(s, e) {
  for (let t = s[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= s.length)
      break;
    let n = s[i];
    if (i + 1 < s.length && n.compare(s[i + 1]) >= 0 && (n = s[i + 1], i++), t.compare(n) < 0)
      break;
    s[i] = t, s[e] = n, e = i;
  }
}
class Nr {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Xa.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Io(this.active, e), Io(this.activeTo, e), Io(this.activeRank, e), this.minActive = hO(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: n, rank: r } = this.cursor;
    for (; t < this.activeRank.length && (r - this.activeRank[t] || n - this.activeTo[t]) > 0; )
      t++;
    qo(this.active, t, i), qo(this.activeTo, t, n), qo(this.activeRank, t, r), e && qo(e, t, this.cursor.from), this.minActive = hO(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && Io(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let r = this.cursor.value;
          if (!r.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function cO(s, e, t, i, n, r) {
  s.goto(e), t.goto(i);
  let a = i + n, o = i, l = i - e;
  for (; ; ) {
    let c = s.to + l - t.to, h = c || s.endSide - t.endSide, u = h < 0 ? s.to + l : t.to, d = Math.min(u, a);
    if (s.point || t.point ? s.point && t.point && (s.point == t.point || s.point.eq(t.point)) && Gd(s.activeForPoint(s.to), t.activeForPoint(t.to)) || r.comparePoint(o, d, s.point, t.point) : d > o && !Gd(s.active, t.active) && r.compareRange(o, d, s.active, t.active), u > a)
      break;
    (c || s.openEnd != t.openEnd) && r.boundChange && r.boundChange(u), o = u, h <= 0 && s.next(), h >= 0 && t.next();
  }
}
function Gd(s, e) {
  if (s.length != e.length)
    return !1;
  for (let t = 0; t < s.length; t++)
    if (s[t] != e[t] && !s[t].eq(e[t]))
      return !1;
  return !0;
}
function Io(s, e) {
  for (let t = e, i = s.length - 1; t < i; t++)
    s[t] = s[t + 1];
  s.pop();
}
function qo(s, e, t) {
  for (let i = s.length - 1; i >= e; i--)
    s[i + 1] = s[i];
  s[e] = t;
}
function hO(s, e) {
  let t = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || s[n].endSide - s[t].endSide) < 0 && (t = n, i = e[n]);
  return t;
}
function Ti(s, e, t = s.length) {
  let i = 0;
  for (let n = 0; n < t && n < s.length; )
    s.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = wt(s, n));
  return i;
}
function Kd(s, e, t, i) {
  for (let n = 0, r = 0; ; ) {
    if (r >= e)
      return n;
    if (n == s.length)
      break;
    r += s.charCodeAt(n) == 9 ? t - r % t : 1, n = wt(s, n);
  }
  return i === !0 ? -1 : s.length;
}
const Jd = "ͼ", uO = typeof Symbol > "u" ? "__" + Jd : Symbol.for(Jd), ef = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), dO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Ys {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function n(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function r(a, o, l, c) {
      let h = [], u = /^@(\w+)\b/.exec(a[0]), d = u && u[1] == "keyframes";
      if (u && o == null) return l.push(a[0] + ";");
      for (let f in o) {
        let p = o[f];
        if (/&/.test(f))
          r(
            f.split(/,\s*/).map((g) => a.map((m) => g.replace(/&/, m))).reduce((g, m) => g.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!u) throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          r(n(f), p, h, d);
        } else p != null && h.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (h.length || d) && l.push((i && !u && !c ? a.map(i) : a).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let a in e) r(n(a), e[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = dO[uO] || 1;
    return dO[uO] = e + 1, Jd + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, i) {
    let n = e[ef], r = i && i.nonce;
    n ? r && n.setNonce(r) : n = new MR(e, r), n.mount(Array.isArray(t) ? t : [t], e);
  }
}
let fO = /* @__PURE__ */ new Map();
class MR {
  constructor(e, t) {
    let i = e.ownerDocument || e, n = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && n.CSSStyleSheet) {
      let r = fO.get(i);
      if (r) return e[ef] = r;
      this.sheet = new n.CSSStyleSheet(), fO.set(i, this);
    } else
      this.styleTag = i.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[ef] = this;
  }
  mount(e, t) {
    let i = this.sheet, n = 0, r = 0;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], l = this.modules.indexOf(o);
      if (l < r && l > -1 && (this.modules.splice(l, 1), r--, l = -1), l == -1) {
        if (this.modules.splice(r++, 0, o), i) for (let c = 0; c < o.rules.length; c++)
          i.insertRule(o.rules[c], n++);
      } else {
        for (; r < l; ) n += this.modules[r++].rules.length;
        n += o.rules.length, r++;
      }
    }
    if (i)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let a = "";
      for (let l = 0; l < this.modules.length; l++)
        a += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = a;
      let o = t.head || t;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Zs = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ma = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, _R = typeof navigator < "u" && /Mac/.test(navigator.platform), LR = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var bt = 0; bt < 10; bt++) Zs[48 + bt] = Zs[96 + bt] = String(bt);
for (var bt = 1; bt <= 24; bt++) Zs[bt + 111] = "F" + bt;
for (var bt = 65; bt <= 90; bt++)
  Zs[bt] = String.fromCharCode(bt + 32), Ma[bt] = String.fromCharCode(bt);
for (var tu in Zs) Ma.hasOwnProperty(tu) || (Ma[tu] = Zs[tu]);
function zR(s) {
  var e = _R && s.metaKey && s.shiftKey && !s.ctrlKey && !s.altKey || LR && s.shiftKey && s.key && s.key.length == 1 || s.key == "Unidentified", t = !e && s.key || (s.shiftKey ? Ma : Zs)[s.keyCode] || s.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function We() {
  var s = arguments[0];
  typeof s == "string" && (s = document.createElement(s));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t) if (Object.prototype.hasOwnProperty.call(t, i)) {
      var n = t[i];
      typeof n == "string" ? s.setAttribute(i, n) : n != null && (s[i] = n);
    }
    e++;
  }
  for (; e < arguments.length; e++) Vv(s, arguments[e]);
  return s;
}
function Vv(s, e) {
  if (typeof e == "string")
    s.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    s.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) Vv(s, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function _a(s) {
  let e;
  return s.nodeType == 11 ? e = s.getSelection ? s : s.ownerDocument : e = s, e.getSelection();
}
function tf(s, e) {
  return e ? s == e || s.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Pl(s, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return tf(s, e.anchorNode);
  } catch {
    return !1;
  }
}
function La(s) {
  return s.nodeType == 3 ? An(s, 0, s.nodeValue.length).getClientRects() : s.nodeType == 1 ? s.getClientRects() : [];
}
function pa(s, e, t, i) {
  return t ? pO(s, e, t, i, -1) || pO(s, e, t, i, 1) : !1;
}
function Cn(s) {
  for (var e = 0; ; e++)
    if (s = s.previousSibling, !s)
      return e;
}
function ac(s) {
  return s.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(s.nodeName);
}
function pO(s, e, t, i, n) {
  for (; ; ) {
    if (s == t && e == i)
      return !0;
    if (e == (n < 0 ? 0 : ts(s))) {
      if (s.nodeName == "DIV")
        return !1;
      let r = s.parentNode;
      if (!r || r.nodeType != 1)
        return !1;
      e = Cn(s) + (n < 0 ? 0 : 1), s = r;
    } else if (s.nodeType == 1) {
      if (s = s.childNodes[e + (n < 0 ? -1 : 0)], s.nodeType == 1 && s.contentEditable == "false")
        return !1;
      e = n < 0 ? ts(s) : 0;
    } else
      return !1;
  }
}
function ts(s) {
  return s.nodeType == 3 ? s.nodeValue.length : s.childNodes.length;
}
function Kc(s, e) {
  let t = e ? s.left : s.right;
  return { left: t, right: t, top: s.top, bottom: s.bottom };
}
function IR(s) {
  let e = s.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: s.innerWidth,
    top: 0,
    bottom: s.innerHeight
  };
}
function Fv(s, e) {
  let t = e.width / s.offsetWidth, i = e.height / s.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - s.offsetWidth) < 1) && (t = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - s.offsetHeight) < 1) && (i = 1), { scaleX: t, scaleY: i };
}
function qR(s, e, t, i, n, r, a, o) {
  let l = s.ownerDocument, c = l.defaultView || window;
  for (let h = s, u = !1; h && !u; )
    if (h.nodeType == 1) {
      let d, f = h == l.body, p = 1, g = 1;
      if (f)
        d = IR(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (u = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let x = h.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = Fv(h, x)), d = {
          left: x.left,
          right: x.left + h.clientWidth * p,
          top: x.top,
          bottom: x.top + h.clientHeight * g
        };
      }
      let m = 0, O = 0;
      if (n == "nearest")
        e.top < d.top ? (O = e.top - (d.top + a), t > 0 && e.bottom > d.bottom + O && (O = e.bottom - d.bottom + a)) : e.bottom > d.bottom && (O = e.bottom - d.bottom + a, t < 0 && e.top - O < d.top && (O = e.top - (d.top + a)));
      else {
        let x = e.bottom - e.top, b = d.bottom - d.top;
        O = (n == "center" && x <= b ? e.top + x / 2 - b / 2 : n == "start" || n == "center" && t < 0 ? e.top - a : e.bottom - b + a) - d.top;
      }
      if (i == "nearest" ? e.left < d.left ? (m = e.left - (d.left + r), t > 0 && e.right > d.right + m && (m = e.right - d.right + r)) : e.right > d.right && (m = e.right - d.right + r, t < 0 && e.left < d.left + m && (m = e.left - (d.left + r))) : m = (i == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : i == "start" == o ? e.left - r : e.right - (d.right - d.left) + r) - d.left, m || O)
        if (f)
          c.scrollBy(m, O);
        else {
          let x = 0, b = 0;
          if (O) {
            let v = h.scrollTop;
            h.scrollTop += O / g, b = (h.scrollTop - v) * g;
          }
          if (m) {
            let v = h.scrollLeft;
            h.scrollLeft += m / p, x = (h.scrollLeft - v) * p;
          }
          e = {
            left: e.left - x,
            top: e.top - b,
            right: e.right - x,
            bottom: e.bottom - b
          }, x && Math.abs(x - m) < 1 && (i = "nearest"), b && Math.abs(b - O) < 1 && (n = "nearest");
        }
      if (f)
        break;
      (e.top < d.top || e.bottom > d.bottom || e.left < d.left || e.right > d.right) && (e = {
        left: Math.max(e.left, d.left),
        right: Math.min(e.right, d.right),
        top: Math.max(e.top, d.top),
        bottom: Math.min(e.bottom, d.bottom)
      }), h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function DR(s) {
  let e = s.ownerDocument, t, i;
  for (let n = s.parentNode; n && !(n == e.body || t && i); )
    if (n.nodeType == 1)
      !i && n.scrollHeight > n.clientHeight && (i = n), !t && n.scrollWidth > n.clientWidth && (t = n), n = n.assignedSlot || n.parentNode;
    else if (n.nodeType == 11)
      n = n.host;
    else
      break;
  return { x: t, y: i };
}
class BR {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? ts(t) : 0), i, Math.min(e.focusOffset, i ? ts(i) : 0));
  }
  set(e, t, i, n) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = n;
  }
}
let Bn = null;
function jv(s) {
  if (s.setActive)
    return s.setActive();
  if (Bn)
    return s.focus(Bn);
  let e = [];
  for (let t = s; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (s.focus(Bn == null ? {
    get preventScroll() {
      return Bn = { preventScroll: !0 }, !0;
    }
  } : void 0), !Bn) {
    Bn = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], n = e[t++], r = e[t++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != r && (i.scrollLeft = r);
    }
  }
}
let gO;
function An(s, e, t = e) {
  let i = gO || (gO = document.createRange());
  return i.setEnd(s, t), i.setStart(s, e), i;
}
function ir(s, e, t, i) {
  let n = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  i && ({ altKey: n.altKey, ctrlKey: n.ctrlKey, shiftKey: n.shiftKey, metaKey: n.metaKey } = i);
  let r = new KeyboardEvent("keydown", n);
  r.synthetic = !0, s.dispatchEvent(r);
  let a = new KeyboardEvent("keyup", n);
  return a.synthetic = !0, s.dispatchEvent(a), r.defaultPrevented || a.defaultPrevented;
}
function WR(s) {
  for (; s; ) {
    if (s && (s.nodeType == 9 || s.nodeType == 11 && s.host))
      return s;
    s = s.assignedSlot || s.parentNode;
  }
  return null;
}
function Hv(s) {
  for (; s.attributes.length; )
    s.removeAttributeNode(s.attributes[0]);
}
function YR(s, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, ts(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let n = t.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (t = n, i = ts(t));
    } else {
      if (t == s)
        return !0;
      i = Cn(t), t = t.parentNode;
    }
}
function Uv(s) {
  return s.scrollTop > Math.max(1, s.scrollHeight - s.clientHeight - 4);
}
function Gv(s, e) {
  for (let t = s, i = e; ; ) {
    if (t.nodeType == 3 && i > 0)
      return { node: t, offset: i };
    if (t.nodeType == 1 && i > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[i - 1], i = ts(t);
    } else if (t.parentNode && !ac(t))
      i = Cn(t), t = t.parentNode;
    else
      return null;
  }
}
function Kv(s, e) {
  for (let t = s, i = e; ; ) {
    if (t.nodeType == 3 && i < t.nodeValue.length)
      return { node: t, offset: i };
    if (t.nodeType == 1 && i < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[i], i = 0;
    } else if (t.parentNode && !ac(t))
      i = Cn(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class Ct {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new Ct(e.parentNode, Cn(e), t);
  }
  static after(e, t) {
    return new Ct(e.parentNode, Cn(e) + 1, t);
  }
}
const Np = [];
class Ne {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, n = null, r;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (r = n ? n.nextSibling : i.firstChild)) {
            let o = Ne.get(r);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(r);
          }
          a.sync(e, t), a.flags &= -8;
        }
        if (r = n ? n.nextSibling : i.firstChild, t && !t.written && t.node == i && r != a.dom && (t.written = !0), a.dom.parentNode == i)
          for (; r && r != a.dom; )
            r = mO(r);
        else
          i.insertBefore(a.dom, r);
        n = a.dom;
      }
      for (r = n ? n.nextSibling : i.firstChild, r && t && t.node == i && (t.written = !0); r; )
        r = mO(r);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let n = ts(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let r = e.parentNode;
        if (r == this.dom)
          break;
        n == 0 && r.firstChild != r.lastChild && (e == r.firstChild ? n = -1 : n = 1), e = r;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ne.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, r = 0; ; n++) {
      let a = this.children[n];
      if (a.dom == i)
        return r;
      r += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let n = -1, r = -1, a = -1, o = -1;
    for (let l = 0, c = i, h = i; l < this.children.length; l++) {
      let u = this.children[l], d = c + u.length;
      if (c < e && d > t)
        return u.domBoundsAround(e, t, c);
      if (d >= e && n == -1 && (n = l, r = c), c > t && u.dom.parentNode == this.dom) {
        a = l, o = h;
        break;
      }
      h = d, c = d + u.breakAfter;
    }
    return {
      from: r,
      to: o < 0 ? i + this.length : o,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = Np) {
    this.markDirty();
    for (let n = e; n < t; n++) {
      let r = this.children[n];
      r.parent == this && i.indexOf(r) < 0 && r.destroy();
    }
    i.length < 250 ? this.children.splice(e, t - e, ...i) : this.children = [].concat(this.children.slice(0, e), i, this.children.slice(t));
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new Jv(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, n, r, a) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Ne.prototype.breakAfter = 0;
function mO(s) {
  let e = s.nextSibling;
  return s.parentNode.removeChild(s), e;
}
class Jv {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function ew(s, e, t, i, n, r, a, o, l) {
  let { children: c } = s, h = c.length ? c[e] : null, u = r.length ? r[r.length - 1] : null, d = u ? u.breakAfter : a;
  if (!(e == i && h && !a && !d && r.length < 2 && h.merge(t, n, r.length ? u : null, t == 0, o, l))) {
    if (i < c.length) {
      let f = c[i];
      f && (n < f.length || f.breakAfter && u?.breakAfter) ? (e == i && (f = f.split(n), n = 0), !d && u && f.merge(0, n, u, !0, 0, l) ? r[r.length - 1] = f : ((n || f.children.length && !f.children[0].length) && f.merge(0, n, null, !1, 0, l), r.push(f))) : f?.breakAfter && (u ? u.breakAfter = 1 : a = 1), i++;
    }
    for (h && (h.breakAfter = a, t > 0 && (!a && r.length && h.merge(t, h.length, r[0], !1, o, 0) ? h.breakAfter = r.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, o, 0), e++)); e < i && r.length; )
      if (c[i - 1].become(r[r.length - 1]))
        i--, r.pop(), l = r.length ? 0 : o;
      else if (c[e].become(r[0]))
        e++, r.shift(), o = r.length ? 0 : l;
      else
        break;
    !r.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, o, l) && e--, (e < i || r.length) && s.replaceChildren(e, i, r);
  }
}
function tw(s, e, t, i, n, r) {
  let a = s.childCursor(), { i: o, off: l } = a.findPos(t, 1), { i: c, off: h } = a.findPos(e, -1), u = e - t;
  for (let d of i)
    u += d.length;
  s.length += u, ew(s, c, h, o, l, i, 0, n, r);
}
let qt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, sf = typeof document < "u" ? document : { documentElement: { style: {} } };
const nf = /* @__PURE__ */ /Edge\/(\d+)/.exec(qt.userAgent), iw = /* @__PURE__ */ /MSIE \d/.test(qt.userAgent), rf = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(qt.userAgent), Jc = !!(iw || rf || nf), OO = !Jc && /* @__PURE__ */ /gecko\/(\d+)/i.test(qt.userAgent), iu = !Jc && /* @__PURE__ */ /Chrome\/(\d+)/.exec(qt.userAgent), ZR = "webkitFontSmoothing" in sf.documentElement.style, sw = !Jc && /* @__PURE__ */ /Apple Computer/.test(qt.vendor), xO = sw && (/* @__PURE__ */ /Mobile\/\w+/.test(qt.userAgent) || qt.maxTouchPoints > 2);
var ne = {
  mac: xO || /* @__PURE__ */ /Mac/.test(qt.platform),
  windows: /* @__PURE__ */ /Win/.test(qt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(qt.platform),
  ie: Jc,
  ie_version: iw ? sf.documentMode || 6 : rf ? +rf[1] : nf ? +nf[1] : 0,
  gecko: OO,
  gecko_version: OO ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(qt.userAgent) || [0, 0])[1] : 0,
  chrome: !!iu,
  chrome_version: iu ? +iu[1] : 0,
  ios: xO,
  android: /* @__PURE__ */ /Android\b/.test(qt.userAgent),
  safari: sw,
  webkit_version: ZR ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(qt.userAgent) || [0, 0])[1] : 0,
  tabSize: sf.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const NR = 256;
class $i extends Ne {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof $i) || this.length - (t - e) + i.length > NR || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new $i(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Ct(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return VR(this.dom, e, t);
  }
}
class ws extends Ne {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let n of t)
      n.setParent(this);
  }
  setAttrs(e) {
    if (Hv(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, n, r, a) {
    return i && (!(i instanceof ws && i.mark.eq(this.mark)) || e && r <= 0 || t < this.length && a <= 0) ? !1 : (tw(this, e, t, i ? i.children.slice() : [], r - 1, a - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, n = -1, r = 0;
    for (let o of this.children) {
      let l = i + o.length;
      l > e && t.push(i < e ? o.split(e - i) : o), n < 0 && i >= e && (n = r), i = l, r++;
    }
    let a = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new ws(this.mark, t, a);
  }
  domAtPos(e) {
    return nw(this, e);
  }
  coordsAt(e, t) {
    return aw(this, e, t);
  }
}
function VR(s, e, t) {
  let i = s.nodeValue.length;
  e > i && (e = i);
  let n = e, r = e, a = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? ne.chrome || ne.gecko || (e ? (n--, a = 1) : r < i && (r++, a = -1)) : t < 0 ? n-- : r < i && r++;
  let o = An(s, n, r).getClientRects();
  if (!o.length)
    return null;
  let l = o[(a ? a < 0 : t >= 0) ? 0 : o.length - 1];
  return ne.safari && !a && l.width == 0 && (l = Array.prototype.find.call(o, (c) => c.width) || l), a ? Kc(l, a < 0) : l || null;
}
class Ms extends Ne {
  static create(e, t, i) {
    return new Ms(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let t = Ms.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, n, r, a) {
    return i && (!(i instanceof Ms) || !this.widget.compare(i.widget) || e > 0 && r <= 0 || t < this.length && a <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Ms && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return $e.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : $e.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Ct.before(this.dom) : Ct.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let n = this.dom.getClientRects(), r = null;
    if (!n.length)
      return null;
    let a = this.side ? this.side < 0 : e > 0;
    for (let o = a ? n.length - 1 : 0; r = n[o], !(e > 0 ? o == 0 : o == n.length - 1 || r.top < r.bottom); o += a ? -1 : 1)
      ;
    return Kc(r, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class dr extends Ne {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof dr && e.side == this.side;
  }
  split() {
    return new dr(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Ct.before(this.dom) : Ct.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return $e.empty;
  }
  get isHidden() {
    return !0;
  }
}
$i.prototype.children = Ms.prototype.children = dr.prototype.children = Np;
function nw(s, e) {
  let t = s.dom, { children: i } = s, n = 0;
  for (let r = 0; n < i.length; n++) {
    let a = i[n], o = r + a.length;
    if (!(o == r && a.getSide() <= 0)) {
      if (e > r && e < o && a.dom.parentNode == t)
        return a.domAtPos(e - r);
      if (e <= r)
        break;
      r = o;
    }
  }
  for (let r = n; r > 0; r--) {
    let a = i[r - 1];
    if (a.dom.parentNode == t)
      return a.domAtPos(a.length);
  }
  for (let r = n; r < i.length; r++) {
    let a = i[r];
    if (a.dom.parentNode == t)
      return a.domAtPos(0);
  }
  return new Ct(t, 0);
}
function rw(s, e, t) {
  let i, { children: n } = s;
  t > 0 && e instanceof ws && n.length && (i = n[n.length - 1]) instanceof ws && i.mark.eq(e.mark) ? rw(i, e.children[0], t - 1) : (n.push(e), e.setParent(s)), s.length += e.length;
}
function aw(s, e, t) {
  let i = null, n = -1, r = null, a = -1;
  function o(c, h) {
    for (let u = 0, d = 0; u < c.children.length && d <= h; u++) {
      let f = c.children[u], p = d + f.length;
      p >= h && (f.children.length ? o(f, h - d) : (!r || r.isHidden && (t > 0 || jR(r, f))) && (p > h || d == p && f.getSide() > 0) ? (r = f, a = h - d) : (d < h || d == p && f.getSide() < 0 && !f.isHidden) && (i = f, n = h - d)), d = p;
    }
  }
  o(s, e);
  let l = (t < 0 ? i : r) || i || r;
  return l ? l.coordsAt(Math.max(0, l == i ? n : a), t) : FR(s);
}
function FR(s) {
  let e = s.dom.lastChild;
  if (!e)
    return s.dom.getBoundingClientRect();
  let t = La(e);
  return t[t.length - 1] || null;
}
function jR(s, e) {
  let t = s.coordsAt(0, 1), i = e.coordsAt(0, 1);
  return t && i && i.top < t.bottom;
}
function af(s, e) {
  for (let t in s)
    t == "class" && e.class ? e.class += " " + s.class : t == "style" && e.style ? e.style += ";" + s.style : e[t] = s[t];
  return e;
}
const bO = /* @__PURE__ */ Object.create(null);
function oc(s, e, t) {
  if (s == e)
    return !0;
  s || (s = bO), e || (e = bO);
  let i = Object.keys(s), n = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != n.length - (t && n.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let r of i)
    if (r != t && (n.indexOf(r) == -1 || s[r] !== e[r]))
      return !1;
  return !0;
}
function of(s, e, t) {
  let i = !1;
  if (e)
    for (let n in e)
      t && n in t || (i = !0, n == "style" ? s.style.cssText = "" : s.removeAttribute(n));
  if (t)
    for (let n in t)
      e && e[n] == t[n] || (i = !0, n == "style" ? s.style.cssText = t[n] : s.setAttribute(n, t[n]));
  return i;
}
function HR(s) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < s.attributes.length; t++) {
    let i = s.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class As {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Xt = /* @__PURE__ */ function(s) {
  return s[s.Text = 0] = "Text", s[s.WidgetBefore = 1] = "WidgetBefore", s[s.WidgetAfter = 2] = "WidgetAfter", s[s.WidgetRange = 3] = "WidgetRange", s;
}(Xt || (Xt = {}));
class de extends Qn {
  constructor(e, t, i, n) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new xo(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Ns(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: r, end: a } = ow(e, t);
      i = (r ? t ? -3e8 : -1 : 5e8) - 1, n = (a ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Ns(e, i, n, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new bo(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Xe.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
de.none = Xe.empty;
class xo extends de {
  constructor(e) {
    let { start: t, end: i } = ow(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof xo && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && oc(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
xo.prototype.point = !1;
class bo extends de {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof bo && this.spec.class == e.spec.class && oc(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
bo.prototype.mapMode = yt.TrackBefore;
bo.prototype.point = !0;
class Ns extends de {
  constructor(e, t, i, n, r, a) {
    super(t, i, r, e), this.block = n, this.isReplace = a, this.mapMode = n ? t <= 0 ? yt.TrackBefore : yt.TrackAfter : yt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Xt.WidgetRange : this.startSide <= 0 ? Xt.WidgetBefore : Xt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Ns && UR(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Ns.prototype.point = !0;
function ow(s, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = s;
  return t == null && (t = s.inclusive), i == null && (i = s.inclusive), { start: t ?? e, end: i ?? e };
}
function UR(s, e) {
  return s == e || !!(s && e && s.compare(e));
}
function Ql(s, e, t, i = 0) {
  let n = t.length - 1;
  n >= 0 && t[n] + i >= s ? t[n] = Math.max(t[n], e) : t.push(s, e);
}
class at extends Ne {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, n, r, a) {
    if (i) {
      if (!(i instanceof at))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), tw(this, e, t, i ? i.children.slice() : [], r, a), !0;
  }
  split(e) {
    let t = new at();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: n } = this.childPos(e);
    n && (t.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let r = i; r < this.children.length; r++)
      t.append(this.children[r], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    oc(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    rw(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = af(t, this.attrs || {})), i && (this.attrs = af({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return nw(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (Hv(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (of(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let n = this.dom.lastChild;
    for (; n && Ne.get(n) instanceof ws; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = Ne.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!ne.ios || !this.children.some((r) => r instanceof $i))) {
      let r = document.createElement("BR");
      r.cmIgnore = !0, this.dom.appendChild(r);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof $i) || /[^ -~]/.test(i.text))
        return null;
      let n = La(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, t = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = aw(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, r = i.bottom - i.top;
      if (Math.abs(r - n.lineHeight) < 2 && n.textHeight < r) {
        let a = (r - n.textHeight) / 2;
        return { top: i.top + a, bottom: i.bottom - a, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return e instanceof at && this.children.length == 0 && e.children.length == 0 && oc(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let r = e.children[i], a = n + r.length;
      if (a >= t) {
        if (r instanceof at)
          return r;
        if (a > t)
          break;
      }
      n = a + r.breakAfter;
    }
    return null;
  }
}
class xs extends Ne {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, n, r, a) {
    return i && (!(i instanceof xs) || !this.widget.compare(i.widget) || e > 0 && r <= 0 || t < this.length && a <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Ct.before(this.dom) : Ct.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new xs(this.widget, t, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return Np;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : $e.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof xs && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    return i || (this.widget instanceof lf ? null : Kc(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: i } = this.deco;
    return t == i ? !1 : e < 0 ? t < 0 : i > 0;
  }
}
class lf extends As {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class ga {
  constructor(e, t, i, n) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof xs && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new at()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Do(new dr(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof xs) && this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: r, lineBreak: a, done: o } = this.cursor.next(this.skip);
        if (this.skip = 0, o)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = r, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(Do(new $i(this.text.slice(this.textOff, this.textOff + n)), t), i), this.atCursorPos = !0, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, t, i, n) {
    this.buildText(t - e, i, n), this.pos = t, this.openStart < 0 && (this.openStart = n);
  }
  point(e, t, i, n, r, a) {
    if (this.disallowBlockEffectsFor[a] && i instanceof Ns) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = t - e;
    if (i instanceof Ns)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new xs(i.widget || fr.block, o, i));
      else {
        let l = Ms.create(i.widget || fr.inline, o, o ? 0 : i.startSide), c = this.atCursorPos && !l.isEditable && r <= n.length && (e < t || i.startSide > 0), h = !l.isEditable && (e < t || r > n.length || i.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), c && (u.append(Do(new dr(1), n), r), r = n.length + Math.max(0, r - n.length)), u.append(Do(l, n), r), this.atCursorPos = h, this.pendingBuffer = h ? e < t || r > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = r);
  }
  static build(e, t, i, n, r) {
    let a = new ga(e, t, i, r);
    return a.openEnd = Xe.spans(n, t, i, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}
function Do(s, e) {
  for (let t of e)
    s = new ws(t, [s], s.length);
  return s;
}
class fr extends As {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
fr.inline = /* @__PURE__ */ new fr("span");
fr.block = /* @__PURE__ */ new fr("div");
var Ge = /* @__PURE__ */ function(s) {
  return s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL", s;
}(Ge || (Ge = {}));
const Tn = Ge.LTR, Vp = Ge.RTL;
function lw(s) {
  let e = [];
  for (let t = 0; t < s.length; t++)
    e.push(1 << +s[t]);
  return e;
}
const GR = /* @__PURE__ */ lw("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), KR = /* @__PURE__ */ lw("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), cf = /* @__PURE__ */ Object.create(null), qi = [];
for (let s of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ s.charCodeAt(0), t = /* @__PURE__ */ s.charCodeAt(1);
  cf[e] = t, cf[t] = -e;
}
function cw(s) {
  return s <= 247 ? GR[s] : 1424 <= s && s <= 1524 ? 2 : 1536 <= s && s <= 1785 ? KR[s - 1536] : 1774 <= s && s <= 2220 ? 4 : 8192 <= s && s <= 8204 ? 256 : 64336 <= s && s <= 65023 ? 4 : 1;
}
const JR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class _s {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Vp : Tn;
  }
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, i, n) {
    let r = -1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      if (o.from <= t && o.to >= t) {
        if (o.level == i)
          return a;
        (r < 0 || (n != 0 ? n < 0 ? o.from < t : o.to > t : e[r].level > o.level)) && (r = a);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
}
function hw(s, e) {
  if (s.length != e.length)
    return !1;
  for (let t = 0; t < s.length; t++) {
    let i = s[t], n = e[t];
    if (i.from != n.from || i.to != n.to || i.direction != n.direction || !hw(i.inner, n.inner))
      return !1;
  }
  return !0;
}
const Ye = [];
function eE(s, e, t, i, n) {
  for (let r = 0; r <= i.length; r++) {
    let a = r ? i[r - 1].to : e, o = r < i.length ? i[r].from : t, l = r ? 256 : n;
    for (let c = a, h = l, u = l; c < o; c++) {
      let d = cw(s.charCodeAt(c));
      d == 512 ? d = h : d == 8 && u == 4 && (d = 16), Ye[c] = d == 4 ? 2 : d, d & 7 && (u = d), h = d;
    }
    for (let c = a, h = l, u = l; c < o; c++) {
      let d = Ye[c];
      if (d == 128)
        c < o - 1 && h == Ye[c + 1] && h & 24 ? d = Ye[c] = h : Ye[c] = 256;
      else if (d == 64) {
        let f = c + 1;
        for (; f < o && Ye[f] == 64; )
          f++;
        let p = c && h == 8 || f < t && Ye[f] == 8 ? u == 1 ? 1 : 8 : 256;
        for (let g = c; g < f; g++)
          Ye[g] = p;
        c = f - 1;
      } else d == 8 && u == 1 && (Ye[c] = 1);
      h = d, d & 7 && (u = d);
    }
  }
}
function tE(s, e, t, i, n) {
  let r = n == 1 ? 2 : 1;
  for (let a = 0, o = 0, l = 0; a <= i.length; a++) {
    let c = a ? i[a - 1].to : e, h = a < i.length ? i[a].from : t;
    for (let u = c, d, f, p; u < h; u++)
      if (f = cf[d = s.charCodeAt(u)])
        if (f < 0) {
          for (let g = o - 3; g >= 0; g -= 3)
            if (qi[g + 1] == -f) {
              let m = qi[g + 2], O = m & 2 ? n : m & 4 ? m & 1 ? r : n : 0;
              O && (Ye[u] = Ye[qi[g]] = O), o = g;
              break;
            }
        } else {
          if (qi.length == 189)
            break;
          qi[o++] = u, qi[o++] = d, qi[o++] = l;
        }
      else if ((p = Ye[u]) == 2 || p == 1) {
        let g = p == n;
        l = g ? 0 : 1;
        for (let m = o - 3; m >= 0; m -= 3) {
          let O = qi[m + 2];
          if (O & 2)
            break;
          if (g)
            qi[m + 2] |= 2;
          else {
            if (O & 4)
              break;
            qi[m + 2] |= 4;
          }
        }
      }
  }
}
function iE(s, e, t, i) {
  for (let n = 0, r = i; n <= t.length; n++) {
    let a = n ? t[n - 1].to : s, o = n < t.length ? t[n].from : e;
    for (let l = a; l < o; ) {
      let c = Ye[l];
      if (c == 256) {
        let h = l + 1;
        for (; ; )
          if (h == o) {
            if (n == t.length)
              break;
            h = t[n++].to, o = n < t.length ? t[n].from : e;
          } else if (Ye[h] == 256)
            h++;
          else
            break;
        let u = r == 1, d = (h < e ? Ye[h] : i) == 1, f = u == d ? u ? 1 : 2 : i;
        for (let p = h, g = n, m = g ? t[g - 1].to : s; p > l; )
          p == m && (p = t[--g].from, m = g ? t[g - 1].to : s), Ye[--p] = f;
        l = h;
      } else
        r = c, l++;
    }
  }
}
function hf(s, e, t, i, n, r, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == n % 2)
    for (let l = e, c = 0; l < t; ) {
      let h = !0, u = !1;
      if (c == r.length || l < r[c].from) {
        let g = Ye[l];
        g != o && (h = !1, u = g == 16);
      }
      let d = !h && o == 1 ? [] : null, f = h ? i : i + 1, p = l;
      e: for (; ; )
        if (c < r.length && p == r[c].from) {
          if (u)
            break e;
          let g = r[c];
          if (!h)
            for (let m = g.to, O = c + 1; ; ) {
              if (m == t)
                break e;
              if (O < r.length && r[O].from == m)
                m = r[O++].to;
              else {
                if (Ye[m] == o)
                  break e;
                break;
              }
            }
          if (c++, d)
            d.push(g);
          else {
            g.from > l && a.push(new _s(l, g.from, f));
            let m = g.direction == Tn != !(f % 2);
            uf(s, m ? i + 1 : i, n, g.inner, g.from, g.to, a), l = g.to;
          }
          p = g.to;
        } else {
          if (p == t || (h ? Ye[p] != o : Ye[p] == o))
            break;
          p++;
        }
      d ? hf(s, l, p, i + 1, n, d, a) : l < p && a.push(new _s(l, p, f)), l = p;
    }
  else
    for (let l = t, c = r.length; l > e; ) {
      let h = !0, u = !1;
      if (!c || l > r[c - 1].to) {
        let g = Ye[l - 1];
        g != o && (h = !1, u = g == 16);
      }
      let d = !h && o == 1 ? [] : null, f = h ? i : i + 1, p = l;
      e: for (; ; )
        if (c && p == r[c - 1].to) {
          if (u)
            break e;
          let g = r[--c];
          if (!h)
            for (let m = g.from, O = c; ; ) {
              if (m == e)
                break e;
              if (O && r[O - 1].to == m)
                m = r[--O].from;
              else {
                if (Ye[m - 1] == o)
                  break e;
                break;
              }
            }
          if (d)
            d.push(g);
          else {
            g.to < l && a.push(new _s(g.to, l, f));
            let m = g.direction == Tn != !(f % 2);
            uf(s, m ? i + 1 : i, n, g.inner, g.from, g.to, a), l = g.from;
          }
          p = g.from;
        } else {
          if (p == e || (h ? Ye[p - 1] != o : Ye[p - 1] == o))
            break;
          p--;
        }
      d ? hf(s, p, l, i + 1, n, d, a) : p < l && a.push(new _s(p, l, f)), l = p;
    }
}
function uf(s, e, t, i, n, r, a) {
  let o = e % 2 ? 2 : 1;
  eE(s, n, r, i, o), tE(s, n, r, i, o), iE(n, r, i, o), hf(s, n, r, e, t, i, a);
}
function sE(s, e, t) {
  if (!s)
    return [new _s(0, 0, e == Vp ? 1 : 0)];
  if (e == Tn && !t.length && !JR.test(s))
    return uw(s.length);
  if (t.length)
    for (; s.length > Ye.length; )
      Ye[Ye.length] = 256;
  let i = [], n = e == Tn ? 0 : 1;
  return uf(s, n, n, t, 0, s.length, i), i;
}
function uw(s) {
  return [new _s(0, s, 0)];
}
let dw = "";
function nE(s, e, t, i, n) {
  var r;
  let a = i.head - s.from, o = _s.find(e, a, (r = i.bidiLevel) !== null && r !== void 0 ? r : -1, i.assoc), l = e[o], c = l.side(n, t);
  if (a == c) {
    let d = o += n ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[o = d], a = l.side(!n, t), c = l.side(n, t);
  }
  let h = wt(s.text, a, l.forward(n, t));
  (h < l.from || h > l.to) && (h = c), dw = s.text.slice(Math.min(a, h), Math.max(a, h));
  let u = o == (n ? e.length - 1 : 0) ? null : e[o + (n ? 1 : -1)];
  return u && h == c && u.level + (n ? 0 : 1) < l.level ? D.cursor(u.side(!n, t) + s.from, u.forward(n, t) ? 1 : -1, u.level) : D.cursor(h + s.from, l.forward(n, t) ? -1 : 1, l.level);
}
function rE(s, e, t) {
  for (let i = e; i < t; i++) {
    let n = cw(s.charCodeAt(i));
    if (n == 1)
      return Tn;
    if (n == 2 || n == 4)
      return Vp;
  }
  return Tn;
}
const fw = /* @__PURE__ */ se.define(), pw = /* @__PURE__ */ se.define(), gw = /* @__PURE__ */ se.define(), mw = /* @__PURE__ */ se.define(), df = /* @__PURE__ */ se.define(), Ow = /* @__PURE__ */ se.define(), xw = /* @__PURE__ */ se.define(), Fp = /* @__PURE__ */ se.define(), jp = /* @__PURE__ */ se.define(), bw = /* @__PURE__ */ se.define({
  combine: (s) => s.some((e) => e)
}), yw = /* @__PURE__ */ se.define({
  combine: (s) => s.some((e) => e)
}), vw = /* @__PURE__ */ se.define();
class sr {
  constructor(e, t = "nearest", i = "nearest", n = 5, r = 5, a = !1) {
    this.range = e, this.y = t, this.x = i, this.yMargin = n, this.xMargin = r, this.isSnapshot = a;
  }
  map(e) {
    return e.empty ? this : new sr(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new sr(D.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Bo = /* @__PURE__ */ xe.define({ map: (s, e) => s.map(e) }), ww = /* @__PURE__ */ xe.define();
function Bt(s, e, t) {
  let i = s.facet(mw);
  i.length ? i[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const ps = /* @__PURE__ */ se.define({ combine: (s) => s.length ? s[0] : !0 });
let aE = 0;
const Un = /* @__PURE__ */ se.define({
  combine(s) {
    return s.filter((e, t) => {
      for (let i = 0; i < t; i++)
        if (s[i].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class ct {
  constructor(e, t, i, n, r) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.domEventObservers = n, this.baseExtensions = r(this), this.extension = this.baseExtensions.concat(Un.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Un.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, eventObservers: n, provide: r, decorations: a } = t || {};
    return new ct(aE++, e, i, n, (o) => {
      let l = [];
      return a && l.push(za.of((c) => {
        let h = c.plugin(o);
        return h ? a(h) : de.none;
      })), r && l.push(r(o)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return ct.define((i, n) => new e(i, n), t);
  }
}
class su {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (Bt(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        Bt(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Bt(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Sw = /* @__PURE__ */ se.define(), Hp = /* @__PURE__ */ se.define(), za = /* @__PURE__ */ se.define(), kw = /* @__PURE__ */ se.define(), Up = /* @__PURE__ */ se.define(), Pw = /* @__PURE__ */ se.define();
function yO(s, e) {
  let t = s.state.facet(Pw);
  if (!t.length)
    return t;
  let i = t.map((r) => r instanceof Function ? r(s) : r), n = [];
  return Xe.spans(i, e.from, e.to, {
    point() {
    },
    span(r, a, o, l) {
      let c = r - e.from, h = a - e.from, u = n;
      for (let d = o.length - 1; d >= 0; d--, l--) {
        let f = o[d].spec.bidiIsolate, p;
        if (f == null && (f = rE(e.text, c, h)), l > 0 && u.length && (p = u[u.length - 1]).to == c && p.direction == f)
          p.to = h, u = p.inner;
        else {
          let g = { from: c, to: h, direction: f, inner: [] };
          u.push(g), u = g.inner;
        }
      }
    }
  }), n;
}
const Qw = /* @__PURE__ */ se.define();
function Gp(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let r of s.state.facet(Qw)) {
    let a = r(s);
    a && (a.left != null && (e = Math.max(e, a.left)), a.right != null && (t = Math.max(t, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (n = Math.max(n, a.bottom)));
  }
  return { left: e, right: t, top: i, bottom: n };
}
const sa = /* @__PURE__ */ se.define();
class gi {
  constructor(e, t, i, n) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new gi(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let n = e[t - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let n = 0, r = 0, a = 0, o = 0; ; n++) {
      let l = n == e.length ? null : e[n], c = a - o, h = l ? l.fromB : 1e9;
      for (; r < t.length && t[r] < h; ) {
        let u = t[r], d = t[r + 1], f = Math.max(o, u), p = Math.min(h, d);
        if (f <= p && new gi(f + c, p + c, f, p).addToSet(i), d > h)
          break;
        r += 2;
      }
      if (!l)
        return i;
      new gi(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), a = l.toA, o = l.toB;
    }
  }
}
class lc {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = ut.empty(this.startState.doc.length);
    for (let r of i)
      this.changes = this.changes.compose(r.changes);
    let n = [];
    this.changes.iterChangedRanges((r, a, o, l) => n.push(new gi(r, a, o, l))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new lc(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class vO extends Ne {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = de.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new at()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new gi(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let n = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? n = this.domChanged.newSel.head : !fE(e.changes, this.hasComposition) && !e.selectionSet && (n = e.state.selection.main.head));
    let r = n > -1 ? lE(this.view, e.changes, n) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      i = new gi(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(i.slice());
    }
    this.hasComposition = r ? { from: r.range.fromB, to: r.range.toB } : null, (ne.ie || ne.chrome) && !r && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.updateDeco(), l = uE(a, o, e.changes);
    return i = gi.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, r), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = ne.chrome || ne.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || n.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let r = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof xs && a.widget instanceof lf && r.push(a.dom);
    n.updateGaps(r);
  }
  updateChildren(e, t, i) {
    let n = i ? i.range.addToSet(e.slice()) : e, r = this.childCursor(t);
    for (let a = n.length - 1; ; a--) {
      let o = a >= 0 ? n[a] : null;
      if (!o)
        break;
      let { fromA: l, toA: c, fromB: h, toB: u } = o, d, f, p, g;
      if (i && i.range.fromB < u && i.range.toB > h) {
        let v = ga.build(this.view.state.doc, h, i.range.fromB, this.decorations, this.dynamicDecorationMap), y = ga.build(this.view.state.doc, i.range.toB, u, this.decorations, this.dynamicDecorationMap);
        f = v.breakAtStart, p = v.openStart, g = y.openEnd;
        let w = this.compositionView(i);
        y.breakAtStart ? w.breakAfter = 1 : y.content.length && w.merge(w.length, w.length, y.content[0], !1, y.openStart, 0) && (w.breakAfter = y.content[0].breakAfter, y.content.shift()), v.content.length && w.merge(0, 0, v.content[v.content.length - 1], !0, 0, v.openEnd) && v.content.pop(), d = v.content.concat(w).concat(y.content);
      } else
        ({ content: d, breakAtStart: f, openStart: p, openEnd: g } = ga.build(this.view.state.doc, h, u, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: O } = r.findPos(c, 1), { i: x, off: b } = r.findPos(l, -1);
      ew(this, x, b, m, O, d, f, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(ww) && (this.editContextFormatting = i.value);
  }
  compositionView(e) {
    let t = new $i(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: n } of e.marks)
      t = new ws(n, [t], t.length);
    let i = new at();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (r, a) => {
      a.flags |= 8 | (a.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let o = Ne.get(r);
      o && o != a && (o.dom = null), a.setDOM(r);
    }, i = this.childPos(e.range.fromB, 1), n = this.children[i.i];
    t(e.line, n);
    for (let r = e.marks.length - 1; r >= -1; r--)
      i = n.childPos(i.off, 1), n = n.children[i.i], t(r >= 0 ? e.marks[r].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, n = i == this.dom, r = !n && !(this.view.state.facet(ps) || this.dom.tabIndex > -1) && Pl(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(n || t || r))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let o = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(o.anchor)), c = o.empty ? l : this.moveToLine(this.domAtPos(o.head));
    if (ne.gecko && o.empty && !this.hasComposition && oE(l)) {
      let u = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(u, l.node.childNodes[l.offset] || null)), l = c = new Ct(u, 0), a = !0;
    }
    let h = this.view.observer.selectionRange;
    (a || !h.focusNode || (!pa(l.node, l.offset, h.anchorNode, h.anchorOffset) || !pa(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, o)) && (this.view.observer.ignore(() => {
      ne.android && ne.chrome && this.dom.contains(h.focusNode) && dE(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let u = _a(this.view.root);
      if (u) if (o.empty) {
        if (ne.gecko) {
          let d = cE(l.node, l.offset);
          if (d && d != 3) {
            let f = (d == 1 ? Gv : Kv)(l.node, l.offset);
            f && (l = new Ct(f.node, f.offset));
          }
        }
        u.collapse(l.node, l.offset), o.bidiLevel != null && u.caretBidiLevel !== void 0 && (u.caretBidiLevel = o.bidiLevel);
      } else if (u.extend) {
        u.collapse(l.node, l.offset);
        try {
          u.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        o.anchor > o.head && ([l, c] = [c, l]), d.setEnd(c.node, c.offset), d.setStart(l.node, l.offset), u.removeAllRanges(), u.addRange(d);
      }
      r && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new Ct(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new Ct(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && pa(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = _a(e.root), { anchorNode: n, anchorOffset: r } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let a = at.find(this, t.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (t.head == o || t.head == o + a.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    i.collapse(h.node, h.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && i.collapse(n, r);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, i;
    if (e.node != t)
      return e;
    for (let n = e.offset; !i && n < t.childNodes.length; n++) {
      let r = Ne.get(t.childNodes[n]);
      r instanceof at && (i = r.domAtPos(0));
    }
    for (let n = e.offset - 1; !i && n >= 0; n--) {
      let r = Ne.get(t.childNodes[n]);
      r instanceof at && (i = r.domAtPos(r.length));
    }
    return i ? new Ct(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = Ne.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let n = this.children[t];
      if (i < n.length || n instanceof at)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    let i = null, n = 0;
    for (let r = this.length, a = this.children.length - 1; a >= 0; a--) {
      let o = this.children[a], l = r - o.breakAfter, c = l - o.length;
      if (l < e)
        break;
      if (c <= e && (c < e || o.covers(-1)) && (l > e || o.covers(1)) && (!i || o instanceof at && !(i instanceof at && t >= 0)))
        i = o, n = c;
      else if (i && c == e && l == e && o instanceof xs && Math.abs(t) < 2) {
        if (o.deco.startSide < 0)
          break;
        a && (i = null);
      }
      r = c;
    }
    return i ? i.coordsAt(e - n, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), n = this.children[t];
    if (!(n instanceof at))
      return null;
    for (; n.children.length; ) {
      let { i: o, off: l } = n.childPos(i, 1);
      for (; ; o++) {
        if (o == n.children.length)
          return null;
        if ((n = n.children[o]).length)
          break;
      }
      i = l;
    }
    if (!(n instanceof $i))
      return null;
    let r = wt(n.text, i);
    if (r == i)
      return null;
    let a = An(n.dom, i, r).getClientRects();
    for (let o = 0; o < a.length; o++) {
      let l = a[o];
      if (o == a.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: n } = e, r = this.view.contentDOM.clientWidth, a = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, l = this.view.textDirection == Ge.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let u = this.children[h], d = c + u.length;
      if (d > n)
        break;
      if (c >= i) {
        let f = u.dom.getBoundingClientRect();
        if (t.push(f.height), a) {
          let p = u.dom.lastChild, g = p ? La(p) : [];
          if (g.length) {
            let m = g[g.length - 1], O = l ? m.right - f.left : f.right - m.left;
            O > o && (o = O, this.minWidth = r, this.minWidthFrom = c, this.minWidthTo = d);
          }
        }
      }
      c = d + u.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Ge.RTL : Ge.LTR;
  }
  measureTextSize() {
    for (let r of this.children)
      if (r instanceof at) {
        let a = r.measureTextSize();
        if (a)
          return a;
      }
    let e = document.createElement("div"), t, i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let r = La(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = r ? r.width / 27 : 7, n = r ? r.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: n };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new Jv(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let r = n == t.viewports.length ? null : t.viewports[n], a = r ? r.from - 1 : this.length;
      if (a > i) {
        let o = (t.lineBlockAt(a).bottom - t.lineBlockAt(i).top) / this.view.scaleY;
        e.push(de.replace({
          widget: new lf(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!r)
        break;
      i = r.to + 1;
    }
    return de.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(za).map((r) => (this.dynamicDecorationMap[e++] = typeof r == "function") ? r(this.view) : r), i = !1, n = this.view.state.facet(kw).map((r, a) => {
      let o = typeof r == "function";
      return o && (i = !0), o ? r(this.view) : r;
    });
    for (n.length && (this.dynamicDecorationMap[e++] = i, t.push(Xe.join(n))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(vw))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (h) {
        Bt(this.view.state, h, "scroll handler");
      }
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), n;
    if (!i)
      return;
    !t.empty && (n = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let r = Gp(this.view), a = {
      left: i.left - r.left,
      top: i.top - r.top,
      right: i.right + r.right,
      bottom: i.bottom + r.bottom
    }, { offsetWidth: o, offsetHeight: l } = this.view.scrollDOM;
    qR(this.view.scrollDOM, a, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, o), -o), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Ge.LTR);
  }
}
function oE(s) {
  return s.node.nodeType == 1 && s.node.firstChild && (s.offset == 0 || s.node.childNodes[s.offset - 1].contentEditable == "false") && (s.offset == s.node.childNodes.length || s.node.childNodes[s.offset].contentEditable == "false");
}
function Cw(s, e) {
  let t = s.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let i = Gv(t.focusNode, t.focusOffset), n = Kv(t.focusNode, t.focusOffset), r = i || n;
  if (n && i && n.node != i.node) {
    let o = Ne.get(n.node);
    if (!o || o instanceof $i && o.text != n.node.nodeValue)
      r = n;
    else if (s.docView.lastCompositionAfterCursor) {
      let l = Ne.get(i.node);
      !l || l instanceof $i && l.text != i.node.nodeValue || (r = n);
    }
  }
  if (s.docView.lastCompositionAfterCursor = r != i, !r)
    return null;
  let a = e - r.offset;
  return { from: a, to: a + r.node.nodeValue.length, node: r.node };
}
function lE(s, e, t) {
  let i = Cw(s, t);
  if (!i)
    return null;
  let { node: n, from: r, to: a } = i, o = n.nodeValue;
  if (/[\n\r]/.test(o) || s.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let l = e.invertedDesc, c = new gi(l.mapPos(r), l.mapPos(a), r, a), h = [];
  for (let u = n.parentNode; ; u = u.parentNode) {
    let d = Ne.get(u);
    if (d instanceof ws)
      h.push({ node: u, deco: d.mark });
    else {
      if (d instanceof at || u.nodeName == "DIV" && u.parentNode == s.contentDOM)
        return { range: c, text: n, marks: h, line: u };
      if (u != s.contentDOM)
        h.push({ node: u, deco: new xo({
          inclusive: !0,
          attributes: HR(u),
          tagName: u.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function cE(s, e) {
  return s.nodeType != 1 ? 0 : (e && s.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < s.childNodes.length && s.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let hE = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Ql(e, t, this.changes);
  }
  comparePoint(e, t) {
    Ql(e, t, this.changes);
  }
  boundChange(e) {
    Ql(e, e, this.changes);
  }
};
function uE(s, e, t) {
  let i = new hE();
  return Xe.compare(s, e, t, i), i.changes;
}
function dE(s, e) {
  for (let t = s; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function fE(s, e) {
  let t = !1;
  return e && s.iterChangedRanges((i, n) => {
    i < e.to && n > e.from && (t = !0);
  }), t;
}
function pE(s, e, t = 1) {
  let i = s.charCategorizer(e), n = s.doc.lineAt(e), r = e - n.from;
  if (n.length == 0)
    return D.cursor(e);
  r == 0 ? t = 1 : r == n.length && (t = -1);
  let a = r, o = r;
  t < 0 ? a = wt(n.text, r, !1) : o = wt(n.text, r);
  let l = i(n.text.slice(a, o));
  for (; a > 0; ) {
    let c = wt(n.text, a, !1);
    if (i(n.text.slice(c, a)) != l)
      break;
    a = c;
  }
  for (; o < n.length; ) {
    let c = wt(n.text, o);
    if (i(n.text.slice(o, c)) != l)
      break;
    o = c;
  }
  return D.range(a + n.from, o + n.from);
}
function gE(s, e) {
  return e.left > s ? e.left - s : Math.max(0, s - e.right);
}
function mE(s, e) {
  return e.top > s ? e.top - s : Math.max(0, s - e.bottom);
}
function nu(s, e) {
  return s.top < e.bottom - 1 && s.bottom > e.top + 1;
}
function wO(s, e) {
  return e < s.top ? { top: e, left: s.left, right: s.right, bottom: s.bottom } : s;
}
function SO(s, e) {
  return e > s.bottom ? { top: s.top, left: s.left, right: s.right, bottom: e } : s;
}
function ff(s, e, t) {
  let i, n, r, a, o = !1, l, c, h, u;
  for (let p = s.firstChild; p; p = p.nextSibling) {
    let g = La(p);
    for (let m = 0; m < g.length; m++) {
      let O = g[m];
      n && nu(n, O) && (O = wO(SO(O, n.bottom), n.top));
      let x = gE(e, O), b = mE(t, O);
      if (x == 0 && b == 0)
        return p.nodeType == 3 ? kO(p, e, t) : ff(p, e, t);
      if (!i || a > b || a == b && r > x) {
        i = p, n = O, r = x, a = b;
        let v = b ? t < O.top ? -1 : 1 : x ? e < O.left ? -1 : 1 : 0;
        o = !v || (v > 0 ? m < g.length - 1 : m > 0);
      }
      x == 0 ? t > O.bottom && (!h || h.bottom < O.bottom) ? (l = p, h = O) : t < O.top && (!u || u.top > O.top) && (c = p, u = O) : h && nu(h, O) ? h = SO(h, O.bottom) : u && nu(u, O) && (u = wO(u, O.top));
    }
  }
  if (h && h.bottom >= t ? (i = l, n = h) : u && u.top <= t && (i = c, n = u), !i)
    return { node: s, offset: 0 };
  let d = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return kO(i, d, t);
  if (o && i.contentEditable != "false")
    return ff(i, d, t);
  let f = Array.prototype.indexOf.call(s.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: s, offset: f };
}
function kO(s, e, t) {
  let i = s.nodeValue.length, n = -1, r = 1e9, a = 0;
  for (let o = 0; o < i; o++) {
    let l = An(s, o, o + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let h = l[c];
      if (h.top == h.bottom)
        continue;
      a || (a = e - h.left);
      let u = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && u < r) {
        let d = e >= (h.left + h.right) / 2, f = d;
        if ((ne.chrome || ne.gecko) && An(s, o).getBoundingClientRect().left == h.right && (f = !d), u <= 0)
          return { node: s, offset: o + (f ? 1 : 0) };
        n = o + (f ? 1 : 0), r = u;
      }
    }
  }
  return { node: s, offset: n > -1 ? n : a > 0 ? s.nodeValue.length : 0 };
}
function Aw(s, e, t, i = -1) {
  var n, r;
  let a = s.contentDOM.getBoundingClientRect(), o = a.top + s.viewState.paddingTop, l, { docHeight: c } = s.viewState, { x: h, y: u } = e, d = u - o;
  if (d < 0)
    return 0;
  if (d > c)
    return s.state.doc.length;
  for (let v = s.viewState.heightOracle.textHeight / 2, y = !1; l = s.elementAtHeight(d), l.type != Xt.Text; )
    for (; d = i > 0 ? l.bottom + v : l.top - v, !(d >= 0 && d <= c); ) {
      if (y)
        return t ? null : 0;
      y = !0, i = -i;
    }
  u = o + d;
  let f = l.from;
  if (f < s.viewport.from)
    return s.viewport.from == 0 ? 0 : t ? null : PO(s, a, l, h, u);
  if (f > s.viewport.to)
    return s.viewport.to == s.state.doc.length ? s.state.doc.length : t ? null : PO(s, a, l, h, u);
  let p = s.dom.ownerDocument, g = s.root.elementFromPoint ? s.root : p, m = g.elementFromPoint(h, u);
  m && !s.contentDOM.contains(m) && (m = null), m || (h = Math.max(a.left + 1, Math.min(a.right - 1, h)), m = g.elementFromPoint(h, u), m && !s.contentDOM.contains(m) && (m = null));
  let O, x = -1;
  if (m && ((n = s.docView.nearest(m)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let v = p.caretPositionFromPoint(h, u);
      v && ({ offsetNode: O, offset: x } = v);
    } else if (p.caretRangeFromPoint) {
      let v = p.caretRangeFromPoint(h, u);
      v && ({ startContainer: O, startOffset: x } = v, (!s.contentDOM.contains(O) || ne.safari && OE(O, x, h) || ne.chrome && xE(O, x, h)) && (O = void 0));
    }
    O && (x = Math.min(ts(O), x));
  }
  if (!O || !s.docView.dom.contains(O)) {
    let v = at.find(s.docView, f);
    if (!v)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: x } = ff(v.dom, h, u));
  }
  let b = s.docView.nearest(O);
  if (!b)
    return null;
  if (b.isWidget && ((r = b.dom) === null || r === void 0 ? void 0 : r.nodeType) == 1) {
    let v = b.dom.getBoundingClientRect();
    return e.y < v.top || e.y <= v.bottom && e.x <= (v.left + v.right) / 2 ? b.posAtStart : b.posAtEnd;
  } else
    return b.localPosFromDOM(O, x) + b.posAtStart;
}
function PO(s, e, t, i, n) {
  let r = Math.round((i - e.left) * s.defaultCharacterWidth);
  if (s.lineWrapping && t.height > s.defaultLineHeight * 1.5) {
    let o = s.viewState.heightOracle.textHeight, l = Math.floor((n - t.top - (s.defaultLineHeight - o) * 0.5) / o);
    r += l * s.viewState.heightOracle.lineLength;
  }
  let a = s.state.sliceDoc(t.from, t.to);
  return t.from + Kd(a, r, s.state.tabSize);
}
function OE(s, e, t) {
  let i;
  if (s.nodeType != 3 || e != (i = s.nodeValue.length))
    return !1;
  for (let n = s.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return An(s, i - 1, i).getBoundingClientRect().left > t;
}
function xE(s, e, t) {
  if (e != 0)
    return !1;
  for (let n = s; ; ) {
    let r = n.parentNode;
    if (!r || r.nodeType != 1 || r.firstChild != n)
      return !1;
    if (r.classList.contains("cm-line"))
      break;
    n = r;
  }
  let i = s.nodeType == 1 ? s.getBoundingClientRect() : An(s, 0, Math.max(s.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function pf(s, e, t) {
  let i = s.lineBlockAt(e);
  if (Array.isArray(i.type)) {
    let n;
    for (let r of i.type) {
      if (r.from > e)
        break;
      if (!(r.to < e)) {
        if (r.from < e && r.to > e)
          return r;
        (!n || r.type == Xt.Text && (n.type != r.type || (t < 0 ? r.from < e : r.to > e))) && (n = r);
      }
    }
    return n || i;
  }
  return i;
}
function bE(s, e, t, i) {
  let n = pf(s, e.head, e.assoc || -1), r = !i || n.type != Xt.Text || !(s.lineWrapping || n.widgetLineBreaks) ? null : s.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (r) {
    let a = s.dom.getBoundingClientRect(), o = s.textDirectionAt(n.from), l = s.posAtCoords({
      x: t == (o == Ge.LTR) ? a.right - 1 : a.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (l != null)
      return D.cursor(l, t ? -1 : 1);
  }
  return D.cursor(t ? n.to : n.from, t ? -1 : 1);
}
function QO(s, e, t, i) {
  let n = s.state.doc.lineAt(e.head), r = s.bidiSpans(n), a = s.textDirectionAt(n.from);
  for (let o = e, l = null; ; ) {
    let c = nE(n, r, a, o, t), h = dw;
    if (!c) {
      if (n.number == (t ? s.state.doc.lines : 1))
        return o;
      h = `
`, n = s.state.doc.line(n.number + (t ? 1 : -1)), r = s.bidiSpans(n), c = s.visualLineSide(n, !t);
    }
    if (l) {
      if (!l(h))
        return o;
    } else {
      if (!i)
        return c;
      l = i(h);
    }
    o = c;
  }
}
function yE(s, e, t) {
  let i = s.state.charCategorizer(e), n = i(t);
  return (r) => {
    let a = i(r);
    return n == Ke.Space && (n = a), n == a;
  };
}
function vE(s, e, t, i) {
  let n = e.head, r = t ? 1 : -1;
  if (n == (t ? s.state.doc.length : 0))
    return D.cursor(n, e.assoc);
  let a = e.goalColumn, o, l = s.contentDOM.getBoundingClientRect(), c = s.coordsAtPos(n, e.assoc || -1), h = s.documentTop;
  if (c)
    a == null && (a = c.left - l.left), o = r < 0 ? c.top : c.bottom;
  else {
    let f = s.viewState.lineBlockAt(n);
    a == null && (a = Math.min(l.right - l.left, s.defaultCharacterWidth * (n - f.from))), o = (r < 0 ? f.top : f.bottom) + h;
  }
  let u = l.left + a, d = i ?? s.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = o + (d + f) * r, g = Aw(s, { x: u, y: p }, !1, r);
    if (p < l.top || p > l.bottom || (r < 0 ? g < n : g > n)) {
      let m = s.docView.coordsForChar(g), O = !m || p < m.top ? -1 : 1;
      return D.cursor(g, O, void 0, a);
    }
  }
}
function Cl(s, e, t) {
  for (; ; ) {
    let i = 0;
    for (let n of s)
      n.between(e - 1, e + 1, (r, a, o) => {
        if (e > r && e < a) {
          let l = i || t || (e - r < a - e ? -1 : 1);
          e = l < 0 ? r : a, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function ru(s, e, t) {
  let i = Cl(s.state.facet(Up).map((n) => n(s)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : D.cursor(i, i < t.from ? 1 : -1);
}
const na = "￿";
class wE {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Ce.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += na;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n);
      let r = this.text.length;
      this.readNode(n);
      let a = n.nextSibling;
      if (a == t)
        break;
      let o = Ne.get(n), l = Ne.get(a);
      (o && l ? o.breakAfter : (o ? o.breakAfter : ac(n)) || ac(a) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > r) && this.lineBreak(), n = a;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, a = 1, o;
      if (this.lineSeparator ? (r = t.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = n.exec(t)) && (r = o.index, a = o[0].length), this.append(t.slice(i, r < 0 ? t.length : r)), r < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= a - 1);
      i = r + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Ne.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (SE(e, i.node, i.offset) ? t : 0));
  }
}
function SE(s, e, t) {
  for (; ; ) {
    if (!e || t < ts(e))
      return !1;
    if (e == s)
      return !0;
    t = Cn(e) + 1, e = e.parentNode;
  }
}
class CO {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class kE {
  constructor(e, t, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: r, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let o = r || a ? [] : CE(e), l = new wE(o, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = AE(o, this.bounds.from);
    } else {
      let o = e.observer.selectionRange, l = r && r.node == o.focusNode && r.offset == o.focusOffset || !tf(e.contentDOM, o.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(o.focusNode, o.focusOffset), c = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !tf(e.contentDOM, o.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(o.anchorNode, o.anchorOffset), h = e.viewport;
      if ((ne.ios || ne.chrome) && e.state.selection.main.empty && l != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let u = Math.min(l, c), d = Math.max(l, c), f = h.from - u, p = h.to - d;
        (f == 0 || f == 1 || u == 0) && (p == 0 || p == -1 || d == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = D.single(c, l);
    }
  }
}
function Tw(s, e) {
  let t, { newSel: i } = e, n = s.state.selection.main, r = s.inputState.lastKeyTime > Date.now() - 100 ? s.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: a, to: o } = e.bounds, l = n.from, c = null;
    (r === 8 || ne.android && e.text.length < o - a) && (l = n.to, c = "end");
    let h = QE(s.state.doc.sliceString(a, o, na), e.text, l - a, c);
    h && (ne.chrome && r == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == na + na && h.toB--, t = {
      from: a + h.from,
      to: a + h.toA,
      insert: $e.of(e.text.slice(h.from, h.toB).split(na))
    });
  } else i && (!s.hasFocus && s.state.facet(ps) || i.main.eq(n)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !n.empty && i && i.main.empty ? t = { from: n.from, to: n.to, insert: s.state.doc.slice(n.from, n.to) } : (ne.mac || ne.android) && t && t.from == t.to && t.from == n.head - 1 && /^\. ?$/.test(t.insert.toString()) && s.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = D.single(i.main.anchor - 1, i.main.head - 1)), t = { from: t.from, to: t.to, insert: $e.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= n.from && t.to <= n.to && (t.from != n.from || t.to != n.to) && n.to - n.from - (t.to - t.from) <= 4 ? t = {
    from: n.from,
    to: n.to,
    insert: s.state.doc.slice(n.from, t.from).append(t.insert).append(s.state.doc.slice(t.to, n.to))
  } : ne.chrome && t && t.from == t.to && t.from == n.head && t.insert.toString() == `
 ` && s.lineWrapping && (i && (i = D.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: $e.of([" "]) }), t)
    return Kp(s, t, i, r);
  if (i && !i.main.eq(n)) {
    let a = !1, o = "select";
    return s.inputState.lastSelectionTime > Date.now() - 50 && (s.inputState.lastSelectionOrigin == "select" && (a = !0), o = s.inputState.lastSelectionOrigin), s.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
function Kp(s, e, t, i = -1) {
  if (ne.ios && s.inputState.flushIOSKey(e))
    return !0;
  let n = s.state.selection.main;
  if (ne.android && (e.to == n.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == n.from || e.from == n.from - 1 && s.state.sliceDoc(e.from, n.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && ir(s.contentDOM, "Enter", 13) || (e.from == n.from - 1 && e.to == n.to && e.insert.length == 0 || i == 8 && e.insert.length < e.to - e.from && e.to > n.head) && ir(s.contentDOM, "Backspace", 8) || e.from == n.from && e.to == n.to + 1 && e.insert.length == 0 && ir(s.contentDOM, "Delete", 46)))
    return !0;
  let r = e.insert.toString();
  s.inputState.composing >= 0 && s.inputState.composing++;
  let a, o = () => a || (a = PE(s, e, t));
  return s.state.facet(Ow).some((l) => l(s, e.from, e.to, r, o)) || s.dispatch(o()), !0;
}
function PE(s, e, t) {
  let i, n = s.state, r = n.selection.main;
  if (e.from >= r.from && e.to <= r.to && e.to - e.from >= (r.to - r.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && s.inputState.composing < 0) {
    let o = r.from < e.from ? n.sliceDoc(r.from, e.from) : "", l = r.to > e.to ? n.sliceDoc(e.to, r.to) : "";
    i = n.replaceSelection(s.state.toText(o + e.insert.sliceString(0, void 0, s.state.lineBreak) + l));
  } else {
    let o = n.changes(e), l = t && t.main.to <= o.newLength ? t.main : void 0;
    if (n.selection.ranges.length > 1 && s.inputState.composing >= 0 && e.to <= r.to && e.to >= r.to - 10) {
      let c = s.state.sliceDoc(e.from, e.to), h, u = t && Cw(s, t.main.head);
      if (u) {
        let p = e.insert.length - (e.to - e.from);
        h = { from: u.from, to: u.to - p };
      } else
        h = s.state.doc.lineAt(r.head);
      let d = r.to - e.to, f = r.to - r.from;
      i = n.changeByRange((p) => {
        if (p.from == r.from && p.to == r.to)
          return { changes: o, range: l || p.map(o) };
        let g = p.to - d, m = g - c.length;
        if (p.to - p.from != f || s.state.sliceDoc(m, g) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= h.from && p.from <= h.to)
          return { range: p };
        let O = n.changes({ from: m, to: g, insert: e.insert }), x = p.to - r.to;
        return {
          changes: O,
          range: l ? D.range(Math.max(0, l.anchor + x), Math.max(0, l.head + x)) : p.map(O)
        };
      });
    } else
      i = {
        changes: o,
        selection: l && n.selection.replaceRange(l)
      };
  }
  let a = "input.type";
  return (s.composing || s.inputState.compositionPendingChange && s.inputState.compositionEndedAt > Date.now() - 50) && (s.inputState.compositionPendingChange = !1, a += ".compose", s.inputState.compositionFirstChange && (a += ".start", s.inputState.compositionFirstChange = !1)), n.update(i, { userEvent: a, scrollIntoView: !0 });
}
function QE(s, e, t, i) {
  let n = Math.min(s.length, e.length), r = 0;
  for (; r < n && s.charCodeAt(r) == e.charCodeAt(r); )
    r++;
  if (r == n && s.length == e.length)
    return null;
  let a = s.length, o = e.length;
  for (; a > 0 && o > 0 && s.charCodeAt(a - 1) == e.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let l = Math.max(0, r - Math.min(a, o));
    t -= a + l - r;
  }
  if (a < r && s.length < e.length) {
    let l = t <= r && t >= a ? r - t : 0;
    r -= l, o = r + (o - a), a = r;
  } else if (o < r) {
    let l = t <= r && t >= o ? r - t : 0;
    r -= l, a = r + (a - o), o = r;
  }
  return { from: r, toA: a, toB: o };
}
function CE(s) {
  let e = [];
  if (s.root.activeElement != s.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: n, focusOffset: r } = s.observer.selectionRange;
  return t && (e.push(new CO(t, i)), (n != t || r != i) && e.push(new CO(n, r))), e;
}
function AE(s, e) {
  if (s.length == 0)
    return null;
  let t = s[0].pos, i = s.length == 2 ? s[1].pos : t;
  return t > -1 && i > -1 ? D.single(t + e, i + e) : null;
}
class TE {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ne.safari && e.contentDOM.addEventListener("input", () => null), ne.gecko && NE(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !zE(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let i = this.handlers[e];
    if (i) {
      for (let n of i.observers)
        n(this.view, t);
      for (let n of i.handlers) {
        if (t.defaultPrevented)
          break;
        if (n(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = $E(e), i = this.handlers, n = this.view.contentDOM;
    for (let r in t)
      if (r != "scroll") {
        let a = !t[r].handlers.length, o = i[r];
        o && a != !o.handlers.length && (n.removeEventListener(r, this.handleEvent), o = null), o || n.addEventListener(r, this.handleEvent, { passive: a });
      }
    for (let r in i)
      r != "scroll" && !t[r] && n.removeEventListener(r, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && Rw.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), ne.android && ne.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return ne.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = $w.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || RE.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ir(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ne.safari && !ne.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function AO(s, e) {
  return (t, i) => {
    try {
      return e.call(s, i, t);
    } catch (n) {
      Bt(t.state, n);
    }
  };
}
function $E(s) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of s) {
    let n = i.spec, r = n && n.plugin.domEventHandlers, a = n && n.plugin.domEventObservers;
    if (r)
      for (let o in r) {
        let l = r[o];
        l && t(o).handlers.push(AO(i.value, l));
      }
    if (a)
      for (let o in a) {
        let l = a[o];
        l && t(o).observers.push(AO(i.value, l));
      }
  }
  for (let i in Ri)
    t(i).handlers.push(Ri[i]);
  for (let i in Oi)
    t(i).observers.push(Oi[i]);
  return e;
}
const $w = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], RE = "dthko", Rw = [16, 17, 18, 20, 91, 92, 224, 225], Wo = 6;
function Yo(s) {
  return Math.max(0, s) * 0.7 + 8;
}
function EE(s, e) {
  return Math.max(Math.abs(s.clientX - e.clientX), Math.abs(s.clientY - e.clientY));
}
class XE {
  constructor(e, t, i, n) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = DR(e.contentDOM), this.atoms = e.state.facet(Up).map((a) => a(e));
    let r = e.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Ce.allowMultipleSelections) && ME(e, t), this.dragging = LE(e, t) && Mw(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && EE(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, i = 0, n = 0, r = 0, a = this.view.win.innerWidth, o = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: n, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: r, bottom: o } = this.scrollParents.y.getBoundingClientRect());
    let l = Gp(this.view);
    e.clientX - l.left <= n + Wo ? t = -Yo(n - e.clientX) : e.clientX + l.right >= a - Wo && (t = Yo(e.clientX - a)), e.clientY - l.top <= r + Wo ? i = -Yo(r - e.clientY) : e.clientY + l.bottom >= o - Wo && (i = Yo(e.clientY - o)), this.setScrollSpeed(t, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let n = e.ranges[i], r = null;
      if (n.empty) {
        let a = Cl(this.atoms, n.from, 0);
        a != n.from && (r = D.cursor(a, -1));
      } else {
        let a = Cl(this.atoms, n.from, -1), o = Cl(this.atoms, n.to, 1);
        (a != n.from || o != n.to) && (r = D.range(n.from == n.anchor ? a : o, n.from == n.head ? a : o));
      }
      r && (t || (t = e.ranges.slice()), t[i] = r);
    }
    return t ? D.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function ME(s, e) {
  let t = s.state.facet(fw);
  return t.length ? t[0](e) : ne.mac ? e.metaKey : e.ctrlKey;
}
function _E(s, e) {
  let t = s.state.facet(pw);
  return t.length ? t[0](e) : ne.mac ? !e.altKey : !e.ctrlKey;
}
function LE(s, e) {
  let { main: t } = s.state.selection;
  if (t.empty)
    return !1;
  let i = _a(s.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let r = 0; r < n.length; r++) {
    let a = n[r];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function zE(s, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != s.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = Ne.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const Ri = /* @__PURE__ */ Object.create(null), Oi = /* @__PURE__ */ Object.create(null), Ew = ne.ie && ne.ie_version < 15 || ne.ios && ne.webkit_version < 604;
function IE(s) {
  let e = s.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    s.focus(), t.remove(), Xw(s, t.value);
  }, 50);
}
function eh(s, e, t) {
  for (let i of s.facet(e))
    t = i(t, s);
  return t;
}
function Xw(s, e) {
  e = eh(s.state, Fp, e);
  let { state: t } = s, i, n = 1, r = t.toText(e), a = r.lines == t.selection.ranges.length;
  if (gf != null && t.selection.ranges.every((l) => l.empty) && gf == r.toString()) {
    let l = -1;
    i = t.changeByRange((c) => {
      let h = t.doc.lineAt(c.from);
      if (h.from == l)
        return { range: c };
      l = h.from;
      let u = t.toText((a ? r.line(n++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: D.cursor(c.from + u.length)
      };
    });
  } else a ? i = t.changeByRange((l) => {
    let c = r.line(n++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: D.cursor(l.from + c.length)
    };
  }) : i = t.replaceSelection(r);
  s.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Oi.scroll = (s) => {
  s.inputState.lastScrollTop = s.scrollDOM.scrollTop, s.inputState.lastScrollLeft = s.scrollDOM.scrollLeft;
};
Ri.keydown = (s, e) => (s.inputState.setSelectionOrigin("select"), e.keyCode == 27 && s.inputState.tabFocusMode != 0 && (s.inputState.tabFocusMode = Date.now() + 2e3), !1);
Oi.touchstart = (s, e) => {
  s.inputState.lastTouchTime = Date.now(), s.inputState.setSelectionOrigin("select.pointer");
};
Oi.touchmove = (s) => {
  s.inputState.setSelectionOrigin("select.pointer");
};
Ri.mousedown = (s, e) => {
  if (s.observer.flush(), s.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let i of s.state.facet(gw))
    if (t = i(s, e), t)
      break;
  if (!t && e.button == 0 && (t = BE(s, e)), t) {
    let i = !s.hasFocus;
    s.inputState.startMouseSelection(new XE(s, e, t, i)), i && s.observer.ignore(() => {
      jv(s.contentDOM);
      let r = s.root.activeElement;
      r && !r.contains(s.contentDOM) && r.blur();
    });
    let n = s.inputState.mouseSelection;
    if (n)
      return n.start(e), n.dragging === !1;
  }
  return !1;
};
function TO(s, e, t, i) {
  if (i == 1)
    return D.cursor(e, t);
  if (i == 2)
    return pE(s.state, e, t);
  {
    let n = at.find(s.docView, e), r = s.state.doc.lineAt(n ? n.posAtEnd : e), a = n ? n.posAtStart : r.from, o = n ? n.posAtEnd : r.to;
    return o < s.state.doc.length && o == r.to && o++, D.range(a, o);
  }
}
let $O = (s, e, t) => e >= t.top && e <= t.bottom && s >= t.left && s <= t.right;
function qE(s, e, t, i) {
  let n = at.find(s.docView, e);
  if (!n)
    return 1;
  let r = e - n.posAtStart;
  if (r == 0)
    return 1;
  if (r == n.length)
    return -1;
  let a = n.coordsAt(r, -1);
  if (a && $O(t, i, a))
    return -1;
  let o = n.coordsAt(r, 1);
  return o && $O(t, i, o) ? 1 : a && a.bottom >= i ? -1 : 1;
}
function RO(s, e) {
  let t = s.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: qE(s, t, e.clientX, e.clientY) };
}
const DE = ne.ie && ne.ie_version <= 11;
let EO = null, XO = 0, MO = 0;
function Mw(s) {
  if (!DE)
    return s.detail;
  let e = EO, t = MO;
  return EO = s, MO = Date.now(), XO = !e || t > Date.now() - 400 && Math.abs(e.clientX - s.clientX) < 2 && Math.abs(e.clientY - s.clientY) < 2 ? (XO + 1) % 3 : 1;
}
function BE(s, e) {
  let t = RO(s, e), i = Mw(e), n = s.state.selection;
  return {
    update(r) {
      r.docChanged && (t.pos = r.changes.mapPos(t.pos), n = n.map(r.changes));
    },
    get(r, a, o) {
      let l = RO(s, r), c, h = TO(s, l.pos, l.bias, i);
      if (t.pos != l.pos && !a) {
        let u = TO(s, t.pos, t.bias, i), d = Math.min(u.from, h.from), f = Math.max(u.to, h.to);
        h = d < h.from ? D.range(d, f) : D.range(f, d);
      }
      return a ? n.replaceRange(n.main.extend(h.from, h.to)) : o && i == 1 && n.ranges.length > 1 && (c = WE(n, l.pos)) ? c : o ? n.addRange(h) : D.create([h]);
    }
  };
}
function WE(s, e) {
  for (let t = 0; t < s.ranges.length; t++) {
    let { from: i, to: n } = s.ranges[t];
    if (i <= e && n >= e)
      return D.create(s.ranges.slice(0, t).concat(s.ranges.slice(t + 1)), s.mainIndex == t ? 0 : s.mainIndex - (s.mainIndex > t ? 1 : 0));
  }
  return null;
}
Ri.dragstart = (s, e) => {
  let { selection: { main: t } } = s.state;
  if (e.target.draggable) {
    let n = s.docView.nearest(e.target);
    if (n && n.isWidget) {
      let r = n.posAtStart, a = r + n.length;
      (r >= t.to || a <= t.from) && (t = D.range(r, a));
    }
  }
  let { inputState: i } = s;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", eh(s.state, jp, s.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ri.dragend = (s) => (s.inputState.draggedContent = null, !1);
function _O(s, e, t, i) {
  if (t = eh(s.state, Fp, t), !t)
    return;
  let n = s.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: r } = s.inputState, a = i && r && _E(s, e) ? { from: r.from, to: r.to } : null, o = { from: n, insert: t }, l = s.state.changes(a ? [a, o] : o);
  s.focus(), s.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(n, -1), head: l.mapPos(n, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), s.inputState.draggedContent = null;
}
Ri.drop = (s, e) => {
  if (!e.dataTransfer)
    return !1;
  if (s.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let i = Array(t.length), n = 0, r = () => {
      ++n == t.length && _O(s, e, i.filter((a) => a != null).join(s.state.lineBreak), !1);
    };
    for (let a = 0; a < t.length; a++) {
      let o = new FileReader();
      o.onerror = r, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), r();
      }, o.readAsText(t[a]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return _O(s, e, i, !0), !0;
  }
  return !1;
};
Ri.paste = (s, e) => {
  if (s.state.readOnly)
    return !0;
  s.observer.flush();
  let t = Ew ? null : e.clipboardData;
  return t ? (Xw(s, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (IE(s), !1);
};
function YE(s, e) {
  let t = s.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), s.focus();
  }, 50);
}
function ZE(s) {
  let e = [], t = [], i = !1;
  for (let n of s.selection.ranges)
    n.empty || (e.push(s.sliceDoc(n.from, n.to)), t.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: r } of s.selection.ranges) {
      let a = s.doc.lineAt(r);
      a.number > n && (e.push(a.text), t.push({ from: a.from, to: Math.min(s.doc.length, a.to + 1) })), n = a.number;
    }
    i = !0;
  }
  return { text: eh(s, jp, e.join(s.lineBreak)), ranges: t, linewise: i };
}
let gf = null;
Ri.copy = Ri.cut = (s, e) => {
  let { text: t, ranges: i, linewise: n } = ZE(s.state);
  if (!t && !n)
    return !1;
  gf = n ? t : null, e.type == "cut" && !s.state.readOnly && s.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let r = Ew ? null : e.clipboardData;
  return r ? (r.clearData(), r.setData("text/plain", t), !0) : (YE(s, t), !1);
};
const _w = /* @__PURE__ */ Cs.define();
function Lw(s, e) {
  let t = [];
  for (let i of s.facet(xw)) {
    let n = i(s, e);
    n && t.push(n);
  }
  return t.length ? s.update({ effects: t, annotations: _w.of(!0) }) : null;
}
function zw(s) {
  setTimeout(() => {
    let e = s.hasFocus;
    if (e != s.inputState.notifiedFocused) {
      let t = Lw(s.state, e);
      t ? s.dispatch(t) : s.update([]);
    }
  }, 10);
}
Oi.focus = (s) => {
  s.inputState.lastFocusTime = Date.now(), !s.scrollDOM.scrollTop && (s.inputState.lastScrollTop || s.inputState.lastScrollLeft) && (s.scrollDOM.scrollTop = s.inputState.lastScrollTop, s.scrollDOM.scrollLeft = s.inputState.lastScrollLeft), zw(s);
};
Oi.blur = (s) => {
  s.observer.clearSelectionRange(), zw(s);
};
Oi.compositionstart = Oi.compositionupdate = (s) => {
  s.observer.editContext || (s.inputState.compositionFirstChange == null && (s.inputState.compositionFirstChange = !0), s.inputState.composing < 0 && (s.inputState.composing = 0));
};
Oi.compositionend = (s) => {
  s.observer.editContext || (s.inputState.composing = -1, s.inputState.compositionEndedAt = Date.now(), s.inputState.compositionPendingKey = !0, s.inputState.compositionPendingChange = s.observer.pendingRecords().length > 0, s.inputState.compositionFirstChange = null, ne.chrome && ne.android ? s.observer.flushSoon() : s.inputState.compositionPendingChange ? Promise.resolve().then(() => s.observer.flush()) : setTimeout(() => {
    s.inputState.composing < 0 && s.docView.hasComposition && s.update([]);
  }, 50));
};
Oi.contextmenu = (s) => {
  s.inputState.lastContextMenu = Date.now();
};
Ri.beforeinput = (s, e) => {
  var t, i;
  if (e.inputType == "insertReplacementText" && s.observer.editContext) {
    let r = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), a = e.getTargetRanges();
    if (r && a.length) {
      let o = a[0], l = s.posAtDOM(o.startContainer, o.startOffset), c = s.posAtDOM(o.endContainer, o.endOffset);
      return Kp(s, { from: l, to: c, insert: s.state.toText(r) }, null), !0;
    }
  }
  let n;
  if (ne.chrome && ne.android && (n = $w.find((r) => r.inputType == e.inputType)) && (s.observer.delayAndroidKey(n.key, n.keyCode), n.key == "Backspace" || n.key == "Delete")) {
    let r = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > r + 10 && s.hasFocus && (s.contentDOM.blur(), s.focus());
    }, 100);
  }
  return ne.ios && e.inputType == "deleteContentForward" && s.observer.flushSoon(), ne.safari && e.inputType == "insertText" && s.inputState.composing >= 0 && setTimeout(() => Oi.compositionend(s, e), 20), !1;
};
const LO = /* @__PURE__ */ new Set();
function NE(s) {
  LO.has(s) || (LO.add(s), s.addEventListener("copy", () => {
  }), s.addEventListener("cut", () => {
  }));
}
const zO = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let pr = !1;
function IO() {
  pr = !1;
}
class VE {
  constructor(e) {
    this.lineWrapping = e, this.doc = $e.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return zO.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (t = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, n, r, a) {
    let o = zO.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = t, this.charWidth = i, this.textHeight = n, this.lineLength = r, l) {
      this.heightSamples = {};
      for (let c = 0; c < a.length; c++) {
        let h = a[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class FE {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Fi {
  /**
  @internal
  */
  constructor(e, t, i, n, r) {
    this.from = e, this.length = t, this.top = i, this.height = n, this._content = r;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Xt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Ns ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Fi(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Ue = /* @__PURE__ */ function(s) {
  return s[s.ByPos = 0] = "ByPos", s[s.ByHeight = 1] = "ByHeight", s[s.ByPosNoHeight = 2] = "ByPosNoHeight", s;
}(Ue || (Ue = {}));
const Al = 1e-3;
class Mt {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Al && (pr = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return Mt.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, n) {
    let r = this, a = i.doc;
    for (let o = n.length - 1; o >= 0; o--) {
      let { fromA: l, toA: c, fromB: h, toB: u } = n[o], d = r.lineAt(l, Ue.ByPosNoHeight, i.setDoc(t), 0, 0), f = d.to >= c ? d : r.lineAt(c, Ue.ByPosNoHeight, i, 0, 0);
      for (u += f.to - c, c = f.to; o > 0 && d.from <= n[o - 1].toA; )
        l = n[o - 1].fromA, h = n[o - 1].fromB, o--, l < d.from && (d = r.lineAt(l, Ue.ByPosNoHeight, i, 0, 0));
      h += d.from - l, l = d.from;
      let p = Jp.build(i.setDoc(a), e, h, u);
      r = cc(r, r.replace(l, c, p));
    }
    return r.updateHeight(i, 0);
  }
  static empty() {
    return new Ut(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, n = 0, r = 0;
    for (; ; )
      if (t == i)
        if (n > r * 2) {
          let o = e[t - 1];
          o.break ? e.splice(--t, 1, o.left, null, o.right) : e.splice(--t, 1, o.left, o.right), i += 1 + o.break, n -= o.size;
        } else if (r > n * 2) {
          let o = e[i];
          o.break ? e.splice(i, 1, o.left, null, o.right) : e.splice(i, 1, o.left, o.right), i += 2 + o.break, r -= o.size;
        } else
          break;
      else if (n < r) {
        let o = e[t++];
        o && (n += o.size);
      } else {
        let o = e[--i];
        o && (r += o.size);
      }
    let a = 0;
    return e[t - 1] == null ? (a = 1, t--) : e[t] == null && (a = 1, i++), new jE(Mt.of(e.slice(0, t)), a, Mt.of(e.slice(i)));
  }
}
function cc(s, e) {
  return s == e ? s : (s.constructor != e.constructor && (pr = !0), e);
}
Mt.prototype.size = 1;
class Iw extends Mt {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, n) {
    return new Fi(n, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, n, r) {
    return this.blockAt(0, i, n, r);
  }
  forEachLine(e, t, i, n, r, a) {
    e <= r + this.length && t >= r && a(this.blockAt(0, i, n, r));
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more && this.setHeight(n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Ut extends Iw {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, n) {
    return new Fi(n, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof Ut || n instanceof Ot && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof Ot ? n = new Ut(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Mt.of(i);
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more ? this.setHeight(n.heights[n.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Ot extends Mt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, n = e.doc.lineAt(t + this.length).number, r = n - i + 1, a, o = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * r);
      a = l / r, this.length > r + 1 && (o = (this.height - l) / (this.length - r - 1));
    } else
      a = this.height / r;
    return { firstLine: i, lastLine: n, perLine: a, perChar: o };
  }
  blockAt(e, t, i, n) {
    let { firstLine: r, lastLine: a, perLine: o, perChar: l } = this.heightMetrics(t, n);
    if (t.lineWrapping) {
      let c = n + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length)), h = t.doc.lineAt(c), u = o + h.length * l, d = Math.max(i, e - u / 2);
      return new Fi(h.from, h.length, d, u, 0);
    } else {
      let c = Math.max(0, Math.min(a - r, Math.floor((e - i) / o))), { from: h, length: u } = t.doc.line(r + c);
      return new Fi(h, u, i + o * c, o, 0);
    }
  }
  lineAt(e, t, i, n, r) {
    if (t == Ue.ByHeight)
      return this.blockAt(e, i, n, r);
    if (t == Ue.ByPosNoHeight) {
      let { from: f, to: p } = i.doc.lineAt(e);
      return new Fi(f, p - f, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: l } = this.heightMetrics(i, r), c = i.doc.lineAt(e), h = o + c.length * l, u = c.number - a, d = n + o * u + l * (c.from - r - u);
    return new Fi(c.from, c.length, Math.max(n, Math.min(d, n + this.height - h)), h, 0);
  }
  forEachLine(e, t, i, n, r, a) {
    e = Math.max(e, r), t = Math.min(t, r + this.length);
    let { firstLine: o, perLine: l, perChar: c } = this.heightMetrics(i, r);
    for (let h = e, u = n; h <= t; ) {
      let d = i.doc.lineAt(h);
      if (h == e) {
        let p = d.number - o;
        u += l * p + c * (e - r - p);
      }
      let f = l + c * d.length;
      a(new Fi(d.from, d.length, u, f, 0)), u += f, h = d.to + 1;
    }
  }
  replace(e, t, i) {
    let n = this.length - t;
    if (n > 0) {
      let r = i[i.length - 1];
      r instanceof Ot ? i[i.length - 1] = new Ot(r.length + n) : i.push(null, new Ot(n - 1));
    }
    if (e > 0) {
      let r = i[0];
      r instanceof Ot ? i[0] = new Ot(e + r.length) : i.unshift(new Ot(e - 1), null);
    }
    return Mt.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new Ot(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Ot(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, n) {
    let r = t + this.length;
    if (n && n.from <= t + this.length && n.more) {
      let a = [], o = Math.max(t, n.from), l = -1;
      for (n.from > t && a.push(new Ot(n.from - t - 1).updateHeight(e, t)); o <= r && n.more; ) {
        let h = e.doc.lineAt(o).length;
        a.length && a.push(null);
        let u = n.heights[n.index++];
        l == -1 ? l = u : Math.abs(u - l) >= Al && (l = -2);
        let d = new Ut(h, u);
        d.outdated = !1, a.push(d), o += h + 1;
      }
      o <= r && a.push(null, new Ot(r - o).updateHeight(e, o));
      let c = Mt.of(a);
      return (l < 0 || Math.abs(c.height - this.height) >= Al || Math.abs(l - this.heightMetrics(e, t).perLine) >= Al) && (pr = !0), cc(this, c);
    } else (i || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class jE extends Mt {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, n) {
    let r = i + this.left.height;
    return e < r ? this.left.blockAt(e, t, i, n) : this.right.blockAt(e, t, r, n + this.left.length + this.break);
  }
  lineAt(e, t, i, n, r) {
    let a = n + this.left.height, o = r + this.left.length + this.break, l = t == Ue.ByHeight ? e < a : e < o, c = l ? this.left.lineAt(e, t, i, n, r) : this.right.lineAt(e, t, i, a, o);
    if (this.break || (l ? c.to < o : c.from > o))
      return c;
    let h = t == Ue.ByPosNoHeight ? Ue.ByPosNoHeight : Ue.ByPos;
    return l ? c.join(this.right.lineAt(o, h, i, a, o)) : this.left.lineAt(o, h, i, n, r).join(c);
  }
  forEachLine(e, t, i, n, r, a) {
    let o = n + this.left.height, l = r + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, i, n, r, a), t >= l && this.right.forEachLine(e, t, i, o, l, a);
    else {
      let c = this.lineAt(l, Ue.ByPos, i, n, r);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, n, r, a), c.to >= e && c.from <= t && a(c), t > c.to && this.right.forEachLine(c.to + 1, t, i, o, l, a);
    }
  }
  replace(e, t, i) {
    let n = this.left.length + this.break;
    if (t < n)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, t - n, i));
    let r = [];
    e > 0 && this.decomposeLeft(e, r);
    let a = r.length;
    for (let o of i)
      r.push(o);
    if (e > 0 && qO(r, a - 1), t < this.length) {
      let o = r.length;
      this.decomposeRight(t, r), qO(r, o);
    }
    return Mt.of(r);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < n && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Mt.of(this.break ? [e, null, t] : [e, t]) : (this.left = cc(this.left, e), this.right = cc(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, n) {
    let { left: r, right: a } = this, o = t + r.length + this.break, l = null;
    return n && n.from <= t + r.length && n.more ? l = r = r.updateHeight(e, t, i, n) : r.updateHeight(e, t, i), n && n.from <= o + a.length && n.more ? l = a = a.updateHeight(e, o, i, n) : a.updateHeight(e, o, i), l ? this.balanced(r, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function qO(s, e) {
  let t, i;
  s[e] == null && (t = s[e - 1]) instanceof Ot && (i = s[e + 1]) instanceof Ot && s.splice(e - 1, 3, new Ot(t.length + 1 + i.length));
}
const HE = 5;
class Jp {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof Ut ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Ut(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0, r = i.widget ? i.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let a = t - e;
      i.block ? this.addBlock(new Iw(a, n, i)) : (a || r || n >= HE) && this.addLineDeco(n, r, a);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Ut(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new Ot(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Ut)
      return e;
    let t = new Ut(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Ut) && !this.isCovered ? this.nodes.push(new Ut(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof Ut && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, n) {
    let r = new Jp(i, e);
    return Xe.spans(t, i, n, r, 0), r.finish(i);
  }
}
function UE(s, e, t) {
  let i = new GE();
  return Xe.compare(s, e, t, i, 0), i.changes;
}
class GE {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, n) {
    (e < t || i && i.heightRelevant || n && n.heightRelevant) && Ql(e, t, this.changes, 5);
  }
}
function KE(s, e) {
  let t = s.getBoundingClientRect(), i = s.ownerDocument, n = i.defaultView || window, r = Math.max(0, t.left), a = Math.min(n.innerWidth, t.right), o = Math.max(0, t.top), l = Math.min(n.innerHeight, t.bottom);
  for (let c = s.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let h = c, u = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && u.overflow != "visible") {
        let d = h.getBoundingClientRect();
        r = Math.max(r, d.left), a = Math.min(a, d.right), o = Math.max(o, d.top), l = Math.min(c == s.parentNode ? n.innerHeight : l, d.bottom);
      }
      c = u.position == "absolute" || u.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: r - t.left,
    right: Math.max(r, a) - t.left,
    top: o - (t.top + e),
    bottom: Math.max(o, l) - (t.top + e)
  };
}
function JE(s) {
  let e = s.getBoundingClientRect(), t = s.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function eX(s, e) {
  let t = s.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class au {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.size = i, this.displaySize = n;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], r = t[i];
      if (n.from != r.from || n.to != r.to || n.size != r.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return de.replace({
      widget: new tX(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class tX extends As {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class DO {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = BO, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Ge.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Hp).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new VE(t), this.stateDeco = e.facet(za).filter((i) => typeof i != "function"), this.heightMap = Mt.empty().applyChanges(this.stateDeco, $e.empty, this.heightOracle.setDoc(e.doc), [new gi(0, 0, 0, e.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = de.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? t.head : t.anchor;
      if (!e.some(({ from: r, to: a }) => n >= r && n <= a)) {
        let { from: r, to: a } = this.lineBlockAt(n);
        e.push(new Zo(r, a));
      }
    }
    return this.viewports = e.sort((i, n) => i.from - n.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? BO : new eg(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(ra(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(za).filter((h) => typeof h != "function");
    let n = e.changedRanges, r = gi.extendWithRanges(n, UE(i, this.stateDeco, e ? e.changes : ut.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    IO(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), r), (this.heightMap.height != a || pr) && (e.flags |= 2), o ? (this.scrollAnchorPos = e.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let l = r.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(yw) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), n = this.heightOracle, r = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Ge.RTL : Ge.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(r), o = t.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (o.width && o.height) {
      let { scaleX: v, scaleY: y } = Fv(t, o);
      (v > 5e-3 && Math.abs(this.scaleX - v) > 5e-3 || y > 5e-3 && Math.abs(this.scaleY - y) > 5e-3) && (this.scaleX = v, this.scaleY = y, c |= 16, a = l = !0);
    }
    let u = (parseInt(i.paddingTop) || 0) * this.scaleY, d = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != u || this.paddingBottom != d) && (this.paddingTop = u, this.paddingBottom = d, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && (this.scrollAnchorHeight = -1, this.scrollTop = f), this.scrolledToBottom = Uv(e.scrollDOM);
    let p = (this.printing ? eX : KE)(t, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (l = !0)), !this.inView && !this.scrollTarget && !JE(e.dom))
      return 0;
    let x = o.width;
    if ((this.contentDOMWidth != x || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
      let v = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(v) && (a = !0), a || n.lineWrapping && Math.abs(x - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: y, charWidth: w, textHeight: S } = e.docView.measureTextSize();
        a = y > 0 && n.refresh(r, y, w, S, x / w, v), a && (e.docView.minWidth = 0, c |= 16);
      }
      g > 0 && m > 0 ? h = Math.max(g, m) : g < 0 && m < 0 && (h = Math.min(g, m)), IO();
      for (let y of this.viewports) {
        let w = y.from == this.viewport.from ? v : e.docView.measureVisibleLineHeights(y);
        this.heightMap = (a ? Mt.empty().applyChanges(this.stateDeco, $e.empty, this.heightOracle, [new gi(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, a, new FE(y.from, w));
      }
      pr && (c |= 2);
    }
    let b = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(h, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || b) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, r = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, l = new Zo(n.lineAt(a - i * 1e3, Ue.ByHeight, r, 0, 0).from, n.lineAt(o + (1 - i) * 1e3, Ue.ByHeight, r, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = n.lineAt(c, Ue.ByPos, r, 0, 0), d;
        t.y == "center" ? d = (u.top + u.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? d = u.top : d = u.bottom - h, l = new Zo(n.lineAt(d - 1e3 / 2, Ue.ByHeight, r, 0, 0).from, n.lineAt(d + h + 1e3 / 2, Ue.ByHeight, r, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), n = t.mapPos(e.to, 1);
    return new Zo(this.heightMap.lineAt(i, Ue.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, Ue.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, Ue.ByPos, this.heightOracle, 0, 0), { bottom: r } = this.heightMap.lineAt(t, Ue.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (e == 0 || n <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || r >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && n > a - 2 * 1e3 && r < o + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let n of e)
      t.touchesRange(n.from, n.to) || i.push(new au(t.mapPos(n.from), t.mapPos(n.to), n.size, n.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, r = n >> 1, a = n << 1;
    if (this.defaultTextDirection != Ge.LTR && !i)
      return [];
    let o = [], l = (h, u, d, f) => {
      if (u - h < r)
        return;
      let p = this.state.selection.main, g = [p.from];
      p.empty || g.push(p.to);
      for (let O of g)
        if (O > h && O < u) {
          l(h, O - 10, d, f), l(O + 10, u, d, f);
          return;
        }
      let m = sX(e, (O) => O.from >= d.from && O.to <= d.to && Math.abs(O.from - h) < r && Math.abs(O.to - u) < r && !g.some((x) => O.from < x && O.to > x));
      if (!m) {
        if (u < d.to && t && i && t.visibleRanges.some((b) => b.from <= u && b.to >= u)) {
          let b = t.moveToLineBoundary(D.cursor(u), !1, !0).head;
          b > h && (u = b);
        }
        let O = this.gapSize(d, h, u, f), x = i || O < 2e6 ? O : 2e6;
        m = new au(h, u, O, x);
      }
      o.push(m);
    }, c = (h) => {
      if (h.length < a || h.type != Xt.Text)
        return;
      let u = iX(h.from, h.to, this.stateDeco);
      if (u.total < a)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, f, p;
      if (i) {
        let g = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, O;
        if (d != null) {
          let x = Vo(u, d), b = ((this.visibleBottom - this.visibleTop) / 2 + g) / h.height;
          m = x - b, O = x + b;
        } else
          m = (this.visibleTop - h.top - g) / h.height, O = (this.visibleBottom - h.top + g) / h.height;
        f = No(u, m), p = No(u, O);
      } else {
        let g = u.total * this.heightOracle.charWidth, m = n * this.heightOracle.charWidth, O = 0;
        if (g > 2e6)
          for (let w of e)
            w.from >= h.from && w.from < h.to && w.size != w.displaySize && w.from * this.heightOracle.charWidth + O < this.pixelViewport.left && (O = w.size - w.displaySize);
        let x = this.pixelViewport.left + O, b = this.pixelViewport.right + O, v, y;
        if (d != null) {
          let w = Vo(u, d), S = ((b - x) / 2 + m) / g;
          v = w - S, y = w + S;
        } else
          v = (x - m) / g, y = (b + m) / g;
        f = No(u, v), p = No(u, y);
      }
      f > h.from && l(h.from, f, h, u), p < h.to && l(p, h.to, h, u);
    };
    for (let h of this.viewportLines)
      Array.isArray(h.type) ? h.type.forEach(c) : c(h);
    return o;
  }
  gapSize(e, t, i, n) {
    let r = Vo(n, i) - Vo(n, t);
    return this.heightOracle.lineWrapping ? e.height * r : n.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(e) {
    au.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = de.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let i = [];
    Xe.spans(t, this.viewport.from, this.viewport.to, {
      span(r, a) {
        i.push({ from: r, to: a });
      },
      point() {
      }
    }, 20);
    let n = 0;
    if (i.length != this.visibleRanges.length)
      n = 12;
    else
      for (let r = 0; r < i.length && !(n & 8); r++) {
        let a = this.visibleRanges[r], o = i[r];
        (a.from != o.from || a.to != o.to) && (n |= 4, e && e.mapPos(a.from, -1) == o.from && e.mapPos(a.to, 1) == o.to || (n |= 8));
      }
    return this.visibleRanges = i, n;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || ra(this.heightMap.lineAt(e, Ue.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || ra(this.heightMap.lineAt(this.scaler.fromDOM(e), Ue.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ra(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Zo {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function iX(s, e, t) {
  let i = [], n = s, r = 0;
  return Xe.spans(t, s, e, {
    span() {
    },
    point(a, o) {
      a > n && (i.push({ from: n, to: a }), r += a - n), n = o;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), r += e - n), { total: r, ranges: i };
}
function No({ total: s, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(s * t);
  for (let n = 0; ; n++) {
    let { from: r, to: a } = e[n], o = a - r;
    if (i <= o)
      return r + i;
    i -= o;
  }
}
function Vo(s, e) {
  let t = 0;
  for (let { from: i, to: n } of s.ranges) {
    if (e <= n) {
      t += e - i;
      break;
    }
    t += n - i;
  }
  return t / s.total;
}
function sX(s, e) {
  for (let t of s)
    if (e(t))
      return t;
}
const BO = {
  toDOM(s) {
    return s;
  },
  fromDOM(s) {
    return s;
  },
  scale: 1,
  eq(s) {
    return s == this;
  }
};
class eg {
  constructor(e, t, i) {
    let n = 0, r = 0, a = 0;
    this.viewports = i.map(({ from: o, to: l }) => {
      let c = t.lineAt(o, Ue.ByPos, e, 0, 0).top, h = t.lineAt(l, Ue.ByPos, e, 0, 0).bottom;
      return n += h - c, { from: o, to: l, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (t.height - n);
    for (let o of this.viewports)
      o.domTop = a + (o.top - r) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), r = o.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let r = t < this.viewports.length ? this.viewports[t] : null;
      if (!r || e < r.top)
        return n + (e - i) * this.scale;
      if (e <= r.bottom)
        return r.domTop + (e - r.top);
      i = r.bottom, n = r.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let r = t < this.viewports.length ? this.viewports[t] : null;
      if (!r || e < r.domTop)
        return i + (e - n) / this.scale;
      if (e <= r.domBottom)
        return r.top + (e - r.domTop);
      i = r.bottom, n = r.domBottom;
    }
  }
  eq(e) {
    return e instanceof eg ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, i) => t.from == e.viewports[i].from && t.to == e.viewports[i].to) : !1;
  }
}
function ra(s, e) {
  if (e.scale == 1)
    return s;
  let t = e.toDOM(s.top), i = e.toDOM(s.bottom);
  return new Fi(s.from, s.length, t, i - t, Array.isArray(s._content) ? s._content.map((n) => ra(n, e)) : s._content);
}
const Fo = /* @__PURE__ */ se.define({ combine: (s) => s.join(" ") }), mf = /* @__PURE__ */ se.define({ combine: (s) => s.indexOf(!0) > -1 }), Of = /* @__PURE__ */ Ys.newName(), qw = /* @__PURE__ */ Ys.newName(), Dw = /* @__PURE__ */ Ys.newName(), Bw = { "&light": "." + qw, "&dark": "." + Dw };
function xf(s, e, t) {
  return new Ys(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return s;
        if (!t || !t[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return t[n];
      }) : s + " " + i;
    }
  });
}
const nX = /* @__PURE__ */ xf("." + Of, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Bw), rX = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, ou = ne.ie && ne.ie_version <= 11;
class aX {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new BR(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (ne.ie && ne.ie_version <= 11 || ne.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(ne.chrome && ne.chrome_version < 126) && (this.editContext = new lX(e), e.state.facet(ps) && (e.contentDOM.editContext = this.editContext.editContext)), ou && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(ps) ? i.root.activeElement != this.dom : !Pl(this.dom, n))
      return;
    let r = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (r && r.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (ne.ie && ne.ie_version <= 11 || ne.android && ne.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && pa(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = _a(e.root);
    if (!t)
      return !1;
    let i = ne.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && oX(this.view, t) || t;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let n = Pl(this.dom, i);
    return n && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && YR(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), n && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, rX), ou && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), ou && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let r = this.delayedAndroidKey;
        r && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = r.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && r.force && ir(this.dom, r.key, r.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, n = !1;
    for (let r of e) {
      let a = this.readMutation(r);
      a && (a.typeOver && (n = !0), t == -1 ? { from: t, to: i } = a : (t = Math.min(a.from, t), i = Math.max(a.to, i)));
    }
    return { from: t, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), n = this.selectionChanged && Pl(this.dom, this.selectionRange);
    if (e < 0 && !n)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let r = new kE(this.view, e, t, i);
    return this.view.docView.domChanged = { newSel: r.newSel ? r.newSel.main : null }, r;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, n = Tw(this.view, t);
    return this.view.state == i && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), n;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = WO(t, e.previousSibling || e.target.previousSibling, -1), n = WO(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: n ? t.posBefore(n) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(ps) != e.state.facet(ps) && (e.view.contentDOM.editContext = e.state.facet(ps) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function WO(s, e, t) {
  for (; e; ) {
    let i = Ne.get(e);
    if (i && i.parent == s)
      return i;
    let n = e.parentNode;
    e = n != s.dom ? n : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function YO(s, e) {
  let t = e.startContainer, i = e.startOffset, n = e.endContainer, r = e.endOffset, a = s.docView.domAtPos(s.state.selection.main.anchor);
  return pa(a.node, a.offset, n, r) && ([t, i, n, r] = [n, r, t, i]), { anchorNode: t, anchorOffset: i, focusNode: n, focusOffset: r };
}
function oX(s, e) {
  if (e.getComposedRanges) {
    let n = e.getComposedRanges(s.root)[0];
    if (n)
      return YO(s, n);
  }
  let t = null;
  function i(n) {
    n.preventDefault(), n.stopImmediatePropagation(), t = n.getTargetRanges()[0];
  }
  return s.contentDOM.addEventListener("beforeinput", i, !0), s.dom.ownerDocument.execCommand("indent"), s.contentDOM.removeEventListener("beforeinput", i, !0), t ? YO(s, t) : null;
}
class lX {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let n = e.state.selection.main, { anchor: r, head: a } = n, o = this.toEditorPos(i.updateRangeStart), l = this.toEditorPos(i.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let c = { from: o, to: l, insert: $e.of(i.text.split(`
`)) };
      if (c.from == this.from && r < this.from ? c.from = r : c.to == this.to && r > this.to && (c.to = r), c.from == c.to && !c.insert.length) {
        let h = D.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        h.main.eq(n) || e.dispatch({ selection: h, userEvent: "select" });
        return;
      }
      if ((ne.mac || ne.android) && c.from == a - 1 && /^\. ?$/.test(i.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: o, to: l, insert: $e.of([i.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let h = this.to - this.from + (c.to - c.from + c.insert.length);
        Kp(e, c, D.single(this.toEditorPos(i.selectionStart, h), this.toEditorPos(i.selectionEnd, h)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (i) => {
      let n = [], r = null;
      for (let a = this.toEditorPos(i.rangeStart), o = this.toEditorPos(i.rangeEnd); a < o; a++) {
        let l = e.coordsForChar(a);
        r = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || r || new DOMRect(), n.push(r);
      }
      t.updateCharacterBounds(i.rangeStart, n);
    }, this.handlers.textformatupdate = (i) => {
      let n = [];
      for (let r of i.getTextFormats()) {
        let a = r.underlineStyle, o = r.underlineThickness;
        if (a != "None" && o != "None") {
          let l = this.toEditorPos(r.rangeStart), c = this.toEditorPos(r.rangeEnd);
          if (l < c) {
            let h = `text-decoration: underline ${a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${o == "Thin" ? 1 : 2}px`;
            n.push(de.mark({ attributes: { style: h } }).range(l, c));
          }
        }
      }
      e.dispatch({ effects: ww.of(de.set(n)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(e.state);
      }
    };
    for (let i in this.handlers)
      t.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let n = _a(i.root);
      n && n.rangeCount && this.editContext.updateSelectionBounds(n.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, i = !1, n = this.pendingContextChange;
    return e.changes.iterChanges((r, a, o, l, c) => {
      if (i)
        return;
      let h = c.length - (a - r);
      if (n && a >= n.to)
        if (n.from == r && n.to == a && n.insert.eq(c)) {
          n = this.pendingContextChange = null, t += h, this.to += h;
          return;
        } else
          n = null, this.revertPending(e.state);
      if (r += t, a += t, a <= this.from)
        this.from += h, this.to += h;
      else if (r < this.to) {
        if (r < this.from || a > this.to || this.to - this.from + c.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(r), this.toContextPos(a), c.toString()), this.to += h;
      }
      t += h;
    }), n && !i && this.revertPending(e.state), !i;
  }
  update(e) {
    let t = this.pendingContextChange, i = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(i.from, i.to) && e.transactions.some((n) => !n.isUserEvent("input.type") && n.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), n = this.toContextPos(t.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != n) && this.editContext.updateSelection(i, n);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (e - i.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class J {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: i } = e;
    this.dispatchTransactions = e.dispatchTransactions || i && ((n) => n.forEach((r) => i(r, this))) || ((n) => this.update(n)), this.dispatch = this.dispatch.bind(this), this._root = e.root || WR(e.parent) || document, this.viewState = new DO(e.state || Ce.create(e)), e.scrollTo && e.scrollTo.is(Bo) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Un).map((n) => new su(n));
    for (let n of this.plugins)
      n.update(this);
    this.observer = new aX(this), this.inputState = new TE(this), this.inputState.ensureHandlers(this.plugins), this.docView = new vO(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof lt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, n, r = this.state;
    for (let d of e) {
      if (d.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    let a = this.hasFocus, o = 0, l = null;
    e.some((d) => d.annotation(_w)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = Lw(r, a), l || (o = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(r.doc) || !this.state.selection.eq(r.selection)) && (h = null)) : this.observer.clear(), r.facet(Ce.phrases) != this.state.facet(Ce.phrases))
      return this.setState(r);
    n = lc.create(this, r, e), n.flags |= o;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (u && (u = u.map(d.changes)), d.scrollIntoView) {
          let { main: f } = d.state.selection;
          u = new sr(f.empty ? f : D.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of d.effects)
          f.is(Bo) && (u = f.value.clip(this.state));
      }
      this.viewState.update(n, u), this.bidiCache = hc.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), t = this.docView.update(n), this.state.facet(sa) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(Fo) != n.state.facet(Fo) && (this.viewState.mustMeasureContent = !0), (t || i || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !n.empty)
      for (let d of this.state.facet(df))
        try {
          d(n);
        } catch (f) {
          Bt(this.state, f, "update listener");
        }
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !Tw(this, h) && c.force && ir(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new DO(e), this.plugins = e.facet(Un).map((i) => new su(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new vO(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Un), i = e.state.facet(Un);
    if (t != i) {
      let n = [];
      for (let r of i) {
        let a = t.indexOf(r);
        if (a < 0)
          n.push(new su(r));
        else {
          let o = this.plugins[a];
          o.mustUpdate = e, n.push(o);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != e && r.destroy(this);
      this.plugins = n, this.pluginMap.clear();
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
    t != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (i) {
          Bt(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, n = i.scrollTop * this.scaleY, { scrollAnchorPos: r, scrollAnchorHeight: a } = this.viewState;
    Math.abs(n - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (Uv(i))
            r = -1, a = this.viewState.heightMap.height;
          else {
            let f = this.viewState.scrollAnchorAt(n);
            r = f.from, a = f.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((f) => {
          try {
            return f.read(this);
          } catch (p) {
            return Bt(this.state, p), ZO;
          }
        }), u = lc.create(this, this.state, []), d = !1;
        u.flags |= l, t ? t.flags |= l : t = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), d = this.docView.update(u), d && this.docViewUpdate());
        for (let f = 0; f < c.length; f++)
          if (h[f] != ZO)
            try {
              let p = c[f];
              p.write && p.write(h[f], this);
            } catch (p) {
              Bt(this.state, p);
            }
        if (d && this.docView.updateSelection(!0), !u.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let p = (r < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(r).top) - a;
              if (p > 1 || p < -1) {
                n = n + p, i.scrollTop = n / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let o of this.state.facet(df))
        o(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Of + " " + (this.state.facet(mf) ? Dw : qw) + " " + this.state.facet(Fo);
  }
  updateAttrs() {
    let e = NO(this, Sw, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(ps) ? "true" : "false",
      class: "cm-content",
      style: `${ne.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), NO(this, Hp, t);
    let i = this.observer.ignore(() => {
      let n = of(this.contentDOM, this.contentAttrs, t), r = of(this.dom, this.editorAttrs, e);
      return n || r;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(J.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(sa);
    let e = this.state.facet(J.cspNonce);
    Ys.mount(this.root, this.styleModules.concat(nX).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return ru(this, e, QO(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return ru(this, e, QO(this, e, t, (i) => yE(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let i = this.bidiSpans(e), n = this.textDirectionAt(e.from), r = i[t ? i.length - 1 : 0];
    return D.cursor(r.side(t, n) + e.from, r.forward(!t, n) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return bE(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return ru(this, e, vE(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), Aw(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), r = this.bidiSpans(n), a = r[_s.find(r, e - n.from, -1, t)];
    return Kc(i, a.dir == Ge.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(bw) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > cX)
      return uw(e.length);
    let t = this.textDirectionAt(e.from), i;
    for (let r of this.bidiCache)
      if (r.from == e.from && r.dir == t && (r.fresh || hw(r.isolates, i = yO(this, e))))
        return r.order;
    i || (i = yO(this, e));
    let n = sE(e.text, t, i);
    return this.bidiCache.push(new hc(e.from, e.to, t, i, !0, n)), n;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ne.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      jv(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Bo.of(new sr(typeof e == "number" ? D.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return Bo.of(new sr(D.cursor(i.from), "start", "start", i.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return ct.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return ct.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = Ys.newName(), n = [Fo.of(i), sa.of(xf(`.${i}`, e))];
    return t && t.dark && n.push(mf.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Qs.lowest(sa.of(xf("." + Of, e, Bw)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), n = i && Ne.get(i) || Ne.get(e);
    return ((t = n?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
J.styleModule = sa;
J.inputHandler = Ow;
J.clipboardInputFilter = Fp;
J.clipboardOutputFilter = jp;
J.scrollHandler = vw;
J.focusChangeEffect = xw;
J.perLineTextDirection = bw;
J.exceptionSink = mw;
J.updateListener = df;
J.editable = ps;
J.mouseSelectionStyle = gw;
J.dragMovesSelection = pw;
J.clickAddsSelectionRange = fw;
J.decorations = za;
J.outerDecorations = kw;
J.atomicRanges = Up;
J.bidiIsolatedRanges = Pw;
J.scrollMargins = Qw;
J.darkTheme = mf;
J.cspNonce = /* @__PURE__ */ se.define({ combine: (s) => s.length ? s[0] : "" });
J.contentAttributes = Hp;
J.editorAttributes = Sw;
J.lineWrapping = /* @__PURE__ */ J.contentAttributes.of({ class: "cm-lineWrapping" });
J.announce = /* @__PURE__ */ xe.define();
const cX = 4096, ZO = {};
class hc {
  constructor(e, t, i, n, r, a) {
    this.from = e, this.to = t, this.dir = i, this.isolates = n, this.fresh = r, this.order = a;
  }
  static update(e, t) {
    if (t.empty && !e.some((r) => r.fresh))
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : Ge.LTR;
    for (let r = Math.max(0, e.length - 10); r < e.length; r++) {
      let a = e[r];
      a.dir == n && !t.touchesRange(a.from, a.to) && i.push(new hc(t.mapPos(a.from, 1), t.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}
function NO(s, e, t) {
  for (let i = s.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let r = i[n], a = typeof r == "function" ? r(s) : r;
    a && af(a, t);
  }
  return t;
}
const hX = ne.mac ? "mac" : ne.windows ? "win" : ne.linux ? "linux" : "key";
function uX(s, e) {
  const t = s.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let n, r, a, o;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      o = !0;
    else if (/^a(lt)?$/i.test(c))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      r = !0;
    else if (/^s(hift)?$/i.test(c))
      a = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? o = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return n && (i = "Alt-" + i), r && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
function jo(s, e, t) {
  return e.altKey && (s = "Alt-" + s), e.ctrlKey && (s = "Ctrl-" + s), e.metaKey && (s = "Meta-" + s), t !== !1 && e.shiftKey && (s = "Shift-" + s), s;
}
const dX = /* @__PURE__ */ Qs.default(/* @__PURE__ */ J.domEventHandlers({
  keydown(s, e) {
    return Yw(Ww(e.state), s, e, "editor");
  }
})), yo = /* @__PURE__ */ se.define({ enables: dX }), VO = /* @__PURE__ */ new WeakMap();
function Ww(s) {
  let e = s.facet(yo), t = VO.get(e);
  return t || VO.set(e, t = gX(e.reduce((i, n) => i.concat(n), []))), t;
}
function fX(s, e, t) {
  return Yw(Ww(s.state), e, s, t);
}
let Es = null;
const pX = 4e3;
function gX(s, e = hX) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (a, o) => {
    let l = i[a];
    if (l == null)
      i[a] = o;
    else if (l != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, r = (a, o, l, c, h) => {
    var u, d;
    let f = t[a] || (t[a] = /* @__PURE__ */ Object.create(null)), p = o.split(/ (?!$)/).map((O) => uX(O, e));
    for (let O = 1; O < p.length; O++) {
      let x = p.slice(0, O).join(" ");
      n(x, !0), f[x] || (f[x] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(b) => {
          let v = Es = { view: b, prefix: x, scope: a };
          return setTimeout(() => {
            Es == v && (Es = null);
          }, pX), !0;
        }]
      });
    }
    let g = p.join(" ");
    n(g, !1);
    let m = f[g] || (f[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (u = f._any) === null || u === void 0 ? void 0 : u.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && m.run.push(l), c && (m.preventDefault = !0), h && (m.stopPropagation = !0);
  };
  for (let a of s) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let c of o) {
        let h = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: u } = a;
        for (let d in h)
          h[d].run.push((f) => u(f, bf));
      }
    let l = a[e] || a.key;
    if (l)
      for (let c of o)
        r(c, l, a.run, a.preventDefault, a.stopPropagation), a.shift && r(c, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return t;
}
let bf = null;
function Yw(s, e, t, i) {
  bf = e;
  let n = zR(e), r = It(n, 0), a = Vi(r) == n.length && n != " ", o = "", l = !1, c = !1, h = !1;
  Es && Es.view == t && Es.scope == i && (o = Es.prefix + " ", Rw.indexOf(e.keyCode) < 0 && (c = !0, Es = null));
  let u = /* @__PURE__ */ new Set(), d = (m) => {
    if (m) {
      for (let O of m.run)
        if (!u.has(O) && (u.add(O), O(t)))
          return m.stopPropagation && (h = !0), !0;
      m.preventDefault && (m.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, f = s[i], p, g;
  return f && (d(f[o + jo(n, e, !a)]) ? l = !0 : a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ne.windows && e.ctrlKey && e.altKey) && (p = Zs[e.keyCode]) && p != n ? (d(f[o + jo(p, e, !0)]) || e.shiftKey && (g = Ma[e.keyCode]) != n && g != p && d(f[o + jo(g, e, !1)])) && (l = !0) : a && e.shiftKey && d(f[o + jo(n, e, !0)]) && (l = !0), !l && d(f._any) && (l = !0)), c && (l = !0), l && h && e.stopPropagation(), bf = null, l;
}
class vo {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, n, r) {
    this.className = e, this.left = t, this.top = i, this.width = n, this.height = r;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let r = Zw(e);
      return [new vo(t, n.left - r.left, n.top - r.top, null, n.bottom - n.top)];
    } else
      return mX(e, t, i);
  }
}
function Zw(s) {
  let e = s.scrollDOM.getBoundingClientRect();
  return { left: (s.textDirection == Ge.LTR ? e.left : e.right - s.scrollDOM.clientWidth * s.scaleX) - s.scrollDOM.scrollLeft * s.scaleX, top: e.top - s.scrollDOM.scrollTop * s.scaleY };
}
function FO(s, e, t, i) {
  let n = s.coordsAtPos(e, t * 2);
  if (!n)
    return i;
  let r = s.dom.getBoundingClientRect(), a = (n.top + n.bottom) / 2, o = s.posAtCoords({ x: r.left + 1, y: a }), l = s.posAtCoords({ x: r.right - 1, y: a });
  return o == null || l == null ? i : { from: Math.max(i.from, Math.min(o, l)), to: Math.min(i.to, Math.max(o, l)) };
}
function mX(s, e, t) {
  if (t.to <= s.viewport.from || t.from >= s.viewport.to)
    return [];
  let i = Math.max(t.from, s.viewport.from), n = Math.min(t.to, s.viewport.to), r = s.textDirection == Ge.LTR, a = s.contentDOM, o = a.getBoundingClientRect(), l = Zw(s), c = a.querySelector(".cm-line"), h = c && window.getComputedStyle(c), u = o.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), d = o.right - (h ? parseInt(h.paddingRight) : 0), f = pf(s, i, 1), p = pf(s, n, -1), g = f.type == Xt.Text ? f : null, m = p.type == Xt.Text ? p : null;
  if (g && (s.lineWrapping || f.widgetLineBreaks) && (g = FO(s, i, 1, g)), m && (s.lineWrapping || p.widgetLineBreaks) && (m = FO(s, n, -1, m)), g && m && g.from == m.from && g.to == m.to)
    return x(b(t.from, t.to, g));
  {
    let y = g ? b(t.from, null, g) : v(f, !1), w = m ? b(null, t.to, m) : v(p, !0), S = [];
    return (g || f).to < (m || p).from - (g && m ? 1 : 0) || f.widgetLineBreaks > 1 && y.bottom + s.defaultLineHeight / 2 < w.top ? S.push(O(u, y.bottom, d, w.top)) : y.bottom < w.top && s.elementAtHeight((y.bottom + w.top) / 2).type == Xt.Text && (y.bottom = w.top = (y.bottom + w.top) / 2), x(y).concat(S).concat(x(w));
  }
  function O(y, w, S, k) {
    return new vo(e, y - l.left, w - l.top, S - y, k - w);
  }
  function x({ top: y, bottom: w, horizontal: S }) {
    let k = [];
    for (let A = 0; A < S.length; A += 2)
      k.push(O(S[A], y, S[A + 1], w));
    return k;
  }
  function b(y, w, S) {
    let k = 1e9, A = -1e9, T = [];
    function C(R, X, M, z, I) {
      let Y = s.coordsAtPos(R, R == S.to ? -2 : 2), V = s.coordsAtPos(M, M == S.from ? 2 : -2);
      !Y || !V || (k = Math.min(Y.top, V.top, k), A = Math.max(Y.bottom, V.bottom, A), I == Ge.LTR ? T.push(r && X ? u : Y.left, r && z ? d : V.right) : T.push(!r && z ? u : V.left, !r && X ? d : Y.right));
    }
    let P = y ?? S.from, $ = w ?? S.to;
    for (let R of s.visibleRanges)
      if (R.to > P && R.from < $)
        for (let X = Math.max(R.from, P), M = Math.min(R.to, $); ; ) {
          let z = s.state.doc.lineAt(X);
          for (let I of s.bidiSpans(z)) {
            let Y = I.from + z.from, V = I.to + z.from;
            if (Y >= M)
              break;
            V > X && C(Math.max(Y, X), y == null && Y <= P, Math.min(V, M), w == null && V >= $, I.dir);
          }
          if (X = z.to + 1, X >= M)
            break;
        }
    return T.length == 0 && C(P, y == null, $, w == null, s.textDirection), { top: k, bottom: A, horizontal: T };
  }
  function v(y, w) {
    let S = o.top + (w ? y.top : y.bottom);
    return { top: S, bottom: S, horizontal: [] };
  }
}
function OX(s, e) {
  return s.constructor == e.constructor && s.eq(e);
}
class xX {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Tl) != e.state.facet(Tl) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, i = e.facet(Tl);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !OX(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && t && n.constructor && this.drawn[i].constructor && n.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(n.draw(), t);
      for (; t; ) {
        let n = t.nextSibling;
        t.remove(), t = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Tl = /* @__PURE__ */ se.define();
function Nw(s) {
  return [
    ct.define((e) => new xX(e, s)),
    Tl.of(s)
  ];
}
const Ia = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function bX(s = {}) {
  return [
    Ia.of(s),
    yX,
    vX,
    wX,
    yw.of(!0)
  ];
}
function Vw(s) {
  return s.startState.facet(Ia) != s.state.facet(Ia);
}
const yX = /* @__PURE__ */ Nw({
  above: !0,
  markers(s) {
    let { state: e } = s, t = e.facet(Ia), i = [];
    for (let n of e.selection.ranges) {
      let r = n == e.selection.main;
      if (n.empty || t.drawRangeCursor) {
        let a = r ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", o = n.empty ? n : D.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let l of vo.forRange(s, a, o))
          i.push(l);
      }
    }
    return i;
  },
  update(s, e) {
    s.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = Vw(s);
    return t && jO(s.state, e), s.docChanged || s.selectionSet || t;
  },
  mount(s, e) {
    jO(e.state, s);
  },
  class: "cm-cursorLayer"
});
function jO(s, e) {
  e.style.animationDuration = s.facet(Ia).cursorBlinkRate + "ms";
}
const vX = /* @__PURE__ */ Nw({
  above: !1,
  markers(s) {
    return s.state.selection.ranges.map((e) => e.empty ? [] : vo.forRange(s, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(s, e) {
    return s.docChanged || s.selectionSet || s.viewportChanged || Vw(s);
  },
  class: "cm-selectionLayer"
}), wX = /* @__PURE__ */ Qs.highest(/* @__PURE__ */ J.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), Fw = /* @__PURE__ */ xe.define({
  map(s, e) {
    return s == null ? null : e.mapPos(s);
  }
}), aa = /* @__PURE__ */ gt.define({
  create() {
    return null;
  },
  update(s, e) {
    return s != null && (s = e.changes.mapPos(s)), e.effects.reduce((t, i) => i.is(Fw) ? i.value : t, s);
  }
}), SX = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.view = s, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(s) {
    var e;
    let t = s.state.field(aa);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (s.startState.field(aa) != t || s.docChanged || s.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: s } = this, e = s.state.field(aa), t = e != null && s.coordsAtPos(e);
    if (!t)
      return null;
    let i = s.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - i.left + s.scrollDOM.scrollLeft * s.scaleX,
      top: t.top - i.top + s.scrollDOM.scrollTop * s.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(s) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      s ? (this.cursor.style.left = s.left / e + "px", this.cursor.style.top = s.top / t + "px", this.cursor.style.height = s.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(s) {
    this.view.state.field(aa) != s && this.view.dispatch({ effects: Fw.of(s) });
  }
}, {
  eventObservers: {
    dragover(s) {
      this.setDropPos(this.view.posAtCoords({ x: s.clientX, y: s.clientY }));
    },
    dragleave(s) {
      (s.target == this.view.contentDOM || !this.view.contentDOM.contains(s.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function kX() {
  return [aa, SX];
}
function HO(s, e, t, i, n) {
  e.lastIndex = 0;
  for (let r = s.iterRange(t, i), a = t, o; !r.next().done; a += r.value.length)
    if (!r.lineBreak)
      for (; o = e.exec(r.value); )
        n(a + o.index, o);
}
function PX(s, e) {
  let t = s.visibleRanges;
  if (t.length == 1 && t[0].from == s.viewport.from && t[0].to == s.viewport.to)
    return t;
  let i = [];
  for (let { from: n, to: r } of t)
    n = Math.max(s.state.doc.lineAt(n).from, n - e), r = Math.min(s.state.doc.lineAt(r).to, r + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = r : i.push({ from: n, to: r });
  return i;
}
class QX {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: n, boundary: r, maxLength: a = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, n)
      this.addMatch = (o, l, c, h) => n(h, c, c + o[0].length, o, l);
    else if (typeof i == "function")
      this.addMatch = (o, l, c, h) => {
        let u = i(o, l, c);
        u && h(c, c + o[0].length, u);
      };
    else if (i)
      this.addMatch = (o, l, c, h) => h(c, c + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new vs(), i = t.add.bind(t);
    for (let { from: n, to: r } of PX(e, this.maxLength))
      HO(e.state.doc, this.regexp, n, r, (a, o) => this.addMatch(o, e, a, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((r, a, o, l) => {
      l >= e.view.viewport.from && o <= e.view.viewport.to && (i = Math.min(o, i), n = Math.max(l, n));
    }), e.viewportMoved || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, t.map(e.changes), i, n) : t;
  }
  updateRange(e, t, i, n) {
    for (let r of e.visibleRanges) {
      let a = Math.max(r.from, i), o = Math.min(r.to, n);
      if (o >= a) {
        let l = e.state.doc.lineAt(a), c = l.to < o ? e.state.doc.lineAt(o) : l, h = Math.max(r.from, l.from), u = Math.min(r.to, c.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              h = a;
              break;
            }
          for (; o < c.to; o++)
            if (this.boundary.test(c.text[o - c.from])) {
              u = o;
              break;
            }
        }
        let d = [], f, p = (g, m, O) => d.push(O.range(g, m));
        if (l == c)
          for (this.regexp.lastIndex = h - l.from; (f = this.regexp.exec(l.text)) && f.index < u - l.from; )
            this.addMatch(f, e, f.index + l.from, p);
        else
          HO(e.state.doc, this.regexp, h, u, (g, m) => this.addMatch(m, e, g, p));
        t = t.update({ filterFrom: h, filterTo: u, filter: (g, m) => g < h || m > u, add: d });
      }
    }
    return t;
  }
}
const yf = /x/.unicode != null ? "gu" : "g", CX = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, yf), AX = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let lu = null;
function TX() {
  var s;
  if (lu == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    lu = ((s = e.tabSize) !== null && s !== void 0 ? s : e.MozTabSize) != null;
  }
  return lu || !1;
}
const $l = /* @__PURE__ */ se.define({
  combine(s) {
    let e = ns(s, {
      render: null,
      specialChars: CX,
      addSpecialChars: null
    });
    return (e.replaceTabs = !TX()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, yf)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, yf)), e;
  }
});
function $X(s = {}) {
  return [$l.of(s), RX()];
}
let UO = null;
function RX() {
  return UO || (UO = ct.fromClass(class {
    constructor(s) {
      this.view = s, this.decorations = de.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(s.state.facet($l)), this.decorations = this.decorator.createDeco(s);
    }
    makeDecorator(s) {
      return new QX({
        regexp: s.specialChars,
        decoration: (e, t, i) => {
          let { doc: n } = t.state, r = It(e[0], 0);
          if (r == 9) {
            let a = n.lineAt(i), o = t.state.tabSize, l = Ti(a.text, o, i - a.from);
            return de.replace({
              widget: new _X((o - l % o) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[r] || (this.decorationCache[r] = de.replace({ widget: new MX(s, r) }));
        },
        boundary: s.replaceTabs ? void 0 : /[^]/
      });
    }
    update(s) {
      let e = s.state.facet($l);
      s.startState.facet($l) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(s.view)) : this.decorations = this.decorator.updateDeco(s, this.decorations);
    }
  }, {
    decorations: (s) => s.decorations
  }));
}
const EX = "•";
function XX(s) {
  return s >= 32 ? EX : s == 10 ? "␤" : String.fromCharCode(9216 + s);
}
class MX extends As {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = XX(this.code), i = e.state.phrase("Control character") + " " + (AX[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, t);
    if (n)
      return n;
    let r = document.createElement("span");
    return r.textContent = t, r.title = i, r.setAttribute("aria-label", i), r.className = "cm-specialChar", r;
  }
  ignoreEvent() {
    return !1;
  }
}
class _X extends As {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function LX() {
  return IX;
}
const zX = /* @__PURE__ */ de.line({ class: "cm-activeLine" }), IX = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.decorations = this.getDeco(s);
  }
  update(s) {
    (s.docChanged || s.selectionSet) && (this.decorations = this.getDeco(s.view));
  }
  getDeco(s) {
    let e = -1, t = [];
    for (let i of s.state.selection.ranges) {
      let n = s.lineBlockAt(i.head);
      n.from > e && (t.push(zX.range(n.from)), e = n.from);
    }
    return de.set(t);
  }
}, {
  decorations: (s) => s.decorations
}), vf = 2e3;
function qX(s, e, t) {
  let i = Math.min(e.line, t.line), n = Math.max(e.line, t.line), r = [];
  if (e.off > vf || t.off > vf || e.col < 0 || t.col < 0) {
    let a = Math.min(e.off, t.off), o = Math.max(e.off, t.off);
    for (let l = i; l <= n; l++) {
      let c = s.doc.line(l);
      c.length <= o && r.push(D.range(c.from + a, c.to + o));
    }
  } else {
    let a = Math.min(e.col, t.col), o = Math.max(e.col, t.col);
    for (let l = i; l <= n; l++) {
      let c = s.doc.line(l), h = Kd(c.text, a, s.tabSize, !0);
      if (h < 0)
        r.push(D.cursor(c.to));
      else {
        let u = Kd(c.text, o, s.tabSize);
        r.push(D.range(c.from + h, c.from + u));
      }
    }
  }
  return r;
}
function DX(s, e) {
  let t = s.coordsAtPos(s.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / s.defaultCharacterWidth)) : -1;
}
function GO(s, e) {
  let t = s.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = s.state.doc.lineAt(t), n = t - i.from, r = n > vf ? -1 : n == i.length ? DX(s, e.clientX) : Ti(i.text, s.state.tabSize, t - i.from);
  return { line: i.number, col: r, off: n };
}
function BX(s, e) {
  let t = GO(s, e), i = s.state.selection;
  return t ? {
    update(n) {
      if (n.docChanged) {
        let r = n.changes.mapPos(n.startState.doc.line(t.line).from), a = n.state.doc.lineAt(r);
        t = { line: a.number, col: t.col, off: Math.min(t.off, a.length) }, i = i.map(n.changes);
      }
    },
    get(n, r, a) {
      let o = GO(s, n);
      if (!o)
        return i;
      let l = qX(s.state, t, o);
      return l.length ? a ? D.create(l.concat(i.ranges)) : D.create(l) : i;
    }
  } : null;
}
function WX(s) {
  let e = (t) => t.altKey && t.button == 0;
  return J.mouseSelectionStyle.of((t, i) => e(i) ? BX(t, i) : null);
}
const YX = {
  Alt: [18, (s) => !!s.altKey],
  Control: [17, (s) => !!s.ctrlKey],
  Shift: [16, (s) => !!s.shiftKey],
  Meta: [91, (s) => !!s.metaKey]
}, ZX = { style: "cursor: crosshair" };
function NX(s = {}) {
  let [e, t] = YX[s.key || "Alt"], i = ct.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = !1;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(n) {
        this.set(n.keyCode == e || t(n));
      },
      keyup(n) {
        (n.keyCode == e || !t(n)) && this.set(!1);
      },
      mousemove(n) {
        this.set(t(n));
      }
    }
  });
  return [
    i,
    J.contentAttributes.of((n) => {
      var r;
      return !((r = n.plugin(i)) === null || r === void 0) && r.isDown ? ZX : null;
    })
  ];
}
const Vr = "-10000px";
class jw {
  constructor(e, t, i, n) {
    this.facet = t, this.createTooltipView = i, this.removeTooltipView = n, this.input = e.state.facet(t), this.tooltips = this.input.filter((a) => a);
    let r = null;
    this.tooltipViews = this.tooltips.map((a) => r = i(a, r));
  }
  update(e, t) {
    var i;
    let n = e.state.facet(this.facet), r = n.filter((l) => l);
    if (n === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let a = [], o = t ? [] : null;
    for (let l = 0; l < r.length; l++) {
      let c = r[l], h = -1;
      if (c) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let d = this.tooltips[u];
          d && d.create == c.create && (h = u);
        }
        if (h < 0)
          a[l] = this.createTooltipView(c, l ? a[l - 1] : null), o && (o[l] = !!c.above);
        else {
          let u = a[l] = this.tooltipViews[h];
          o && (o[l] = t[h]), u.update && u.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return t && (o.forEach((l, c) => t[c] = l), t.length = o.length), this.input = n, this.tooltips = r, this.tooltipViews = a, !0;
  }
}
function VX(s) {
  let e = s.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const cu = /* @__PURE__ */ se.define({
  combine: (s) => {
    var e, t, i;
    return {
      position: ne.ios ? "absolute" : ((e = s.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = s.find((n) => n.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = s.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || VX
    };
  }
}), KO = /* @__PURE__ */ new WeakMap(), tg = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.view = s, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = s.state.facet(cu);
    this.position = e.position, this.parent = e.parent, this.classes = s.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new jw(s, ig, (t, i) => this.createTooltip(t, i), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), s.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let s of this.manager.tooltipViews)
        this.intersectionObserver.observe(s.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(s) {
    s.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(s, this.above);
    e && this.observeIntersection();
    let t = e || s.geometryChanged, i = s.state.facet(cu);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(s, e) {
    let t = s.create(this.view), i = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), s.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let n = document.createElement("div");
      n.className = "cm-tooltip-arrow", t.dom.appendChild(n);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Vr, t.dom.style.left = "0px", this.container.insertBefore(t.dom, i), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var s, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (s = i.destroy) === null || s === void 0 || s.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let s = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (ne.gecko)
        t = r.offsetParent != this.container.ownerDocument.body;
      else if (r.style.top == Vr && r.style.left == "0px") {
        let a = r.getBoundingClientRect();
        t = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (s = r.width / this.parent.offsetWidth, e = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: s, scaleY: e } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), n = Gp(this.view);
    return {
      visible: {
        left: i.left + n.left,
        top: i.top + n.top,
        right: i.right - n.right,
        bottom: i.bottom - n.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((r, a) => {
        let o = this.manager.tooltipViews[a];
        return o.getCoords ? o.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(cu).tooltipSpace(this.view),
      scaleX: s,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(s) {
    var e;
    if (s.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { visible: t, space: i, scaleX: n, scaleY: r } = s, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let l = this.manager.tooltips[o], c = this.manager.tooltipViews[o], { dom: h } = c, u = s.pos[o], d = s.size[o];
      if (!u || l.clip !== !1 && (u.bottom <= Math.max(t.top, i.top) || u.top >= Math.min(t.bottom, i.bottom) || u.right < Math.max(t.left, i.left) - 0.1 || u.left > Math.min(t.right, i.right) + 0.1)) {
        h.style.top = Vr;
        continue;
      }
      let f = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = f ? 7 : 0, g = d.right - d.left, m = (e = KO.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top, O = c.offset || jX, x = this.view.textDirection == Ge.LTR, b = d.width > i.right - i.left ? x ? i.left : i.right - d.width : x ? Math.max(i.left, Math.min(u.left - (f ? 14 : 0) + O.x, i.right - g)) : Math.min(Math.max(i.left, u.left - g + (f ? 14 : 0) - O.x), i.right - g), v = this.above[o];
      !l.strictSide && (v ? u.top - m - p - O.y < i.top : u.bottom + m + p + O.y > i.bottom) && v == i.bottom - u.bottom > u.top - i.top && (v = this.above[o] = !v);
      let y = (v ? u.top - i.top : i.bottom - u.bottom) - p;
      if (y < m && c.resize !== !1) {
        if (y < this.view.defaultLineHeight) {
          h.style.top = Vr;
          continue;
        }
        KO.set(c, m), h.style.height = (m = y) / r + "px";
      } else h.style.height && (h.style.height = "");
      let w = v ? u.top - m - p - O.y : u.bottom + p + O.y, S = b + g;
      if (c.overlap !== !0)
        for (let k of a)
          k.left < S && k.right > b && k.top < w + m && k.bottom > w && (w = v ? k.top - m - 2 - p : k.bottom + p + 2);
      if (this.position == "absolute" ? (h.style.top = (w - s.parent.top) / r + "px", JO(h, (b - s.parent.left) / n)) : (h.style.top = w / r + "px", JO(h, b / n)), f) {
        let k = u.left + (x ? O.x : -O.x) - (b + 14 - 7);
        f.style.left = k / n + "px";
      }
      c.overlap !== !0 && a.push({ left: b, top: w, right: S, bottom: w + m }), h.classList.toggle("cm-tooltip-above", v), h.classList.toggle("cm-tooltip-below", !v), c.positioned && c.positioned(s.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let s of this.manager.tooltipViews)
        s.dom.style.top = Vr;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function JO(s, e) {
  let t = parseInt(s.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (s.style.left = e + "px");
}
const FX = /* @__PURE__ */ J.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), jX = { x: 0, y: 0 }, ig = /* @__PURE__ */ se.define({
  enables: [tg, FX]
}), uc = /* @__PURE__ */ se.define({
  combine: (s) => s.reduce((e, t) => e.concat(t), [])
});
class th {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new th(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new jw(e, uc, (t, i) => this.createHostedView(t, i), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let i of this.manager.tooltipViews) {
      let n = i[e];
      if (n !== void 0) {
        if (t === void 0)
          t = n;
        else if (t !== n)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const HX = /* @__PURE__ */ ig.compute([uc], (s) => {
  let e = s.facet(uc);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var i;
      return (i = t.end) !== null && i !== void 0 ? i : t.pos;
    })),
    create: th.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class UX {
  constructor(e, t, i, n, r) {
    this.view = e, this.source = t, this.field = i, this.setHover = n, this.hoverTime = r, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, i = e.docView.nearest(t.target);
    if (!i)
      return;
    let n, r = 1;
    if (i instanceof Ms)
      n = i.posAtStart;
    else {
      if (n = e.posAtCoords(t), n == null)
        return;
      let o = e.coordsAtPos(n);
      if (!o || t.y < o.top || t.y > o.bottom || t.x < o.left - e.defaultCharacterWidth || t.x > o.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(n)).find((h) => h.from <= n && h.to >= n), c = l && l.dir == Ge.RTL ? -1 : 1;
      r = t.x < o.left ? -c : c;
    }
    let a = this.source(e, n, r);
    if (a?.then) {
      let o = this.pending = { pos: n };
      a.then((l) => {
        this.pending == o && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => Bt(e.state, l, "hover tooltip"));
    } else a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) });
  }
  get tooltip() {
    let e = this.view.plugin(tg), t = e ? e.manager.tooltips.findIndex((i) => i.create == th.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: n, tooltip: r } = this;
    if (n.length && r && !GX(r.dom, e) || this.pending) {
      let { pos: a } = n[0] || this.pending, o = (i = (t = n[0]) === null || t === void 0 ? void 0 : t.end) !== null && i !== void 0 ? i : a;
      (a == o ? this.view.posAtCoords(this.lastMove) != a : !KX(this.view, a, o, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (i) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Ho = 4;
function GX(s, e) {
  let { left: t, right: i, top: n, bottom: r } = s.getBoundingClientRect(), a;
  if (a = s.querySelector(".cm-tooltip-arrow")) {
    let o = a.getBoundingClientRect();
    n = Math.min(o.top, n), r = Math.max(o.bottom, r);
  }
  return e.clientX >= t - Ho && e.clientX <= i + Ho && e.clientY >= n - Ho && e.clientY <= r + Ho;
}
function KX(s, e, t, i, n, r) {
  let a = s.scrollDOM.getBoundingClientRect(), o = s.documentTop + s.documentPadding.top + s.contentHeight;
  if (a.left > i || a.right < i || a.top > n || Math.min(a.bottom, o) < n)
    return !1;
  let l = s.posAtCoords({ x: i, y: n }, !1);
  return l >= e && l <= t;
}
function JX(s, e = {}) {
  let t = xe.define(), i = gt.define({
    create() {
      return [];
    },
    update(n, r) {
      if (n.length && (e.hideOnChange && (r.docChanged || r.selection) ? n = [] : e.hideOn && (n = n.filter((a) => !e.hideOn(r, a))), r.docChanged)) {
        let a = [];
        for (let o of n) {
          let l = r.changes.mapPos(o.pos, -1, yt.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), o);
            c.pos = l, c.end != null && (c.end = r.changes.mapPos(c.end)), a.push(c);
          }
        }
        n = a;
      }
      for (let a of r.effects)
        a.is(t) && (n = a.value), a.is(eM) && (n = []);
      return n;
    },
    provide: (n) => uc.from(n)
  });
  return {
    active: i,
    extension: [
      i,
      ct.define((n) => new UX(
        n,
        s,
        i,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      HX
    ]
  };
}
function Hw(s, e) {
  let t = s.plugin(tg);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const eM = /* @__PURE__ */ xe.define(), ex = /* @__PURE__ */ se.define({
  combine(s) {
    let e, t;
    for (let i of s)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function qa(s, e) {
  let t = s.plugin(Uw), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const Uw = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.input = s.state.facet(Da), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(s));
    let e = s.state.facet(ex);
    this.top = new Uo(s, !0, e.topContainer), this.bottom = new Uo(s, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(s) {
    let e = s.state.facet(ex);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Uo(s.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Uo(s.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = s.state.facet(Da);
    if (t != this.input) {
      let i = t.filter((l) => l), n = [], r = [], a = [], o = [];
      for (let l of i) {
        let c = this.specs.indexOf(l), h;
        c < 0 ? (h = l(s.view), o.push(h)) : (h = this.panels[c], h.update && h.update(s)), n.push(h), (h.top ? r : a).push(h);
      }
      this.specs = i, this.panels = n, this.top.sync(r), this.bottom.sync(a);
      for (let l of o)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(s);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (s) => J.scrollMargins.of((e) => {
    let t = e.plugin(s);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Uo {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = tx(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = tx(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function tx(s) {
  let e = s.nextSibling;
  return s.remove(), e;
}
const Da = /* @__PURE__ */ se.define({
  enables: Uw
});
class Ss extends Qn {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Ss.prototype.elementClass = "";
Ss.prototype.toDOM = void 0;
Ss.prototype.mapMode = yt.TrackBefore;
Ss.prototype.startSide = Ss.prototype.endSide = -1;
Ss.prototype.point = !0;
const Rl = /* @__PURE__ */ se.define(), tM = /* @__PURE__ */ se.define(), iM = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Xe.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, ma = /* @__PURE__ */ se.define();
function sM(s) {
  return [Gw(), ma.of({ ...iM, ...s })];
}
const ix = /* @__PURE__ */ se.define({
  combine: (s) => s.some((e) => e)
});
function Gw(s) {
  return [
    nM
  ];
}
const nM = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.view = s, this.prevViewport = s.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = s.state.facet(ma).map((e) => new nx(s, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !s.state.facet(ix), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), s.scrollDOM.insertBefore(this.dom, s.contentDOM);
  }
  update(s) {
    if (this.updateGutters(s)) {
      let e = this.prevViewport, t = s.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    s.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(ix) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = s.view.viewport;
  }
  syncGutters(s) {
    let e = this.dom.nextSibling;
    s && this.dom.remove();
    let t = Xe.iter(this.view.state.facet(Rl), this.view.viewport.from), i = [], n = this.gutters.map((r) => new rM(r, this.view.viewport, -this.view.documentPadding.top));
    for (let r of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(r.type)) {
        let a = !0;
        for (let o of r.type)
          if (o.type == Xt.Text && a) {
            wf(t, i, o.from);
            for (let l of n)
              l.line(this.view, o, i);
            a = !1;
          } else if (o.widget)
            for (let l of n)
              l.widget(this.view, o);
      } else if (r.type == Xt.Text) {
        wf(t, i, r.from);
        for (let a of n)
          a.line(this.view, r, i);
      } else if (r.widget)
        for (let a of n)
          a.widget(this.view, r);
    for (let r of n)
      r.finish();
    s && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(s) {
    let e = s.startState.facet(ma), t = s.state.facet(ma), i = s.docChanged || s.heightChanged || s.viewportChanged || !Xe.eq(s.startState.facet(Rl), s.state.facet(Rl), s.view.viewport.from, s.view.viewport.to);
    if (e == t)
      for (let n of this.gutters)
        n.update(s) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let r of t) {
        let a = e.indexOf(r);
        a < 0 ? n.push(new nx(this.view, r)) : (this.gutters[a].update(s), n.push(this.gutters[a]));
      }
      for (let r of this.gutters)
        r.dom.remove(), n.indexOf(r) < 0 && r.destroy();
      for (let r of n)
        this.dom.appendChild(r.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let s of this.gutters)
      s.destroy();
    this.dom.remove();
  }
}, {
  provide: (s) => J.scrollMargins.of((e) => {
    let t = e.plugin(s);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Ge.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function sx(s) {
  return Array.isArray(s) ? s : [s];
}
function wf(s, e, t) {
  for (; s.value && s.from <= t; )
    s.from == t && e.push(s.value), s.next();
}
class rM {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = Xe.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: n } = this, r = (t.top - this.height) / e.scaleY, a = t.height / e.scaleY;
    if (this.i == n.elements.length) {
      let o = new Kw(e, a, r, i);
      n.elements.push(o), n.dom.appendChild(o.dom);
    } else
      n.elements[this.i].update(e, a, r, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let n = [];
    wf(this.cursor, n, t.from), i.length && (n = n.concat(i));
    let r = this.gutter.config.lineMarker(e, t, n);
    r && n.unshift(r);
    let a = this.gutter;
    n.length == 0 && !a.config.renderEmptyElements || this.addElement(e, t, n);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t), n = i ? [i] : null;
    for (let r of e.state.facet(tM)) {
      let a = r(e, t.widget, t);
      a && (n || (n = [])).push(a);
    }
    n && this.addElement(e, t, n);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class nx {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let r = n.target, a;
        if (r != this.dom && this.dom.contains(r)) {
          for (; r.parentNode != this.dom; )
            r = r.parentNode;
          let l = r.getBoundingClientRect();
          a = (l.top + l.bottom) / 2;
        } else
          a = n.clientY;
        let o = e.lineBlockAtHeight(a - e.documentTop);
        t.domEventHandlers[i](e, o, n) && n.preventDefault();
      });
    this.markers = sx(t.markers(e)), t.initialSpacer && (this.spacer = new Kw(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = sx(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !Xe.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class Kw {
  constructor(e, t, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, n);
  }
  update(e, t, i, n) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), aM(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let r = 0, a = 0; ; ) {
      let o = a, l = r < t.length ? t[r++] : null, c = !1;
      if (l) {
        let h = l.elementClass;
        h && (i += " " + h);
        for (let u = a; u < this.markers.length; u++)
          if (this.markers[u].compare(l)) {
            o = u, c = !0;
            break;
          }
      } else
        o = this.markers.length;
      for (; a < o; ) {
        let h = this.markers[a++];
        if (h.toDOM) {
          h.destroy(n);
          let u = n.nextSibling;
          n.remove(), n = u;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? n = n.nextSibling : this.dom.insertBefore(l.toDOM(e), n)), c && a++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function aM(s, e) {
  if (s.length != e.length)
    return !1;
  for (let t = 0; t < s.length; t++)
    if (!s[t].compare(e[t]))
      return !1;
  return !0;
}
const oM = /* @__PURE__ */ se.define(), lM = /* @__PURE__ */ se.define(), Gn = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let n in t) {
          let r = i[n], a = t[n];
          i[n] = r ? (o, l, c) => r(o, l, c) || a(o, l, c) : a;
        }
        return i;
      }
    });
  }
});
class hu extends Ss {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function uu(s, e) {
  return s.state.facet(Gn).formatNumber(e, s.state);
}
const cM = /* @__PURE__ */ ma.compute([Gn], (s) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(oM);
  },
  lineMarker(e, t, i) {
    return i.some((n) => n.toDOM) ? null : new hu(uu(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, i) => {
    for (let n of e.state.facet(lM)) {
      let r = n(e, t, i);
      if (r)
        return r;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Gn) != e.state.facet(Gn),
  initialSpacer(e) {
    return new hu(uu(e, rx(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = uu(t.view, rx(t.view.state.doc.lines));
    return i == e.number ? e : new hu(i);
  },
  domEventHandlers: s.facet(Gn).domEventHandlers
}));
function hM(s = {}) {
  return [
    Gn.of(s),
    Gw(),
    cM
  ];
}
function rx(s) {
  let e = 9;
  for (; e < s; )
    e = e * 10 + 9;
  return e;
}
const uM = /* @__PURE__ */ new class extends Ss {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), dM = /* @__PURE__ */ Rl.compute(["selection"], (s) => {
  let e = [], t = -1;
  for (let i of s.selection.ranges) {
    let n = s.doc.lineAt(i.head).from;
    n > t && (t = n, e.push(uM.range(n)));
  }
  return Xe.of(e);
});
function fM() {
  return dM;
}
const Jw = 1024;
let pM = 0;
class hi {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class me {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = pM++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = ft.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
me.closedBy = new me({ deserialize: (s) => s.split(" ") });
me.openedBy = new me({ deserialize: (s) => s.split(" ") });
me.group = new me({ deserialize: (s) => s.split(" ") });
me.isolate = new me({ deserialize: (s) => {
  if (s && s != "rtl" && s != "ltr" && s != "auto")
    throw new RangeError("Invalid value for isolate: " + s);
  return s || "auto";
} });
me.contextHash = new me({ perNode: !0 });
me.lookAhead = new me({ perNode: !0 });
me.mounted = new me({ perNode: !0 });
class Ba {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[me.mounted.id];
  }
}
const gM = /* @__PURE__ */ Object.create(null);
class ft {
  /**
  @internal
  */
  constructor(e, t, i, n = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : gM, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new ft(e.name || "", t, e.id, i);
    if (e.props) {
      for (let r of e.props)
        if (Array.isArray(r) || (r = r(n)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[r[0].id] = r[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(me.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        t[n] = e[i];
    return (i) => {
      for (let n = i.prop(me.group), r = -1; r < (n ? n.length : 0); r++) {
        let a = t[r < 0 ? i.name : n[r]];
        if (a)
          return a;
      }
    };
  }
}
ft.none = new ft(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class wo {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let n = null;
      for (let r of e) {
        let a = r(i);
        a && (n || (n = Object.assign({}, i.props)), n[a[0].id] = a[1]);
      }
      t.push(n ? new ft(i.name, n, i.id, i.flags) : i);
    }
    return new wo(t);
  }
}
const Go = /* @__PURE__ */ new WeakMap(), ax = /* @__PURE__ */ new WeakMap();
var Ze;
(function(s) {
  s[s.ExcludeBuffers = 1] = "ExcludeBuffers", s[s.IncludeAnonymous = 2] = "IncludeAnonymous", s[s.IgnoreMounts = 4] = "IgnoreMounts", s[s.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ze || (Ze = {}));
class ze {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, i, n, r) {
    if (this.type = e, this.children = t, this.positions = i, this.length = n, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of r)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Ba.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (t && (t += ","), t += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new dc(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, i = 0) {
    let n = Go.get(this) || this.topNode, r = new dc(n);
    return r.moveTo(e, t), Go.set(this, r._tree), r;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new $t(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let i = Wa(Go.get(this) || this.topNode, e, t, !1);
    return Go.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let i = Wa(ax.get(this) || this.topNode, e, t, !0);
    return ax.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return xM(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: i, from: n = 0, to: r = this.length } = e, a = e.mode || 0, o = (a & Ze.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Ze.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= r && l.to >= n && (!o && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : rg(ft.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, n) => new ze(this.type, t, i, n, this.propValues), e.makeTree || ((t, i, n) => new ze(ft.none, t, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return bM(e);
  }
}
ze.empty = new ze(ft.none, [], [], 0);
class sg {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new sg(this.buffer, this.index);
  }
}
class Vs {
  /**
  Create a tree buffer.
  */
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return ft.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[t], r = n.name;
    if (/\W/.test(r) && !n.isError && (r = JSON.stringify(r)), e += 4, i == e)
      return r;
    let a = [];
    for (; e < i; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return r + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, i, n, r) {
    let { buffer: a } = this, o = -1;
    for (let l = e; l != t && !(e1(r, n, a[l + 1], a[l + 2]) && (o = l, i > 0)); l = a[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(e, t, i) {
    let n = this.buffer, r = new Uint16Array(t - e), a = 0;
    for (let o = e, l = 0; o < t; ) {
      r[l++] = n[o++], r[l++] = n[o++] - i;
      let c = r[l++] = n[o++] - i;
      r[l++] = n[o++] - e, a = Math.max(a, c);
    }
    return new Vs(r, a, this.set);
  }
}
function e1(s, e, t, i) {
  switch (s) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function Wa(s, e, t, i) {
  for (var n; s.from == s.to || (t < 1 ? s.from >= e : s.from > e) || (t > -1 ? s.to <= e : s.to < e); ) {
    let a = !i && s instanceof $t && s.index < 0 ? null : s.parent;
    if (!a)
      return s;
    s = a;
  }
  let r = i ? 0 : Ze.IgnoreOverlays;
  if (i)
    for (let a = s, o = a.parent; o; a = o, o = a.parent)
      a instanceof $t && a.index < 0 && ((n = o.enter(e, t, r)) === null || n === void 0 ? void 0 : n.from) != a.from && (s = o);
  for (; ; ) {
    let a = s.enter(e, t, r);
    if (!a)
      return s;
    s = a;
  }
}
class t1 {
  cursor(e = 0) {
    return new dc(this, e);
  }
  getChild(e, t = null, i = null) {
    let n = ox(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return ox(this, e, t, i);
  }
  resolve(e, t = 0) {
    return Wa(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Wa(this, e, t, !0);
  }
  matchContext(e) {
    return Sf(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), i = this;
    for (; t; ) {
      let n = t.lastChild;
      if (!n || n.to != t.to)
        break;
      n.type.isError && n.from == n.to ? (i = t, t = n.prevSibling) : t = n;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class $t extends t1 {
  constructor(e, t, i, n) {
    super(), this._tree = e, this.from = t, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, n, r = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: l } = a._tree, c = t > 0 ? o.length : -1; e != c; e += t) {
        let h = o[e], u = l[e] + a.from;
        if (e1(n, i, u, u + h.length)) {
          if (h instanceof Vs) {
            if (r & Ze.ExcludeBuffers)
              continue;
            let d = h.findChild(0, h.buffer.length, t, i - u, n);
            if (d > -1)
              return new ji(new mM(a, h, e, u), null, d);
          } else if (r & Ze.IncludeAnonymous || !h.type.isAnonymous || ng(h)) {
            let d;
            if (!(r & Ze.IgnoreMounts) && (d = Ba.get(h)) && !d.overlay)
              return new $t(d.tree, u, e, a);
            let f = new $t(h, u, e, a);
            return r & Ze.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(t < 0 ? h.children.length - 1 : 0, t, i, n);
          }
        }
      }
      if (r & Ze.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + t : e = t < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let n;
    if (!(i & Ze.IgnoreOverlays) && (n = Ba.get(this._tree)) && n.overlay) {
      let r = e - this.from;
      for (let { from: a, to: o } of n.overlay)
        if ((t > 0 ? a <= r : a < r) && (t < 0 ? o >= r : o > r))
          return new $t(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function ox(s, e, t, i) {
  let n = s.cursor(), r = [];
  if (!n.firstChild())
    return r;
  if (t != null) {
    for (let a = !1; !a; )
      if (a = n.type.is(t), !n.nextSibling())
        return r;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return r;
    if (n.type.is(e) && r.push(n.node), !n.nextSibling())
      return i == null ? r : [];
  }
}
function Sf(s, e, t = e.length - 1) {
  for (let i = s; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class mM {
  constructor(e, t, i, n) {
    this.parent = e, this.buffer = t, this.index = i, this.start = n;
  }
}
class ji extends t1 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    super(), this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: n } = this.context, r = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.context.start, i);
    return r < 0 ? null : new ji(this.context, this, r);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & Ze.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, r = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return r < 0 ? null : new ji(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new ji(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new ji(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, n = this.index + 4, r = i.buffer[this.index + 3];
    if (r > n) {
      let a = i.buffer[this.index + 1];
      e.push(i.slice(n, r, a)), t.push(0);
    }
    return new ze(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function i1(s) {
  if (!s.length)
    return null;
  let e = 0, t = s[0];
  for (let r = 1; r < s.length; r++) {
    let a = s[r];
    (a.from > t.from || a.to < t.to) && (t = a, e = r);
  }
  let i = t instanceof $t && t.index < 0 ? null : t.parent, n = s.slice();
  return i ? n[e] = i : n.splice(e, 1), new OM(n, t);
}
class OM {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return i1(this.heads);
  }
}
function xM(s, e, t) {
  let i = s.resolveInner(e, t), n = null;
  for (let r = i instanceof $t ? i : i.context.parent; r; r = r.parent)
    if (r.index < 0) {
      let a = r.parent;
      (n || (n = [i])).push(a.resolve(e, t)), r = a;
    } else {
      let a = Ba.get(r.tree);
      if (a && a.overlay && a.overlay[0].from <= e && a.overlay[a.overlay.length - 1].to >= e) {
        let o = new $t(a.tree, a.overlay[0].from + r.from, -1, r);
        (n || (n = [i])).push(Wa(o, e, t, !1));
      }
    }
  return n ? i1(n) : i;
}
class dc {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof $t)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = t || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof $t ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: n } = this.buffer, r = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.buffer.start, i);
    return r < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(r));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, i = this.mode) {
    return this.buffer ? i & Ze.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ze.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ze.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(t.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = t.buffer[this.index + 3];
      if (n < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let r = 0; r < this.index; r++)
          if (n.buffer.buffer[r + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = n);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let r = t + e, a = e < 0 ? -1 : i._tree.children.length; r != a; r += e) {
          let o = i._tree.children[r];
          if (this.mode & Ze.IncludeAnonymous || o instanceof Vs || !o.type.isAnonymous || ng(o))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e: for (let n = this.index, r = this.stack.length; r >= 0; ) {
        for (let a = e; a; a = a._parent)
          if (a.index == n) {
            if (n == this.index)
              return a;
            t = a, i = r + 1;
            break e;
          }
        n = this.stack[--r];
      }
    for (let n = i; n < this.stack.length; n++)
      t = new ji(this.buffer, t, this.stack[n]);
    return this.bufferNode = new ji(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; ; ) {
        if (n && t && t(this), n = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Sf(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let n = e.length - 1, r = this.stack.length - 1; n >= 0; r--) {
      if (r < 0)
        return Sf(this._tree, e, n);
      let a = i[t.buffer[this.stack[r]]];
      if (!a.isAnonymous) {
        if (e[n] && e[n] != a.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function ng(s) {
  return s.children.some((e) => e instanceof Vs || !e.type.isAnonymous || ng(e));
}
function bM(s) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: n = Jw, reused: r = [], minRepeatType: a = i.types.length } = s, o = Array.isArray(t) ? new sg(t, t.length) : t, l = i.types, c = 0, h = 0;
  function u(y, w, S, k, A, T) {
    let { id: C, start: P, end: $, size: R } = o, X = h, M = c;
    for (; R < 0; )
      if (o.next(), R == -1) {
        let N = r[C];
        S.push(N), k.push(P - y);
        return;
      } else if (R == -3) {
        c = C;
        return;
      } else if (R == -4) {
        h = C;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${R}`);
    let z = l[C], I, Y, V = P - y;
    if ($ - P <= n && (Y = m(o.pos - w, A))) {
      let N = new Uint16Array(Y.size - Y.skip), _ = o.pos - Y.size, U = N.length;
      for (; o.pos > _; )
        U = O(Y.start, N, U);
      I = new Vs(N, $ - Y.start, i), V = Y.start - y;
    } else {
      let N = o.pos - R;
      o.next();
      let _ = [], U = [], q = C >= a ? C : -1, oe = 0, ae = $;
      for (; o.pos > N; )
        q >= 0 && o.id == q && o.size >= 0 ? (o.end <= ae - n && (p(_, U, P, oe, o.end, ae, q, X, M), oe = _.length, ae = o.end), o.next()) : T > 2500 ? d(P, N, _, U) : u(P, N, _, U, q, T + 1);
      if (q >= 0 && oe > 0 && oe < _.length && p(_, U, P, oe, P, ae, q, X, M), _.reverse(), U.reverse(), q > -1 && oe > 0) {
        let ue = f(z, M);
        I = rg(z, _, U, 0, _.length, 0, $ - P, ue, ue);
      } else
        I = g(z, _, U, $ - P, X - $, M);
    }
    S.push(I), k.push(V);
  }
  function d(y, w, S, k) {
    let A = [], T = 0, C = -1;
    for (; o.pos > w; ) {
      let { id: P, start: $, end: R, size: X } = o;
      if (X > 4)
        o.next();
      else {
        if (C > -1 && $ < C)
          break;
        C < 0 && (C = R - n), A.push(P, $, R), T++, o.next();
      }
    }
    if (T) {
      let P = new Uint16Array(T * 4), $ = A[A.length - 2];
      for (let R = A.length - 3, X = 0; R >= 0; R -= 3)
        P[X++] = A[R], P[X++] = A[R + 1] - $, P[X++] = A[R + 2] - $, P[X++] = X;
      S.push(new Vs(P, A[2] - $, i)), k.push($ - y);
    }
  }
  function f(y, w) {
    return (S, k, A) => {
      let T = 0, C = S.length - 1, P, $;
      if (C >= 0 && (P = S[C]) instanceof ze) {
        if (!C && P.type == y && P.length == A)
          return P;
        ($ = P.prop(me.lookAhead)) && (T = k[C] + P.length + $);
      }
      return g(y, S, k, A, T, w);
    };
  }
  function p(y, w, S, k, A, T, C, P, $) {
    let R = [], X = [];
    for (; y.length > k; )
      R.push(y.pop()), X.push(w.pop() + S - A);
    y.push(g(i.types[C], R, X, T - A, P - T, $)), w.push(A - S);
  }
  function g(y, w, S, k, A, T, C) {
    if (T) {
      let P = [me.contextHash, T];
      C = C ? [P].concat(C) : [P];
    }
    if (A > 25) {
      let P = [me.lookAhead, A];
      C = C ? [P].concat(C) : [P];
    }
    return new ze(y, w, S, k, C);
  }
  function m(y, w) {
    let S = o.fork(), k = 0, A = 0, T = 0, C = S.end - n, P = { size: 0, start: 0, skip: 0 };
    e: for (let $ = S.pos - y; S.pos > $; ) {
      let R = S.size;
      if (S.id == w && R >= 0) {
        P.size = k, P.start = A, P.skip = T, T += 4, k += 4, S.next();
        continue;
      }
      let X = S.pos - R;
      if (R < 0 || X < $ || S.start < C)
        break;
      let M = S.id >= a ? 4 : 0, z = S.start;
      for (S.next(); S.pos > X; ) {
        if (S.size < 0)
          if (S.size == -3)
            M += 4;
          else
            break e;
        else S.id >= a && (M += 4);
        S.next();
      }
      A = z, k += R, T += M;
    }
    return (w < 0 || k == y) && (P.size = k, P.start = A, P.skip = T), P.size > 4 ? P : void 0;
  }
  function O(y, w, S) {
    let { id: k, start: A, end: T, size: C } = o;
    if (o.next(), C >= 0 && k < a) {
      let P = S;
      if (C > 4) {
        let $ = o.pos - (C - 4);
        for (; o.pos > $; )
          S = O(y, w, S);
      }
      w[--S] = P, w[--S] = T - y, w[--S] = A - y, w[--S] = k;
    } else C == -3 ? c = k : C == -4 && (h = k);
    return S;
  }
  let x = [], b = [];
  for (; o.pos > 0; )
    u(s.start || 0, s.bufferStart || 0, x, b, -1, 0);
  let v = (e = s.length) !== null && e !== void 0 ? e : x.length ? b[0] + x[0].length : 0;
  return new ze(l[s.topID], x.reverse(), b.reverse(), v);
}
const lx = /* @__PURE__ */ new WeakMap();
function El(s, e) {
  if (!s.isAnonymous || e instanceof Vs || e.type != s)
    return 1;
  let t = lx.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != s || !(i instanceof ze)) {
        t = 1;
        break;
      }
      t += El(s, i);
    }
    lx.set(e, t);
  }
  return t;
}
function rg(s, e, t, i, n, r, a, o, l) {
  let c = 0;
  for (let p = i; p < n; p++)
    c += El(s, e[p]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), u = [], d = [];
  function f(p, g, m, O, x) {
    for (let b = m; b < O; ) {
      let v = b, y = g[b], w = El(s, p[b]);
      for (b++; b < O; b++) {
        let S = El(s, p[b]);
        if (w + S >= h)
          break;
        w += S;
      }
      if (b == v + 1) {
        if (w > h) {
          let S = p[v];
          f(S.children, S.positions, 0, S.children.length, g[v] + x);
          continue;
        }
        u.push(p[v]);
      } else {
        let S = g[b - 1] + p[b - 1].length - y;
        u.push(rg(s, p, g, v, b, y, S, null, l));
      }
      d.push(y + x - r);
    }
  }
  return f(e, t, i, n, 0), (o || l)(u, d, a);
}
class ag {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof ji ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof $t && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof ji ? this.getBuffer(e.context.buffer, e.index) : e instanceof $t ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class bs {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, i, n, r = !1, a = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = n, this.open = (r ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], i = !1) {
    let n = [new bs(0, e.length, e, 0, !1, i)];
    for (let r of t)
      r.to > e.length && n.push(r);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let n = [], r = 1, a = e.length ? e[0] : null;
    for (let o = 0, l = 0, c = 0; ; o++) {
      let h = o < t.length ? t[o] : null, u = h ? h.fromA : 1e9;
      if (u - l >= i)
        for (; a && a.from < u; ) {
          let d = a;
          if (l >= d.from || u <= d.to || c) {
            let f = Math.max(d.from, l) - c, p = Math.min(d.to, u) - c;
            d = f >= p ? null : new bs(f, p, d.tree, d.offset + c, o > 0, !!h);
          }
          if (d && n.push(d), a.to > u)
            break;
          a = r < e.length ? e[r++] : null;
        }
      if (!h)
        break;
      l = h.toA, c = h.toA - h.toB;
    }
    return n;
  }
}
class og {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, i) {
    return typeof e == "string" && (e = new yM(e)), i = i ? i.length ? i.map((n) => new hi(n.from, n.to)) : [new hi(0, 0)] : [new hi(0, e.length)], this.createParse(e, t || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, i) {
    let n = this.startParse(e, t, i);
    for (; ; ) {
      let r = n.advance();
      if (r)
        return r;
    }
  }
}
class yM {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function s1(s) {
  return (e, t, i, n) => new wM(e, s, t, i, n);
}
class cx {
  constructor(e, t, i, n, r) {
    this.parser = e, this.parse = t, this.overlay = i, this.target = n, this.from = r;
  }
}
function hx(s) {
  if (!s.length || s.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(s));
}
class vM {
  constructor(e, t, i, n, r, a, o) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = n, this.start = r, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
}
const kf = new me({ perNode: !0 });
class wM {
  constructor(e, t, i, n, r) {
    this.nest = t, this.input = i, this.fragments = n, this.ranges = r, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new ze(i.type, i.children, i.positions, i.length, i.propValues.concat([[kf, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[me.mounted.id] = new Ba(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new PM(this.fragments), t = null, i = null, n = new dc(new $t(this.baseTree, this.ranges[0].from, 0, null), Ze.IncludeAnonymous | Ze.IgnoreMounts);
    e: for (let r, a; ; ) {
      let o = !0, l;
      if (this.stoppedAt != null && n.from >= this.stoppedAt)
        o = !1;
      else if (e.hasNode(n)) {
        if (t) {
          let c = t.mounts.find((h) => h.frag.from <= n.from && h.frag.to >= n.to && h.mount.overlay);
          if (c)
            for (let h of c.mount.overlay) {
              let u = h.from + c.pos, d = h.to + c.pos;
              u >= n.from && d <= n.to && !t.ranges.some((f) => f.from < d && f.to > u) && t.ranges.push({ from: u, to: d });
            }
        }
        o = !1;
      } else if (i && (a = SM(i.ranges, n.from, n.to)))
        o = a != 2;
      else if (!n.type.isAnonymous && (r = this.nest(n, this.input)) && (n.from < n.to || !r.overlay)) {
        n.tree || kM(n);
        let c = e.findMounts(n.from, r.parser);
        if (typeof r.overlay == "function")
          t = new vM(r.parser, r.overlay, c, this.inner.length, n.from, n.tree, t);
        else {
          let h = fx(this.ranges, r.overlay || (n.from < n.to ? [new hi(n.from, n.to)] : []));
          h.length && hx(h), (h.length || !r.overlay) && this.inner.push(new cx(r.parser, h.length ? r.parser.startParse(this.input, px(c, h), h) : r.parser.startParse(""), r.overlay ? r.overlay.map((u) => new hi(u.from - n.from, u.to - n.from)) : null, n.tree, h.length ? h[0].from : n.from)), r.overlay ? h.length && (i = { ranges: h, depth: 0, prev: i }) : o = !1;
        }
      } else if (t && (l = t.predicate(n)) && (l === !0 && (l = new hi(n.from, n.to)), l.from < l.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == l.from ? t.ranges[c] = { from: t.ranges[c].from, to: l.to } : t.ranges.push(l);
      }
      if (o && n.firstChild())
        t && t.depth++, i && i.depth++;
      else
        for (; !n.nextSibling(); ) {
          if (!n.parent())
            break e;
          if (t && !--t.depth) {
            let c = fx(this.ranges, t.ranges);
            c.length && (hx(c), this.inner.splice(t.index, 0, new cx(t.parser, t.parser.startParse(this.input, px(t.mounts, c), c), t.ranges.map((h) => new hi(h.from - t.start, h.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}
function SM(s, e, t) {
  for (let i of s) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function ux(s, e, t, i, n, r) {
  if (e < t) {
    let a = s.buffer[e + 1];
    i.push(s.slice(e, t, a)), n.push(a - r);
  }
}
function kM(s) {
  let { node: e } = s, t = [], i = e.context.buffer;
  do
    t.push(s.index), s.parent();
  while (!s.tree);
  let n = s.tree, r = n.children.indexOf(i), a = n.children[r], o = a.buffer, l = [r];
  function c(h, u, d, f, p, g) {
    let m = t[g], O = [], x = [];
    ux(a, h, m, O, x, f);
    let b = o[m + 1], v = o[m + 2];
    l.push(O.length);
    let y = g ? c(m + 4, o[m + 3], a.set.types[o[m]], b, v - b, g - 1) : e.toTree();
    return O.push(y), x.push(b - f), ux(a, o[m + 3], u, O, x, f), new ze(d, O, x, p);
  }
  n.children[r] = c(0, o.length, ft.none, 0, a.length, t.length - 1);
  for (let h of l) {
    let u = s.tree.children[h], d = s.tree.positions[h];
    s.yield(new $t(u, d + s.from, h, s._tree));
  }
}
class dx {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Ze.IncludeAnonymous | Ze.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, Ze.IgnoreOverlays | Ze.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof ze)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let PM = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(kf)) !== null && t !== void 0 ? t : i.to, this.inner = new dx(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(kf)) !== null && e !== void 0 ? e : t.to, this.inner = new dx(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let r = this.inner.cursor.node; r; r = r.parent) {
        let a = (i = r.tree) === null || i === void 0 ? void 0 : i.prop(me.mounted);
        if (a && a.parser == t)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= r.to)
              break;
            l.tree == this.curFrag.tree && n.push({
              frag: l,
              pos: r.from - l.offset,
              mount: a
            });
          }
      }
    }
    return n;
  }
};
function fx(s, e) {
  let t = null, i = e;
  for (let n = 1, r = 0; n < s.length; n++) {
    let a = s[n - 1].to, o = s[n].from;
    for (; r < i.length; r++) {
      let l = i[r];
      if (l.from >= o)
        break;
      l.to <= a || (t || (i = t = e.slice()), l.from < a ? (t[r] = new hi(l.from, a), l.to > o && t.splice(r + 1, 0, new hi(o, l.to))) : l.to > o ? t[r--] = new hi(o, l.to) : t.splice(r--, 1));
    }
  }
  return i;
}
function QM(s, e, t, i) {
  let n = 0, r = 0, a = !1, o = !1, l = -1e9, c = [];
  for (; ; ) {
    let h = n == s.length ? 1e9 : a ? s[n].to : s[n].from, u = r == e.length ? 1e9 : o ? e[r].to : e[r].from;
    if (a != o) {
      let d = Math.max(l, t), f = Math.min(h, u, i);
      d < f && c.push(new hi(d, f));
    }
    if (l = Math.min(h, u), l == 1e9)
      break;
    h == l && (a ? (a = !1, n++) : a = !0), u == l && (o ? (o = !1, r++) : o = !0);
  }
  return c;
}
function px(s, e) {
  let t = [];
  for (let { pos: i, mount: n, frag: r } of s) {
    let a = i + (n.overlay ? n.overlay[0].from : 0), o = a + n.tree.length, l = Math.max(r.from, a), c = Math.min(r.to, o);
    if (n.overlay) {
      let h = n.overlay.map((d) => new hi(d.from + i, d.to + i)), u = QM(e, h, l, c);
      for (let d = 0, f = l; ; d++) {
        let p = d == u.length, g = p ? c : u[d].from;
        if (g > f && t.push(new bs(f, g, n.tree, -a, r.from >= f || r.openStart, r.to <= g || r.openEnd)), p)
          break;
        f = u[d].to;
      }
    } else
      t.push(new bs(l, c, n.tree, -a, r.from >= a || r.openStart, r.to <= o || r.openEnd));
  }
  return t;
}
let CM = 0, Zi = class Pf {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.name = e, this.set = t, this.base = i, this.modified = n, this.id = CM++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let i = typeof e == "string" ? e : "?";
    if (e instanceof Pf && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let n = new Pf(i, [], null, []);
    if (n.set.push(n), t)
      for (let r of t.set)
        n.set.push(r);
    return n;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new fc(e);
    return (i) => i.modified.indexOf(t) > -1 ? i : fc.get(i.base || i, i.modified.concat(t).sort((n, r) => n.id - r.id));
  }
}, AM = 0;
class fc {
  constructor(e) {
    this.name = e, this.instances = [], this.id = AM++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((o) => o.base == e && TM(t, o.modified));
    if (i)
      return i;
    let n = [], r = new Zi(e.name, n, e, t);
    for (let o of t)
      o.instances.push(r);
    let a = $M(t);
    for (let o of e.set)
      if (!o.modified.length)
        for (let l of a)
          n.push(fc.get(o, l));
    return r;
  }
}
function TM(s, e) {
  return s.length == e.length && s.every((t, i) => t == e[i]);
}
function $M(s) {
  let e = [[]];
  for (let t = 0; t < s.length; t++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(s[t]));
  return e.sort((t, i) => i.length - t.length);
}
function _i(s) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in s) {
    let i = s[t];
    Array.isArray(i) || (i = [i]);
    for (let n of t.split(" "))
      if (n) {
        let r = [], a = 2, o = n;
        for (let u = 0; ; ) {
          if (o == "..." && u > 0 && u + 3 == n.length) {
            a = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!d)
            throw new RangeError("Invalid path: " + n);
          if (r.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), u += d[0].length, u == n.length)
            break;
          let f = n[u++];
          if (u == n.length && f == "!") {
            a = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + n);
          o = n.slice(u);
        }
        let l = r.length - 1, c = r[l];
        if (!c)
          throw new RangeError("Invalid path: " + n);
        let h = new pc(i, a, l > 0 ? r.slice(0, l) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return n1.add(e);
}
const n1 = new me();
class pc {
  constructor(e, t, i, n) {
    this.tags = e, this.mode = t, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
pc.empty = new pc([], 2, null);
function r1(s, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r of s)
    if (!Array.isArray(r.tag))
      t[r.tag.id] = r.class;
    else
      for (let a of r.tag)
        t[a.id] = r.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (r) => {
      let a = n;
      for (let o of r)
        for (let l of o.set) {
          let c = t[l.id];
          if (c) {
            a = a ? a + " " + c : c;
            break;
          }
        }
      return a;
    },
    scope: i
  };
}
function RM(s, e) {
  let t = null;
  for (let i of s) {
    let n = i.style(e);
    n && (t = t ? t + " " + n : n);
  }
  return t;
}
function EM(s, e, t, i = 0, n = s.length) {
  let r = new XM(i, Array.isArray(e) ? e : [e], t);
  r.highlightRange(s.cursor(), i, n, "", r.highlighters), r.flush(n);
}
class XM {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, n, r) {
    let { type: a, from: o, to: l } = e;
    if (o >= i || l <= t)
      return;
    a.isTop && (r = this.highlighters.filter((f) => !f.scope || f.scope(a)));
    let c = n, h = MM(e) || pc.empty, u = RM(r, h.tags);
    if (u && (c && (c += " "), c += u, h.mode == 1 && (n += (n ? " " : "") + u)), this.startSpan(Math.max(t, o), c), h.opaque)
      return;
    let d = e.tree && e.tree.prop(me.mounted);
    if (d && d.overlay) {
      let f = e.node.enter(d.overlay[0].from + o, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(d.tree.type)), g = e.firstChild();
      for (let m = 0, O = o; ; m++) {
        let x = m < d.overlay.length ? d.overlay[m] : null, b = x ? x.from + o : l, v = Math.max(t, O), y = Math.min(i, b);
        if (v < y && g)
          for (; e.from < y && (this.highlightRange(e, v, y, n, r), this.startSpan(Math.min(y, e.to), c), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!x || b > i)
          break;
        O = x.to + o, O > t && (this.highlightRange(f.cursor(), Math.max(t, x.from + o), Math.min(i, O), "", p), this.startSpan(Math.min(i, O), c));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      d && (n = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, n, r), this.startSpan(Math.min(i, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function MM(s) {
  let e = s.type.prop(n1);
  for (; e && e.context && !s.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const G = Zi.define, Ko = G(), Ts = G(), gx = G(Ts), mx = G(Ts), $s = G(), Jo = G($s), du = G($s), Yi = G(), Hs = G(Yi), Di = G(), Bi = G(), Qf = G(), Fr = G(Qf), el = G(), Q = {
  /**
  A comment.
  */
  comment: Ko,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: G(Ko),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: G(Ko),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: G(Ko),
  /**
  Any kind of identifier.
  */
  name: Ts,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: G(Ts),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: gx,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: G(gx),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: mx,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: G(mx),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: G(Ts),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: G(Ts),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: G(Ts),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: G(Ts),
  /**
  A literal value.
  */
  literal: $s,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Jo,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: G(Jo),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: G(Jo),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: G(Jo),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: du,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: G(du),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: G(du),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: G($s),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: G($s),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: G($s),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: G($s),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: G($s),
  /**
  A language keyword.
  */
  keyword: Di,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: G(Di),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: G(Di),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: G(Di),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: G(Di),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: G(Di),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: G(Di),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: G(Di),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: G(Di),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: G(Di),
  /**
  An operator.
  */
  operator: Bi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: G(Bi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: G(Bi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: G(Bi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: G(Bi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: G(Bi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: G(Bi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: G(Bi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: G(Bi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: G(Bi),
  /**
  Program or markup punctuation.
  */
  punctuation: Qf,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: G(Qf),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Fr,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: G(Fr),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: G(Fr),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: G(Fr),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: G(Fr),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Yi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Hs,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: G(Hs),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: G(Hs),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: G(Hs),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: G(Hs),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: G(Hs),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: G(Hs),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: G(Yi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: G(Yi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: G(Yi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: G(Yi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: G(Yi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: G(Yi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: G(Yi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: G(Yi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: G(),
  /**
  Deleted text.
  */
  deleted: G(),
  /**
  Changed text.
  */
  changed: G(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: G(),
  /**
  Metadata or meta-instruction.
  */
  meta: el,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: G(el),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: G(el),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: G(el),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Zi.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Zi.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Zi.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Zi.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Zi.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Zi.defineModifier("special")
};
for (let s in Q) {
  let e = Q[s];
  e instanceof Zi && (e.name = s);
}
r1([
  { tag: Q.link, class: "tok-link" },
  { tag: Q.heading, class: "tok-heading" },
  { tag: Q.emphasis, class: "tok-emphasis" },
  { tag: Q.strong, class: "tok-strong" },
  { tag: Q.keyword, class: "tok-keyword" },
  { tag: Q.atom, class: "tok-atom" },
  { tag: Q.bool, class: "tok-bool" },
  { tag: Q.url, class: "tok-url" },
  { tag: Q.labelName, class: "tok-labelName" },
  { tag: Q.inserted, class: "tok-inserted" },
  { tag: Q.deleted, class: "tok-deleted" },
  { tag: Q.literal, class: "tok-literal" },
  { tag: Q.string, class: "tok-string" },
  { tag: Q.number, class: "tok-number" },
  { tag: [Q.regexp, Q.escape, Q.special(Q.string)], class: "tok-string2" },
  { tag: Q.variableName, class: "tok-variableName" },
  { tag: Q.local(Q.variableName), class: "tok-variableName tok-local" },
  { tag: Q.definition(Q.variableName), class: "tok-variableName tok-definition" },
  { tag: Q.special(Q.variableName), class: "tok-variableName2" },
  { tag: Q.definition(Q.propertyName), class: "tok-propertyName tok-definition" },
  { tag: Q.typeName, class: "tok-typeName" },
  { tag: Q.namespace, class: "tok-namespace" },
  { tag: Q.className, class: "tok-className" },
  { tag: Q.macroName, class: "tok-macroName" },
  { tag: Q.propertyName, class: "tok-propertyName" },
  { tag: Q.operator, class: "tok-operator" },
  { tag: Q.comment, class: "tok-comment" },
  { tag: Q.meta, class: "tok-meta" },
  { tag: Q.invalid, class: "tok-invalid" },
  { tag: Q.punctuation, class: "tok-punctuation" }
]);
var fu;
const un = /* @__PURE__ */ new me();
function lg(s) {
  return se.define({
    combine: s ? (e) => e.concat(s) : void 0
  });
}
const cg = /* @__PURE__ */ new me();
class ui {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], n = "") {
    this.data = e, this.name = n, Ce.prototype.hasOwnProperty("tree") || Object.defineProperty(Ce.prototype, "tree", { get() {
      return Ie(this);
    } }), this.parser = t, this.extension = [
      Fs.of(this),
      Ce.languageData.of((r, a, o) => {
        let l = Ox(r, a, o), c = l.type.prop(un);
        if (!c)
          return [];
        let h = r.facet(c), u = l.type.prop(cg);
        if (u) {
          let d = l.resolve(a - l.from, o);
          for (let f of u)
            if (f.test(d, r)) {
              let p = r.facet(f.facet);
              return f.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return Ox(e, t, i).type.prop(un) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Fs);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], n = (r, a) => {
      if (r.prop(un) == this.data) {
        i.push({ from: a, to: a + r.length });
        return;
      }
      let o = r.prop(me.mounted);
      if (o) {
        if (o.tree.prop(un) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + a, to: l.to + a });
          else
            i.push({ from: a, to: a + r.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (n(o.tree, o.overlay[0].from + a), i.length > l)
            return;
        }
      }
      for (let l = 0; l < r.children.length; l++) {
        let c = r.children[l];
        c instanceof ze && n(c, r.positions[l] + a);
      }
    };
    return n(Ie(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ui.setState = /* @__PURE__ */ xe.define();
function Ox(s, e, t) {
  let i = s.facet(Fs), n = Ie(s).topNode;
  if (!i || i.allowsNesting)
    for (let r = n; r; r = r.enter(e, t, Ze.ExcludeBuffers))
      r.type.isTop && (n = r);
  return n;
}
class Ei extends ui {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = lg(e.languageData);
    return new Ei(t, e.parser.configure({
      props: [un.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Ei(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Ie(s) {
  let e = s.field(ui.state, !1);
  return e ? e.tree : ze.empty;
}
class _M {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let jr = null;
class Ya {
  constructor(e, t, i = [], n, r, a, o, l) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = n, this.treeLen = r, this.viewport = a, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Ya(e, t, [], ze.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new _M(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != ze.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(bs.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(bs.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = jr;
    jr = this;
    try {
      return e();
    } finally {
      jr = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = xx(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: n, treeLen: r, viewport: a, skipped: o } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, h, u, d) => l.push({ fromA: c, toA: h, fromB: u, toB: d })), i = bs.applyChanges(i, l), n = ze.empty, r = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), u = e.mapPos(c.to, -1);
          h < u && o.push({ from: h, to: u });
        }
      }
    }
    return new Ya(this.parser, t, i, n, r, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: r } = this.skipped[i];
      n < e.to && r > e.from && (this.fragments = xx(this.fragments, n, r), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends og {
      createParse(t, i, n) {
        let r = n[0].from, a = n[n.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let l = jr;
            if (l) {
              for (let c of n)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new ze(ft.none, [], [], a - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return jr;
  }
}
function xx(s, e, t) {
  return bs.applyChanges(s, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class gr {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new gr(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = Ya.create(e.facet(Fs).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new gr(i);
  }
}
ui.state = /* @__PURE__ */ gt.define({
  create: gr.init,
  update(s, e) {
    for (let t of e.effects)
      if (t.is(ui.setState))
        return t.value;
    return e.startState.facet(Fs) != e.state.facet(Fs) ? gr.init(e.state) : s.apply(e);
  }
});
let a1 = (s) => {
  let e = setTimeout(
    () => s(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (a1 = (s) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(s, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const pu = typeof navigator < "u" && (!((fu = navigator.scheduling) === null || fu === void 0) && fu.isInputPending) ? () => navigator.scheduling.isInputPending() : null, LM = /* @__PURE__ */ ct.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(ui.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(ui.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = a1(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, r = i.field(ui.state);
    if (r.tree == r.context.tree && r.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, e && !pu ? Math.max(25, e.timeRemaining() - 5) : 1e9), o = r.context.treeLen < n && i.doc.length > n + 1e3, l = r.context.work(() => pu && pu() || Date.now() > a, n + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: ui.setState.of(new gr(r.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Bt(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Fs = /* @__PURE__ */ se.define({
  combine(s) {
    return s.length ? s[0] : null;
  },
  enables: (s) => [
    ui.state,
    LM,
    J.contentAttributes.compute([s], (e) => {
      let t = e.facet(s);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class is {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class gc {
  constructor(e, t, i, n, r, a = void 0) {
    this.name = e, this.alias = t, this.extensions = i, this.filename = n, this.loadFunc = r, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: i } = e;
    if (!t) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(i);
    }
    return new gc(e.name, (e.alias || []).concat(e.name).map((n) => n.toLowerCase()), e.extensions || [], e.filename, t, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let n of e)
      if (n.filename && n.filename.test(t))
        return n;
    let i = /\.([^.]+)$/.exec(t);
    if (i) {
      for (let n of e)
        if (n.extensions.indexOf(i[1]) > -1)
          return n;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, i = !0) {
    t = t.toLowerCase();
    for (let n of e)
      if (n.alias.some((r) => r == t))
        return n;
    if (i)
      for (let n of e)
        for (let r of n.alias) {
          let a = t.indexOf(r);
          if (a > -1 && (r.length > 2 || !/\w/.test(t[a - 1]) && !/\w/.test(t[a + r.length])))
            return n;
        }
    return null;
  }
}
const zM = /* @__PURE__ */ se.define(), So = /* @__PURE__ */ se.define({
  combine: (s) => {
    if (!s.length)
      return "  ";
    let e = s[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(s[0]));
    return e;
  }
});
function mc(s) {
  let e = s.facet(So);
  return e.charCodeAt(0) == 9 ? s.tabSize * e.length : e.length;
}
function Za(s, e) {
  let t = "", i = s.tabSize, n = s.facet(So)[0];
  if (n == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    n = " ";
  }
  for (let r = 0; r < e; r++)
    t += n;
  return t;
}
function hg(s, e) {
  s instanceof Ce && (s = new ih(s));
  for (let i of s.state.facet(zM)) {
    let n = i(s, e);
    if (n !== void 0)
      return n;
  }
  let t = Ie(s.state);
  return t.length >= e ? IM(s, t, e) : null;
}
class ih {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = mc(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: r } = this.options;
    return n != null && n >= i.from && n <= i.to ? r && n == e ? { text: "", from: e } : (t < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, t);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), r = this.countColumn(i, e - n), a = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return a > -1 && (r += a - this.countColumn(i, i.search(/\S|$/))), r;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Ti(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), r = this.options.overrideIndentation;
    if (r) {
      let a = r(n);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const rs = /* @__PURE__ */ new me();
function IM(s, e, t) {
  let i = e.resolveStack(t), n = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (n != i.node) {
    let r = [];
    for (let a = n; a && !(a.from == i.node.from && a.type == i.node.type); a = a.parent)
      r.push(a);
    for (let a = r.length - 1; a >= 0; a--)
      i = { node: r[a], next: i };
  }
  return o1(i, s, t);
}
function o1(s, e, t) {
  for (let i = s; i; i = i.next) {
    let n = DM(i.node);
    if (n)
      return n(ug.create(e, t, i));
  }
  return 0;
}
function qM(s) {
  return s.pos == s.options.simulateBreak && s.options.simulateDoubleBreak;
}
function DM(s) {
  let e = s.type.prop(rs);
  if (e)
    return e;
  let t = s.firstChild, i;
  if (t && (i = t.type.prop(me.closedBy))) {
    let n = s.lastChild, r = n && i.indexOf(n.name) > -1;
    return (a) => l1(a, !0, 1, void 0, r && !qM(a) ? n.from : void 0);
  }
  return s.parent == null ? BM : null;
}
function BM() {
  return 0;
}
class ug extends ih {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new ug(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (WM(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return o1(this.context.next, this.base, this.pos);
  }
}
function WM(s, e) {
  for (let t = e; t; t = t.parent)
    if (s == t)
      return !0;
  return !1;
}
function YM(s) {
  let e = s.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let n = s.options.simulateBreak, r = s.state.doc.lineAt(t.from), a = n == null || n <= r.from ? r.to : Math.min(r.to, n);
  for (let o = t.to; ; ) {
    let l = e.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= a)
        return null;
      let c = /^ */.exec(r.text.slice(t.to - r.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    o = l.to;
  }
}
function nr({ closing: s, align: e = !0, units: t = 1 }) {
  return (i) => l1(i, e, t, s);
}
function l1(s, e, t, i, n) {
  let r = s.textAfter, a = r.match(/^\s*/)[0].length, o = i && r.slice(a, a + i.length) == i || n == s.pos + a, l = e ? YM(s) : null;
  return l ? o ? s.column(l.from) : s.column(l.to) : s.baseIndent + (o ? 0 : s.unit * t);
}
const ZM = (s) => s.baseIndent;
function xn({ except: s, units: e = 1 } = {}) {
  return (t) => {
    let i = s && s.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const NM = 200;
function VM() {
  return Ce.transactionFilter.of((s) => {
    if (!s.docChanged || !s.isUserEvent("input.type") && !s.isUserEvent("input.complete"))
      return s;
    let e = s.startState.languageDataAt("indentOnInput", s.startState.selection.main.head);
    if (!e.length)
      return s;
    let t = s.newDoc, { head: i } = s.newSelection.main, n = t.lineAt(i);
    if (i > n.from + NM)
      return s;
    let r = t.sliceString(n.from, i);
    if (!e.some((c) => c.test(r)))
      return s;
    let { state: a } = s, o = -1, l = [];
    for (let { head: c } of a.selection.ranges) {
      let h = a.doc.lineAt(c);
      if (h.from == o)
        continue;
      o = h.from;
      let u = hg(a, h.from);
      if (u == null)
        continue;
      let d = /^\s*/.exec(h.text)[0], f = Za(a, u);
      d != f && l.push({ from: h.from, to: h.from + d.length, insert: f });
    }
    return l.length ? [s, { changes: l, sequential: !0 }] : s;
  });
}
const c1 = /* @__PURE__ */ se.define(), Li = /* @__PURE__ */ new me();
function ko(s) {
  let e = s.firstChild, t = s.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? s.to : t.from } : null;
}
function FM(s, e, t) {
  let i = Ie(s);
  if (i.length < t)
    return null;
  let n = i.resolveStack(t, 1), r = null;
  for (let a = n; a; a = a.next) {
    let o = a.node;
    if (o.to <= t || o.from > t)
      continue;
    if (r && o.from < e)
      break;
    let l = o.type.prop(Li);
    if (l && (o.to < i.length - 50 || i.length == s.doc.length || !jM(o))) {
      let c = l(o, s);
      c && c.from <= t && c.from >= e && c.to > t && (r = c);
    }
  }
  return r;
}
function jM(s) {
  let e = s.lastChild;
  return e && e.to == s.to && e.type.isError;
}
function Oc(s, e, t) {
  for (let i of s.facet(c1)) {
    let n = i(s, e, t);
    if (n)
      return n;
  }
  return FM(s, e, t);
}
function h1(s, e) {
  let t = e.mapPos(s.from, 1), i = e.mapPos(s.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const sh = /* @__PURE__ */ xe.define({ map: h1 }), Po = /* @__PURE__ */ xe.define({ map: h1 });
function u1(s) {
  let e = [];
  for (let { head: t } of s.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(s.lineBlockAt(t));
  return e;
}
const $n = /* @__PURE__ */ gt.define({
  create() {
    return de.none;
  },
  update(s, e) {
    s = s.map(e.changes);
    for (let t of e.effects)
      if (t.is(sh) && !HM(s, t.value.from, t.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(p1), n = i ? de.replace({ widget: new i_(i(e.state, t.value)) }) : bx;
        s = s.update({ add: [n.range(t.value.from, t.value.to)] });
      } else t.is(Po) && (s = s.update({
        filter: (i, n) => t.value.from != i || t.value.to != n,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      s.between(i, i, (n, r) => {
        n < i && r > i && (t = !0);
      }), t && (s = s.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, r) => r <= i || n >= i
      }));
    }
    return s;
  },
  provide: (s) => J.decorations.from(s),
  toJSON(s, e) {
    let t = [];
    return s.between(0, e.doc.length, (i, n) => {
      t.push(i, n);
    }), t;
  },
  fromJSON(s) {
    if (!Array.isArray(s) || s.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < s.length; ) {
      let i = s[t++], n = s[t++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(bx.range(i, n));
    }
    return de.set(e, !0);
  }
});
function xc(s, e, t) {
  var i;
  let n = null;
  return (i = s.field($n, !1)) === null || i === void 0 || i.between(e, t, (r, a) => {
    (!n || n.from > r) && (n = { from: r, to: a });
  }), n;
}
function HM(s, e, t) {
  let i = !1;
  return s.between(e, e, (n, r) => {
    n == e && r == t && (i = !0);
  }), i;
}
function d1(s, e) {
  return s.field($n, !1) ? e : e.concat(xe.appendConfig.of(g1()));
}
const UM = (s) => {
  for (let e of u1(s)) {
    let t = Oc(s.state, e.from, e.to);
    if (t)
      return s.dispatch({ effects: d1(s.state, [sh.of(t), f1(s, t)]) }), !0;
  }
  return !1;
}, GM = (s) => {
  if (!s.state.field($n, !1))
    return !1;
  let e = [];
  for (let t of u1(s)) {
    let i = xc(s.state, t.from, t.to);
    i && e.push(Po.of(i), f1(s, i, !1));
  }
  return e.length && s.dispatch({ effects: e }), e.length > 0;
};
function f1(s, e, t = !0) {
  let i = s.state.doc.lineAt(e.from).number, n = s.state.doc.lineAt(e.to).number;
  return J.announce.of(`${s.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${s.state.phrase("to")} ${n}.`);
}
const KM = (s) => {
  let { state: e } = s, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = s.lineBlockAt(i), r = Oc(e, n.from, n.to);
    r && t.push(sh.of(r)), i = (r ? s.lineBlockAt(r.to) : n).to + 1;
  }
  return t.length && s.dispatch({ effects: d1(s.state, t) }), !!t.length;
}, JM = (s) => {
  let e = s.state.field($n, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, s.state.doc.length, (i, n) => {
    t.push(Po.of({ from: i, to: n }));
  }), s.dispatch({ effects: t }), !0;
}, e_ = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: UM },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: GM },
  { key: "Ctrl-Alt-[", run: KM },
  { key: "Ctrl-Alt-]", run: JM }
], t_ = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, p1 = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, t_);
  }
});
function g1(s) {
  return [$n, r_];
}
function m1(s, e) {
  let { state: t } = s, i = t.facet(p1), n = (a) => {
    let o = s.lineBlockAt(s.posAtDOM(a.target)), l = xc(s.state, o.from, o.to);
    l && s.dispatch({ effects: Po.of(l) }), a.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(s, n, e);
  let r = document.createElement("span");
  return r.textContent = i.placeholderText, r.setAttribute("aria-label", t.phrase("folded code")), r.title = t.phrase("unfold"), r.className = "cm-foldPlaceholder", r.onclick = n, r;
}
const bx = /* @__PURE__ */ de.replace({ widget: /* @__PURE__ */ new class extends As {
  toDOM(s) {
    return m1(s, null);
  }
}() });
class i_ extends As {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return m1(e, this.value);
  }
}
const s_ = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class gu extends Ss {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function n_(s = {}) {
  let e = Object.assign(Object.assign({}, s_), s), t = new gu(e, !0), i = new gu(e, !1), n = ct.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(Fs) != a.state.facet(Fs) || a.startState.field($n, !1) != a.state.field($n, !1) || Ie(a.startState) != Ie(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let o = new vs();
      for (let l of a.viewportLineBlocks) {
        let c = xc(a.state, l.from, l.to) ? i : Oc(a.state, l.from, l.to) ? t : null;
        c && o.add(l.from, l.from, c);
      }
      return o.finish();
    }
  }), { domEventHandlers: r } = e;
  return [
    n,
    sM({
      class: "cm-foldGutter",
      markers(a) {
        var o;
        return ((o = a.plugin(n)) === null || o === void 0 ? void 0 : o.markers) || Xe.empty;
      },
      initialSpacer() {
        return new gu(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, r), { click: (a, o, l) => {
        if (r.click && r.click(a, o, l))
          return !0;
        let c = xc(a.state, o.from, o.to);
        if (c)
          return a.dispatch({ effects: Po.of(c) }), !0;
        let h = Oc(a.state, o.from, o.to);
        return h ? (a.dispatch({ effects: sh.of(h) }), !0) : !1;
      } })
    }),
    g1()
  ];
}
const r_ = /* @__PURE__ */ J.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Er {
  constructor(e, t) {
    this.specs = e;
    let i;
    function n(o) {
      let l = Ys.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    const r = typeof t.all == "string" ? t.all : t.all ? n(t.all) : void 0, a = t.scope;
    this.scope = a instanceof ui ? (o) => o.prop(un) == a.data : a ? (o) => o == a : void 0, this.style = r1(e.map((o) => ({
      tag: o.tag,
      class: o.class || n(Object.assign({}, o, { tag: null }))
    })), {
      all: r
    }).style, this.module = i ? new Ys(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Er(e, t || {});
  }
}
const Cf = /* @__PURE__ */ se.define(), O1 = /* @__PURE__ */ se.define({
  combine(s) {
    return s.length ? [s[0]] : null;
  }
});
function mu(s) {
  let e = s.facet(Cf);
  return e.length ? e : s.facet(O1);
}
function x1(s, e) {
  let t = [o_], i;
  return s instanceof Er && (s.module && t.push(J.styleModule.of(s.module)), i = s.themeType), e?.fallback ? t.push(O1.of(s)) : i ? t.push(Cf.computeN([J.darkTheme], (n) => n.facet(J.darkTheme) == (i == "dark") ? [s] : [])) : t.push(Cf.of(s)), t;
}
class a_ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ie(e.state), this.decorations = this.buildDeco(e, mu(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = Ie(e.state), i = mu(e.state), n = i != mu(e.startState), { viewport: r } = e.view, a = e.changes.mapPos(this.decoratedTo, 1);
    t.length < r.to && !n && t.type == this.tree.type && a >= r.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = a) : (t != this.tree || e.viewportChanged || n) && (this.tree = t, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = r.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return de.none;
    let i = new vs();
    for (let { from: n, to: r } of e.visibleRanges)
      EM(this.tree, t, (a, o, l) => {
        i.add(a, o, this.markCache[l] || (this.markCache[l] = de.mark({ class: l })));
      }, n, r);
    return i.finish();
  }
}
const o_ = /* @__PURE__ */ Qs.high(/* @__PURE__ */ ct.fromClass(a_, {
  decorations: (s) => s.decorations
})), l_ = /* @__PURE__ */ Er.define([
  {
    tag: Q.meta,
    color: "#404740"
  },
  {
    tag: Q.link,
    textDecoration: "underline"
  },
  {
    tag: Q.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: Q.emphasis,
    fontStyle: "italic"
  },
  {
    tag: Q.strong,
    fontWeight: "bold"
  },
  {
    tag: Q.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: Q.keyword,
    color: "#708"
  },
  {
    tag: [Q.atom, Q.bool, Q.url, Q.contentSeparator, Q.labelName],
    color: "#219"
  },
  {
    tag: [Q.literal, Q.inserted],
    color: "#164"
  },
  {
    tag: [Q.string, Q.deleted],
    color: "#a11"
  },
  {
    tag: [Q.regexp, Q.escape, /* @__PURE__ */ Q.special(Q.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ Q.definition(Q.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ Q.local(Q.variableName),
    color: "#30a"
  },
  {
    tag: [Q.typeName, Q.namespace],
    color: "#085"
  },
  {
    tag: Q.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ Q.special(Q.variableName), Q.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ Q.definition(Q.propertyName),
    color: "#00c"
  },
  {
    tag: Q.comment,
    color: "#940"
  },
  {
    tag: Q.invalid,
    color: "#f00"
  }
]), c_ = /* @__PURE__ */ J.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), b1 = 1e4, y1 = "()[]{}", v1 = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, {
      afterCursor: !0,
      brackets: y1,
      maxScanDistance: b1,
      renderMatch: d_
    });
  }
}), h_ = /* @__PURE__ */ de.mark({ class: "cm-matchingBracket" }), u_ = /* @__PURE__ */ de.mark({ class: "cm-nonmatchingBracket" });
function d_(s) {
  let e = [], t = s.matched ? h_ : u_;
  return e.push(t.range(s.start.from, s.start.to)), s.end && e.push(t.range(s.end.from, s.end.to)), e;
}
const f_ = /* @__PURE__ */ gt.define({
  create() {
    return de.none;
  },
  update(s, e) {
    if (!e.docChanged && !e.selection)
      return s;
    let t = [], i = e.state.facet(v1);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let r = Hi(e.state, n.head, -1, i) || n.head > 0 && Hi(e.state, n.head - 1, 1, i) || i.afterCursor && (Hi(e.state, n.head, 1, i) || n.head < e.state.doc.length && Hi(e.state, n.head + 1, -1, i));
      r && (t = t.concat(i.renderMatch(r, e.state)));
    }
    return de.set(t, !0);
  },
  provide: (s) => J.decorations.from(s)
}), p_ = [
  f_,
  c_
];
function g_(s = {}) {
  return [v1.of(s), p_];
}
const dg = /* @__PURE__ */ new me();
function Af(s, e, t) {
  let i = s.prop(e < 0 ? me.openedBy : me.closedBy);
  if (i)
    return i;
  if (s.name.length == 1) {
    let n = t.indexOf(s.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [t[n + e]];
  }
  return null;
}
function Tf(s) {
  let e = s.type.prop(dg);
  return e ? e(s.node) : s;
}
function Hi(s, e, t, i = {}) {
  let n = i.maxScanDistance || b1, r = i.brackets || y1, a = Ie(s), o = a.resolveInner(e, t);
  for (let l = o; l; l = l.parent) {
    let c = Af(l.type, t, r);
    if (c && l.from < l.to) {
      let h = Tf(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return m_(s, e, t, l, h, c, r);
    }
  }
  return O_(s, e, t, a, o.type, n, r);
}
function m_(s, e, t, i, n, r, a) {
  let o = i.parent, l = { from: n.from, to: n.to }, c = 0, h = o?.cursor();
  if (h && (t < 0 ? h.childBefore(i.from) : h.childAfter(i.to)))
    do
      if (t < 0 ? h.to <= i.from : h.from >= i.to) {
        if (c == 0 && r.indexOf(h.type.name) > -1 && h.from < h.to) {
          let u = Tf(h);
          return { start: l, end: u ? { from: u.from, to: u.to } : void 0, matched: !0 };
        } else if (Af(h.type, t, a))
          c++;
        else if (Af(h.type, -t, a)) {
          if (c == 0) {
            let u = Tf(h);
            return {
              start: l,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function O_(s, e, t, i, n, r, a) {
  let o = t < 0 ? s.sliceDoc(e - 1, e) : s.sliceDoc(e, e + 1), l = a.indexOf(o);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = s.doc.iterRange(e, t > 0 ? s.doc.length : 0), u = 0;
  for (let d = 0; !h.next().done && d <= r; ) {
    let f = h.value;
    t < 0 && (d += f.length);
    let p = e + d * t;
    for (let g = t > 0 ? 0 : f.length - 1, m = t > 0 ? f.length : -1; g != m; g += t) {
      let O = a.indexOf(f[g]);
      if (!(O < 0 || i.resolveInner(p + g, 1).type != n))
        if (O % 2 == 0 == t > 0)
          u++;
        else {
          if (u == 1)
            return { start: c, end: { from: p + g, to: p + g + 1 }, matched: O >> 1 == l >> 1 };
          u--;
        }
    }
    t > 0 && (d += f.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const x_ = /* @__PURE__ */ Object.create(null), yx = [ft.none], vx = [], wx = /* @__PURE__ */ Object.create(null), b_ = /* @__PURE__ */ Object.create(null);
for (let [s, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  b_[s] = /* @__PURE__ */ y_(x_, e);
function Ou(s, e) {
  vx.indexOf(s) > -1 || (vx.push(s), console.warn(e));
}
function y_(s, e) {
  let t = [];
  for (let o of e.split(" ")) {
    let l = [];
    for (let c of o.split(".")) {
      let h = s[c] || Q[c];
      h ? typeof h == "function" ? l.length ? l = l.map(h) : Ou(c, `Modifier ${c} used at start of tag`) : l.length ? Ou(c, `Tag ${c} used as modifier`) : l = Array.isArray(h) ? h : [h] : Ou(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let i = e.replace(/ /g, "_"), n = i + " " + t.map((o) => o.id), r = wx[n];
  if (r)
    return r.id;
  let a = wx[n] = ft.define({
    id: yx.length,
    name: i,
    props: [_i({ [i]: t })]
  });
  return yx.push(a), a.id;
}
Ge.RTL, Ge.LTR;
const v_ = (s) => {
  let { state: e } = s, t = e.doc.lineAt(e.selection.main.from), i = pg(s.state, t.from);
  return i.line ? w_(s) : i.block ? k_(s) : !1;
};
function fg(s, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let n = s(e, t);
    return n ? (i(t.update(n)), !0) : !1;
  };
}
const w_ = /* @__PURE__ */ fg(
  C_,
  0
  /* CommentOption.Toggle */
), S_ = /* @__PURE__ */ fg(
  w1,
  0
  /* CommentOption.Toggle */
), k_ = /* @__PURE__ */ fg(
  (s, e) => w1(s, e, Q_(e)),
  0
  /* CommentOption.Toggle */
);
function pg(s, e) {
  let t = s.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const Hr = 50;
function P_(s, { open: e, close: t }, i, n) {
  let r = s.sliceDoc(i - Hr, i), a = s.sliceDoc(n, n + Hr), o = /\s*$/.exec(r)[0].length, l = /^\s*/.exec(a)[0].length, c = r.length - o;
  if (r.slice(c - e.length, c) == e && a.slice(l, l + t.length) == t)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: n + l, margin: l && 1 }
    };
  let h, u;
  n - i <= 2 * Hr ? h = u = s.sliceDoc(i, n) : (h = s.sliceDoc(i, i + Hr), u = s.sliceDoc(n - Hr, n));
  let d = /^\s*/.exec(h)[0].length, f = /\s*$/.exec(u)[0].length, p = u.length - f - t.length;
  return h.slice(d, d + e.length) == e && u.slice(p, p + t.length) == t ? {
    open: {
      pos: i + d + e.length,
      margin: /\s/.test(h.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: n - f - t.length,
      margin: /\s/.test(u.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function Q_(s) {
  let e = [];
  for (let t of s.selection.ranges) {
    let i = s.doc.lineAt(t.from), n = t.to <= i.to ? i : s.doc.lineAt(t.to);
    n.from > i.from && n.from == t.to && (n = t.to == i.to + 1 ? i : s.doc.lineAt(t.to - 1));
    let r = e.length - 1;
    r >= 0 && e[r].to > i.from ? e[r].to = n.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return e;
}
function w1(s, e, t = e.selection.ranges) {
  let i = t.map((r) => pg(e, r.from).block);
  if (!i.every((r) => r))
    return null;
  let n = t.map((r, a) => P_(e, i[a], r.from, r.to));
  if (s != 2 && !n.every((r) => r))
    return { changes: e.changes(t.map((r, a) => n[a] ? [] : [{ from: r.from, insert: i[a].open + " " }, { from: r.to, insert: " " + i[a].close }])) };
  if (s != 1 && n.some((r) => r)) {
    let r = [];
    for (let a = 0, o; a < n.length; a++)
      if (o = n[a]) {
        let l = i[a], { open: c, close: h } = o;
        r.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: r };
  }
  return null;
}
function C_(s, e, t = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: r, to: a } of t) {
    let o = i.length, l = 1e9, c = pg(e, r).line;
    if (c) {
      for (let h = r; h <= a; ) {
        let u = e.doc.lineAt(h);
        if (u.from > n && (r == a || a > u.from)) {
          n = u.from;
          let d = /^\s*/.exec(u.text)[0].length, f = d == u.length, p = u.text.slice(d, d + c.length) == c ? d : -1;
          d < u.text.length && d < l && (l = d), i.push({ line: u, comment: p, token: c, indent: d, empty: f, single: !1 });
        }
        h = u.to + 1;
      }
      if (l < 1e9)
        for (let h = o; h < i.length; h++)
          i[h].indent < i[h].line.text.length && (i[h].indent = l);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (s != 2 && i.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: o, token: l, indent: c, empty: h, single: u } of i)
      (u || !h) && r.push({ from: o.from + c, insert: l + " " });
    let a = e.changes(r);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (s != 1 && i.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: a, comment: o, token: l } of i)
      if (o >= 0) {
        let c = a.from + o, h = c + l.length;
        a.text[h - a.from] == " " && h++, r.push({ from: c, to: h });
      }
    return { changes: r };
  }
  return null;
}
const $f = /* @__PURE__ */ Cs.define(), A_ = /* @__PURE__ */ Cs.define(), T_ = /* @__PURE__ */ se.define(), S1 = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, n) => e(i, n) || t(i, n)
    });
  }
}), k1 = /* @__PURE__ */ gt.define({
  create() {
    return Ui.empty;
  },
  update(s, e) {
    let t = e.state.facet(S1), i = e.annotation($f);
    if (i) {
      let l = Wt.fromTransaction(e, i.selection), c = i.side, h = c == 0 ? s.undone : s.done;
      return l ? h = bc(h, h.length, t.minDepth, l) : h = C1(h, e.startState.selection), new Ui(c == 0 ? i.rest : h, c == 0 ? h : i.rest);
    }
    let n = e.annotation(A_);
    if ((n == "full" || n == "before") && (s = s.isolate()), e.annotation(lt.addToHistory) === !1)
      return e.changes.empty ? s : s.addMapping(e.changes.desc);
    let r = Wt.fromTransaction(e), a = e.annotation(lt.time), o = e.annotation(lt.userEvent);
    return r ? s = s.addChanges(r, a, o, t, e) : e.selection && (s = s.addSelection(e.startState.selection, a, o, t.newGroupDelay)), (n == "full" || n == "after") && (s = s.isolate()), s;
  },
  toJSON(s) {
    return { done: s.done.map((e) => e.toJSON()), undone: s.undone.map((e) => e.toJSON()) };
  },
  fromJSON(s) {
    return new Ui(s.done.map(Wt.fromJSON), s.undone.map(Wt.fromJSON));
  }
});
function $_(s = {}) {
  return [
    k1,
    S1.of(s),
    J.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? P1 : e.inputType == "historyRedo" ? Rf : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
function nh(s, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let n = t.field(k1, !1);
    if (!n)
      return !1;
    let r = n.pop(s, t, e);
    return r ? (i(r), !0) : !1;
  };
}
const P1 = /* @__PURE__ */ nh(0, !1), Rf = /* @__PURE__ */ nh(1, !1), R_ = /* @__PURE__ */ nh(0, !0), E_ = /* @__PURE__ */ nh(1, !0);
class Wt {
  constructor(e, t, i, n, r) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = n, this.selectionsAfter = r;
  }
  setSelAfter(e) {
    return new Wt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new Wt(e.changes && ut.fromJSON(e.changes), [], e.mapped && Ki.fromJSON(e.mapped), e.startSelection && D.fromJSON(e.startSelection), e.selectionsAfter.map(D.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = di;
    for (let n of e.startState.facet(T_)) {
      let r = n(e);
      r.length && (i = i.concat(r));
    }
    return !i.length && e.changes.empty ? null : new Wt(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, di);
  }
  static selection(e) {
    return new Wt(void 0, di, void 0, void 0, e);
  }
}
function bc(s, e, t, i) {
  let n = e + 1 > t + 20 ? e - t - 1 : 0, r = s.slice(n, e);
  return r.push(i), r;
}
function X_(s, e) {
  let t = [], i = !1;
  return s.iterChangedRanges((n, r) => t.push(n, r)), e.iterChangedRanges((n, r, a, o) => {
    for (let l = 0; l < t.length; ) {
      let c = t[l++], h = t[l++];
      o >= c && a <= h && (i = !0);
    }
  }), i;
}
function M_(s, e) {
  return s.ranges.length == e.ranges.length && s.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function Q1(s, e) {
  return s.length ? e.length ? s.concat(e) : s : e;
}
const di = [], __ = 200;
function C1(s, e) {
  if (s.length) {
    let t = s[s.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - __));
    return i.length && i[i.length - 1].eq(e) ? s : (i.push(e), bc(s, s.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [Wt.selection([e])];
}
function L_(s) {
  let e = s[s.length - 1], t = s.slice();
  return t[s.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function xu(s, e) {
  if (!s.length)
    return s;
  let t = s.length, i = di;
  for (; t; ) {
    let n = z_(s[t - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let r = s.slice(0, t);
      return r[t - 1] = n, r;
    } else
      e = n.mapped, t--, i = n.selectionsAfter;
  }
  return i.length ? [Wt.selection(i)] : di;
}
function z_(s, e, t) {
  let i = Q1(s.selectionsAfter.length ? s.selectionsAfter.map((o) => o.map(e)) : di, t);
  if (!s.changes)
    return Wt.selection(i);
  let n = s.changes.map(e), r = e.mapDesc(s.changes, !0), a = s.mapped ? s.mapped.composeDesc(r) : r;
  return new Wt(n, xe.mapEffects(s.effects, e), a, s.startSelection.map(r), i);
}
const I_ = /^(input\.type|delete)($|\.)/;
class Ui {
  constructor(e, t, i = 0, n = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new Ui(this.done, this.undone) : this;
  }
  addChanges(e, t, i, n, r) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && e.changes && (!i || I_.test(i)) && (!o.selectionsAfter.length && t - this.prevTime < n.newGroupDelay && n.joinToEvent(r, X_(o.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = bc(a, a.length - 1, n.minDepth, new Wt(e.changes.compose(o.changes), Q1(xe.mapEffects(e.effects, o.changes), o.effects), o.mapped, o.startSelection, di)) : a = bc(a, a.length, n.minDepth, e), new Ui(a, di, t, i);
  }
  addSelection(e, t, i, n) {
    let r = this.done.length ? this.done[this.done.length - 1].selectionsAfter : di;
    return r.length > 0 && t - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && M_(r[r.length - 1], e) ? this : new Ui(C1(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new Ui(xu(this.done, e), xu(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let r = n[n.length - 1], a = r.selectionsAfter[0] || t.selection;
    if (i && r.selectionsAfter.length)
      return t.update({
        selection: r.selectionsAfter[r.selectionsAfter.length - 1],
        annotations: $f.of({ side: e, rest: L_(n), selection: a }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (r.changes) {
      let o = n.length == 1 ? di : n.slice(0, n.length - 1);
      return r.mapped && (o = xu(o, r.mapped)), t.update({
        changes: r.changes,
        selection: r.startSelection,
        effects: r.effects,
        annotations: $f.of({ side: e, rest: o, selection: a }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Ui.empty = /* @__PURE__ */ new Ui(di, di);
const q_ = [
  { key: "Mod-z", run: P1, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Rf, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Rf, preventDefault: !0 },
  { key: "Mod-u", run: R_, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: E_, preventDefault: !0 }
];
function Xr(s, e) {
  return D.create(s.ranges.map(e), s.mainIndex);
}
function as(s, e) {
  return s.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function zi({ state: s, dispatch: e }, t) {
  let i = Xr(s.selection, t);
  return i.eq(s.selection, !0) ? !1 : (e(as(s, i)), !0);
}
function rh(s, e) {
  return D.cursor(e ? s.to : s.from);
}
function A1(s, e) {
  return zi(s, (t) => t.empty ? s.moveByChar(t, e) : rh(t, e));
}
function Rt(s) {
  return s.textDirectionAt(s.state.selection.main.head) == Ge.LTR;
}
const T1 = (s) => A1(s, !Rt(s)), $1 = (s) => A1(s, Rt(s));
function R1(s, e) {
  return zi(s, (t) => t.empty ? s.moveByGroup(t, e) : rh(t, e));
}
const D_ = (s) => R1(s, !Rt(s)), B_ = (s) => R1(s, Rt(s));
function W_(s, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(s.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ah(s, e, t) {
  let i = Ie(s).resolveInner(e.head), n = t ? me.closedBy : me.openedBy;
  for (let l = e.head; ; ) {
    let c = t ? i.childAfter(l) : i.childBefore(l);
    if (!c)
      break;
    W_(s, c, n) ? i = c : l = t ? c.to : c.from;
  }
  let r = i.type.prop(n), a, o;
  return r && (a = t ? Hi(s, i.from, 1) : Hi(s, i.to, -1)) && a.matched ? o = t ? a.end.to : a.end.from : o = t ? i.to : i.from, D.cursor(o, t ? -1 : 1);
}
const Y_ = (s) => zi(s, (e) => ah(s.state, e, !Rt(s))), Z_ = (s) => zi(s, (e) => ah(s.state, e, Rt(s)));
function E1(s, e) {
  return zi(s, (t) => {
    if (!t.empty)
      return rh(t, e);
    let i = s.moveVertically(t, e);
    return i.head != t.head ? i : s.moveToLineBoundary(t, e);
  });
}
const X1 = (s) => E1(s, !1), M1 = (s) => E1(s, !0);
function _1(s) {
  let e = s.scrollDOM.clientHeight < s.scrollDOM.scrollHeight - 2, t = 0, i = 0, n;
  if (e) {
    for (let r of s.state.facet(J.scrollMargins)) {
      let a = r(s);
      a?.top && (t = Math.max(a?.top, t)), a?.bottom && (i = Math.max(a?.bottom, i));
    }
    n = s.scrollDOM.clientHeight - t - i;
  } else
    n = (s.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(s.defaultLineHeight, n - 5)
  };
}
function L1(s, e) {
  let t = _1(s), { state: i } = s, n = Xr(i.selection, (a) => a.empty ? s.moveVertically(a, e, t.height) : rh(a, e));
  if (n.eq(i.selection))
    return !1;
  let r;
  if (t.selfScroll) {
    let a = s.coordsAtPos(i.selection.main.head), o = s.scrollDOM.getBoundingClientRect(), l = o.top + t.marginTop, c = o.bottom - t.marginBottom;
    a && a.top > l && a.bottom < c && (r = J.scrollIntoView(n.main.head, { y: "start", yMargin: a.top - l }));
  }
  return s.dispatch(as(i, n), { effects: r }), !0;
}
const Sx = (s) => L1(s, !1), Ef = (s) => L1(s, !0);
function js(s, e, t) {
  let i = s.lineBlockAt(e.head), n = s.moveToLineBoundary(e, t);
  if (n.head == e.head && n.head != (t ? i.to : i.from) && (n = s.moveToLineBoundary(e, t, !1)), !t && n.head == i.from && i.length) {
    let r = /^\s*/.exec(s.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    r && e.head != i.from + r && (n = D.cursor(i.from + r));
  }
  return n;
}
const N_ = (s) => zi(s, (e) => js(s, e, !0)), V_ = (s) => zi(s, (e) => js(s, e, !1)), F_ = (s) => zi(s, (e) => js(s, e, !Rt(s))), j_ = (s) => zi(s, (e) => js(s, e, Rt(s))), H_ = (s) => zi(s, (e) => D.cursor(s.lineBlockAt(e.head).from, 1)), U_ = (s) => zi(s, (e) => D.cursor(s.lineBlockAt(e.head).to, -1));
function G_(s, e, t) {
  let i = !1, n = Xr(s.selection, (r) => {
    let a = Hi(s, r.head, -1) || Hi(s, r.head, 1) || r.head > 0 && Hi(s, r.head - 1, 1) || r.head < s.doc.length && Hi(s, r.head + 1, -1);
    if (!a || !a.end)
      return r;
    i = !0;
    let o = a.start.from == r.head ? a.end.to : a.end.from;
    return D.cursor(o);
  });
  return i ? (e(as(s, n)), !0) : !1;
}
const K_ = ({ state: s, dispatch: e }) => G_(s, e);
function xi(s, e) {
  let t = Xr(s.state.selection, (i) => {
    let n = e(i);
    return D.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return t.eq(s.state.selection) ? !1 : (s.dispatch(as(s.state, t)), !0);
}
function z1(s, e) {
  return xi(s, (t) => s.moveByChar(t, e));
}
const I1 = (s) => z1(s, !Rt(s)), q1 = (s) => z1(s, Rt(s));
function D1(s, e) {
  return xi(s, (t) => s.moveByGroup(t, e));
}
const J_ = (s) => D1(s, !Rt(s)), eL = (s) => D1(s, Rt(s)), tL = (s) => xi(s, (e) => ah(s.state, e, !Rt(s))), iL = (s) => xi(s, (e) => ah(s.state, e, Rt(s)));
function B1(s, e) {
  return xi(s, (t) => s.moveVertically(t, e));
}
const W1 = (s) => B1(s, !1), Y1 = (s) => B1(s, !0);
function Z1(s, e) {
  return xi(s, (t) => s.moveVertically(t, e, _1(s).height));
}
const kx = (s) => Z1(s, !1), Px = (s) => Z1(s, !0), sL = (s) => xi(s, (e) => js(s, e, !0)), nL = (s) => xi(s, (e) => js(s, e, !1)), rL = (s) => xi(s, (e) => js(s, e, !Rt(s))), aL = (s) => xi(s, (e) => js(s, e, Rt(s))), oL = (s) => xi(s, (e) => D.cursor(s.lineBlockAt(e.head).from)), lL = (s) => xi(s, (e) => D.cursor(s.lineBlockAt(e.head).to)), Qx = ({ state: s, dispatch: e }) => (e(as(s, { anchor: 0 })), !0), Cx = ({ state: s, dispatch: e }) => (e(as(s, { anchor: s.doc.length })), !0), Ax = ({ state: s, dispatch: e }) => (e(as(s, { anchor: s.selection.main.anchor, head: 0 })), !0), Tx = ({ state: s, dispatch: e }) => (e(as(s, { anchor: s.selection.main.anchor, head: s.doc.length })), !0), cL = ({ state: s, dispatch: e }) => (e(s.update({ selection: { anchor: 0, head: s.doc.length }, userEvent: "select" })), !0), hL = ({ state: s, dispatch: e }) => {
  let t = oh(s).map(({ from: i, to: n }) => D.range(i, Math.min(n + 1, s.doc.length)));
  return e(s.update({ selection: D.create(t), userEvent: "select" })), !0;
}, uL = ({ state: s, dispatch: e }) => {
  let t = Xr(s.selection, (i) => {
    let n = Ie(s), r = n.resolveStack(i.from, 1);
    if (i.empty) {
      let a = n.resolveStack(i.from, -1);
      a.node.from >= r.node.from && a.node.to <= r.node.to && (r = a);
    }
    for (let a = r; a; a = a.next) {
      let { node: o } = a;
      if ((o.from < i.from && o.to >= i.to || o.to > i.to && o.from <= i.from) && a.next)
        return D.range(o.to, o.from);
    }
    return i;
  });
  return t.eq(s.selection) ? !1 : (e(as(s, t)), !0);
}, dL = ({ state: s, dispatch: e }) => {
  let t = s.selection, i = null;
  return t.ranges.length > 1 ? i = D.create([t.main]) : t.main.empty || (i = D.create([D.cursor(t.main.head)])), i ? (e(as(s, i)), !0) : !1;
};
function Qo(s, e) {
  if (s.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = s, n = i.changeByRange((r) => {
    let { from: a, to: o } = r;
    if (a == o) {
      let l = e(r);
      l < a ? (t = "delete.backward", l = tl(s, l, !1)) : l > a && (t = "delete.forward", l = tl(s, l, !0)), a = Math.min(a, l), o = Math.max(o, l);
    } else
      a = tl(s, a, !1), o = tl(s, o, !0);
    return a == o ? { range: r } : { changes: { from: a, to: o }, range: D.cursor(a, a < r.head ? -1 : 1) };
  });
  return n.changes.empty ? !1 : (s.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? J.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function tl(s, e, t) {
  if (s instanceof J)
    for (let i of s.state.facet(J.atomicRanges).map((n) => n(s)))
      i.between(e, e, (n, r) => {
        n < e && r > e && (e = t ? r : n);
      });
  return e;
}
const N1 = (s, e, t) => Qo(s, (i) => {
  let n = i.from, { state: r } = s, a = r.doc.lineAt(n), o, l;
  if (t && !e && n > a.from && n < a.from + 200 && !/[^ \t]/.test(o = a.text.slice(0, n - a.from))) {
    if (o[o.length - 1] == "	")
      return n - 1;
    let c = Ti(o, r.tabSize), h = c % mc(r) || mc(r);
    for (let u = 0; u < h && o[o.length - 1 - u] == " "; u++)
      n--;
    l = n;
  } else
    l = wt(a.text, n - a.from, e, e) + a.from, l == n && a.number != (e ? r.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(a.text.slice(l - a.from, n - a.from)) && (l = wt(a.text, l - a.from, !1, !1) + a.from);
  return l;
}), Xf = (s) => N1(s, !1, !0), V1 = (s) => N1(s, !0, !1), F1 = (s, e) => Qo(s, (t) => {
  let i = t.head, { state: n } = s, r = n.doc.lineAt(i), a = n.charCategorizer(i);
  for (let o = null; ; ) {
    if (i == (e ? r.to : r.from)) {
      i == t.head && r.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = wt(r.text, i - r.from, e) + r.from, c = r.text.slice(Math.min(i, l) - r.from, Math.max(i, l) - r.from), h = a(c);
    if (o != null && h != o)
      break;
    (c != " " || i != t.head) && (o = h), i = l;
  }
  return i;
}), j1 = (s) => F1(s, !1), fL = (s) => F1(s, !0), pL = (s) => Qo(s, (e) => {
  let t = s.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(s.state.doc.length, e.head + 1);
}), gL = (s) => Qo(s, (e) => {
  let t = s.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), mL = (s) => Qo(s, (e) => {
  let t = s.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(s.state.doc.length, e.head + 1);
}), OL = ({ state: s, dispatch: e }) => {
  if (s.readOnly)
    return !1;
  let t = s.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: $e.of(["", ""]) },
    range: D.cursor(i.from)
  }));
  return e(s.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, xL = ({ state: s, dispatch: e }) => {
  if (s.readOnly)
    return !1;
  let t = s.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == s.doc.length)
      return { range: i };
    let n = i.from, r = s.doc.lineAt(n), a = n == r.from ? n - 1 : wt(r.text, n - r.from, !1) + r.from, o = n == r.to ? n + 1 : wt(r.text, n - r.from, !0) + r.from;
    return {
      changes: { from: a, to: o, insert: s.doc.slice(n, o).append(s.doc.slice(a, n)) },
      range: D.cursor(o)
    };
  });
  return t.changes.empty ? !1 : (e(s.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function oh(s) {
  let e = [], t = -1;
  for (let i of s.selection.ranges) {
    let n = s.doc.lineAt(i.from), r = s.doc.lineAt(i.to);
    if (!i.empty && i.to == r.from && (r = s.doc.lineAt(i.to - 1)), t >= n.number) {
      let a = e[e.length - 1];
      a.to = r.to, a.ranges.push(i);
    } else
      e.push({ from: n.from, to: r.to, ranges: [i] });
    t = r.number + 1;
  }
  return e;
}
function H1(s, e, t) {
  if (s.readOnly)
    return !1;
  let i = [], n = [];
  for (let r of oh(s)) {
    if (t ? r.to == s.doc.length : r.from == 0)
      continue;
    let a = s.doc.lineAt(t ? r.to + 1 : r.from - 1), o = a.length + 1;
    if (t) {
      i.push({ from: r.to, to: a.to }, { from: r.from, insert: a.text + s.lineBreak });
      for (let l of r.ranges)
        n.push(D.range(Math.min(s.doc.length, l.anchor + o), Math.min(s.doc.length, l.head + o)));
    } else {
      i.push({ from: a.from, to: r.from }, { from: r.to, insert: s.lineBreak + a.text });
      for (let l of r.ranges)
        n.push(D.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (e(s.update({
    changes: i,
    scrollIntoView: !0,
    selection: D.create(n, s.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const bL = ({ state: s, dispatch: e }) => H1(s, e, !1), yL = ({ state: s, dispatch: e }) => H1(s, e, !0);
function U1(s, e, t) {
  if (s.readOnly)
    return !1;
  let i = [];
  for (let n of oh(s))
    t ? i.push({ from: n.from, insert: s.doc.slice(n.from, n.to) + s.lineBreak }) : i.push({ from: n.to, insert: s.lineBreak + s.doc.slice(n.from, n.to) });
  return e(s.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const vL = ({ state: s, dispatch: e }) => U1(s, e, !1), wL = ({ state: s, dispatch: e }) => U1(s, e, !0), SL = (s) => {
  if (s.state.readOnly)
    return !1;
  let { state: e } = s, t = e.changes(oh(e).map(({ from: n, to: r }) => (n > 0 ? n-- : r < e.doc.length && r++, { from: n, to: r }))), i = Xr(e.selection, (n) => {
    let r;
    if (s.lineWrapping) {
      let a = s.lineBlockAt(n.head), o = s.coordsAtPos(n.head, n.assoc || 1);
      o && (r = a.bottom + s.documentTop - o.bottom + s.defaultLineHeight / 2);
    }
    return s.moveVertically(n, !0, r);
  }).map(t);
  return s.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function kL(s, e) {
  if (/\(\)|\[\]|\{\}/.test(s.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Ie(s).resolveInner(e), i = t.childBefore(e), n = t.childAfter(e), r;
  return i && n && i.to <= e && n.from >= e && (r = i.type.prop(me.closedBy)) && r.indexOf(n.name) > -1 && s.doc.lineAt(i.to).from == s.doc.lineAt(n.from).from && !/\S/.test(s.sliceDoc(i.to, n.from)) ? { from: i.to, to: n.from } : null;
}
const $x = /* @__PURE__ */ G1(!1), PL = /* @__PURE__ */ G1(!0);
function G1(s) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((n) => {
      let { from: r, to: a } = n, o = e.doc.lineAt(r), l = !s && r == a && kL(e, r);
      s && (r = a = (a <= o.to ? o : e.doc.lineAt(a)).to);
      let c = new ih(e, { simulateBreak: r, simulateDoubleBreak: !!l }), h = hg(c, r);
      for (h == null && (h = Ti(/^\s*/.exec(e.doc.lineAt(r).text)[0], e.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      l ? { from: r, to: a } = l : r > o.from && r < o.from + 100 && !/\S/.test(o.text.slice(0, r)) && (r = o.from);
      let u = ["", Za(e, h)];
      return l && u.push(Za(e, c.lineIndent(o.from, -1))), {
        changes: { from: r, to: a, insert: $e.of(u) },
        range: D.cursor(r + 1 + u[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function gg(s, e) {
  let t = -1;
  return s.changeByRange((i) => {
    let n = [];
    for (let a = i.from; a <= i.to; ) {
      let o = s.doc.lineAt(a);
      o.number > t && (i.empty || i.to > o.from) && (e(o, n, i), t = o.number), a = o.to + 1;
    }
    let r = s.changes(n);
    return {
      changes: n,
      range: D.range(r.mapPos(i.anchor, 1), r.mapPos(i.head, 1))
    };
  });
}
const QL = ({ state: s, dispatch: e }) => {
  if (s.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new ih(s, { overrideIndentation: (r) => {
    let a = t[r];
    return a ?? -1;
  } }), n = gg(s, (r, a, o) => {
    let l = hg(i, r.from);
    if (l == null)
      return;
    /\S/.test(r.text) || (l = 0);
    let c = /^\s*/.exec(r.text)[0], h = Za(s, l);
    (c != h || o.from < r.from + c.length) && (t[r.from] = l, a.push({ from: r.from, to: r.from + c.length, insert: h }));
  });
  return n.changes.empty || e(s.update(n, { userEvent: "indent" })), !0;
}, CL = ({ state: s, dispatch: e }) => s.readOnly ? !1 : (e(s.update(gg(s, (t, i) => {
  i.push({ from: t.from, insert: s.facet(So) });
}), { userEvent: "input.indent" })), !0), AL = ({ state: s, dispatch: e }) => s.readOnly ? !1 : (e(s.update(gg(s, (t, i) => {
  let n = /^\s*/.exec(t.text)[0];
  if (!n)
    return;
  let r = Ti(n, s.tabSize), a = 0, o = Za(s, Math.max(0, r - mc(s)));
  for (; a < n.length && a < o.length && n.charCodeAt(a) == o.charCodeAt(a); )
    a++;
  i.push({ from: t.from + a, to: t.from + n.length, insert: o.slice(a) });
}), { userEvent: "delete.dedent" })), !0), TL = (s) => (s.setTabFocusMode(), !0), $L = [
  { key: "Ctrl-b", run: T1, shift: I1, preventDefault: !0 },
  { key: "Ctrl-f", run: $1, shift: q1 },
  { key: "Ctrl-p", run: X1, shift: W1 },
  { key: "Ctrl-n", run: M1, shift: Y1 },
  { key: "Ctrl-a", run: H_, shift: oL },
  { key: "Ctrl-e", run: U_, shift: lL },
  { key: "Ctrl-d", run: V1 },
  { key: "Ctrl-h", run: Xf },
  { key: "Ctrl-k", run: pL },
  { key: "Ctrl-Alt-h", run: j1 },
  { key: "Ctrl-o", run: OL },
  { key: "Ctrl-t", run: xL },
  { key: "Ctrl-v", run: Ef }
], RL = /* @__PURE__ */ [
  { key: "ArrowLeft", run: T1, shift: I1, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: D_, shift: J_, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: F_, shift: rL, preventDefault: !0 },
  { key: "ArrowRight", run: $1, shift: q1, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: B_, shift: eL, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: j_, shift: aL, preventDefault: !0 },
  { key: "ArrowUp", run: X1, shift: W1, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Qx, shift: Ax },
  { mac: "Ctrl-ArrowUp", run: Sx, shift: kx },
  { key: "ArrowDown", run: M1, shift: Y1, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Cx, shift: Tx },
  { mac: "Ctrl-ArrowDown", run: Ef, shift: Px },
  { key: "PageUp", run: Sx, shift: kx },
  { key: "PageDown", run: Ef, shift: Px },
  { key: "Home", run: V_, shift: nL, preventDefault: !0 },
  { key: "Mod-Home", run: Qx, shift: Ax },
  { key: "End", run: N_, shift: sL, preventDefault: !0 },
  { key: "Mod-End", run: Cx, shift: Tx },
  { key: "Enter", run: $x, shift: $x },
  { key: "Mod-a", run: cL },
  { key: "Backspace", run: Xf, shift: Xf },
  { key: "Delete", run: V1 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: j1 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: fL },
  { mac: "Mod-Backspace", run: gL },
  { mac: "Mod-Delete", run: mL }
].concat(/* @__PURE__ */ $L.map((s) => ({ mac: s.key, run: s.run, shift: s.shift }))), EL = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: Y_, shift: tL },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: Z_, shift: iL },
  { key: "Alt-ArrowUp", run: bL },
  { key: "Shift-Alt-ArrowUp", run: vL },
  { key: "Alt-ArrowDown", run: yL },
  { key: "Shift-Alt-ArrowDown", run: wL },
  { key: "Escape", run: dL },
  { key: "Mod-Enter", run: PL },
  { key: "Alt-l", mac: "Ctrl-l", run: hL },
  { key: "Mod-i", run: uL, preventDefault: !0 },
  { key: "Mod-[", run: AL },
  { key: "Mod-]", run: CL },
  { key: "Mod-Alt-\\", run: QL },
  { key: "Shift-Mod-k", run: SL },
  { key: "Shift-Mod-\\", run: K_ },
  { key: "Mod-/", run: v_ },
  { key: "Alt-A", run: S_ },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: TL }
].concat(RL), Rx = typeof String.prototype.normalize == "function" ? (s) => s.normalize("NFKD") : (s) => s;
class mr {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, n = e.length, r, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = r ? (o) => r(Rx(o)) : Rx, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return It(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = Bp(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Vi(e);
      let n = this.normalize(t);
      if (n.length)
        for (let r = 0, a = i; ; r++) {
          let o = n.charCodeAt(r), l = this.match(o, a, this.bufferPos + this.bufferStart);
          if (r == n.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          a == i && r < t.length && t.charCodeAt(r) == o && a++;
        }
    }
  }
  match(e, t, i) {
    let n = null;
    for (let r = 0; r < this.matches.length; r += 2) {
      let a = this.matches[r], o = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? n = { from: this.matches[r + 1], to: i } : (this.matches[r]++, o = !0)), o || (this.matches.splice(r, 2), r -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? n = { from: t, to: i } : this.matches.push(1, t)), n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferStart) && (n = null), n;
  }
}
typeof Symbol < "u" && (mr.prototype[Symbol.iterator] = function() {
  return this;
});
const K1 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, mg = "gm" + (/x/.unicode == null ? "" : "u");
class J1 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, n = 0, r = e.length) {
    if (this.text = e, this.to = r, this.curLine = "", this.done = !1, this.value = K1, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new eS(e, t, i, n, r);
    this.re = new RegExp(t, mg + (i?.ignoreCase ? "i" : "")), this.test = i?.test, this.iter = e.iter();
    let a = e.lineAt(n);
    this.curLineStart = a.from, this.matchPos = yc(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, n = i + t[0].length;
        if (this.matchPos = yc(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const bu = /* @__PURE__ */ new WeakMap();
class rr {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let n = bu.get(e);
    if (!n || n.from >= i || n.to <= t) {
      let o = new rr(t, e.sliceString(t, i));
      return bu.set(e, o), o;
    }
    if (n.from == t && n.to == i)
      return n;
    let { text: r, from: a } = n;
    return a > t && (r = e.sliceString(t, a) + r, a = t), n.to < i && (r += e.sliceString(n.to, i)), bu.set(e, new rr(a, r)), new rr(t, r.slice(t - a, i - a));
  }
}
class eS {
  constructor(e, t, i, n, r) {
    this.text = e, this.to = r, this.done = !1, this.value = K1, this.matchPos = yc(e, n), this.re = new RegExp(t, mg + (i?.ignoreCase ? "i" : "")), this.test = i?.test, this.flat = rr.get(e, n, this.chunkEnd(
      n + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, n = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this.matchPos = yc(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = rr.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (J1.prototype[Symbol.iterator] = eS.prototype[Symbol.iterator] = function() {
  return this;
});
function XL(s) {
  try {
    return new RegExp(s, mg), !0;
  } catch {
    return !1;
  }
}
function yc(s, e) {
  if (e >= s.length)
    return e;
  let t = s.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function Mf(s) {
  let e = String(s.state.doc.lineAt(s.state.selection.main.head).number), t = We("input", { class: "cm-textfield", name: "line", value: e }), i = We("form", {
    class: "cm-gotoLine",
    onkeydown: (r) => {
      r.keyCode == 27 ? (r.preventDefault(), s.dispatch({ effects: Oa.of(!1) }), s.focus()) : r.keyCode == 13 && (r.preventDefault(), n());
    },
    onsubmit: (r) => {
      r.preventDefault(), n();
    }
  }, We("label", s.state.phrase("Go to line"), ": ", t), " ", We("button", { class: "cm-button", type: "submit" }, s.state.phrase("go")), We("button", {
    name: "close",
    onclick: () => {
      s.dispatch({ effects: Oa.of(!1) }), s.focus();
    },
    "aria-label": s.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function n() {
    let r = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!r)
      return;
    let { state: a } = s, o = a.doc.lineAt(a.selection.main.head), [, l, c, h, u] = r, d = h ? +h.slice(1) : 0, f = c ? +c : o.number;
    if (c && u) {
      let m = f / 100;
      l && (m = m * (l == "-" ? -1 : 1) + o.number / a.doc.lines), f = Math.round(a.doc.lines * m);
    } else c && l && (f = f * (l == "-" ? -1 : 1) + o.number);
    let p = a.doc.line(Math.max(1, Math.min(a.doc.lines, f))), g = D.cursor(p.from + Math.max(0, Math.min(d, p.length)));
    s.dispatch({
      effects: [Oa.of(!1), J.scrollIntoView(g.from, { y: "center" })],
      selection: g
    }), s.focus();
  }
  return { dom: i };
}
const Oa = /* @__PURE__ */ xe.define(), Ex = /* @__PURE__ */ gt.define({
  create() {
    return !0;
  },
  update(s, e) {
    for (let t of e.effects)
      t.is(Oa) && (s = t.value);
    return s;
  },
  provide: (s) => Da.from(s, (e) => e ? Mf : null)
}), ML = (s) => {
  let e = qa(s, Mf);
  if (!e) {
    let t = [Oa.of(!0)];
    s.state.field(Ex, !1) == null && t.push(xe.appendConfig.of([Ex, _L])), s.dispatch({ effects: t }), e = qa(s, Mf);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, _L = /* @__PURE__ */ J.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), LL = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, zL = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, LL, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function IL(s) {
  return [YL, WL];
}
const qL = /* @__PURE__ */ de.mark({ class: "cm-selectionMatch" }), DL = /* @__PURE__ */ de.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Xx(s, e, t, i) {
  return (t == 0 || s(e.sliceDoc(t - 1, t)) != Ke.Word) && (i == e.doc.length || s(e.sliceDoc(i, i + 1)) != Ke.Word);
}
function BL(s, e, t, i) {
  return s(e.sliceDoc(t, t + 1)) == Ke.Word && s(e.sliceDoc(i - 1, i)) == Ke.Word;
}
const WL = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.decorations = this.getDeco(s);
  }
  update(s) {
    (s.selectionSet || s.docChanged || s.viewportChanged) && (this.decorations = this.getDeco(s.view));
  }
  getDeco(s) {
    let e = s.state.facet(zL), { state: t } = s, i = t.selection;
    if (i.ranges.length > 1)
      return de.none;
    let n = i.main, r, a = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return de.none;
      let l = t.wordAt(n.head);
      if (!l)
        return de.none;
      a = t.charCategorizer(n.head), r = t.sliceDoc(l.from, l.to);
    } else {
      let l = n.to - n.from;
      if (l < e.minSelectionLength || l > 200)
        return de.none;
      if (e.wholeWords) {
        if (r = t.sliceDoc(n.from, n.to), a = t.charCategorizer(n.head), !(Xx(a, t, n.from, n.to) && BL(a, t, n.from, n.to)))
          return de.none;
      } else if (r = t.sliceDoc(n.from, n.to), !r)
        return de.none;
    }
    let o = [];
    for (let l of s.visibleRanges) {
      let c = new mr(t.doc, r, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: h, to: u } = c.value;
        if ((!a || Xx(a, t, h, u)) && (n.empty && h <= n.from && u >= n.to ? o.push(DL.range(h, u)) : (h >= n.to || u <= n.from) && o.push(qL.range(h, u)), o.length > e.maxMatches))
          return de.none;
      }
    }
    return de.set(o);
  }
}, {
  decorations: (s) => s.decorations
}), YL = /* @__PURE__ */ J.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), ZL = ({ state: s, dispatch: e }) => {
  let { selection: t } = s, i = D.create(t.ranges.map((n) => s.wordAt(n.head) || D.cursor(n.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(s.update({ selection: i })), !0);
};
function NL(s, e) {
  let { main: t, ranges: i } = s.selection, n = s.wordAt(t.head), r = n && n.from == t.from && n.to == t.to;
  for (let a = !1, o = new mr(s.doc, e, i[i.length - 1].to); ; )
    if (o.next(), o.done) {
      if (a)
        return null;
      o = new mr(s.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), a = !0;
    } else {
      if (a && i.some((l) => l.from == o.value.from))
        continue;
      if (r) {
        let l = s.wordAt(o.value.from);
        if (!l || l.from != o.value.from || l.to != o.value.to)
          continue;
      }
      return o.value;
    }
}
const VL = ({ state: s, dispatch: e }) => {
  let { ranges: t } = s.selection;
  if (t.some((r) => r.from === r.to))
    return ZL({ state: s, dispatch: e });
  let i = s.sliceDoc(t[0].from, t[0].to);
  if (s.selection.ranges.some((r) => s.sliceDoc(r.from, r.to) != i))
    return !1;
  let n = NL(s, i);
  return n ? (e(s.update({
    selection: s.selection.addRange(D.range(n.from, n.to), !1),
    effects: J.scrollIntoView(n.to)
  })), !0) : !1;
}, Mr = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new n5(e),
      scrollToMatch: (e) => J.scrollIntoView(e)
    });
  }
});
class tS {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || XL(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new UL(this) : new jL(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let n = e.doc ? e : Ce.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? Nn(this, n, t, i) : Zn(this, n, t, i);
  }
}
class iS {
  constructor(e) {
    this.spec = e;
  }
}
function Zn(s, e, t, i) {
  return new mr(e.doc, s.unquoted, t, i, s.caseSensitive ? void 0 : (n) => n.toLowerCase(), s.wholeWord ? FL(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function FL(s, e) {
  return (t, i, n, r) => ((r > t || r + n.length < i) && (r = Math.max(0, t - 2), n = s.sliceString(r, Math.min(s.length, i + 2))), (e(vc(n, t - r)) != Ke.Word || e(wc(n, t - r)) != Ke.Word) && (e(wc(n, i - r)) != Ke.Word || e(vc(n, i - r)) != Ke.Word));
}
class jL extends iS {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let n = Zn(this.spec, e, i, e.doc.length).nextOverlapping();
    if (n.done) {
      let r = Math.min(e.doc.length, t + this.spec.unquoted.length);
      n = Zn(this.spec, e, 0, r).nextOverlapping();
    }
    return n.done || n.value.from == t && n.value.to == i ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let n = i; ; ) {
      let r = Math.max(t, n - 1e4 - this.spec.unquoted.length), a = Zn(this.spec, e, r, n), o = null;
      for (; !a.nextOverlapping().done; )
        o = a.value;
      if (o)
        return o;
      if (r == t)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    let n = this.prevMatchInRange(e, 0, t);
    return n || (n = this.prevMatchInRange(e, Math.max(0, i - this.spec.unquoted.length), e.doc.length)), n && (n.from != t || n.to != i) ? n : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = Zn(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let r = Zn(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !r.next().done; )
      n(r.value.from, r.value.to);
  }
}
function Nn(s, e, t, i) {
  return new J1(e.doc, s.search, {
    ignoreCase: !s.caseSensitive,
    test: s.wholeWord ? HL(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function vc(s, e) {
  return s.slice(wt(s, e, !1), e);
}
function wc(s, e) {
  return s.slice(e, wt(s, e));
}
function HL(s) {
  return (e, t, i) => !i[0].length || (s(vc(i.input, i.index)) != Ke.Word || s(wc(i.input, i.index)) != Ke.Word) && (s(wc(i.input, i.index + i[0].length)) != Ke.Word || s(vc(i.input, i.index + i[0].length)) != Ke.Word);
}
class UL extends iS {
  nextMatch(e, t, i) {
    let n = Nn(this.spec, e, i, e.doc.length).next();
    return n.done && (n = Nn(this.spec, e, 0, t).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, t, i) {
    for (let n = 1; ; n++) {
      let r = Math.max(
        t,
        i - n * 1e4
        /* FindPrev.ChunkSize */
      ), a = Nn(this.spec, e, r, i), o = null;
      for (; !a.next().done; )
        o = a.value;
      if (o && (r == t || o.from > r + 10))
        return o;
      if (r == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, i) => {
      if (i == "&")
        return e.match[0];
      if (i == "$")
        return "$";
      for (let n = i.length; n > 0; n--) {
        let r = +i.slice(0, n);
        if (r > 0 && r < e.match.length)
          return e.match[r] + i.slice(n);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let i = Nn(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let r = Nn(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !r.next().done; )
      n(r.value.from, r.value.to);
  }
}
const Na = /* @__PURE__ */ xe.define(), Og = /* @__PURE__ */ xe.define(), Is = /* @__PURE__ */ gt.define({
  create(s) {
    return new yu(_f(s).create(), null);
  },
  update(s, e) {
    for (let t of e.effects)
      t.is(Na) ? s = new yu(t.value.create(), s.panel) : t.is(Og) && (s = new yu(s.query, t.value ? xg : null));
    return s;
  },
  provide: (s) => Da.from(s, (e) => e.panel)
});
class yu {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const GL = /* @__PURE__ */ de.mark({ class: "cm-searchMatch" }), KL = /* @__PURE__ */ de.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), JL = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.view = s, this.decorations = this.highlight(s.state.field(Is));
  }
  update(s) {
    let e = s.state.field(Is);
    (e != s.startState.field(Is) || s.docChanged || s.selectionSet || s.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: s, panel: e }) {
    if (!e || !s.spec.valid)
      return de.none;
    let { view: t } = this, i = new vs();
    for (let n = 0, r = t.visibleRanges, a = r.length; n < a; n++) {
      let { from: o, to: l } = r[n];
      for (; n < a - 1 && l > r[n + 1].from - 2 * 250; )
        l = r[++n].to;
      s.highlight(t.state, o, l, (c, h) => {
        let u = t.state.selection.ranges.some((d) => d.from == c && d.to == h);
        i.add(c, h, u ? KL : GL);
      });
    }
    return i.finish();
  }
}, {
  decorations: (s) => s.decorations
});
function Co(s) {
  return (e) => {
    let t = e.state.field(Is, !1);
    return t && t.query.spec.valid ? s(e, t) : rS(e);
  };
}
const Sc = /* @__PURE__ */ Co((s, { query: e }) => {
  let { to: t } = s.state.selection.main, i = e.nextMatch(s.state, t, t);
  if (!i)
    return !1;
  let n = D.single(i.from, i.to), r = s.state.facet(Mr);
  return s.dispatch({
    selection: n,
    effects: [bg(s, i), r.scrollToMatch(n.main, s)],
    userEvent: "select.search"
  }), nS(s), !0;
}), kc = /* @__PURE__ */ Co((s, { query: e }) => {
  let { state: t } = s, { from: i } = t.selection.main, n = e.prevMatch(t, i, i);
  if (!n)
    return !1;
  let r = D.single(n.from, n.to), a = s.state.facet(Mr);
  return s.dispatch({
    selection: r,
    effects: [bg(s, n), a.scrollToMatch(r.main, s)],
    userEvent: "select.search"
  }), nS(s), !0;
}), e5 = /* @__PURE__ */ Co((s, { query: e }) => {
  let t = e.matchAll(s.state, 1e3);
  return !t || !t.length ? !1 : (s.dispatch({
    selection: D.create(t.map((i) => D.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), t5 = ({ state: s, dispatch: e }) => {
  let t = s.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: n } = t.main, r = [], a = 0;
  for (let o = new mr(s.doc, s.sliceDoc(i, n)); !o.next().done; ) {
    if (r.length > 1e3)
      return !1;
    o.value.from == i && (a = r.length), r.push(D.range(o.value.from, o.value.to));
  }
  return e(s.update({
    selection: D.create(r, a),
    userEvent: "select.search.matches"
  })), !0;
}, Mx = /* @__PURE__ */ Co((s, { query: e }) => {
  let { state: t } = s, { from: i, to: n } = t.selection.main;
  if (t.readOnly)
    return !1;
  let r = e.nextMatch(t, i, i);
  if (!r)
    return !1;
  let a = r, o = [], l, c, h = [];
  a.from == i && a.to == n && (c = t.toText(e.getReplacement(a)), o.push({ from: a.from, to: a.to, insert: c }), a = e.nextMatch(t, a.from, a.to), h.push(J.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + ".")));
  let u = s.state.changes(o);
  return a && (l = D.single(a.from, a.to).map(u), h.push(bg(s, a)), h.push(t.facet(Mr).scrollToMatch(l.main, s))), s.dispatch({
    changes: u,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), i5 = /* @__PURE__ */ Co((s, { query: e }) => {
  if (s.state.readOnly)
    return !1;
  let t = e.matchAll(s.state, 1e9).map((n) => {
    let { from: r, to: a } = n;
    return { from: r, to: a, insert: e.getReplacement(n) };
  });
  if (!t.length)
    return !1;
  let i = s.state.phrase("replaced $ matches", t.length) + ".";
  return s.dispatch({
    changes: t,
    effects: J.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function xg(s) {
  return s.state.facet(Mr).createPanel(s);
}
function _f(s, e) {
  var t, i, n, r, a;
  let o = s.selection.main, l = o.empty || o.to > o.from + 100 ? "" : s.sliceDoc(o.from, o.to);
  if (e && !l)
    return e;
  let c = s.facet(Mr);
  return new tS({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e?.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (n = e?.literal) !== null && n !== void 0 ? n : c.literal,
    regexp: (r = e?.regexp) !== null && r !== void 0 ? r : c.regexp,
    wholeWord: (a = e?.wholeWord) !== null && a !== void 0 ? a : c.wholeWord
  });
}
function sS(s) {
  let e = qa(s, xg);
  return e && e.dom.querySelector("[main-field]");
}
function nS(s) {
  let e = sS(s);
  e && e == s.root.activeElement && e.select();
}
const rS = (s) => {
  let e = s.state.field(Is, !1);
  if (e && e.panel) {
    let t = sS(s);
    if (t && t != s.root.activeElement) {
      let i = _f(s.state, e.query.spec);
      i.valid && s.dispatch({ effects: Na.of(i) }), t.focus(), t.select();
    }
  } else
    s.dispatch({ effects: [
      Og.of(!0),
      e ? Na.of(_f(s.state, e.query.spec)) : xe.appendConfig.of(a5)
    ] });
  return !0;
}, aS = (s) => {
  let e = s.state.field(Is, !1);
  if (!e || !e.panel)
    return !1;
  let t = qa(s, xg);
  return t && t.dom.contains(s.root.activeElement) && s.focus(), s.dispatch({ effects: Og.of(!1) }), !0;
}, s5 = [
  { key: "Mod-f", run: rS, scope: "editor search-panel" },
  { key: "F3", run: Sc, shift: kc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Sc, shift: kc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: aS, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: t5 },
  { key: "Mod-Alt-g", run: ML },
  { key: "Mod-d", run: VL, preventDefault: !0 }
];
class n5 {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Is).query.spec;
    this.commit = this.commit.bind(this), this.searchField = We("input", {
      value: t.search,
      placeholder: Ft(e, "Find"),
      "aria-label": Ft(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = We("input", {
      value: t.replace,
      placeholder: Ft(e, "Replace"),
      "aria-label": Ft(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = We("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = We("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = We("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(n, r, a) {
      return We("button", { class: "cm-button", name: n, onclick: r, type: "button" }, a);
    }
    this.dom = We("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => Sc(e), [Ft(e, "next")]),
      i("prev", () => kc(e), [Ft(e, "previous")]),
      i("select", () => e5(e), [Ft(e, "all")]),
      We("label", null, [this.caseField, Ft(e, "match case")]),
      We("label", null, [this.reField, Ft(e, "regexp")]),
      We("label", null, [this.wordField, Ft(e, "by word")]),
      ...e.state.readOnly ? [] : [
        We("br"),
        this.replaceField,
        i("replace", () => Mx(e), [Ft(e, "replace")]),
        i("replaceAll", () => i5(e), [Ft(e, "replace all")])
      ],
      We("button", {
        name: "close",
        onclick: () => aS(e),
        "aria-label": Ft(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new tS({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Na.of(e) }));
  }
  keydown(e) {
    fX(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? kc : Sc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Mx(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(Na) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Mr).top;
  }
}
function Ft(s, e) {
  return s.state.phrase(e);
}
const il = 30, sl = /[\s\.,:;?!]/;
function bg(s, { from: e, to: t }) {
  let i = s.state.doc.lineAt(e), n = s.state.doc.lineAt(t).to, r = Math.max(i.from, e - il), a = Math.min(n, t + il), o = s.state.sliceDoc(r, a);
  if (r != i.from) {
    for (let l = 0; l < il; l++)
      if (!sl.test(o[l + 1]) && sl.test(o[l])) {
        o = o.slice(l);
        break;
      }
  }
  if (a != n) {
    for (let l = o.length - 1; l > o.length - il; l--)
      if (!sl.test(o[l - 1]) && sl.test(o[l])) {
        o = o.slice(0, l);
        break;
      }
  }
  return J.announce.of(`${s.state.phrase("current match")}. ${o} ${s.state.phrase("on line")} ${i.number}.`);
}
const r5 = /* @__PURE__ */ J.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), a5 = [
  Is,
  /* @__PURE__ */ Qs.low(JL),
  r5
];
class yg {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i, n) {
    this.state = e, this.pos = t, this.explicit = i, this.view = n, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Ie(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), n = t.text.slice(i - t.from, this.pos - t.from), r = n.search(oS(e, !1));
    return r < 0 ? null : { from: i + r, to: this.pos, text: n.slice(r) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, i) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}
function _x(s) {
  let e = Object.keys(s).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function o5(s) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of s) {
    e[n[0]] = !0;
    for (let r = 1; r < n.length; r++)
      t[n[r]] = !0;
  }
  let i = _x(e) + _x(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function lh(s) {
  let e = s.map((n) => typeof n == "string" ? { label: n } : n), [t, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : o5(e);
  return (n) => {
    let r = n.matchBefore(i);
    return r || n.explicit ? { from: r ? r.from : n.pos, options: e, validFor: t } : null;
  };
}
function vg(s, e) {
  return (t) => {
    for (let i = Ie(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
      if (s.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(t);
  };
}
class Lx {
  constructor(e, t, i, n) {
    this.completion = e, this.source = t, this.match = i, this.score = n;
  }
}
function bn(s) {
  return s.selection.main.from;
}
function oS(s, e) {
  var t;
  let { source: i } = s, n = e && i[0] != "^", r = i[i.length - 1] != "$";
  return !n && !r ? s : new RegExp(`${n ? "^" : ""}(?:${i})${r ? "$" : ""}`, (t = s.flags) !== null && t !== void 0 ? t : s.ignoreCase ? "i" : "");
}
const wg = /* @__PURE__ */ Cs.define();
function l5(s, e, t, i) {
  let { main: n } = s.selection, r = t - n.from, a = i - n.from;
  return Object.assign(Object.assign({}, s.changeByRange((o) => {
    if (o != n && t != i && s.sliceDoc(o.from + r, o.from + a) != s.sliceDoc(t, i))
      return { range: o };
    let l = s.toText(e);
    return {
      changes: { from: o.from + r, to: i == n.from ? o.to : o.from + a, insert: l },
      range: D.cursor(o.from + r + l.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const zx = /* @__PURE__ */ new WeakMap();
function c5(s) {
  if (!Array.isArray(s))
    return s;
  let e = zx.get(s);
  return e || zx.set(s, e = lh(s)), e;
}
const Pc = /* @__PURE__ */ xe.define(), Va = /* @__PURE__ */ xe.define();
class h5 {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let i = It(e, t), n = Vi(i);
      this.chars.push(i);
      let r = e.slice(t, t + n), a = r.toUpperCase();
      this.folded.push(It(a == r ? r.toLowerCase() : a, 0)), t += n;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: i, any: n, precise: r, byWord: a } = this;
    if (t.length == 1) {
      let x = It(e, 0), b = Vi(x), v = b == e.length ? 0 : -100;
      if (x != t[0]) if (x == i[0])
        v += -200;
      else
        return null;
      return this.ret(v, [0, b]);
    }
    let o = e.indexOf(this.pattern);
    if (o == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, c = 0;
    if (o < 0) {
      for (let x = 0, b = Math.min(e.length, 200); x < b && c < l; ) {
        let v = It(e, x);
        (v == t[c] || v == i[c]) && (n[c++] = x), x += Vi(v);
      }
      if (c < l)
        return null;
    }
    let h = 0, u = 0, d = !1, f = 0, p = -1, g = -1, m = /[a-z]/.test(e), O = !0;
    for (let x = 0, b = Math.min(e.length, 200), v = 0; x < b && u < l; ) {
      let y = It(e, x);
      o < 0 && (h < l && y == t[h] && (r[h++] = x), f < l && (y == t[f] || y == i[f] ? (f == 0 && (p = x), g = x + 1, f++) : f = 0));
      let w, S = y < 255 ? y >= 48 && y <= 57 || y >= 97 && y <= 122 ? 2 : y >= 65 && y <= 90 ? 1 : 0 : (w = Bp(y)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!x || S == 1 && m || v == 0 && S != 0) && (t[u] == y || i[u] == y && (d = !0) ? a[u++] = x : a.length && (O = !1)), v = S, x += Vi(y);
    }
    return u == l && a[0] == 0 && O ? this.result(-100 + (d ? -200 : 0), a, e) : f == l && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : o > -1 ? this.ret(-700 - e.length, [o, o + this.pattern.length]) : f == l ? this.ret(-900 - e.length, [p, g]) : u == l ? this.result(-100 + (d ? -200 : 0) + -700 + (O ? 0 : -1100), a, e) : t.length == 2 ? null : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, t, i) {
    let n = [], r = 0;
    for (let a of t) {
      let o = a + (this.astral ? Vi(It(i, a)) : 1);
      r && n[r - 1] == a ? n[r - 1] = o : (n[r++] = a, n[r++] = o);
    }
    return this.ret(e - i.length, n);
  }
}
class u5 {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), i = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, t.length], this.score = i + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const pt = /* @__PURE__ */ se.define({
  combine(s) {
    return ns(s, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: d5,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => Ix(e(i), t(i)),
      optionClass: (e, t) => (i) => Ix(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function Ix(s, e) {
  return s ? e ? s + " " + e : s : e;
}
function d5(s, e, t, i, n, r) {
  let a = s.textDirection == Ge.RTL, o = a, l = !1, c = "top", h, u, d = e.left - n.left, f = n.right - e.right, p = i.right - i.left, g = i.bottom - i.top;
  if (o && d < Math.min(p, f) ? o = !1 : !o && f < Math.min(p, d) && (o = !0), p <= (o ? d : f))
    h = Math.max(n.top, Math.min(t.top, n.bottom - g)) - e.top, u = Math.min(400, o ? d : f);
  else {
    l = !0, u = Math.min(
      400,
      (a ? e.right : n.right - e.left) - 30
      /* Info.Margin */
    );
    let x = n.bottom - e.bottom;
    x >= g || x > e.top ? h = t.bottom - e.top : (c = "bottom", h = e.bottom - t.top);
  }
  let m = (e.bottom - e.top) / r.offsetHeight, O = (e.right - e.left) / r.offsetWidth;
  return {
    style: `${c}: ${h / m}px; max-width: ${u / O}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function f5(s) {
  let e = s.addToOptions.slice();
  return s.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, n, r) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = t.displayLabel || t.label, l = 0;
      for (let c = 0; c < r.length; ) {
        let h = r[c++], u = r[c++];
        h > l && a.appendChild(document.createTextNode(o.slice(l, h)));
        let d = a.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(o.slice(h, u))), d.className = "cm-completionMatchedText", l = u;
      }
      return l < o.length && a.appendChild(document.createTextNode(o.slice(l))), a;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function vu(s, e, t) {
  if (s <= t)
    return { from: 0, to: s };
  if (e < 0 && (e = 0), e <= s >> 1) {
    let n = Math.floor(e / t);
    return { from: n * t, to: (n + 1) * t };
  }
  let i = Math.floor((s - e) / t);
  return { from: s - (i + 1) * t, to: s - i * t };
}
class p5 {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(t), { options: r, selected: a } = n.open, o = e.state.facet(pt);
    this.optionContent = f5(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = vu(r.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(t).open;
      for (let h = l.target, u; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (u = /-(\d+)$/.exec(h.id)) && +u[1] < c.length) {
          this.applyCompletion(e, c[+u[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(pt).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Va.of(null) });
    }), this.showOptions(r, n.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let i = e.state.field(this.stateField), n = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != n) {
      let { options: r, selected: a, disabled: o } = i.open;
      (!n.open || n.open.options != r) && (this.range = vu(r.length, a, e.state.facet(pt).maxRenderedOptions), this.showOptions(r, i.id)), this.updateSel(), o != ((t = n.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = vu(t.options.length, t.selected, this.view.state.facet(pt).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: n } = i;
      if (!n)
        return;
      let r = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!r)
        return;
      "then" in r ? r.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, i);
      }).catch((a) => Bt(this.view.state, a, "completion info")) : this.addInfoPane(r, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: n, destroy: r } = e;
      i.appendChild(n), this.infoDestroy = r || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && m5(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), r = this.space;
    if (!r) {
      let a = this.dom.ownerDocument.documentElement;
      r = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return n.top > Math.min(r.bottom, t.bottom) - 10 || n.bottom < Math.max(r.top, t.top) + 10 ? null : this.view.state.facet(pt).positionInfo(this.view, t, n, i, r, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const n = document.createElement("ul");
    n.id = t, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions")), n.addEventListener("mousedown", (a) => {
      a.target == n && a.preventDefault();
    });
    let r = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: l } = e[a], { section: c } = o;
      if (c) {
        let d = typeof c == "string" ? c : c.name;
        if (d != r && (a > i.from || i.from == 0))
          if (r = d, typeof c != "string" && c.header)
            n.appendChild(c.header(c));
          else {
            let f = n.appendChild(document.createElement("completion-section"));
            f.textContent = d;
          }
      }
      const h = n.appendChild(document.createElement("li"));
      h.id = t + "-" + a, h.setAttribute("role", "option");
      let u = this.optionClass(o);
      u && (h.className = u);
      for (let d of this.optionContent) {
        let f = d(o, this.view.state, this.view, l);
        f && h.appendChild(f);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function g5(s, e) {
  return (t) => new p5(t, s, e);
}
function m5(s, e) {
  let t = s.getBoundingClientRect(), i = e.getBoundingClientRect(), n = t.height / s.offsetHeight;
  i.top < t.top ? s.scrollTop -= (t.top - i.top) / n : i.bottom > t.bottom && (s.scrollTop += (i.bottom - t.bottom) / n);
}
function qx(s) {
  return (s.boost || 0) * 100 + (s.apply ? 10 : 0) + (s.info ? 5 : 0) + (s.type ? 1 : 0);
}
function O5(s, e) {
  let t = [], i = null, n = (c) => {
    t.push(c);
    let { section: h } = c.completion;
    if (h) {
      i || (i = []);
      let u = typeof h == "string" ? h : h.name;
      i.some((d) => d.name == u) || i.push(typeof h == "string" ? { name: u } : h);
    }
  }, r = e.facet(pt);
  for (let c of s)
    if (c.hasResult()) {
      let h = c.result.getMatch;
      if (c.result.filter === !1)
        for (let u of c.result.options)
          n(new Lx(u, c.source, h ? h(u) : [], 1e9 - t.length));
      else {
        let u = e.sliceDoc(c.from, c.to), d, f = r.filterStrict ? new u5(u) : new h5(u);
        for (let p of c.result.options)
          if (d = f.match(p.label)) {
            let g = p.displayLabel ? h ? h(p, d.matched) : [] : d.matched;
            n(new Lx(p, c.source, g, d.score + (p.boost || 0)));
          }
      }
    }
  if (i) {
    let c = /* @__PURE__ */ Object.create(null), h = 0, u = (d, f) => {
      var p, g;
      return ((p = d.rank) !== null && p !== void 0 ? p : 1e9) - ((g = f.rank) !== null && g !== void 0 ? g : 1e9) || (d.name < f.name ? -1 : 1);
    };
    for (let d of i.sort(u))
      h -= 1e5, c[d.name] = h;
    for (let d of t) {
      let { section: f } = d.completion;
      f && (d.score += c[typeof f == "string" ? f : f.name]);
    }
  }
  let a = [], o = null, l = r.compareCompletions;
  for (let c of t.sort((h, u) => u.score - h.score || l(h.completion, u.completion))) {
    let h = c.completion;
    !o || o.label != h.label || o.detail != h.detail || o.type != null && h.type != null && o.type != h.type || o.apply != h.apply || o.boost != h.boost ? a.push(c) : qx(c.completion) > qx(o) && (a[a.length - 1] = c), o = c.completion;
  }
  return a;
}
class Kn {
  constructor(e, t, i, n, r, a) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = n, this.selected = r, this.disabled = a;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Kn(this.options, Dx(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, n, r, a) {
    if (n && !a && e.some((c) => c.isPending))
      return n.setDisabled();
    let o = O5(e, t);
    if (!o.length)
      return n && e.some((c) => c.isPending) ? n.setDisabled() : null;
    let l = t.facet(pt).selectOnOpen ? 0 : -1;
    if (n && n.selected != l && n.selected != -1) {
      let c = n.options[n.selected].completion;
      for (let h = 0; h < o.length; h++)
        if (o[h].completion == c) {
          l = h;
          break;
        }
    }
    return new Kn(o, Dx(i, l), {
      pos: e.reduce((c, h) => h.hasResult() ? Math.min(c, h.from) : c, 1e8),
      create: S5,
      above: r.aboveCursor
    }, n ? n.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Kn(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Kn(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class Qc {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new Qc(v5, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(pt), r = (i.override || t.languageDataAt("autocomplete", bn(t)).map(c5)).map((l) => (this.active.find((h) => h.source == l) || new fi(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    r.length == this.active.length && r.every((l, c) => l == this.active[c]) && (r = this.active);
    let a = this.open, o = e.effects.some((l) => l.is(Sg));
    a && e.docChanged && (a = a.map(e.changes)), e.selection || r.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !x5(r, this.active) || o ? a = Kn.build(r, t, this.id, a, i, o) : a && a.disabled && !r.some((l) => l.isPending) && (a = null), !a && r.every((l) => !l.isPending) && r.some((l) => l.hasResult()) && (r = r.map((l) => l.hasResult() ? new fi(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(cS) && (a = a && a.setSelected(l.value, this.id));
    return r == this.active && a == this.open ? this : new Qc(r, this.id, a);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? b5 : y5;
  }
}
function x5(s, e) {
  if (s == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < s.length && !s[t].hasResult(); )
      t++;
    for (; i < e.length && !e[i].hasResult(); )
      i++;
    let n = t == s.length, r = i == e.length;
    if (n || r)
      return n == r;
    if (s[t++].result != e[i++].result)
      return !1;
  }
}
const b5 = {
  "aria-autocomplete": "list"
}, y5 = {};
function Dx(s, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": s
  };
  return e > -1 && (t["aria-activedescendant"] = s + "-" + e), t;
}
const v5 = [];
function lS(s, e) {
  if (s.isUserEvent("input.complete")) {
    let i = s.annotation(wg);
    if (i && e.activateOnCompletion(i))
      return 12;
  }
  let t = s.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : s.isUserEvent("delete.backward") ? 2 : s.selection ? 8 : s.docChanged ? 16 : 0;
}
class fi {
  constructor(e, t, i = !1) {
    this.source = e, this.state = t, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let i = lS(e, t), n = this;
    (i & 8 || i & 16 && this.touches(e)) && (n = new fi(
      n.source,
      0
      /* State.Inactive */
    )), i & 4 && n.state == 0 && (n = new fi(
      this.source,
      1
      /* State.Pending */
    )), n = n.updateFor(e, i);
    for (let r of e.effects)
      if (r.is(Pc))
        n = new fi(n.source, 1, r.value);
      else if (r.is(Va))
        n = new fi(
          n.source,
          0
          /* State.Inactive */
        );
      else if (r.is(Sg))
        for (let a of r.value)
          a.source == n.source && (n = a);
    return n;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(bn(e.state));
  }
}
class ar extends fi {
  constructor(e, t, i, n, r, a) {
    super(e, 3, t), this.limit = i, this.result = n, this.from = r, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var i;
    if (!(t & 3))
      return this.map(e.changes);
    let n = this.result;
    n.map && !e.changes.empty && (n = n.map(n, e.changes));
    let r = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), o = bn(e.state);
    if (o > a || !n || t & 2 && (bn(e.startState) == this.from || o < this.limit))
      return new fi(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return w5(n.validFor, e.state, r, a) ? new ar(this.source, this.explicit, l, n, r, a) : n.update && (n = n.update(n, r, a, new yg(e.state, o, !1))) ? new ar(this.source, this.explicit, l, n, n.from, (i = n.to) !== null && i !== void 0 ? i : bn(e.state)) : new fi(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new ar(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new fi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function w5(s, e, t, i) {
  if (!s)
    return !1;
  let n = e.sliceDoc(t, i);
  return typeof s == "function" ? s(n, t, i, e) : oS(s, !0).test(n);
}
const Sg = /* @__PURE__ */ xe.define({
  map(s, e) {
    return s.map((t) => t.map(e));
  }
}), cS = /* @__PURE__ */ xe.define(), Dt = /* @__PURE__ */ gt.define({
  create() {
    return Qc.start();
  },
  update(s, e) {
    return s.update(e);
  },
  provide: (s) => [
    ig.from(s, (e) => e.tooltip),
    J.contentAttributes.from(s, (e) => e.attrs)
  ]
});
function kg(s, e) {
  const t = e.completion.apply || e.completion.label;
  let i = s.state.field(Dt).active.find((n) => n.source == e.source);
  return i instanceof ar ? (typeof t == "string" ? s.dispatch(Object.assign(Object.assign({}, l5(s.state, t, i.from, i.to)), { annotations: wg.of(e.completion) })) : t(s, e.completion, i.from, i.to), !0) : !1;
}
const S5 = /* @__PURE__ */ g5(Dt, kg);
function nl(s, e = "option") {
  return (t) => {
    let i = t.state.field(Dt, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(pt).interactionDelay)
      return !1;
    let n = 1, r;
    e == "page" && (r = Hw(t, i.open.tooltip)) && (n = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + n * (s ? 1 : -1) : s ? 0 : a - 1;
    return o < 0 ? o = e == "page" ? 0 : a - 1 : o >= a && (o = e == "page" ? a - 1 : 0), t.dispatch({ effects: cS.of(o) }), !0;
  };
}
const k5 = (s) => {
  let e = s.state.field(Dt, !1);
  return s.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < s.state.facet(pt).interactionDelay ? !1 : kg(s, e.open.options[e.open.selected]);
}, Bx = (s) => s.state.field(Dt, !1) ? (s.dispatch({ effects: Pc.of(!0) }), !0) : !1, P5 = (s) => {
  let e = s.state.field(Dt, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (s.dispatch({ effects: Va.of(null) }), !0);
};
class Q5 {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const C5 = 50, A5 = 1e3, T5 = /* @__PURE__ */ ct.fromClass(class {
  constructor(s) {
    this.view = s, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of s.state.field(Dt).active)
      e.isPending && this.startQuery(e);
  }
  update(s) {
    let e = s.state.field(Dt), t = s.state.facet(pt);
    if (!s.selectionSet && !s.docChanged && s.startState.field(Dt) == e)
      return;
    let i = s.transactions.some((r) => {
      let a = lS(r, t);
      return a & 8 || (r.selection || r.docChanged) && !(a & 3);
    });
    for (let r = 0; r < this.running.length; r++) {
      let a = this.running[r];
      if (i || a.context.abortOnDocChange && s.docChanged || a.updates.length + s.transactions.length > C5 && Date.now() - a.time > A5) {
        for (let o of a.context.abortListeners)
          try {
            o();
          } catch (l) {
            Bt(this.view.state, l);
          }
        a.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        a.updates.push(...s.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), s.transactions.some((r) => r.effects.some((a) => a.is(Pc))) && (this.pendingStart = !0);
    let n = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((r) => r.isPending && !this.running.some((a) => a.active.source == r.source)) ? setTimeout(() => this.startUpdate(), n) : -1, this.composing != 0)
      for (let r of s.transactions)
        r.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: s } = this.view, e = s.field(Dt);
    for (let t of e.active)
      t.isPending && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(pt).updateSyncTime));
  }
  startQuery(s) {
    let { state: e } = this.view, t = bn(e), i = new yg(e, t, s.explicit, this.view), n = new Q5(s, i);
    this.running.push(n), Promise.resolve(s.source(i)).then((r) => {
      n.context.aborted || (n.done = r || null, this.scheduleAccept());
    }, (r) => {
      this.view.dispatch({ effects: Va.of(null) }), Bt(this.view.state, r);
    });
  }
  scheduleAccept() {
    this.running.every((s) => s.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(pt).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var s;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(pt), i = this.view.state.field(Dt);
    for (let n = 0; n < this.running.length; n++) {
      let r = this.running[n];
      if (r.done === void 0)
        continue;
      if (this.running.splice(n--, 1), r.done) {
        let o = bn(r.updates.length ? r.updates[0].startState : this.view.state), l = Math.min(o, r.done.from + (r.active.explicit ? 0 : 1)), c = new ar(r.active.source, r.active.explicit, l, r.done, r.done.from, (s = r.done.to) !== null && s !== void 0 ? s : o);
        for (let h of r.updates)
          c = c.update(h, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let a = i.active.find((o) => o.source == r.active.source);
      if (a && a.isPending)
        if (r.done == null) {
          let o = new fi(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let l of r.updates)
            o = o.update(l, t);
          o.isPending || e.push(o);
        } else
          this.startQuery(a);
    }
    (e.length || i.open && i.open.disabled) && this.view.dispatch({ effects: Sg.of(e) });
  }
}, {
  eventHandlers: {
    blur(s) {
      let e = this.view.state.field(Dt, !1);
      if (e && e.tooltip && this.view.state.facet(pt).closeOnBlur) {
        let t = e.open && Hw(this.view, e.open.tooltip);
        (!t || !t.dom.contains(s.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Va.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Pc.of(!1) }), 20), this.composing = 0;
    }
  }
}), $5 = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), R5 = /* @__PURE__ */ Qs.highest(/* @__PURE__ */ J.domEventHandlers({
  keydown(s, e) {
    let t = e.state.field(Dt, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || s.key.length > 1 || s.ctrlKey && !($5 && s.altKey) || s.metaKey)
      return !1;
    let i = t.open.options[t.open.selected], n = t.active.find((a) => a.source == i.source), r = i.completion.commitCharacters || n.result.commitCharacters;
    return r && r.indexOf(s.key) > -1 && kg(e, i), !1;
  }
})), hS = /* @__PURE__ */ J.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class E5 {
  constructor(e, t, i, n) {
    this.field = e, this.line = t, this.from = i, this.to = n;
  }
}
class Pg {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, yt.TrackDel), i = e.mapPos(this.to, 1, yt.TrackDel);
    return t == null || i == null ? null : new Pg(this.field, t, i);
  }
}
class Qg {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], n = [t], r = e.doc.lineAt(t), a = /^\s*/.exec(r.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let c = a, h = /^\t*/.exec(l)[0].length;
        for (let u = 0; u < h; u++)
          c += e.facet(So);
        n.push(t + c.length - h), l = c + l.slice(h);
      }
      i.push(l), t += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new Pg(l.field, n[l.line] + l.from, n[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(e) {
    let t = [], i = [], n = [], r;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; r = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(a); ) {
        let o = r[1] ? +r[1] : null, l = r[2] || r[3] || "", c = -1, h = l.replace(/\\[{}]/g, (u) => u[1]);
        for (let u = 0; u < t.length; u++)
          (o != null ? t[u].seq == o : h && t[u].name == h) && (c = u);
        if (c < 0) {
          let u = 0;
          for (; u < t.length && (o == null || t[u].seq != null && t[u].seq < o); )
            u++;
          t.splice(u, 0, { seq: o, name: h }), c = u;
          for (let d of n)
            d.field >= c && d.field++;
        }
        n.push(new E5(c, i.length, r.index, r.index + h.length)), a = a.slice(0, r.index) + l + a.slice(r.index + r[0].length);
      }
      a = a.replace(/\\([{}])/g, (o, l, c) => {
        for (let h of n)
          h.line == i.length && h.from > c && (h.from--, h.to--);
        return l;
      }), i.push(a);
    }
    return new Qg(i, n);
  }
}
let X5 = /* @__PURE__ */ de.widget({ widget: /* @__PURE__ */ new class extends As {
  toDOM() {
    let s = document.createElement("span");
    return s.className = "cm-snippetFieldPosition", s;
  }
  ignoreEvent() {
    return !1;
  }
}() }), M5 = /* @__PURE__ */ de.mark({ class: "cm-snippetField" });
class _r {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = de.set(e.map((i) => (i.from == i.to ? X5 : M5).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      t.push(n);
    }
    return new _r(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const Ao = /* @__PURE__ */ xe.define({
  map(s, e) {
    return s && s.map(e);
  }
}), _5 = /* @__PURE__ */ xe.define(), Fa = /* @__PURE__ */ gt.define({
  create() {
    return null;
  },
  update(s, e) {
    for (let t of e.effects) {
      if (t.is(Ao))
        return t.value;
      if (t.is(_5) && s)
        return new _r(s.ranges, t.value);
    }
    return s && e.docChanged && (s = s.map(e.changes)), s && e.selection && !s.selectionInsideField(e.selection) && (s = null), s;
  },
  provide: (s) => J.decorations.from(s, (e) => e ? e.deco : de.none)
});
function Cg(s, e) {
  return D.create(s.filter((t) => t.field == e).map((t) => D.range(t.from, t.to)));
}
function L5(s) {
  let e = Qg.parse(s);
  return (t, i, n, r) => {
    let { text: a, ranges: o } = e.instantiate(t.state, n), { main: l } = t.state.selection, c = {
      changes: { from: n, to: r == l.from ? l.to : r, insert: $e.of(a) },
      scrollIntoView: !0,
      annotations: i ? [wg.of(i), lt.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (c.selection = Cg(o, 0)), o.some((h) => h.field > 0)) {
      let h = new _r(o, 0), u = c.effects = [Ao.of(h)];
      t.state.field(Fa, !1) === void 0 && u.push(xe.appendConfig.of([Fa, B5, W5, hS]));
    }
    t.dispatch(t.state.update(c));
  };
}
function uS(s) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(Fa, !1);
    if (!i || s < 0 && i.active == 0)
      return !1;
    let n = i.active + s, r = s > 0 && !i.ranges.some((a) => a.field == n + s);
    return t(e.update({
      selection: Cg(i.ranges, n),
      effects: Ao.of(r ? null : new _r(i.ranges, n)),
      scrollIntoView: !0
    })), !0;
  };
}
const z5 = ({ state: s, dispatch: e }) => s.field(Fa, !1) ? (e(s.update({ effects: Ao.of(null) })), !0) : !1, I5 = /* @__PURE__ */ uS(1), q5 = /* @__PURE__ */ uS(-1), D5 = [
  { key: "Tab", run: I5, shift: q5 },
  { key: "Escape", run: z5 }
], Wx = /* @__PURE__ */ se.define({
  combine(s) {
    return s.length ? s[0] : D5;
  }
}), B5 = /* @__PURE__ */ Qs.highest(/* @__PURE__ */ yo.compute([Wx], (s) => s.facet(Wx)));
function et(s, e) {
  return Object.assign(Object.assign({}, e), { apply: L5(s) });
}
const W5 = /* @__PURE__ */ J.domEventHandlers({
  mousedown(s, e) {
    let t = e.state.field(Fa, !1), i;
    if (!t || (i = e.posAtCoords({ x: s.clientX, y: s.clientY })) == null)
      return !1;
    let n = t.ranges.find((r) => r.from <= i && r.to >= i);
    return !n || n.field == t.active ? !1 : (e.dispatch({
      selection: Cg(t.ranges, n.field),
      effects: Ao.of(t.ranges.some((r) => r.field > n.field) ? new _r(t.ranges, n.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), ja = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, dn = /* @__PURE__ */ xe.define({
  map(s, e) {
    let t = e.mapPos(s, -1, yt.TrackAfter);
    return t ?? void 0;
  }
}), Ag = /* @__PURE__ */ new class extends Qn {
}();
Ag.startSide = 1;
Ag.endSide = -1;
const dS = /* @__PURE__ */ gt.define({
  create() {
    return Xe.empty;
  },
  update(s, e) {
    if (s = s.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      s = s.update({ filter: (i) => i >= t.from && i <= t.to });
    }
    for (let t of e.effects)
      t.is(dn) && (s = s.update({ add: [Ag.range(t.value, t.value + 1)] }));
    return s;
  }
});
function Y5() {
  return [N5, dS];
}
const wu = "()[]{}<>«»»«［］｛｝";
function fS(s) {
  for (let e = 0; e < wu.length; e += 2)
    if (wu.charCodeAt(e) == s)
      return wu.charAt(e + 1);
  return Bp(s < 128 ? s : s + 1);
}
function pS(s, e) {
  return s.languageDataAt("closeBrackets", e)[0] || ja;
}
const Z5 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), N5 = /* @__PURE__ */ J.inputHandler.of((s, e, t, i) => {
  if ((Z5 ? s.composing : s.compositionStarted) || s.state.readOnly)
    return !1;
  let n = s.state.selection.main;
  if (i.length > 2 || i.length == 2 && Vi(It(i, 0)) == 1 || e != n.from || t != n.to)
    return !1;
  let r = j5(s.state, i);
  return r ? (s.dispatch(r), !0) : !1;
}), V5 = ({ state: s, dispatch: e }) => {
  if (s.readOnly)
    return !1;
  let i = pS(s, s.selection.main.head).brackets || ja.brackets, n = null, r = s.changeByRange((a) => {
    if (a.empty) {
      let o = H5(s.doc, a.head);
      for (let l of i)
        if (l == o && ch(s.doc, a.head) == fS(It(l, 0)))
          return {
            changes: { from: a.head - l.length, to: a.head + l.length },
            range: D.cursor(a.head - l.length)
          };
    }
    return { range: n = a };
  });
  return n || e(s.update(r, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, F5 = [
  { key: "Backspace", run: V5 }
];
function j5(s, e) {
  let t = pS(s, s.selection.main.head), i = t.brackets || ja.brackets;
  for (let n of i) {
    let r = fS(It(n, 0));
    if (e == n)
      return r == n ? K5(s, n, i.indexOf(n + n + n) > -1, t) : U5(s, n, r, t.before || ja.before);
    if (e == r && gS(s, s.selection.main.from))
      return G5(s, n, r);
  }
  return null;
}
function gS(s, e) {
  let t = !1;
  return s.field(dS).between(0, s.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function ch(s, e) {
  let t = s.sliceString(e, e + 2);
  return t.slice(0, Vi(It(t, 0)));
}
function H5(s, e) {
  let t = s.sliceString(e - 2, e);
  return Vi(It(t, 0)) == t.length ? t : t.slice(1);
}
function U5(s, e, t, i) {
  let n = null, r = s.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: t, from: a.to }],
        effects: dn.of(a.to + e.length),
        range: D.range(a.anchor + e.length, a.head + e.length)
      };
    let o = ch(s.doc, a.head);
    return !o || /\s/.test(o) || i.indexOf(o) > -1 ? {
      changes: { insert: e + t, from: a.head },
      effects: dn.of(a.head + e.length),
      range: D.cursor(a.head + e.length)
    } : { range: n = a };
  });
  return n ? null : s.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function G5(s, e, t) {
  let i = null, n = s.changeByRange((r) => r.empty && ch(s.doc, r.head) == t ? {
    changes: { from: r.head, to: r.head + t.length, insert: t },
    range: D.cursor(r.head + t.length)
  } : i = { range: r });
  return i ? null : s.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function K5(s, e, t, i) {
  let n = i.stringPrefixes || ja.stringPrefixes, r = null, a = s.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: e, from: o.to }],
        effects: dn.of(o.to + e.length),
        range: D.range(o.anchor + e.length, o.head + e.length)
      };
    let l = o.head, c = ch(s.doc, l), h;
    if (c == e) {
      if (Yx(s, l))
        return {
          changes: { insert: e + e, from: l },
          effects: dn.of(l + e.length),
          range: D.cursor(l + e.length)
        };
      if (gS(s, l)) {
        let d = t && s.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: D.cursor(l + d.length)
        };
      }
    } else {
      if (t && s.sliceDoc(l - 2 * e.length, l) == e + e && (h = Zx(s, l - 2 * e.length, n)) > -1 && Yx(s, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: dn.of(l + e.length),
          range: D.cursor(l + e.length)
        };
      if (s.charCategorizer(l)(c) != Ke.Word && Zx(s, l, n) > -1 && !J5(s, l, e, n))
        return {
          changes: { insert: e + e, from: l },
          effects: dn.of(l + e.length),
          range: D.cursor(l + e.length)
        };
    }
    return { range: r = o };
  });
  return r ? null : s.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Yx(s, e) {
  let t = Ie(s).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function J5(s, e, t, i) {
  let n = Ie(s).resolveInner(e, -1), r = i.reduce((a, o) => Math.max(a, o.length), 0);
  for (let a = 0; a < 5; a++) {
    let o = s.sliceDoc(n.from, Math.min(n.to, n.from + t.length + r)), l = o.indexOf(t);
    if (!l || l > -1 && i.indexOf(o.slice(0, l)) > -1) {
      let h = n.firstChild;
      for (; h && h.from == n.from && h.to - h.from > t.length + l; ) {
        if (s.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = n.to == e && n.parent;
    if (!c)
      break;
    n = c;
  }
  return !1;
}
function Zx(s, e, t) {
  let i = s.charCategorizer(e);
  if (i(s.sliceDoc(e - 1, e)) != Ke.Word)
    return e;
  for (let n of t) {
    let r = e - n.length;
    if (s.sliceDoc(r, e) == n && i(s.sliceDoc(r - 1, r)) != Ke.Word)
      return r;
  }
  return -1;
}
function ez(s = {}) {
  return [
    R5,
    Dt,
    pt.of(s),
    T5,
    tz,
    hS
  ];
}
const mS = [
  { key: "Ctrl-Space", run: Bx },
  { mac: "Alt-`", run: Bx },
  { key: "Escape", run: P5 },
  { key: "ArrowDown", run: /* @__PURE__ */ nl(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ nl(!1) },
  { key: "PageDown", run: /* @__PURE__ */ nl(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ nl(!1, "page") },
  { key: "Enter", run: k5 }
], tz = /* @__PURE__ */ Qs.highest(/* @__PURE__ */ yo.computeN([pt], (s) => s.facet(pt).defaultKeymap ? [mS] : []));
class Nx {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class rn {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let n = i.facet(Ha).markerFilter;
    n && (e = n(e, i));
    let r = e.slice().sort((h, u) => h.from - u.from || h.to - u.to), a = new vs(), o = [], l = 0;
    for (let h = 0; ; ) {
      let u = h == r.length ? null : r[h];
      if (!u && !o.length)
        break;
      let d, f;
      for (o.length ? (d = l, f = o.reduce((g, m) => Math.min(g, m.to), u && u.from > d ? u.from : 1e8)) : (d = u.from, f = u.to, o.push(u), h++); h < r.length; ) {
        let g = r[h];
        if (g.from == d && (g.to > g.from || g.to == d))
          o.push(g), h++, f = Math.min(g.to, f);
        else {
          f = Math.min(g.from, f);
          break;
        }
      }
      let p = pz(o);
      if (o.some((g) => g.from == g.to || g.from == g.to - 1 && i.doc.lineAt(g.from).to == g.from))
        a.add(d, d, de.widget({
          widget: new hz(p),
          diagnostics: o.slice()
        }));
      else {
        let g = o.reduce((m, O) => O.markClass ? m + " " + O.markClass : m, "");
        a.add(d, f, de.mark({
          class: "cm-lintRange cm-lintRange-" + p + g,
          diagnostics: o.slice(),
          inclusiveEnd: o.some((m) => m.to > f)
        }));
      }
      l = f;
      for (let g = 0; g < o.length; g++)
        o[g].to <= l && o.splice(g--, 1);
    }
    let c = a.finish();
    return new rn(c, t, Or(c));
  }
}
function Or(s, e = null, t = 0) {
  let i = null;
  return s.between(t, 1e9, (n, r, { spec: a }) => {
    if (!(e && a.diagnostics.indexOf(e) < 0))
      if (!i)
        i = new Nx(n, r, e || a.diagnostics[0]);
      else {
        if (a.diagnostics.indexOf(i.diagnostic) < 0)
          return !1;
        i = new Nx(i.from, r, i.diagnostic);
      }
  }), i;
}
function iz(s, e) {
  let t = e.pos, i = e.end || t, n = s.state.facet(Ha).hideOn(s, t, i);
  if (n != null)
    return n;
  let r = s.startState.doc.lineAt(e.pos);
  return !!(s.effects.some((a) => a.is(OS)) || s.changes.touchesRange(r.from, Math.max(r.to, i)));
}
function sz(s, e) {
  return s.field(Kt, !1) ? e : e.concat(xe.appendConfig.of(gz));
}
const OS = /* @__PURE__ */ xe.define(), Tg = /* @__PURE__ */ xe.define(), xS = /* @__PURE__ */ xe.define(), Kt = /* @__PURE__ */ gt.define({
  create() {
    return new rn(de.none, null, null);
  },
  update(s, e) {
    if (e.docChanged && s.diagnostics.size) {
      let t = s.diagnostics.map(e.changes), i = null, n = s.panel;
      if (s.selected) {
        let r = e.changes.mapPos(s.selected.from, 1);
        i = Or(t, s.selected.diagnostic, r) || Or(t, null, r);
      }
      !t.size && n && e.state.facet(Ha).autoPanel && (n = null), s = new rn(t, n, i);
    }
    for (let t of e.effects)
      if (t.is(OS)) {
        let i = e.state.facet(Ha).autoPanel ? t.value.length ? Ua.open : null : s.panel;
        s = rn.init(t.value, i, e.state);
      } else t.is(Tg) ? s = new rn(s.diagnostics, t.value ? Ua.open : null, s.selected) : t.is(xS) && (s = new rn(s.diagnostics, s.panel, t.value));
    return s;
  },
  provide: (s) => [
    Da.from(s, (e) => e.panel),
    J.decorations.from(s, (e) => e.diagnostics)
  ]
}), nz = /* @__PURE__ */ de.mark({ class: "cm-lintRange cm-lintRange-active" });
function rz(s, e, t) {
  let { diagnostics: i } = s.state.field(Kt), n, r = -1, a = -1;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: h }) => {
    if (e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)))
      return n = h.diagnostics, r = l, a = c, !1;
  });
  let o = s.state.facet(Ha).tooltipFilter;
  return n && o && (n = o(n, s.state)), n ? {
    pos: r,
    end: a,
    above: s.state.doc.lineAt(r).to < a,
    create() {
      return { dom: az(s, n) };
    }
  } : null;
}
function az(s, e) {
  return We("ul", { class: "cm-tooltip-lint" }, e.map((t) => yS(s, t, !1)));
}
const oz = (s) => {
  let e = s.state.field(Kt, !1);
  (!e || !e.panel) && s.dispatch({ effects: sz(s.state, [Tg.of(!0)]) });
  let t = qa(s, Ua.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Vx = (s) => {
  let e = s.state.field(Kt, !1);
  return !e || !e.panel ? !1 : (s.dispatch({ effects: Tg.of(!1) }), !0);
}, lz = (s) => {
  let e = s.state.field(Kt, !1);
  if (!e)
    return !1;
  let t = s.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (s.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, cz = [
  { key: "Mod-Shift-m", run: oz, preventDefault: !0 },
  { key: "F8", run: lz }
], Ha = /* @__PURE__ */ se.define({
  combine(s) {
    return Object.assign({ sources: s.map((e) => e.source).filter((e) => e != null) }, ns(s.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function bS(s) {
  let e = [];
  if (s)
    e: for (let { name: t } of s) {
      for (let i = 0; i < t.length; i++) {
        let n = t[i];
        if (/[a-zA-Z]/.test(n) && !e.some((r) => r.toLowerCase() == n.toLowerCase())) {
          e.push(n);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function yS(s, e, t) {
  var i;
  let n = t ? bS(e.actions) : [];
  return We("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, We("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(s) : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((r, a) => {
    let o = !1, l = (d) => {
      if (d.preventDefault(), o)
        return;
      o = !0;
      let f = Or(s.state.field(Kt).diagnostics, e);
      f && r.apply(s, f.from, f.to);
    }, { name: c } = r, h = n[a] ? c.indexOf(n[a]) : -1, u = h < 0 ? c : [
      c.slice(0, h),
      We("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return We("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${n[a]})"`}.`
    }, u);
  }), e.source && We("div", { class: "cm-diagnosticSource" }, e.source));
}
class hz extends As {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return We("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class Fx {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = yS(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ua {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (n) => {
      if (n.keyCode == 27)
        Vx(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: r } = this.items[this.selectedIndex], a = bS(r.actions);
        for (let o = 0; o < a.length; o++)
          if (a[o].toUpperCase().charCodeAt(0) == n.keyCode) {
            let l = Or(this.view.state.field(Kt).diagnostics, r);
            l && r.actions[o].apply(e, l.from, l.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let r = 0; r < this.items.length; r++)
        this.items[r].dom.contains(n.target) && this.moveSelection(r);
    };
    this.list = We("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = We("div", { class: "cm-panel-lint" }, this.list, We("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Vx(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Kt).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Kt), i = 0, n = !1, r = null, a = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (o, l, { spec: c }) => {
      for (let h of c.diagnostics) {
        if (a.has(h))
          continue;
        a.add(h);
        let u = -1, d;
        for (let f = i; f < this.items.length; f++)
          if (this.items[f].diagnostic == h) {
            u = f;
            break;
          }
        u < 0 ? (d = new Fx(this.view, h), this.items.splice(i, 0, d), n = !0) : (d = this.items[u], u > i && (this.items.splice(i, u - i), n = !0)), t && d.diagnostic == t.diagnostic ? d.dom.hasAttribute("aria-selected") || (d.dom.setAttribute("aria-selected", "true"), r = d) : d.dom.hasAttribute("aria-selected") && d.dom.removeAttribute("aria-selected"), i++;
      }
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Fx(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), r ? (this.list.setAttribute("aria-activedescendant", r.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: r.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        let c = l.height / this.list.offsetHeight;
        o.top < l.top ? this.list.scrollTop -= (l.top - o.top) / c : o.bottom > l.bottom && (this.list.scrollTop += (o.bottom - l.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Kt), i = Or(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: xS.of(i)
    });
  }
  static open(e) {
    return new Ua(e);
  }
}
function uz(s, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(s)}</svg>')`;
}
function rl(s) {
  return uz(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${s}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const dz = /* @__PURE__ */ J.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ rl("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ rl("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ rl("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ rl("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function fz(s) {
  return s == "error" ? 4 : s == "warning" ? 3 : s == "info" ? 2 : 1;
}
function pz(s) {
  let e = "hint", t = 1;
  for (let i of s) {
    let n = fz(i.severity);
    n > t && (t = n, e = i.severity);
  }
  return e;
}
const gz = [
  Kt,
  /* @__PURE__ */ J.decorations.compute([Kt], (s) => {
    let { selected: e, panel: t } = s.field(Kt);
    return !e || !t || e.from == e.to ? de.none : de.set([
      nz.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ JX(rz, { hideOn: iz }),
  dz
], mz = [
  hM(),
  fM(),
  $X(),
  $_(),
  n_(),
  bX(),
  kX(),
  Ce.allowMultipleSelections.of(!0),
  VM(),
  x1(l_, { fallback: !0 }),
  g_(),
  Y5(),
  ez(),
  WX(),
  NX(),
  LX(),
  IL(),
  yo.of([
    ...F5,
    ...EL,
    ...s5,
    ...q_,
    ...e_,
    ...mS,
    ...cz
  ])
];
class Cc {
  /**
  @internal
  */
  constructor(e, t, i, n, r, a, o, l, c, h = 0, u) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = n, this.pos = r, this.score = a, this.buffer = o, this.bufferBase = l, this.curContext = c, this.lookAhead = h, this.parent = u;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, i = 0) {
    let n = e.parser.context;
    return new Cc(e, [], t, i, i, 0, [], 0, n ? new jx(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let i = e >> 19, n = e & 65535, { parser: r } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let o = r.dynamicPrecedence(n);
    if (o && (this.score += o), i == 0) {
      this.pushState(r.getGoto(this.state, n, !0), this.reducePos), n < r.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(n, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), c = l ? this.stack[l - 2] : this.p.ranges[0].from, h = this.reducePos - c;
    h >= 2e3 && !(!((t = this.p.parser.nodeSet.types[n]) === null || t === void 0) && t.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = h));
    let u = l ? this.stack[l - 1] : 0, d = this.bufferBase + this.buffer.length - u;
    if (n < r.minRepeatTerm || e & 131072) {
      let f = r.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, c, f, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let f = this.stack[l - 3];
      this.state = r.getGoto(f, n, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(n, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, i, n = 4, r = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (t == i)
          return;
        if (a.buffer[o - 2] >= t) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!r || this.pos == i)
      this.buffer.push(e, t, i, n);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0) {
        let o = !1;
        for (let l = a; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            o = !0;
            break;
          }
        if (o)
          for (; a > 0 && this.buffer[a - 2] > i; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, n > 4 && (n -= 4);
      }
      this.buffer[a] = e, this.buffer[a + 1] = t, this.buffer[a + 2] = i, this.buffer[a + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, i, n) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let r = e, { parser: a } = this.p;
      (n > this.pos || t <= a.maxNode) && (this.pos = n, a.stateFlag(
        r,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = n)), this.pushState(r, i), this.shiftContext(t, i), t <= a.maxNode && this.buffer.push(t, i, n, 4);
    } else
      this.pos = n, this.shiftContext(t, i), t <= this.p.parser.maxNode && this.buffer.push(t, i, n, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, i, n) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i, n);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(t, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), n = e.bufferBase + t;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new Cc(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new Oz(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let r = 0, a; r < t.length; r += 2)
        (a = t[r + 1]) != this.state && this.p.parser.hasAction(a, e) && n.push(t[r], a);
      if (this.stack.length < 120)
        for (let r = 0; n.length < 8 && r < t.length; r += 2) {
          let a = t[r + 1];
          n.some((o, l) => l & 1 && o == a) || n.push(t[r], a);
        }
      t = n;
    }
    let i = [];
    for (let n = 0; n < t.length && i.length < 4; n += 2) {
      let r = t[n + 1];
      if (r == this.state)
        continue;
      let a = this.split();
      a.pushState(r, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(t[n], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((t & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, n = t & 65535, r = this.stack.length - i * 3;
      if (r < 0 || e.getGoto(this.stack[r], n, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        t = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], i = (n, r) => {
      if (!t.includes(n))
        return t.push(n), e.allActions(n, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let o = (a >> 19) - r;
            if (o > 1) {
              let l = a & 65535, c = this.stack.length - o * 3;
              if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                return o << 19 | 65536 | l;
            }
          } else {
            let o = i(a, r + 1);
            if (o != null)
              return o;
          }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new jx(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class jx {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class Oz {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = n;
  }
}
class Ac {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new Ac(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Ac(this.stack, this.pos, this.index);
  }
}
function oa(s, e = Uint16Array) {
  if (typeof s != "string")
    return s;
  let t = null;
  for (let i = 0, n = 0; i < s.length; ) {
    let r = 0;
    for (; ; ) {
      let a = s.charCodeAt(i++), o = !1;
      if (a == 126) {
        r = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, o = !0), r += l, o)
        break;
      r *= 46;
    }
    t ? t[n++] = r : t = new e(r);
  }
  return t;
}
class Xl {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Hx = new Xl();
class xz {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Hx, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let i = this.range, n = this.rangeIndex, r = this.pos + e;
    for (; r < i.from; ) {
      if (!n)
        return null;
      let a = this.ranges[--n];
      r -= i.from - a.to, i = a;
    }
    for (; t < 0 ? r > i.to : r >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let a = this.ranges[++n];
      r += a.from - i.to, i = a;
    }
    return r;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, i, n;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(t);
    else {
      let r = this.resolveOffset(e, 1);
      if (r == null)
        return -1;
      if (i = r, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = Hx, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= t)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, t)));
    }
    return i;
  }
}
class or {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    vS(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
}
or.prototype.contextual = or.prototype.fallback = or.prototype.extend = !1;
class Tc {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? oa(e) : e;
  }
  token(e, t) {
    let i = e.pos, n = 0;
    for (; ; ) {
      let r = e.next < 0, a = e.resolveOffset(1, 1);
      if (vS(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (r || n++, a == null)
        break;
      e.reset(a, e.token);
    }
    n && (e.reset(i, e.token), e.acceptToken(this.elseToken, n));
  }
}
Tc.prototype.contextual = or.prototype.fallback = or.prototype.extend = !1;
class tt {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function vS(s, e, t, i, n, r) {
  let a = 0, o = 1 << i, { dialect: l } = t.p.parser;
  e: for (; (o & s[a]) != 0; ) {
    let c = s[a + 1];
    for (let f = a + 3; f < c; f += 2)
      if ((s[f + 1] & o) > 0) {
        let p = s[f];
        if (l.allows(p) && (e.token.value == -1 || e.token.value == p || bz(p, e.token.value, n, r))) {
          e.acceptToken(p);
          break;
        }
      }
    let h = e.next, u = 0, d = s[a + 2];
    if (e.next < 0 && d > u && s[c + d * 3 - 3] == 65535) {
      a = s[c + d * 3 - 1];
      continue e;
    }
    for (; u < d; ) {
      let f = u + d >> 1, p = c + f + (f << 1), g = s[p], m = s[p + 1] || 65536;
      if (h < g)
        d = f;
      else if (h >= m)
        u = f + 1;
      else {
        a = s[p + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function Ux(s, e, t) {
  for (let i = e, n; (n = s[i]) != 65535; i++)
    if (n == t)
      return i - e;
  return -1;
}
function bz(s, e, t, i) {
  let n = Ux(t, i, e);
  return n < 0 || Ux(t, i, s) < n;
}
const jt = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Su = null;
function Gx(s, e, t) {
  let i = s.cursor(Ze.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(s.length, Math.max(
            i.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : s.length;
      }
}
let yz = class {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Gx(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Gx(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], n = this.index[t];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = i.children[n], a = this.start[t] + i.positions[n];
      if (a > e)
        return this.nextStart = a, null;
      if (r instanceof ze) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let o = a + r.length;
          if (o <= this.safeTo) {
            let l = r.prop(me.lookAhead);
            if (!l || o + l < this.fragment.to)
              return r;
          }
        }
        this.index[t]++, a + r.length >= Math.max(this.safeFrom, e) && (this.trees.push(r), this.start.push(a), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = a + r.length;
    }
  }
};
class vz {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new Xl());
  }
  getActions(e) {
    let t = 0, i = null, { parser: n } = e.p, { tokenizers: r } = n, a = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), o = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < r.length; c++) {
      if ((1 << c & a) == 0)
        continue;
      let h = r[c], u = this.tokens[c];
      if (!(i && !h.fallback) && ((h.contextual || u.start != e.pos || u.mask != a || u.context != o) && (this.updateCachedToken(u, h, e), u.mask = a, u.context = o), u.lookAhead > u.end + 25 && (l = Math.max(u.lookAhead, l)), u.value != 0)) {
        let d = t;
        if (u.extended > -1 && (t = this.addActions(e, u.extended, u.end, t)), t = this.addActions(e, u.value, u.end, t), !h.extend && (i = u, t > d))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new Xl(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new Xl(), { pos: i, p: n } = e;
    return t.start = i, t.end = Math.min(i + 1, n.stream.end), t.value = i == n.stream.end ? n.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let n = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: r } = i.p;
      for (let a = 0; a < r.specialized.length; a++)
        if (r.specialized[a] == e.value) {
          let o = r.specializers[a](this.stream.read(e.start, e.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            (o & 1) == 0 ? e.value = o >> 1 : e.extended = o >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, t, i, n) {
    for (let r = 0; r < n; r += 3)
      if (this.actions[r] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = t, this.actions[n++] = i, n;
  }
  addActions(e, t, i, n) {
    let { state: r } = e, { parser: a } = e.p, { data: o } = a;
    for (let l = 0; l < 2; l++)
      for (let c = a.stateSlot(
        r,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (o[c] == 65535)
          if (o[c + 1] == 1)
            c = fs(o, c + 2);
          else {
            n == 0 && o[c + 1] == 2 && (n = this.putAction(fs(o, c + 2), t, i, n));
            break;
          }
        o[c] == t && (n = this.putAction(fs(o, c + 1), t, i, n));
      }
    return n;
  }
}
class wz {
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new xz(t, n), this.tokens = new vz(e, this.stream), this.topTerm = e.top[1];
    let { from: r } = n[0];
    this.stacks = [Cc.start(this, e.top[0], r)], this.fragments = i.length && this.stream.end - r > e.bufferLength * 4 ? new yz(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], n, r;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > t)
          i.push(o);
        else {
          if (this.advanceStack(o, i, e))
            continue;
          {
            n || (n = [], r = []), n.push(o);
            let l = this.tokens.getMainToken(o);
            r.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = n && kz(n);
      if (a)
        return jt && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw jt && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let a = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, r, i);
      if (a)
        return jt && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, l) => l.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e: for (let a = 0; a < i.length - 1; a++) {
        let o = i[a];
        for (let l = a + 1; l < i.length; l++) {
          let c = i[l];
          if (o.sameState(c) || o.buffer.length > 500 && c.buffer.length > 500)
            if ((o.score - c.score || o.buffer.length - c.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(a--, 1);
              continue e;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let n = e.pos, { parser: r } = this, a = jt ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let u = this.fragments.nodeAt(n); u; ) {
        let d = this.parser.nodeSet.types[u.type.id] == u.type ? r.getGoto(e.state, u.type.id) : -1;
        if (d > -1 && u.length && (!c || (u.prop(me.contextHash) || 0) == h))
          return e.useNode(u, d), jt && console.log(a + this.stackID(e) + ` (via reuse of ${r.getName(u.type.id)})`), !0;
        if (!(u instanceof ze) || u.children.length == 0 || u.positions[0] > 0)
          break;
        let f = u.children[0];
        if (f instanceof ze && u.positions[0] == 0)
          u = f;
        else
          break;
      }
    }
    let o = r.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return e.reduce(o), jt && console.log(a + this.stackID(e) + ` (via always-reduce ${r.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let h = l[c++], u = l[c++], d = l[c++], f = c == l.length || !i, p = f ? e : e.split(), g = this.tokens.mainToken;
      if (p.apply(h, u, g ? g.start : p.pos, d), jt && console.log(a + this.stackID(p) + ` (via ${(h & 65536) == 0 ? "shift" : `reduce of ${r.getName(
        h & 65535
        /* Action.ValueMask */
      )}`} for ${r.getName(u)} @ ${n}${p == e ? "" : ", split"})`), f)
        return !0;
      p.pos > n ? t.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return Kx(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let n = null, r = !1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], l = t[a << 1], c = t[(a << 1) + 1], h = jt ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (r || (r = !0, o.restart(), jt && console.log(h + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let u = o.split(), d = h;
      for (let f = 0; u.forceReduce() && f < 10 && (jt && console.log(d + this.stackID(u) + " (via force-reduce)"), !this.advanceFully(u, i)); f++)
        jt && (d = this.stackID(u) + " -> ");
      for (let f of o.recoverByInsert(l))
        jt && console.log(h + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, i);
      this.stream.end > o.pos ? (c == o.pos && (c++, l = 0), o.recoverByDelete(l, c), jt && console.log(h + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), Kx(o, i)) : (!n || n.score < o.score) && (n = o);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), ze.build({
      buffer: Ac.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Su || (Su = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Su.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function Kx(s, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == s.pos && i.sameState(s)) {
      e[t].score < s.score && (e[t] = s);
      return;
    }
  }
  e.push(s);
}
class Sz {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const ku = (s) => s;
class To {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || ku, this.reduce = e.reduce || ku, this.reuse = e.reuse || ku, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Xi extends og {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let o = 0; o < e.repeatNodeCount; o++)
      t.push("");
    let i = Object.keys(e.topRules).map((o) => e.topRules[o][1]), n = [];
    for (let o = 0; o < t.length; o++)
      n.push([]);
    function r(o, l, c) {
      n[o].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let o of e.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = me[l]);
        for (let c = 1; c < o.length; ) {
          let h = o[c++];
          if (h >= 0)
            r(h, l, o[c++]);
          else {
            let u = o[c + -h];
            for (let d = -h; d > 0; d--)
              r(o[c++], l, u);
            c++;
          }
        }
      }
    this.nodeSet = new wo(t.map((o, l) => ft.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: n[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Jw;
    let a = oa(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(Jx), this.states = oa(e.states, Uint32Array), this.data = oa(e.stateData), this.goto = oa(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((o) => typeof o == "number" ? new or(a, o) : o), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let n = new wz(this, e, t, i);
    for (let r of this.wrappers)
      n = r(n, e, t, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, i = !1) {
    let n = this.goto;
    if (t >= n[0])
      return -1;
    for (let r = n[t + 1]; ; ) {
      let a = n[r++], o = a & 1, l = n[r++];
      if (o && i)
        return l;
      for (let c = r + (a >> 1); r < c; r++)
        if (n[r] == e)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let r = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), a; ; r += 3) {
        if ((a = i[r]) == 65535)
          if (i[r + 1] == 1)
            a = i[r = fs(i, r + 2)];
          else {
            if (i[r + 1] == 2)
              return fs(i, r + 2);
            break;
          }
        if (a == t || a == 0)
          return fs(i, r + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (i) => i == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? t(i) : void 0;
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); n == null; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = fs(this.data, r + 2);
        else
          break;
      n = t(fs(this.data, r + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = fs(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let n = this.data[i + 1];
        t.some((r, a) => a & 1 && r == n) || t.push(this.data[i], n);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(Xi.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((r) => r.from == i);
      return n ? n.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let r = e.specializers.find((o) => o.from == i.external);
      if (!r)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: r.to });
      return t.specializers[n] = Jx(a), a;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let r of e.split(" ")) {
        let a = t.indexOf(r);
        a >= 0 && (i[a] = !0);
      }
    let n = null;
    for (let r = 0; r < t.length; r++)
      if (!i[r])
        for (let a = this.dialects[t[r]], o; (o = this.data[a++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new Sz(e, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Xi(e);
  }
}
function fs(s, e) {
  return s[e] | s[e + 1] << 16;
}
function kz(s) {
  let e = null;
  for (let t of s) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function Jx(s) {
  if (s.external) {
    let e = s.extend ? 1 : 0;
    return (t, i) => s.external(t, i) << 1 | e;
  }
  return s.get;
}
const Pz = 315, Qz = 316, eb = 1, Cz = 2, Az = 3, Tz = 4, $z = 317, Rz = 319, Ez = 320, Xz = 5, Mz = 6, _z = 0, Lf = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], wS = 125, Lz = 59, zf = 47, zz = 42, Iz = 43, qz = 45, Dz = 60, Bz = 44, Wz = 63, Yz = 46, Zz = 91, Nz = new To({
  start: !1,
  shift(s, e) {
    return e == Xz || e == Mz || e == Rz ? s : e == Ez;
  },
  strict: !1
}), Vz = new tt((s, e) => {
  let { next: t } = s;
  (t == wS || t == -1 || e.context) && s.acceptToken($z);
}, { contextual: !0, fallback: !0 }), Fz = new tt((s, e) => {
  let { next: t } = s, i;
  Lf.indexOf(t) > -1 || t == zf && ((i = s.peek(1)) == zf || i == zz) || t != wS && t != Lz && t != -1 && !e.context && s.acceptToken(Pz);
}, { contextual: !0 }), jz = new tt((s, e) => {
  s.next == Zz && !e.context && s.acceptToken(Qz);
}, { contextual: !0 }), Hz = new tt((s, e) => {
  let { next: t } = s;
  if (t == Iz || t == qz) {
    if (s.advance(), t == s.next) {
      s.advance();
      let i = !e.context && e.canShift(eb);
      s.acceptToken(i ? eb : Cz);
    }
  } else t == Wz && s.peek(1) == Yz && (s.advance(), s.advance(), (s.next < 48 || s.next > 57) && s.acceptToken(Az));
}, { contextual: !0 });
function Pu(s, e) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122 || s == 95 || s >= 192 || !e && s >= 48 && s <= 57;
}
const Uz = new tt((s, e) => {
  if (s.next != Dz || !e.dialectEnabled(_z) || (s.advance(), s.next == zf)) return;
  let t = 0;
  for (; Lf.indexOf(s.next) > -1; )
    s.advance(), t++;
  if (Pu(s.next, !0)) {
    for (s.advance(), t++; Pu(s.next, !1); )
      s.advance(), t++;
    for (; Lf.indexOf(s.next) > -1; )
      s.advance(), t++;
    if (s.next == Bz) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!Pu(s.next, !0)) return;
        break;
      }
      if (s.next != "extends".charCodeAt(i)) break;
      s.advance(), t++;
    }
  }
  s.acceptToken(Tz, -t);
}), Gz = _i({
  "get set async static": Q.modifier,
  "for while do if else switch try catch finally return throw break continue default case": Q.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": Q.operatorKeyword,
  "let var const using function class extends": Q.definitionKeyword,
  "import export from": Q.moduleKeyword,
  "with debugger new": Q.keyword,
  TemplateString: Q.special(Q.string),
  super: Q.atom,
  BooleanLiteral: Q.bool,
  this: Q.self,
  null: Q.null,
  Star: Q.modifier,
  VariableName: Q.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": Q.function(Q.variableName),
  VariableDefinition: Q.definition(Q.variableName),
  Label: Q.labelName,
  PropertyName: Q.propertyName,
  PrivatePropertyName: Q.special(Q.propertyName),
  "CallExpression/MemberExpression/PropertyName": Q.function(Q.propertyName),
  "FunctionDeclaration/VariableDefinition": Q.function(Q.definition(Q.variableName)),
  "ClassDeclaration/VariableDefinition": Q.definition(Q.className),
  "NewExpression/VariableName": Q.className,
  PropertyDefinition: Q.definition(Q.propertyName),
  PrivatePropertyDefinition: Q.definition(Q.special(Q.propertyName)),
  UpdateOp: Q.updateOperator,
  "LineComment Hashbang": Q.lineComment,
  BlockComment: Q.blockComment,
  Number: Q.number,
  String: Q.string,
  Escape: Q.escape,
  ArithOp: Q.arithmeticOperator,
  LogicOp: Q.logicOperator,
  BitOp: Q.bitwiseOperator,
  CompareOp: Q.compareOperator,
  RegExp: Q.regexp,
  Equals: Q.definitionOperator,
  Arrow: Q.function(Q.punctuation),
  ": Spread": Q.punctuation,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace,
  "InterpolationStart InterpolationEnd": Q.special(Q.brace),
  ".": Q.derefOperator,
  ", ;": Q.separator,
  "@": Q.meta,
  TypeName: Q.typeName,
  TypeDefinition: Q.definition(Q.typeName),
  "type enum interface implements namespace module declare": Q.definitionKeyword,
  "abstract global Privacy readonly override": Q.modifier,
  "is keyof unique infer asserts": Q.operatorKeyword,
  JSXAttributeValue: Q.attributeValue,
  JSXText: Q.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": Q.angleBracket,
  "JSXIdentifier JSXNameSpacedName": Q.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": Q.attributeName,
  "JSXBuiltin/JSXIdentifier": Q.standard(Q.tagName)
}), Kz = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, for: 474, of: 483, while: 486, with: 490, do: 494, if: 498, else: 500, switch: 504, case: 510, try: 516, catch: 520, finally: 524, return: 528, throw: 532, break: 536, continue: 540, debugger: 544 }, Jz = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, eI = { __proto__: null, "<": 193 }, tI = Xi.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]",
  stateData: "((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~",
  goto: "$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 379,
  context: Nz,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 236, 242, 244, 246, 248, 251, 257, 263, 265, 267, 269, 271, 273, 274, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [Gz],
  skippedNodes: [0, 5, 6, 277],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [Fz, jz, Hz, Uz, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, Vz, new Tc("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~", 141, 339), new Tc("j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~", 25, 322)],
  topRules: { Script: [0, 7], SingleExpression: [1, 275], SingleClassItem: [2, 276] },
  dialects: { jsx: 0, ts: 15098 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 326, get: (s) => Kz[s] || -1 }, { term: 342, get: (s) => Jz[s] || -1 }, { term: 95, get: (s) => eI[s] || -1 }],
  tokenPrec: 15124
}), SS = [
  /* @__PURE__ */ et("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ et("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ et("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ et("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ et("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ et(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ et("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ et(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ et(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ et('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ et('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], iI = /* @__PURE__ */ SS.concat([
  /* @__PURE__ */ et("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ et("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ et("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), tb = /* @__PURE__ */ new ag(), kS = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Ur(s) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, s), !0;
  };
}
const sI = ["FunctionDeclaration"], nI = {
  FunctionDeclaration: /* @__PURE__ */ Ur("function"),
  ClassDeclaration: /* @__PURE__ */ Ur("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Ur("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Ur("type"),
  NamespaceDeclaration: /* @__PURE__ */ Ur("namespace"),
  VariableDefinition(s, e) {
    s.matchContext(sI) || e(s, "variable");
  },
  TypeDefinition(s, e) {
    e(s, "type");
  },
  __proto__: null
};
function PS(s, e) {
  let t = tb.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function r(a, o) {
    let l = s.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return e.cursor(Ze.IncludeAnonymous).iterate((a) => {
    if (n)
      n = !1;
    else if (a.name) {
      let o = nI[a.name];
      if (o && o(a, r) || kS.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of PS(s, a.node))
        i.push(o);
      return !1;
    }
  }), tb.set(e, i), i;
}
const ib = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, QS = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function rI(s) {
  let e = Ie(s.state).resolveInner(s.pos, -1);
  if (QS.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && ib.test(s.state.sliceDoc(e.from, e.to));
  if (!t && !s.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    kS.has(n.name) && (i = i.concat(PS(s.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : s.pos,
    validFor: ib
  };
}
const Ji = /* @__PURE__ */ Ei.define({
  name: "javascript",
  parser: /* @__PURE__ */ tI.configure({
    props: [
      /* @__PURE__ */ rs.add({
        IfStatement: /* @__PURE__ */ xn({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ xn({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: ZM,
        SwitchBody: (s) => {
          let e = s.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return s.baseIndent + (t ? 0 : i ? 1 : 2) * s.unit;
        },
        Block: /* @__PURE__ */ nr({ closing: "}" }),
        ArrowFunction: (s) => s.baseIndent + s.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ xn({ except: /^\s*{/ }),
        JSXElement(s) {
          let e = /^\s*<\//.test(s.textAfter);
          return s.lineIndent(s.node.from) + (e ? 0 : s.unit);
        },
        JSXEscape(s) {
          let e = /\s*\}/.test(s.textAfter);
          return s.lineIndent(s.node.from) + (e ? 0 : s.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(s) {
          return s.column(s.node.from) + s.unit;
        }
      }),
      /* @__PURE__ */ Li.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": ko,
        BlockComment(s) {
          return { from: s.from + 2, to: s.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), CS = {
  test: (s) => /^JSX/.test(s.name),
  facet: /* @__PURE__ */ lg({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, AS = /* @__PURE__ */ Ji.configure({ dialect: "ts" }, "typescript"), TS = /* @__PURE__ */ Ji.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ cg.add((s) => s.isTop ? [CS] : void 0)]
}), $S = /* @__PURE__ */ Ji.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ cg.add((s) => s.isTop ? [CS] : void 0)]
}, "typescript");
let RS = (s) => ({ label: s, type: "keyword" });
const ES = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(RS), aI = /* @__PURE__ */ ES.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(RS));
function XS(s = {}) {
  let e = s.jsx ? s.typescript ? $S : TS : s.typescript ? AS : Ji, t = s.typescript ? iI.concat(aI) : SS.concat(ES);
  return new is(e, [
    Ji.data.of({
      autocomplete: vg(QS, lh(t))
    }),
    Ji.data.of({
      autocomplete: rI
    }),
    s.jsx ? cI : []
  ]);
}
function oI(s) {
  for (; ; ) {
    if (s.name == "JSXOpenTag" || s.name == "JSXSelfClosingTag" || s.name == "JSXFragmentTag")
      return s;
    if (s.name == "JSXEscape" || !s.parent)
      return null;
    s = s.parent;
  }
}
function sb(s, e, t = s.length) {
  for (let i = e?.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return s.sliceString(i.from, Math.min(i.to, t));
  return "";
}
const lI = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), cI = /* @__PURE__ */ J.inputHandler.of((s, e, t, i, n) => {
  if ((lI ? s.composing : s.compositionStarted) || s.state.readOnly || e != t || i != ">" && i != "/" || !Ji.isActiveAt(s.state, e, -1))
    return !1;
  let r = n(), { state: a } = r, o = a.changeByRange((l) => {
    var c;
    let { head: h } = l, u = Ie(a).resolveInner(h - 1, -1), d;
    if (u.name == "JSXStartTag" && (u = u.parent), !(a.doc.sliceString(h - 1, h) != i || u.name == "JSXAttributeValue" && u.to > h)) {
      if (i == ">" && u.name == "JSXFragmentTag")
        return { range: l, changes: { from: h, insert: "</>" } };
      if (i == "/" && u.name == "JSXStartCloseTag") {
        let f = u.parent, p = f.parent;
        if (p && f.from == h - 2 && ((d = sb(a.doc, p.firstChild, h)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let g = `${d}>`;
          return { range: D.cursor(h + g.length, -1), changes: { from: h, insert: g } };
        }
      } else if (i == ">") {
        let f = oI(u);
        if (f && f.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(h, h + 2)) && (d = sb(a.doc, f, h)))
          return { range: l, changes: { from: h, insert: `</${d}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (s.dispatch([
    r,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
class $c {
  static create(e, t, i, n, r) {
    let a = n + (n << 8) + e + (t << 4) | 0;
    return new $c(e, t, i, a, r, [], []);
  }
  constructor(e, t, i, n, r, a, o) {
    this.type = e, this.value = t, this.from = i, this.hash = n, this.end = r, this.children = a, this.positions = o, this.hashProp = [[me.contextHash, n]];
  }
  addChild(e, t) {
    e.prop(me.contextHash) != this.hash && (e = new ze(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(t);
  }
  toTree(e, t = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (t = Math.max(t, this.positions[i] + this.children[i].length + this.from)), new ze(e.types[this.type], this.children, this.positions, t - this.from).balance({
      makeTree: (n, r, a) => new ze(ft.none, n, r, a, this.hashProp)
    });
  }
}
var H;
(function(s) {
  s[s.Document = 1] = "Document", s[s.CodeBlock = 2] = "CodeBlock", s[s.FencedCode = 3] = "FencedCode", s[s.Blockquote = 4] = "Blockquote", s[s.HorizontalRule = 5] = "HorizontalRule", s[s.BulletList = 6] = "BulletList", s[s.OrderedList = 7] = "OrderedList", s[s.ListItem = 8] = "ListItem", s[s.ATXHeading1 = 9] = "ATXHeading1", s[s.ATXHeading2 = 10] = "ATXHeading2", s[s.ATXHeading3 = 11] = "ATXHeading3", s[s.ATXHeading4 = 12] = "ATXHeading4", s[s.ATXHeading5 = 13] = "ATXHeading5", s[s.ATXHeading6 = 14] = "ATXHeading6", s[s.SetextHeading1 = 15] = "SetextHeading1", s[s.SetextHeading2 = 16] = "SetextHeading2", s[s.HTMLBlock = 17] = "HTMLBlock", s[s.LinkReference = 18] = "LinkReference", s[s.Paragraph = 19] = "Paragraph", s[s.CommentBlock = 20] = "CommentBlock", s[s.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", s[s.Escape = 22] = "Escape", s[s.Entity = 23] = "Entity", s[s.HardBreak = 24] = "HardBreak", s[s.Emphasis = 25] = "Emphasis", s[s.StrongEmphasis = 26] = "StrongEmphasis", s[s.Link = 27] = "Link", s[s.Image = 28] = "Image", s[s.InlineCode = 29] = "InlineCode", s[s.HTMLTag = 30] = "HTMLTag", s[s.Comment = 31] = "Comment", s[s.ProcessingInstruction = 32] = "ProcessingInstruction", s[s.Autolink = 33] = "Autolink", s[s.HeaderMark = 34] = "HeaderMark", s[s.QuoteMark = 35] = "QuoteMark", s[s.ListMark = 36] = "ListMark", s[s.LinkMark = 37] = "LinkMark", s[s.EmphasisMark = 38] = "EmphasisMark", s[s.CodeMark = 39] = "CodeMark", s[s.CodeText = 40] = "CodeText", s[s.CodeInfo = 41] = "CodeInfo", s[s.LinkTitle = 42] = "LinkTitle", s[s.LinkLabel = 43] = "LinkLabel", s[s.URL = 44] = "URL";
})(H || (H = {}));
class hI {
  /**
  @internal
  */
  constructor(e, t) {
    this.start = e, this.content = t, this.marks = [], this.parsers = [];
  }
}
class uI {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(e) {
    return xa(this.text, e);
  }
  /**
  @internal
  */
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(e) {
    this.markers.push(e);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(e, t = 0, i = 0) {
    for (let n = t; n < e; n++)
      i += this.text.charCodeAt(n) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(e) {
    let t = 0;
    for (let i = 0; t < this.text.length && i < e; t++)
      i += this.text.charCodeAt(t) == 9 ? 4 - i % 4 : 1;
    return t;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let t = 0; t < this.basePos; t++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function nb(s, e, t) {
  if (t.pos == t.text.length || s != e.block && t.indent >= e.stack[t.depth + 1].value + t.baseIndent)
    return !0;
  if (t.indent >= t.baseIndent + 4)
    return !1;
  let i = (s.type == H.OrderedList ? Eg : Rg)(t, e, !1);
  return i > 0 && (s.type != H.BulletList || $g(t, e, !1) < 0) && t.text.charCodeAt(t.pos + i - 1) == s.value;
}
const MS = {
  [H.Blockquote](s, e, t) {
    return t.next != 62 ? !1 : (t.markers.push(Qe(H.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1)), t.moveBase(t.pos + (bi(t.text.charCodeAt(t.pos + 1)) ? 2 : 1)), s.end = e.lineStart + t.text.length, !0);
  },
  [H.ListItem](s, e, t) {
    return t.indent < t.baseIndent + s.value && t.next > -1 ? !1 : (t.moveBaseColumn(t.baseIndent + s.value), !0);
  },
  [H.OrderedList]: nb,
  [H.BulletList]: nb,
  [H.Document]() {
    return !0;
  }
};
function bi(s) {
  return s == 32 || s == 9 || s == 10 || s == 13;
}
function xa(s, e = 0) {
  for (; e < s.length && bi(s.charCodeAt(e)); )
    e++;
  return e;
}
function rb(s, e, t) {
  for (; e > t && bi(s.charCodeAt(e - 1)); )
    e--;
  return e;
}
function _S(s) {
  if (s.next != 96 && s.next != 126)
    return -1;
  let e = s.pos + 1;
  for (; e < s.text.length && s.text.charCodeAt(e) == s.next; )
    e++;
  if (e < s.pos + 3)
    return -1;
  if (s.next == 96) {
    for (let t = e; t < s.text.length; t++)
      if (s.text.charCodeAt(t) == 96)
        return -1;
  }
  return e;
}
function LS(s) {
  return s.next != 62 ? -1 : s.text.charCodeAt(s.pos + 1) == 32 ? 2 : 1;
}
function $g(s, e, t) {
  if (s.next != 42 && s.next != 45 && s.next != 95)
    return -1;
  let i = 1;
  for (let n = s.pos + 1; n < s.text.length; n++) {
    let r = s.text.charCodeAt(n);
    if (r == s.next)
      i++;
    else if (!bi(r))
      return -1;
  }
  return t && s.next == 45 && qS(s) > -1 && s.depth == e.stack.length && e.parser.leafBlockParsers.indexOf(YS.SetextHeading) > -1 || i < 3 ? -1 : 1;
}
function zS(s, e) {
  for (let t = s.stack.length - 1; t >= 0; t--)
    if (s.stack[t].type == e)
      return !0;
  return !1;
}
function Rg(s, e, t) {
  return (s.next == 45 || s.next == 43 || s.next == 42) && (s.pos == s.text.length - 1 || bi(s.text.charCodeAt(s.pos + 1))) && (!t || zS(e, H.BulletList) || s.skipSpace(s.pos + 2) < s.text.length) ? 1 : -1;
}
function Eg(s, e, t) {
  let i = s.pos, n = s.next;
  for (; n >= 48 && n <= 57; ) {
    i++;
    if (i == s.text.length)
      return -1;
    n = s.text.charCodeAt(i);
  }
  return i == s.pos || i > s.pos + 9 || n != 46 && n != 41 || i < s.text.length - 1 && !bi(s.text.charCodeAt(i + 1)) || t && !zS(e, H.OrderedList) && (s.skipSpace(i + 1) == s.text.length || i > s.pos + 1 || s.next != 49) ? -1 : i + 1 - s.pos;
}
function IS(s) {
  if (s.next != 35)
    return -1;
  let e = s.pos + 1;
  for (; e < s.text.length && s.text.charCodeAt(e) == 35; )
    e++;
  if (e < s.text.length && s.text.charCodeAt(e) != 32)
    return -1;
  let t = e - s.pos;
  return t > 6 ? -1 : t;
}
function qS(s) {
  if (s.next != 45 && s.next != 61 || s.indent >= s.baseIndent + 4)
    return -1;
  let e = s.pos + 1;
  for (; e < s.text.length && s.text.charCodeAt(e) == s.next; )
    e++;
  let t = e;
  for (; e < s.text.length && bi(s.text.charCodeAt(e)); )
    e++;
  return e == s.text.length ? t : -1;
}
const If = /^[ \t]*$/, DS = /-->/, BS = /\?>/, qf = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, DS],
  [/^\s*<\?/, BS],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, If],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, If]
];
function WS(s, e, t) {
  if (s.next != 60)
    return -1;
  let i = s.text.slice(s.pos);
  for (let n = 0, r = qf.length - (t ? 1 : 0); n < r; n++)
    if (qf[n][0].test(i))
      return n;
  return -1;
}
function ab(s, e) {
  let t = s.countIndent(e, s.pos, s.indent), i = s.countIndent(s.skipSpace(e), e, t);
  return i >= t + 5 ? t + 1 : i;
}
function Us(s, e, t) {
  let i = s.length - 1;
  i >= 0 && s[i].to == e && s[i].type == H.CodeText ? s[i].to = t : s.push(Qe(H.CodeText, e, t));
}
const al = {
  LinkReference: void 0,
  IndentedCode(s, e) {
    let t = e.baseIndent + 4;
    if (e.indent < t)
      return !1;
    let i = e.findColumn(t), n = s.lineStart + i, r = s.lineStart + e.text.length, a = [], o = [];
    for (Us(a, n, r); s.nextLine() && e.depth >= s.stack.length; )
      if (e.pos == e.text.length) {
        Us(o, s.lineStart - 1, s.lineStart);
        for (let l of e.markers)
          o.push(l);
      } else {
        if (e.indent < t)
          break;
        {
          if (o.length) {
            for (let c of o)
              c.type == H.CodeText ? Us(a, c.from, c.to) : a.push(c);
            o = [];
          }
          Us(a, s.lineStart - 1, s.lineStart);
          for (let c of e.markers)
            a.push(c);
          r = s.lineStart + e.text.length;
          let l = s.lineStart + e.findColumn(e.baseIndent + 4);
          l < r && Us(a, l, r);
        }
      }
    return o.length && (o = o.filter((l) => l.type != H.CodeText), o.length && (e.markers = o.concat(e.markers))), s.addNode(s.buffer.writeElements(a, -n).finish(H.CodeBlock, r - n), n), !0;
  },
  FencedCode(s, e) {
    let t = _S(e);
    if (t < 0)
      return !1;
    let i = s.lineStart + e.pos, n = e.next, r = t - e.pos, a = e.skipSpace(t), o = rb(e.text, e.text.length, a), l = [Qe(H.CodeMark, i, i + r)];
    a < o && l.push(Qe(H.CodeInfo, s.lineStart + a, s.lineStart + o));
    for (let c = !0; s.nextLine() && e.depth >= s.stack.length; c = !1) {
      let h = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; h < e.text.length && e.text.charCodeAt(h) == n; )
          h++;
      if (h - e.pos >= r && e.skipSpace(h) == e.text.length) {
        for (let u of e.markers)
          l.push(u);
        l.push(Qe(H.CodeMark, s.lineStart + e.pos, s.lineStart + h)), s.nextLine();
        break;
      } else {
        c || Us(l, s.lineStart - 1, s.lineStart);
        for (let f of e.markers)
          l.push(f);
        let u = s.lineStart + e.basePos, d = s.lineStart + e.text.length;
        u < d && Us(l, u, d);
      }
    }
    return s.addNode(s.buffer.writeElements(l, -i).finish(H.FencedCode, s.prevLineEnd() - i), i), !0;
  },
  Blockquote(s, e) {
    let t = LS(e);
    return t < 0 ? !1 : (s.startContext(H.Blockquote, e.pos), s.addNode(H.QuoteMark, s.lineStart + e.pos, s.lineStart + e.pos + 1), e.moveBase(e.pos + t), null);
  },
  HorizontalRule(s, e) {
    if ($g(e, s, !1) < 0)
      return !1;
    let t = s.lineStart + e.pos;
    return s.nextLine(), s.addNode(H.HorizontalRule, t), !0;
  },
  BulletList(s, e) {
    let t = Rg(e, s, !1);
    if (t < 0)
      return !1;
    s.block.type != H.BulletList && s.startContext(H.BulletList, e.basePos, e.next);
    let i = ab(e, e.pos + 1);
    return s.startContext(H.ListItem, e.basePos, i - e.baseIndent), s.addNode(H.ListMark, s.lineStart + e.pos, s.lineStart + e.pos + t), e.moveBaseColumn(i), null;
  },
  OrderedList(s, e) {
    let t = Eg(e, s, !1);
    if (t < 0)
      return !1;
    s.block.type != H.OrderedList && s.startContext(H.OrderedList, e.basePos, e.text.charCodeAt(e.pos + t - 1));
    let i = ab(e, e.pos + t);
    return s.startContext(H.ListItem, e.basePos, i - e.baseIndent), s.addNode(H.ListMark, s.lineStart + e.pos, s.lineStart + e.pos + t), e.moveBaseColumn(i), null;
  },
  ATXHeading(s, e) {
    let t = IS(e);
    if (t < 0)
      return !1;
    let i = e.pos, n = s.lineStart + i, r = rb(e.text, e.text.length, i), a = r;
    for (; a > i && e.text.charCodeAt(a - 1) == e.next; )
      a--;
    (a == r || a == i || !bi(e.text.charCodeAt(a - 1))) && (a = e.text.length);
    let o = s.buffer.write(H.HeaderMark, 0, t).writeElements(s.parser.parseInline(e.text.slice(i + t + 1, a), n + t + 1), -n);
    a < e.text.length && o.write(H.HeaderMark, a - i, r - i);
    let l = o.finish(H.ATXHeading1 - 1 + t, e.text.length - i);
    return s.nextLine(), s.addNode(l, n), !0;
  },
  HTMLBlock(s, e) {
    let t = WS(e, s, !1);
    if (t < 0)
      return !1;
    let i = s.lineStart + e.pos, n = qf[t][1], r = [], a = n != If;
    for (; !n.test(e.text) && s.nextLine(); ) {
      if (e.depth < s.stack.length) {
        a = !1;
        break;
      }
      for (let c of e.markers)
        r.push(c);
    }
    a && s.nextLine();
    let o = n == DS ? H.CommentBlock : n == BS ? H.ProcessingInstructionBlock : H.HTMLBlock, l = s.prevLineEnd();
    return s.addNode(s.buffer.writeElements(r, -i).finish(o, l - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
class dI {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, t, i) {
    if (this.stage == -1)
      return !1;
    let n = i.content + `
` + t.scrub(), r = this.advance(n);
    return r > -1 && r < n.length ? this.complete(e, i, r) : !1;
  }
  finish(e, t) {
    return (this.stage == 2 || this.stage == 3) && xa(t.content, this.pos) == t.content.length ? this.complete(e, t, t.content.length) : !1;
  }
  complete(e, t, i) {
    return e.addLeafElement(t, Qe(H.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(KS(e, this.pos, this.start, !0)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Qe(H.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(US(e, xa(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let t = xa(e, this.pos), i = 0;
        if (t > this.pos) {
          let n = GS(e, t, this.start);
          if (n) {
            let r = Qu(e, n.to - this.start);
            r > 0 && (this.nextStage(n), i = r);
          }
        }
        return i || (i = Qu(e, this.pos)), i > 0 && i < e.length ? i : -1;
      } else
        return Qu(e, this.pos);
    }
  }
}
function Qu(s, e) {
  for (; e < s.length; e++) {
    let t = s.charCodeAt(e);
    if (t == 10)
      break;
    if (!bi(t))
      return -1;
  }
  return e;
}
class fI {
  nextLine(e, t, i) {
    let n = t.depth < e.stack.length ? -1 : qS(t), r = t.next;
    if (n < 0)
      return !1;
    let a = Qe(H.HeaderMark, e.lineStart + t.pos, e.lineStart + n);
    return e.nextLine(), e.addLeafElement(i, Qe(r == 61 ? H.SetextHeading1 : H.SetextHeading2, i.start, e.prevLineEnd(), [
      ...e.parser.parseInline(i.content, i.start),
      a
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const YS = {
  LinkReference(s, e) {
    return e.content.charCodeAt(0) == 91 ? new dI(e) : null;
  },
  SetextHeading() {
    return new fI();
  }
}, pI = [
  (s, e) => IS(e) >= 0,
  (s, e) => _S(e) >= 0,
  (s, e) => LS(e) >= 0,
  (s, e) => Rg(e, s, !0) >= 0,
  (s, e) => Eg(e, s, !0) >= 0,
  (s, e) => $g(e, s, !0) >= 0,
  (s, e) => WS(e, s, !0) >= 0
], gI = { text: "", end: 0 };
class mI {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.line = new uI(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = n[n.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = n[0].from, this.block = $c.create(H.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new yI(i, t) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let n = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < e.markers.length && (!n || e.markers[i].from < n.end); ) {
          let r = e.markers[i++];
          this.addNode(r.type, r.from, r.to);
        }
        if (!n)
          break;
        this.finishContext();
      }
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let n = i(this, e);
          if (n != !1) {
            if (n == !0)
              return null;
            e.forward();
            continue e;
          }
        }
      break;
    }
    let t = new hI(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let n = i(this, t);
        n && t.parsers.push(n);
      }
    e: for (; this.nextLine() && e.pos != e.text.length; ) {
      if (e.indent < e.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, e, t))
            break e;
      }
      for (let i of t.parsers)
        if (i.nextLine(this, e, t))
          return null;
      t.content += `
` + e.scrub();
      for (let i of e.markers)
        t.marks.push(i);
    }
    return this.finishLeaf(t), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let t = this.fragments.takeNodes(this);
    return t ? (this.absoluteLineStart += t, this.lineStart = JS(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(e) {
    let t = gI;
    if (t.end = e, e >= this.to)
      t.text = "";
    else if (t.text = this.lineChunkAt(e), t.end += t.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, n = this.rangeI;
      for (; this.ranges[n].to < t.end; ) {
        n++;
        let r = this.ranges[n].from, a = this.lineChunkAt(r);
        t.end = r + a.length, t.text = t.text.slice(0, this.ranges[n - 1].to - i) + a, i = t.end - t.text.length;
      }
    }
    return t;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: e } = this, { text: t, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, e.reset(t); e.depth < this.stack.length; e.depth++) {
      let n = this.stack[e.depth], r = this.parser.skipContextMarkup[n.type];
      if (!r)
        throw new Error("Unhandled block context " + H[n.type]);
      if (!r(n, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let t = this.input.chunk(e), i;
    if (this.input.lineChunks)
      i = t == `
` ? "" : t;
    else {
      let n = t.indexOf(`
`);
      i = n < 0 ? t : t.slice(0, n);
    }
    return e + i.length > this.to ? i.slice(0, this.to - e) : i;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(e, t, i = 0) {
    this.block = $c.create(e, i, this.lineStart + t, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(e, t, i = 0) {
    this.startContext(this.parser.getNodeType(e), t, i);
  }
  /**
  @internal
  */
  addNode(e, t, i) {
    typeof e == "number" && (e = new ze(this.parser.nodeSet.types[e], xr, xr, (i ?? this.prevLineEnd()) - t)), this.block.addChild(e, t - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(e, t) {
    this.addNode(this.buffer.writeElements(Wf(t.children, e.marks), -t.from).finish(t.type, t.to - t.from), t.from);
  }
  /**
  @internal
  */
  finishContext() {
    let e = this.stack.pop(), t = this.stack[this.stack.length - 1];
    t.addChild(e.toTree(this.parser.nodeSet), e.from - t.from), this.block = t;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? ZS(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  /**
  @internal
  */
  finishLeaf(e) {
    for (let i of e.parsers)
      if (i.finish(this, e))
        return;
    let t = Wf(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(t, -e.start).finish(H.Paragraph, e.content.length), e.start);
  }
  elt(e, t, i, n) {
    return typeof e == "string" ? Qe(this.parser.getNodeType(e), t, i, n) : new FS(e, t);
  }
  /**
  @internal
  */
  get buffer() {
    return new VS(this.parser.nodeSet);
  }
}
function ZS(s, e, t, i, n) {
  let r = s[e].to, a = [], o = [], l = t.from + i;
  function c(h, u) {
    for (; u ? h >= r : h > r; ) {
      let d = s[e + 1].from - r;
      i += d, h += d, e++, r = s[e].to;
    }
  }
  for (let h = t.firstChild; h; h = h.nextSibling) {
    c(h.from + i, !0);
    let u = h.from + i, d, f = n.get(h.tree);
    f ? d = f : h.to + i > r ? (d = ZS(s, e, h, i, n), c(h.to + i, !1)) : d = h.toTree(), a.push(d), o.push(u - l);
  }
  return c(t.to + i, !1), new ze(t.type, a, o, t.to + i - l, t.tree ? t.tree.propValues : void 0);
}
class hh extends og {
  /**
  @internal
  */
  constructor(e, t, i, n, r, a, o, l, c) {
    super(), this.nodeSet = e, this.blockParsers = t, this.leafBlockParsers = i, this.blockNames = n, this.endLeafBlock = r, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = l, this.wrappers = c, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let h of e.types)
      this.nodeTypes[h.name] = h.id;
  }
  createParse(e, t, i) {
    let n = new mI(this, e, t, i);
    for (let r of this.wrappers)
      n = r(n, e, t, i);
    return n;
  }
  /**
  Reconfigure the parser.
  */
  configure(e) {
    let t = Df(e);
    if (!t)
      return this;
    let { nodeSet: i, skipContextMarkup: n } = this, r = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), l = this.inlineParsers.slice(), c = this.inlineNames.slice(), h = this.endLeafBlock.slice(), u = this.wrappers;
    if (Gr(t.defineNodes)) {
      n = Object.assign({}, n);
      let d = i.types.slice(), f;
      for (let p of t.defineNodes) {
        let { name: g, block: m, composite: O, style: x } = typeof p == "string" ? { name: p } : p;
        if (d.some((y) => y.name == g))
          continue;
        O && (n[d.length] = (y, w, S) => O(w, S, y.value));
        let b = d.length, v = O ? ["Block", "BlockContext"] : m ? b >= H.ATXHeading1 && b <= H.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        d.push(ft.define({
          id: b,
          name: g,
          props: v && [[me.group, v]]
        })), x && (f || (f = {}), Array.isArray(x) || x instanceof Zi ? f[g] = x : Object.assign(f, x));
      }
      i = new wo(d), f && (i = i.extend(_i(f)));
    }
    if (Gr(t.props) && (i = i.extend(...t.props)), Gr(t.remove))
      for (let d of t.remove) {
        let f = this.blockNames.indexOf(d), p = this.inlineNames.indexOf(d);
        f > -1 && (r[f] = a[f] = void 0), p > -1 && (l[p] = void 0);
      }
    if (Gr(t.parseBlock))
      for (let d of t.parseBlock) {
        let f = o.indexOf(d.name);
        if (f > -1)
          r[f] = d.parse, a[f] = d.leaf;
        else {
          let p = d.before ? ol(o, d.before) : d.after ? ol(o, d.after) + 1 : o.length - 1;
          r.splice(p, 0, d.parse), a.splice(p, 0, d.leaf), o.splice(p, 0, d.name);
        }
        d.endLeaf && h.push(d.endLeaf);
      }
    if (Gr(t.parseInline))
      for (let d of t.parseInline) {
        let f = c.indexOf(d.name);
        if (f > -1)
          l[f] = d.parse;
        else {
          let p = d.before ? ol(c, d.before) : d.after ? ol(c, d.after) + 1 : c.length - 1;
          l.splice(p, 0, d.parse), c.splice(p, 0, d.name);
        }
      }
    return t.wrap && (u = u.concat(t.wrap)), new hh(i, r, a, o, h, n, l, c, u);
  }
  /**
  @internal
  */
  getNodeType(e) {
    let t = this.nodeTypes[e];
    if (t == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return t;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(e, t) {
    let i = new xI(this, e, t);
    e: for (let n = t; n < i.end; ) {
      let r = i.char(n);
      for (let a of this.inlineParsers)
        if (a) {
          let o = a(i, r, n);
          if (o >= 0) {
            n = o;
            continue e;
          }
        }
      n++;
    }
    return i.resolveMarkers(0);
  }
}
function Gr(s) {
  return s != null && s.length > 0;
}
function Df(s) {
  if (!Array.isArray(s))
    return s;
  if (s.length == 0)
    return null;
  let e = Df(s[0]);
  if (s.length == 1)
    return e;
  let t = Df(s.slice(1));
  if (!t || !e)
    return e || t;
  let i = (a, o) => (a || xr).concat(o || xr), n = e.wrap, r = t.wrap;
  return {
    props: i(e.props, t.props),
    defineNodes: i(e.defineNodes, t.defineNodes),
    parseBlock: i(e.parseBlock, t.parseBlock),
    parseInline: i(e.parseInline, t.parseInline),
    remove: i(e.remove, t.remove),
    wrap: n ? r ? (a, o, l, c) => n(r(a, o, l, c), o, l, c) : n : r
  };
}
function ol(s, e) {
  let t = s.indexOf(e);
  if (t < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return t;
}
let NS = [ft.none];
for (let s = 1, e; e = H[s]; s++)
  NS[s] = ft.define({
    id: s,
    name: e,
    props: s >= H.Escape ? [] : [[me.group, s in MS ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document"
  });
const xr = [];
let VS = class {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, t, i, n = 0) {
    return this.content.push(e, t, i, 4 + n * 4), this;
  }
  writeElements(e, t = 0) {
    for (let i of e)
      i.writeTo(this, t);
    return this;
  }
  finish(e, t) {
    return ze.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: t
    });
  }
}, Ga = class {
  /**
  @internal
  */
  constructor(e, t, i, n = xr) {
    this.type = e, this.from = t, this.to = i, this.children = n;
  }
  /**
  @internal
  */
  writeTo(e, t) {
    let i = e.content.length;
    e.writeElements(this.children, t), e.content.push(this.type, this.from + t, this.to + t, e.content.length + 4 - i);
  }
  /**
  @internal
  */
  toTree(e) {
    return new VS(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class FS {
  constructor(e, t) {
    this.tree = e, this.from = t;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return xr;
  }
  writeTo(e, t) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + t, this.to + t, -1);
  }
  toTree() {
    return this.tree;
  }
}
function Qe(s, e, t, i) {
  return new Ga(s, e, t, i);
}
const jS = { resolve: "Emphasis", mark: "EmphasisMark" }, HS = { resolve: "Emphasis", mark: "EmphasisMark" }, Vn = {}, Bf = {};
class oi {
  constructor(e, t, i, n) {
    this.type = e, this.from = t, this.to = i, this.side = n;
  }
}
const ob = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Ka = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Ka = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const Cu = {
  Escape(s, e, t) {
    if (e != 92 || t == s.end - 1)
      return -1;
    let i = s.char(t + 1);
    for (let n = 0; n < ob.length; n++)
      if (ob.charCodeAt(n) == i)
        return s.append(Qe(H.Escape, t, t + 2));
    return -1;
  },
  Entity(s, e, t) {
    if (e != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(s.slice(t + 1, t + 31));
    return i ? s.append(Qe(H.Entity, t, t + 1 + i[0].length)) : -1;
  },
  InlineCode(s, e, t) {
    if (e != 96 || t && s.char(t - 1) == 96)
      return -1;
    let i = t + 1;
    for (; i < s.end && s.char(i) == 96; )
      i++;
    let n = i - t, r = 0;
    for (; i < s.end; i++)
      if (s.char(i) == 96) {
        if (r++, r == n && s.char(i + 1) != 96)
          return s.append(Qe(H.InlineCode, t, i + 1, [
            Qe(H.CodeMark, t, t + n),
            Qe(H.CodeMark, i + 1 - n, i + 1)
          ]));
      } else
        r = 0;
    return -1;
  },
  HTMLTag(s, e, t) {
    if (e != 60 || t == s.end - 1)
      return -1;
    let i = s.slice(t + 1, s.end), n = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (n)
      return s.append(Qe(H.Autolink, t, t + 1 + n[0].length, [
        Qe(H.LinkMark, t, t + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        Qe(H.URL, t + 1, t + n[0].length),
        Qe(H.LinkMark, t + n[0].length, t + 1 + n[0].length)
      ]));
    let r = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (r)
      return s.append(Qe(H.Comment, t, t + 1 + r[0].length));
    let a = /^\?[^]*?\?>/.exec(i);
    if (a)
      return s.append(Qe(H.ProcessingInstruction, t, t + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? s.append(Qe(H.HTMLTag, t, t + 1 + o[0].length)) : -1;
  },
  Emphasis(s, e, t) {
    if (e != 95 && e != 42)
      return -1;
    let i = t + 1;
    for (; s.char(i) == e; )
      i++;
    let n = s.slice(t - 1, t), r = s.slice(i, i + 1), a = Ka.test(n), o = Ka.test(r), l = /\s|^$/.test(n), c = /\s|^$/.test(r), h = !c && (!o || l || a), u = !l && (!a || c || o), d = h && (e == 42 || !u || a), f = u && (e == 42 || !h || o);
    return s.append(new oi(e == 95 ? jS : HS, t, i, (d ? 1 : 0) | (f ? 2 : 0)));
  },
  HardBreak(s, e, t) {
    if (e == 92 && s.char(t + 1) == 10)
      return s.append(Qe(H.HardBreak, t, t + 2));
    if (e == 32) {
      let i = t + 1;
      for (; s.char(i) == 32; )
        i++;
      if (s.char(i) == 10 && i >= t + 2)
        return s.append(Qe(H.HardBreak, t, i + 1));
    }
    return -1;
  },
  Link(s, e, t) {
    return e == 91 ? s.append(new oi(
      Vn,
      t,
      t + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(s, e, t) {
    return e == 33 && s.char(t + 1) == 91 ? s.append(new oi(
      Bf,
      t,
      t + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(s, e, t) {
    if (e != 93)
      return -1;
    for (let i = s.parts.length - 1; i >= 0; i--) {
      let n = s.parts[i];
      if (n instanceof oi && (n.type == Vn || n.type == Bf)) {
        if (!n.side || s.skipSpace(n.to) == t && !/[(\[]/.test(s.slice(t + 1, t + 2)))
          return s.parts[i] = null, -1;
        let r = s.takeContent(i), a = s.parts[i] = OI(s, r, n.type == Vn ? H.Link : H.Image, n.from, t + 1);
        if (n.type == Vn)
          for (let o = 0; o < i; o++) {
            let l = s.parts[o];
            l instanceof oi && l.type == Vn && (l.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function OI(s, e, t, i, n) {
  let { text: r } = s, a = s.char(n), o = n;
  if (e.unshift(Qe(H.LinkMark, i, i + (t == H.Image ? 2 : 1))), e.push(Qe(H.LinkMark, n - 1, n)), a == 40) {
    let l = s.skipSpace(n + 1), c = US(r, l - s.offset, s.offset), h;
    c && (l = s.skipSpace(c.to), l != c.to && (h = GS(r, l - s.offset, s.offset), h && (l = s.skipSpace(h.to)))), s.char(l) == 41 && (e.push(Qe(H.LinkMark, n, n + 1)), o = l + 1, c && e.push(c), h && e.push(h), e.push(Qe(H.LinkMark, l, o)));
  } else if (a == 91) {
    let l = KS(r, n - s.offset, s.offset, !1);
    l && (e.push(l), o = l.to);
  }
  return Qe(t, i, o, e);
}
function US(s, e, t) {
  if (s.charCodeAt(e) == 60) {
    for (let n = e + 1; n < s.length; n++) {
      let r = s.charCodeAt(n);
      if (r == 62)
        return Qe(H.URL, e + t, n + 1 + t);
      if (r == 60 || r == 10)
        return !1;
    }
    return null;
  } else {
    let n = 0, r = e;
    for (let a = !1; r < s.length; r++) {
      let o = s.charCodeAt(r);
      if (bi(o))
        break;
      if (a)
        a = !1;
      else if (o == 40)
        n++;
      else if (o == 41) {
        if (!n)
          break;
        n--;
      } else o == 92 && (a = !0);
    }
    return r > e ? Qe(H.URL, e + t, r + t) : r == s.length ? null : !1;
  }
}
function GS(s, e, t) {
  let i = s.charCodeAt(e);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let n = i == 40 ? 41 : i;
  for (let r = e + 1, a = !1; r < s.length; r++) {
    let o = s.charCodeAt(r);
    if (a)
      a = !1;
    else {
      if (o == n)
        return Qe(H.LinkTitle, e + t, r + 1 + t);
      o == 92 && (a = !0);
    }
  }
  return null;
}
function KS(s, e, t, i) {
  for (let n = !1, r = e + 1, a = Math.min(s.length, r + 999); r < a; r++) {
    let o = s.charCodeAt(r);
    if (n)
      n = !1;
    else {
      if (o == 93)
        return i ? !1 : Qe(H.LinkLabel, e + t, r + 1 + t);
      if (i && !bi(o) && (i = !1), o == 91)
        return !1;
      o == 92 && (n = !0);
    }
  }
  return null;
}
class xI {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.parser = e, this.text = t, this.offset = i, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(e, t) {
    return this.text.slice(e - this.offset, t - this.offset);
  }
  /**
  @internal
  */
  append(e) {
    return this.parts.push(e), e.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(e, t, i, n, r) {
    return this.append(new oi(e, t, i, (n ? 1 : 0) | (r ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let t = this.parts[e];
      if (t instanceof oi && (t.type == Vn || t.type == Bf))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(e) {
    return this.append(e);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(e) {
    for (let i = e; i < this.parts.length; i++) {
      let n = this.parts[i];
      if (!(n instanceof oi && n.type.resolve && n.side & 2))
        continue;
      let r = n.type == jS || n.type == HS, a = n.to - n.from, o, l = i - 1;
      for (; l >= e; l--) {
        let g = this.parts[l];
        if (g instanceof oi && g.side & 1 && g.type == n.type && // Ignore emphasis delimiters where the character count doesn't match
        !(r && (n.side & 1 || g.side & 2) && (g.to - g.from + a) % 3 == 0 && ((g.to - g.from) % 3 || a % 3))) {
          o = g;
          break;
        }
      }
      if (!o)
        continue;
      let c = n.type.resolve, h = [], u = o.from, d = n.to;
      if (r) {
        let g = Math.min(2, o.to - o.from, a);
        u = o.to - g, d = n.from + g, c = g == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && h.push(this.elt(o.type.mark, u, o.to));
      for (let g = l + 1; g < i; g++)
        this.parts[g] instanceof Ga && h.push(this.parts[g]), this.parts[g] = null;
      n.type.mark && h.push(this.elt(n.type.mark, n.from, d));
      let f = this.elt(c, u, d, h);
      this.parts[l] = r && o.from != u ? new oi(o.type, o.from, u, o.side) : null, (this.parts[i] = r && n.to != d ? new oi(n.type, d, n.to, n.side) : null) ? this.parts.splice(i, 0, f) : this.parts[i] = f;
    }
    let t = [];
    for (let i = e; i < this.parts.length; i++) {
      let n = this.parts[i];
      n instanceof Ga && t.push(n);
    }
    return t;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(e) {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let i = this.parts[t];
      if (i instanceof oi && i.type == e)
        return t;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(e) {
    let t = this.resolveMarkers(e);
    return this.parts.length = e, t;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(e) {
    return xa(this.text, e - this.offset) + this.offset;
  }
  elt(e, t, i, n) {
    return typeof e == "string" ? Qe(this.parser.getNodeType(e), t, i, n) : new FS(e, t);
  }
}
function Wf(s, e) {
  if (!e.length)
    return s;
  if (!s.length)
    return e;
  let t = s.slice(), i = 0;
  for (let n of e) {
    for (; i < t.length && t[i].to < n.to; )
      i++;
    if (i < t.length && t[i].from < n.from) {
      let r = t[i];
      r instanceof Ga && (t[i] = new Ga(r.type, r.from, r.to, Wf(r.children, [n])));
    } else
      t.splice(i++, 0, n);
  }
  return t;
}
const bI = [H.CodeBlock, H.ListItem, H.OrderedList, H.BulletList];
class yI {
  constructor(e, t) {
    this.fragments = e, this.input = t, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, t) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let r = this.fragment.to;
      for (; r > 0 && this.input.read(r - 1, r) != `
`; )
        r--;
      this.fragmentEnd = r ? r - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let n = e + this.fragment.offset;
    for (; i.to <= n; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= n)
        return this.fragment.from <= t;
      if (!i.childAfter(n))
        return !1;
    }
  }
  matches(e) {
    let t = this.cursor.tree;
    return t && t.prop(me.contextHash) == e;
  }
  takeNodes(e) {
    let t = this.cursor, i = this.fragment.offset, n = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), r = e.absoluteLineStart, a = r, o = e.block.children.length, l = a, c = o;
    for (; ; ) {
      if (t.to - i > n) {
        if (t.type.isAnonymous && t.firstChild())
          continue;
        break;
      }
      let h = JS(t.from - i, e.ranges);
      if (t.to - i <= e.ranges[e.rangeI].to)
        e.addNode(t.tree, h);
      else {
        let u = new ze(e.parser.nodeSet.types[H.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(u, t.tree), e.addNode(u, h);
      }
      if (t.type.is("Block") && (bI.indexOf(t.type.id) < 0 ? (a = t.to - i, o = e.block.children.length) : (a = l, o = c, l = t.to - i, c = e.block.children.length)), !t.nextSibling())
        break;
    }
    for (; e.block.children.length > o; )
      e.block.children.pop(), e.block.positions.pop();
    return a - r;
  }
}
function JS(s, e) {
  let t = s;
  for (let i = 1; i < e.length; i++) {
    let n = e[i - 1].to, r = e[i].from;
    n < s && (t -= r - n);
  }
  return t;
}
const vI = _i({
  "Blockquote/...": Q.quote,
  HorizontalRule: Q.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": Q.heading1,
  "ATXHeading2/... SetextHeading2/...": Q.heading2,
  "ATXHeading3/...": Q.heading3,
  "ATXHeading4/...": Q.heading4,
  "ATXHeading5/...": Q.heading5,
  "ATXHeading6/...": Q.heading6,
  "Comment CommentBlock": Q.comment,
  Escape: Q.escape,
  Entity: Q.character,
  "Emphasis/...": Q.emphasis,
  "StrongEmphasis/...": Q.strong,
  "Link/... Image/...": Q.link,
  "OrderedList/... BulletList/...": Q.list,
  "BlockQuote/...": Q.quote,
  "InlineCode CodeText": Q.monospace,
  "URL Autolink": Q.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": Q.processingInstruction,
  "CodeInfo LinkLabel": Q.labelName,
  LinkTitle: Q.string,
  Paragraph: Q.content
}), wI = new hh(new wo(NS).extend(vI), Object.keys(al).map((s) => al[s]), Object.keys(al).map((s) => YS[s]), Object.keys(al), pI, MS, Object.keys(Cu).map((s) => Cu[s]), Object.keys(Cu), []);
function SI(s, e, t) {
  let i = [];
  for (let n = s.firstChild, r = e; ; n = n.nextSibling) {
    let a = n ? n.from : t;
    if (a > r && i.push({ from: r, to: a }), !n)
      break;
    r = n.to;
  }
  return i;
}
function kI(s) {
  let { codeParser: e, htmlParser: t } = s;
  return { wrap: s1((n, r) => {
    let a = n.type.id;
    if (e && (a == H.CodeBlock || a == H.FencedCode)) {
      let o = "";
      if (a == H.FencedCode) {
        let c = n.node.getChild(H.CodeInfo);
        c && (o = r.read(c.from, c.to));
      }
      let l = e(o);
      if (l)
        return { parser: l, overlay: (c) => c.type.id == H.CodeText };
    } else if (t && (a == H.HTMLBlock || a == H.HTMLTag || a == H.CommentBlock))
      return { parser: t, overlay: SI(n.node, n.from, n.to) };
    return null;
  }) };
}
const PI = { resolve: "Strikethrough", mark: "StrikethroughMark" }, QI = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": Q.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: Q.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(s, e, t) {
      if (e != 126 || s.char(t + 1) != 126 || s.char(t + 2) == 126)
        return -1;
      let i = s.slice(t - 1, t), n = s.slice(t + 2, t + 3), r = /\s|^$/.test(i), a = /\s|^$/.test(n), o = Ka.test(i), l = Ka.test(n);
      return s.addDelimiter(PI, t, t + 2, !a && (!l || r || o), !r && (!o || a || l));
    },
    after: "Emphasis"
  }]
};
function ba(s, e, t = 0, i, n = 0) {
  let r = 0, a = !0, o = -1, l = -1, c = !1, h = () => {
    i.push(s.elt("TableCell", n + o, n + l, s.parser.parseInline(e.slice(o, l), n + o)));
  };
  for (let u = t; u < e.length; u++) {
    let d = e.charCodeAt(u);
    d == 124 && !c ? ((!a || o > -1) && r++, a = !1, i && (o > -1 && h(), i.push(s.elt("TableDelimiter", u + n, u + n + 1))), o = l = -1) : (c || d != 32 && d != 9) && (o < 0 && (o = u), l = u + 1), c = !c && d == 92;
  }
  return o > -1 && (r++, i && h()), r;
}
function lb(s, e) {
  for (let t = e; t < s.length; t++) {
    let i = s.charCodeAt(t);
    if (i == 124)
      return !0;
    i == 92 && t++;
  }
  return !1;
}
const ek = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class cb {
  constructor() {
    this.rows = null;
  }
  nextLine(e, t, i) {
    if (this.rows == null) {
      this.rows = !1;
      let n;
      if ((t.next == 45 || t.next == 58 || t.next == 124) && ek.test(n = t.text.slice(t.pos))) {
        let r = [];
        ba(e, i.content, 0, r, i.start) == ba(e, n, t.pos) && (this.rows = [
          e.elt("TableHeader", i.start, i.start + i.content.length, r),
          e.elt("TableDelimiter", e.lineStart + t.pos, e.lineStart + t.text.length)
        ]);
      }
    } else if (this.rows) {
      let n = [];
      ba(e, t.text, t.pos, n, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + t.pos, e.lineStart + t.text.length, n));
    }
    return !1;
  }
  finish(e, t) {
    return this.rows ? (e.addLeafElement(t, e.elt("Table", t.start, t.start + t.content.length, this.rows)), !0) : !1;
  }
}
const CI = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": Q.heading } },
    "TableRow",
    { name: "TableCell", style: Q.content },
    { name: "TableDelimiter", style: Q.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(s, e) {
      return lb(e.content, 0) ? new cb() : null;
    },
    endLeaf(s, e, t) {
      if (t.parsers.some((n) => n instanceof cb) || !lb(e.text, e.basePos))
        return !1;
      let i = s.peekLine();
      return ek.test(i) && ba(s, e.text, e.basePos) == ba(s, i, e.basePos);
    },
    before: "SetextHeading"
  }]
};
class AI {
  nextLine() {
    return !1;
  }
  finish(e, t) {
    return e.addLeafElement(t, e.elt("Task", t.start, t.start + t.content.length, [
      e.elt("TaskMarker", t.start, t.start + 3),
      ...e.parser.parseInline(t.content.slice(3), t.start + 3)
    ])), !0;
  }
}
const TI = {
  defineNodes: [
    { name: "Task", block: !0, style: Q.list },
    { name: "TaskMarker", style: Q.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(s, e) {
      return /^\[[ xX]\][ \t]/.test(e.content) && s.parentType().name == "ListItem" ? new AI() : null;
    },
    after: "SetextHeading"
  }]
}, hb = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, ub = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, $I = /[\w-]+\.[\w-]+($|\/)/, db = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, fb = /\/[a-zA-Z\d@.]+/gy;
function pb(s, e, t, i) {
  let n = 0;
  for (let r = e; r < t; r++)
    s[r] == i && n++;
  return n;
}
function RI(s, e) {
  ub.lastIndex = e;
  let t = ub.exec(s);
  if (!t || $I.exec(t[0])[0].indexOf("_") > -1)
    return -1;
  let i = e + t[0].length;
  for (; ; ) {
    let n = s[i - 1], r;
    if (/[?!.,:*_~]/.test(n) || n == ")" && pb(s, e, i, ")") > pb(s, e, i, "("))
      i--;
    else if (n == ";" && (r = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(s.slice(e, i))))
      i = e + r.index;
    else
      break;
  }
  return i;
}
function gb(s, e) {
  db.lastIndex = e;
  let t = db.exec(s);
  if (!t)
    return -1;
  let i = t[0][t[0].length - 1];
  return i == "_" || i == "-" ? -1 : e + t[0].length - (i == "." ? 1 : 0);
}
const EI = {
  parseInline: [{
    name: "Autolink",
    parse(s, e, t) {
      let i = t - s.offset;
      if (i && /\w/.test(s.text[i - 1]))
        return -1;
      hb.lastIndex = i;
      let n = hb.exec(s.text), r = -1;
      if (!n)
        return -1;
      if (n[1] || n[2]) {
        if (r = RI(s.text, i + n[0].length), r > -1 && s.hasOpenLink) {
          let a = /([^\[\]]|\[[^\]]*\])*/.exec(s.text.slice(i, r));
          r = i + a[0].length;
        }
      } else n[3] ? r = gb(s.text, i) : (r = gb(s.text, i + n[0].length), r > -1 && n[0] == "xmpp:" && (fb.lastIndex = r, n = fb.exec(s.text), n && (r = n.index + n[0].length)));
      return r < 0 ? -1 : (s.addElement(s.elt("URL", t, r + s.offset)), r + s.offset);
    }
  }]
}, XI = [CI, TI, QI, EI];
function tk(s, e, t) {
  return (i, n, r) => {
    if (n != s || i.char(r + 1) == s)
      return -1;
    let a = [i.elt(t, r, r + 1)];
    for (let o = r + 1; o < i.end; o++) {
      let l = i.char(o);
      if (l == s)
        return i.addElement(i.elt(e, r, o + 1, a.concat(i.elt(t, o, o + 1))));
      if (l == 92 && a.push(i.elt("Escape", o, o++ + 2)), bi(l))
        break;
    }
    return -1;
  };
}
const MI = {
  defineNodes: [
    { name: "Superscript", style: Q.special(Q.content) },
    { name: "SuperscriptMark", style: Q.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: tk(94, "Superscript", "SuperscriptMark")
  }]
}, _I = {
  defineNodes: [
    { name: "Subscript", style: Q.special(Q.content) },
    { name: "SubscriptMark", style: Q.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: tk(126, "Subscript", "SubscriptMark")
  }]
}, LI = {
  defineNodes: [{ name: "Emoji", style: Q.character }],
  parseInline: [{
    name: "Emoji",
    parse(s, e, t) {
      let i;
      return e != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(s.slice(t + 1, s.end))) ? -1 : s.addElement(s.elt("Emoji", t, t + 1 + i[0].length));
    }
  }]
}, zI = 54, II = 1, qI = 55, DI = 2, BI = 56, WI = 3, mb = 4, YI = 5, Rc = 6, ik = 7, sk = 8, nk = 9, rk = 10, ZI = 11, NI = 12, VI = 13, Au = 57, FI = 14, Ob = 58, ak = 20, jI = 22, ok = 23, HI = 24, Yf = 26, lk = 27, UI = 28, GI = 31, KI = 34, JI = 36, eq = 37, tq = 0, iq = 1, sq = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, nq = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, xb = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function rq(s) {
  return s == 45 || s == 46 || s == 58 || s >= 65 && s <= 90 || s == 95 || s >= 97 && s <= 122 || s >= 161;
}
function ck(s) {
  return s == 9 || s == 10 || s == 13 || s == 32;
}
let bb = null, yb = null, vb = 0;
function Zf(s, e) {
  let t = s.pos + e;
  if (vb == t && yb == s) return bb;
  let i = s.peek(e);
  for (; ck(i); ) i = s.peek(++e);
  let n = "";
  for (; rq(i); )
    n += String.fromCharCode(i), i = s.peek(++e);
  return yb = s, vb = t, bb = n ? n.toLowerCase() : i == aq || i == oq ? void 0 : null;
}
const hk = 60, Ec = 62, Xg = 47, aq = 63, oq = 33, lq = 45;
function wb(s, e) {
  this.name = s, this.parent = e;
}
const cq = [Rc, rk, ik, sk, nk], hq = new To({
  start: null,
  shift(s, e, t, i) {
    return cq.indexOf(e) > -1 ? new wb(Zf(i, 1) || "", s) : s;
  },
  reduce(s, e) {
    return e == ak && s ? s.parent : s;
  },
  reuse(s, e, t, i) {
    let n = e.type.id;
    return n == Rc || n == JI ? new wb(Zf(i, 1) || "", s) : s;
  },
  strict: !1
}), uq = new tt((s, e) => {
  if (s.next != hk) {
    s.next < 0 && e.context && s.acceptToken(Au);
    return;
  }
  s.advance();
  let t = s.next == Xg;
  t && s.advance();
  let i = Zf(s, 0);
  if (i === void 0) return;
  if (!i) return s.acceptToken(t ? FI : Rc);
  let n = e.context ? e.context.name : null;
  if (t) {
    if (i == n) return s.acceptToken(ZI);
    if (n && nq[n]) return s.acceptToken(Au, -2);
    if (e.dialectEnabled(tq)) return s.acceptToken(NI);
    for (let r = e.context; r; r = r.parent) if (r.name == i) return;
    s.acceptToken(VI);
  } else {
    if (i == "script") return s.acceptToken(ik);
    if (i == "style") return s.acceptToken(sk);
    if (i == "textarea") return s.acceptToken(nk);
    if (sq.hasOwnProperty(i)) return s.acceptToken(rk);
    n && xb[n] && xb[n][i] ? s.acceptToken(Au, -1) : s.acceptToken(Rc);
  }
}, { contextual: !0 }), dq = new tt((s) => {
  for (let e = 0, t = 0; ; t++) {
    if (s.next < 0) {
      t && s.acceptToken(Ob);
      break;
    }
    if (s.next == lq)
      e++;
    else if (s.next == Ec && e >= 2) {
      t >= 3 && s.acceptToken(Ob, -2);
      break;
    } else
      e = 0;
    s.advance();
  }
});
function fq(s) {
  for (; s; s = s.parent)
    if (s.name == "svg" || s.name == "math") return !0;
  return !1;
}
const pq = new tt((s, e) => {
  if (s.next == Xg && s.peek(1) == Ec) {
    let t = e.dialectEnabled(iq) || fq(e.context);
    s.acceptToken(t ? YI : mb, 2);
  } else s.next == Ec && s.acceptToken(mb, 1);
});
function Mg(s, e, t) {
  let i = 2 + s.length;
  return new tt((n) => {
    for (let r = 0, a = 0, o = 0; ; o++) {
      if (n.next < 0) {
        o && n.acceptToken(e);
        break;
      }
      if (r == 0 && n.next == hk || r == 1 && n.next == Xg || r >= 2 && r < i && n.next == s.charCodeAt(r - 2))
        r++, a++;
      else if ((r == 2 || r == i) && ck(n.next))
        a++;
      else if (r == i && n.next == Ec) {
        o > a ? n.acceptToken(e, -a) : n.acceptToken(t, -(a - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && o) {
        n.acceptToken(e, 1);
        break;
      } else
        r = a = 0;
      n.advance();
    }
  });
}
const gq = Mg("script", zI, II), mq = Mg("style", qI, DI), Oq = Mg("textarea", BI, WI), xq = _i({
  "Text RawText": Q.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": Q.angleBracket,
  TagName: Q.tagName,
  "MismatchedCloseTag/TagName": [Q.tagName, Q.invalid],
  AttributeName: Q.attributeName,
  "AttributeValue UnquotedAttributeValue": Q.attributeValue,
  Is: Q.definitionOperator,
  "EntityReference CharacterReference": Q.character,
  Comment: Q.blockComment,
  ProcessingInst: Q.processingInstruction,
  DoctypeDecl: Q.documentMeta
}), bq = Xi.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: hq,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [xq],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [gq, mq, Oq, pq, uq, dq, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function uk(s, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of s.getChildren(ok)) {
    let n = i.getChild(HI), r = i.getChild(Yf) || i.getChild(lk);
    n && (t[e.read(n.from, n.to)] = r ? r.type.id == Yf ? e.read(r.from + 1, r.to - 1) : e.read(r.from, r.to) : "");
  }
  return t;
}
function Sb(s, e) {
  let t = s.getChild(jI);
  return t ? e.read(t.from, t.to) : " ";
}
function Tu(s, e, t) {
  let i;
  for (let n of t)
    if (!n.attrs || n.attrs(i || (i = uk(s.node.parent.firstChild, e))))
      return { parser: n.parser };
  return null;
}
function dk(s = [], e = []) {
  let t = [], i = [], n = [], r = [];
  for (let o of s)
    (o.tag == "script" ? t : o.tag == "style" ? i : o.tag == "textarea" ? n : r).push(o);
  let a = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of e) (a[o.name] || (a[o.name] = [])).push(o);
  return s1((o, l) => {
    let c = o.type.id;
    if (c == UI) return Tu(o, l, t);
    if (c == GI) return Tu(o, l, i);
    if (c == KI) return Tu(o, l, n);
    if (c == ak && r.length) {
      let h = o.node, u = h.firstChild, d = u && Sb(u, l), f;
      if (d) {
        for (let p of r)
          if (p.tag == d && (!p.attrs || p.attrs(f || (f = uk(u, l))))) {
            let g = h.lastChild, m = g.type.id == eq ? g.from : h.to;
            if (m > u.to)
              return { parser: p.parser, overlay: [{ from: u.to, to: m }] };
          }
      }
    }
    if (a && c == ok) {
      let h = o.node, u;
      if (u = h.firstChild) {
        let d = a[l.read(u.from, u.to)];
        if (d) for (let f of d) {
          if (f.tagName && f.tagName != Sb(h.parent, l)) continue;
          let p = h.lastChild;
          if (p.type.id == Yf) {
            let g = p.from + 1, m = p.lastChild, O = p.to - (m && m.isError ? 0 : 1);
            if (O > g) return { parser: f.parser, overlay: [{ from: g, to: O }] };
          } else if (p.type.id == lk)
            return { parser: f.parser, overlay: [{ from: p.from, to: p.to }] };
        }
      }
    }
    return null;
  });
}
const yq = 107, kb = 1, vq = 108, wq = 109, Pb = 2, Qb = 110, fk = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Sq = 58, kq = 40, pk = 95, Pq = 91, Ml = 45, Qq = 46, Cq = 35, Aq = 37, Tq = 38, $q = 92, Rq = 10, Eq = 42;
function Ja(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122 || s >= 161;
}
function gk(s) {
  return s >= 48 && s <= 57;
}
const Xq = new tt((s, e) => {
  for (let t = !1, i = 0, n = 0; ; n++) {
    let { next: r } = s;
    if (Ja(r) || r == Ml || r == pk || t && gk(r))
      !t && (r != Ml || n > 0) && (t = !0), i === n && r == Ml && i++, s.advance();
    else if (r == $q && s.peek(1) != Rq)
      s.advance(), s.next > -1 && s.advance(), t = !0;
    else {
      t && s.acceptToken(
        i == 2 && e.canShift(Pb) ? Pb : e.canShift(Qb) ? Qb : r == kq ? vq : wq
      );
      break;
    }
  }
}), Mq = new tt((s) => {
  if (fk.includes(s.peek(-1))) {
    let { next: e } = s;
    (Ja(e) || e == pk || e == Cq || e == Qq || e == Eq || e == Pq || e == Sq && Ja(s.peek(1)) || e == Ml || e == Tq) && s.acceptToken(yq);
  }
}), _q = new tt((s) => {
  if (!fk.includes(s.peek(-1))) {
    let { next: e } = s;
    if (e == Aq && (s.advance(), s.acceptToken(kb)), Ja(e)) {
      do
        s.advance();
      while (Ja(s.next) || gk(s.next));
      s.acceptToken(kb);
    }
  }
}), Lq = _i({
  "AtKeyword import charset namespace keyframes media supports": Q.definitionKeyword,
  "from to selector": Q.keyword,
  NamespaceName: Q.namespace,
  KeyframeName: Q.labelName,
  KeyframeRangeName: Q.operatorKeyword,
  TagName: Q.tagName,
  ClassName: Q.className,
  PseudoClassName: Q.constant(Q.className),
  IdName: Q.labelName,
  "FeatureName PropertyName": Q.propertyName,
  AttributeName: Q.attributeName,
  NumberLiteral: Q.number,
  KeywordQuery: Q.keyword,
  UnaryQueryOp: Q.operatorKeyword,
  "CallTag ValueName": Q.atom,
  VariableName: Q.variableName,
  Callee: Q.operatorKeyword,
  Unit: Q.unit,
  "UniversalSelector NestingSelector": Q.definitionOperator,
  "MatchOp CompareOp": Q.compareOperator,
  "ChildOp SiblingOp, LogicOp": Q.logicOperator,
  BinOp: Q.arithmeticOperator,
  Important: Q.modifier,
  Comment: Q.blockComment,
  ColorLiteral: Q.color,
  "ParenthesizedContent StringLiteral": Q.string,
  ":": Q.punctuation,
  "PseudoOp #": Q.derefOperator,
  "; ,": Q.separator,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
}), zq = { __proto__: null, lang: 34, "nth-child": 34, "nth-last-child": 34, "nth-of-type": 34, "nth-last-of-type": 34, dir: 34, "host-context": 34, url: 62, "url-prefix": 62, domain: 62, regexp: 62 }, Iq = { __proto__: null, "@import": 120, "@media": 154, "@charset": 158, "@namespace": 162, "@keyframes": 168, "@supports": 180 }, qq = { __proto__: null, layer: 124, not: 144, only: 144, selector: 150 }, Dq = Xi.deserialize({
  version: 14,
  states: ">`QYQ[OOO#kQ[OOP#rOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#wQ[O'#CfO$hQXO'#CaO$rQ[O'#CiO$}Q[O'#DUO%SQ[O'#DXO%XQ[O'#D[O%XQ[O'#D_OOQP'#Ev'#EvO%yQdO'#DhO&hQ[O'#DzO%yQdO'#D|O&yQ[O'#EOO'UQ[O'#ERO'^Q[O'#EXO'lQ[O'#EZOOQS'#Eu'#EuOOQS'#E^'#E^QYQ[OOO'sQXO'#CdO(hQWO'#DdO(mQWO'#E{O(xQ[O'#E{QOQWOOP)SO#tO'#C_POOO)C@e)C@eOOQP'#Ch'#ChOOQP,59Q,59QO#wQ[O,59QO)_Q[O,59TO$}Q[O,59pO%SQ[O,59sO%XQ[O,59vO%XQ[O,59xO%XQ[O,59yO%XQ[O'#EcO)jQWO,58{O)rQ[O'#DcOOQS,58{,58{OOQP'#Cl'#ClOOQO'#DS'#DSOOQP,59T,59TO)yQWO,59TO*OQWO,59TOOQP'#DW'#DWOOQP,59p,59pOOQO'#DY'#DYO*TQ`O,59sO*nQXO,59vO+UQXO,59yOOQS'#Cq'#CqO%yQdO'#CrO+lQvO'#CtO-hQtO,5:SOOQO'#Cy'#CyO*OQWO'#CxO-rQWO'#CzO-wQ[O'#DPOOQS'#Ex'#ExOOQO'#Dn'#DnO.eQdO'#DwO.uQWO'#E|O'^Q[O'#DuO/TQWO'#DxOOQO'#E}'#E}O)mQWO,5:fO/YQpO,5:hOOQS'#EQ'#EQO/bQWO,5:jO/gQ[O,5:jOOQO'#ET'#ETO/oQWO,5:mO/tQWO,5:sO/|QWO,5:uOOQS-E8[-E8[O0UQdO,5:OO0fQ[O'#EeO0sQWO,5;gO0sQWO,5;gPOOO'#E]'#E]P1OO#tO,58yPOOO,58y,58yOOQP1G.l1G.lOOQP1G.o1G.oO)yQWO1G.oO*OQWO1G.oOOQP1G/[1G/[O1ZQ`O1G/_O1cQXO1G/bO1yQXO1G/dO2aQXO1G/eO2wQXO,5:}OOQO-E8a-E8aOOQS1G.g1G.gO3RQWO,59}O3WQ[O'#DTO3_QdO'#CpOOQP1G/_1G/_O%yQdO1G/_O3fQpO,59^OOQS,59`,59`O%yQdO,59bO3nQ[O'#DkO4PQWO1G/nO-VQ[O1G/nOOQS,59d,59dO4UQ!bO,59fOOQS'#DQ'#DQOOQS'#E`'#E`O4aQ[O,59kOOQS,59k,59kO4iQpO'#DnO4wQpO,5:ZO5PQWO,5:cOOQO'#FO'#FOO4zQpO,5:_O'^Q[O,5:]O5XQ[O'#EgO5pQWO,5;hO5{QWO,5:aO%XQ[O,5:dOOQS1G0Q1G0QOOQS1G0S1G0SOOQS1G0U1G0UO6^QWO1G0UO6cQdO'#EUOOQS1G0X1G0XOOQS1G0_1G0_OOQS1G0a1G0aO6nQtO1G/jOOQO1G/j1G/jOOQO,5;P,5;PO7UQ[O,5;POOQO-E8c-E8cO7cQWO1G1RPOOO-E8Z-E8ZPOOO1G.e1G.eOOQP7+$Z7+$ZOOQP7+$y7+$yO%yQdO7+$yOOQS1G/i1G/iO7nQXO'#EzO7xQWO,59oO7}QtO'#E_O8uQdO'#EwO9PQWO,59[O9UQpO7+$yOOQS1G.x1G.xOOQS1G.|1G.|O9^Q[O,5:VOOQS7+%Y7+%YO9cQWO7+%YOOQS1G/Q1G/QO9hQWO1G/QOOQS-E8^-E8^OOQS1G/V1G/VO%yQdO1G/uO9mQdO1G/yOOQO1G/}1G/}OOQO1G/w1G/wO9tQWO,5;ROOQO-E8e-E8eO:SQXO1G0OOOQS7+%p7+%pO:ZQYO'#CtOOQO'#EW'#EWO:iQ`O'#EVOOQO'#EV'#EVO:tQWO'#EhO:|QdO,5:pOOQS,5:p,5:pO;XQtO'#EdO%yQdO'#EdO<YQdO7+%UOOQO7+%U7+%UOOQO1G0k1G0kO<mQpO<<HeO<uQ[O'#EbO=PQWO,5;fOOQP1G/Z1G/ZOOQS-E8]-E8]O=XQdO'#EaO=cQWO,5;cOOQT1G.v1G.vOOQP<<He<<HeOOQO'#Dm'#DmO=kQWO1G/qOOQS<<Ht<<HtOOQS7+$l7+$lO=sQdO7+%aOOQO'#Dp'#DpO=zQpO7+%eOOQO7+%j7+%jOOQO,5:q,5:qO6fQdO'#EiO:tQWO,5;SOOQS,5;S,5;SOOQS-E8f-E8fOOQS1G0[1G0[O>SQtO,5;OOOQS-E8b-E8bOOQO<<Hp<<HpOOQPAN>PAN>PO?TQXO,5:|OOQO-E8`-E8`O?_QdO,5:{OOQO-E8_-E8_O9^Q[O'#EfO?iQWO7+%]OOQS7+%]7+%]OOQO<<H{<<H{OOQO<<IP<<IPO?qQdO<<IPOOQO,5;T,5;TOOQO-E8g-E8gOOQS1G0n1G0nOOQO,5;Q,5;QOOQO-E8d-E8dOOQS<<Hw<<HwO@YQWOAN>kOOQOG24VG24V",
  stateData: "@g~O#dOS#eQQ~OU[OX[OZTO^VO_VOrXOyWO!PYO!SZO!]cO!^]O!o^O!q_O!s`O!vaO!|bO#aRO~OQhOU[OX[OZTO^VO_VOrXOyWO!PYO!SZO!]cO!^]O!o^O!q_O!s`O!vaO!|bO#agO~O#^#oP~P!aO#elO~O#anO~OZpO^qO_qOrsOyrO!PtO!SvO#_uO~OuwO!UyO~P#|Oa!PO#`|O#a{O~O#a!QO~O#a!SO~OU[OX[OZTO^VO_VOrXOyWO!PYO!SZO#aRO~OQ!`Oc!XOg!`Oi!`Oo!^Or!_O#`![O#a!WO#m!YO~Oc!bO!j!dO!m!eO#b!aO!U#pP~Oi!jOo!^O#a!iO~Oi!lO#a!lO~Oc!bO!j!dO!m!eO#b!aO~O!Z#pP~P&hOZWX^WX^!XX_WXrWXuWXyWX!PWX!SWX!UWX#_WX~O^!qO~O!Z!rO#^#oX!T#oX~O#^#oX!T#oX~P!aO#f!uO#g!uO#h!wO~Oa!{O#`|O#a{O~OuwO!UyO~O!T#oP~P!aOc#VO~Oc#WO~Oq#XO}#YO~OZpO^qO_qOrsOyrO~Ou!Oa!P!Oa!S!Oa!U!Oa#_!Oab!Oa~P*]Ou!Ra!P!Ra!S!Ra!U!Ra#_!Rab!Ra~P*]OP#[OchXkhX!ZhX!`hX!jhX!mhX#bhXbhX!hhXQhXghXihXohXrhXuhX!YhX#^hX#`hX#ahX#mhXqhX!ThX~Oc!bO!j!dO!m!eO#b!aO!Z#pP~Ok#]O!`#^O~P-VOc#bO~Oq#fO#a#cO~OQ#jOg#jOi#jOo!^O#`![O#m!YO~Oc!bO!j!dO!m!eO#b#gO~P.POu#mO!f#lO!U#pX!Z#pX~Oc#pO~Ok#]O!Z#rO~O!Z#sO~Oi#tOo!^O~O!U#uO~O!UyO!f#lO~O!UyO!Z#xO~O!Y#zO!Z!Wa#^!Wa!T!Wa~P%yO!Z#XX#^#XX!T#XX~P!aO!Z!rO#^#oa!T#oa~O#f!uO#g!uO#h$QO~Oq$SO}$TO~Ou!Oi!P!Oi!S!Oi!U!Oi#_!Oib!Oi~P*]Ou!Qi!P!Qi!S!Qi!U!Qi#_!Qib!Qi~P*]Ou!Ri!P!Ri!S!Ri!U!Ri#_!Rib!Ri~P*]Ou#Va!U#Va~P#|O!T$UO~Ob#nP~P%XOb#kP~P%yOb$]Ok#]O~Oc$_O!Z!_X!j!_X!m!_X#b!_X~O!Z$`O~Ob$bOi$cOp$cO~Oq$eO#a#cO~O^!dXb!bX!f!bX!h!dX~O^$fO!h$gO~Ob$hO!f#lO~Oc!bO!j!dO!m!eO#b!aOu#ZX!U#ZX!Z#ZX~Ou#mO!U#pa!Z#pa~O!f#lOu!ia!U!ia!Z!iab!ia~O!Z$mO~O!T$tO#a$oO#m$nO~Ok#]Ou$vO!Y$xO!Z!Wi#^!Wi!T!Wi~P%yO!Z#Xa#^#Xa!T#Xa~P!aO!Z!rO#^#oi!T#oi~Ou${Ob#nX~P#|Ob$}O~Ok#]OQ#RXb#RXc#RXg#RXi#RXo#RXr#RXu#RX#`#RX#a#RX#m#RX~Ou%POb#kX~P%yOb%RO~Ok#]Oq%SO~O#a%TO~O!Z%VO~Ob%WO~O#b%YO~P.PO!f#lOu#Za!U#Za!Z#Za~Ob%[O~P#|OP#[OuhX!UhXbhX~O#m$nOu!yX!U!yX~Ou%^O!UyO~O!T%bO#a$oO#m$nO~Ok#]OQ#WXc#WXg#WXi#WXo#WXr#WXu#WX!Y#WX!Z#WX#^#WX#`#WX#a#WX#m#WX!T#WX~Ou$vO!Y%eO!Z!Wq#^!Wq!T!Wq~P%yOk#]Oq%fO~Ob#UXu#UX~P%XOu${Ob#na~Ob#TXu#TX~P%yOu%POb#ka~OZ%kOb%mO~Ob%nO~P%yOb%oO!h%pO~Ok#]OQ#Wac#Wag#Wai#Wao#War#Wau#Wa!Y#Wa!Z#Wa#^#Wa#`#Wa#a#Wa#m#Wa!T#Wa~Ob#Uau#Ua~P#|Ob#Tau#Ta~P%yOZ%kOb%vO~OQ#jOg#jOi#jOo!^O#`![O#b%YO#m$nO~Ob%xO~O#dp#e#mk!S#m~",
  goto: "/l#sPPP#tP#wP$Q$dP$QP$v$QPP$|PPP%S%]%]P%oP%]P&`&w'^PPPP%]'{P(P(V$QP(]$Q(cP$QP$Q$QPPP(i)O)]PP#wPP)dP)g)m)m)x)mP)mP)mP)m)mP#wP#wP#wP*R#wP*U*X*[*c#wP#wP*h*n*}+]+c+i+o+u+{,V,],c,iPPPPPPPPPPP,o,x-n-qP.g.j.p.|/cRmQ_dOPfjy!r#|q[OPYZfjtuvwy!r#V#p#|${qSOPYZfjtuvwy!r#V#p#|${QoTR!xpQ}VR!yqQ!y!PQ#a!]R$R!{q!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%ip!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iU#j!b$g%pU$q#u$s%^R%]$pp!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iV#j!b$g%pw!]]_!X!b!q#W#Y#]#y$T$Y$f$g$v$w%P%X%i%pp!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iQ!j`U#j!b$g%pR#t!kT#d!_#eQ!OVR!zqQ!y!OR$R!zQ!RWR!|rQ!TXR!}sQzUQ#TxQ#q!gQ#w!nQ#x!oQ%`$rR%s%_SiPyQ!tjQ#{!rR$y#|ZhPjy!r#|R#`!ZQ%U$_R%t%kc!f^bc!Z!b!d#`#l#mQ#h!bQ%Z$gR%w%pR!k`R!maR#v!mS$r#u$sR%q%^V$p#u$s%^Q!vlR$P!vQfOSjPyU!pfj#|R#|!rQ$Y#WU%O$Y%X%iQ%X$fR%i%PQ#e!_R$d#eQ%Q$YR%j%QQ$|$VR%h$|QxUR#SxQ$w#yR%d$wQ!siS#}!s$OR$O!tQ%l%UR%u%lQ#n!cR$k#nQ$s#uR%a$sQ%_$rR%r%__eOPfjy!r#|^UOPfjy!r#|Q!UYQ!VZQ#OtQ#PuQ#QvQ#RwQ$V#VQ$l#pR%g${R$Z#WQ!Z]Q!h_Q#Z!XQ#y!q[$X#W$Y$f%P%X%iQ$[#YQ$^#]S$u#y$wQ$z$TR%c$vR$W#VQkPR#UyQ!g^Q!ocQ#_!ZR$a#`W!c^c!Z#`Q!nbQ#i!bQ#o!dQ$i#lR$j#mQ#k!bQ%Z$gR%w%p",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import Layer layer LayerName KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 126,
  nodeProps: [
    ["isolate", -2, 3, 25, ""],
    ["openedBy", 18, "(", 33, "[", 51, "{"],
    ["closedBy", 19, ")", 34, "]", 52, "}"]
  ],
  propSources: [Lq],
  skippedNodes: [0, 3, 93],
  repeatNodeCount: 13,
  tokenData: "LU~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_Cj!_!`Df!`!aDy!a!b$}!b!cEz!c!}$}!}#OHX#O#P$}#P#QHj#Q#R6d#R#T$}#T#UH{#U#c$}#c#dJ^#d#o$}#o#pJs#p#q6d#q#rKU#r#sKg#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`LO<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSp`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#d~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#d~p`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUp`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Up`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUp`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Up`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUp`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Up`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUp`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Up`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!Y[p`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOi~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYyQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYp`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYp`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYg[p`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYg[p`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYp`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYg[p`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYp`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSg[p`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS}Sp`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSc^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOb~n9{UUQkWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWkW!SQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUp`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYp`#m[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYp`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUp`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUp`#m[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[p`#m[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSu^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWkWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VUZQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTkWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSp`#e~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#m[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^jBbU^YOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S_Qp`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Z^Oy%^z;'S%^;'S;=`%o<%lO%^hCoU!hWOy%^z!_%^!_!`DR!`;'S%^;'S;=`%o<%lO%^hDYS!hWp`Oy%^z;'S%^;'S;=`%o<%lO%^lDmS!hW}SOy%^z;'S%^;'S;=`%o<%lO%^jEQV!PQ!hWOy%^z!_%^!_!`DR!`!aEg!a;'S%^;'S;=`%o<%lO%^bEnS!PQp`Oy%^z;'S%^;'S;=`%o<%lO%^bE}YOy%^z}%^}!OFm!O!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^bFrWp`Oy%^z!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^bGc[!]Qp`Oy%^z}%^}!OG[!O!Q%^!Q![G[![!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^nH^Sr^Oy%^z;'S%^;'S;=`%o<%lO%^nHoSq^Oy%^z;'S%^;'S;=`%o<%lO%^jIOUOy%^z#b%^#b#cIb#c;'S%^;'S;=`%o<%lO%^jIgUp`Oy%^z#W%^#W#XIy#X;'S%^;'S;=`%o<%lO%^jJQS!fYp`Oy%^z;'S%^;'S;=`%o<%lO%^jJaUOy%^z#f%^#f#gIy#g;'S%^;'S;=`%o<%lO%^fJxS!UUOy%^z;'S%^;'S;=`%o<%lO%^nKZS!T^Oy%^z;'S%^;'S;=`%o<%lO%^fKlU!SQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`LRP;=`<%l$}",
  tokenizers: [Mq, _q, Xq, 1, 2, 3, 4, new Tc("m~RRYZ[z{a~~g~aO#g~~dP!P!Qg~lO#h~~", 28, 114)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 92] },
  specialized: [{ term: 108, get: (s) => zq[s] || -1 }, { term: 59, get: (s) => Iq[s] || -1 }, { term: 110, get: (s) => qq[s] || -1 }],
  tokenPrec: 1441
});
let $u = null;
function Ru() {
  if (!$u && typeof document == "object" && document.body) {
    let { style: s } = document.body, e = [], t = /* @__PURE__ */ new Set();
    for (let i in s)
      i != "cssText" && i != "cssFloat" && typeof s[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase())), t.has(i) || (e.push(i), t.add(i)));
    $u = e.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return $u || [];
}
const Cb = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((s) => ({ type: "class", label: s })), Ab = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((s) => ({ type: "keyword", label: s })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((s) => ({ type: "constant", label: s }))), Bq = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((s) => ({ type: "type", label: s })), Wq = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((s) => ({ type: "keyword", label: s })), ls = /^(\w[\w-]*|-\w[\w-]*|)$/, Yq = /^-(-[\w-]*)?$/;
function Zq(s, e) {
  var t;
  if ((s.name == "(" || s.type.isError) && (s = s.parent || s), s.name != "ArgList")
    return !1;
  let i = (t = s.parent) === null || t === void 0 ? void 0 : t.firstChild;
  return i?.name != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
}
const Tb = /* @__PURE__ */ new ag(), Nq = ["Declaration"];
function Vq(s) {
  for (let e = s; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return s;
  }
}
function mk(s, e, t) {
  if (e.to - e.from > 4096) {
    let i = Tb.get(e);
    if (i)
      return i;
    let n = [], r = /* @__PURE__ */ new Set(), a = e.cursor(Ze.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of mk(s, a.node, t))
          r.has(o.label) || (r.add(o.label), n.push(o));
      while (a.nextSibling());
    return Tb.set(e, n), n;
  } else {
    let i = [], n = /* @__PURE__ */ new Set();
    return e.cursor().iterate((r) => {
      var a;
      if (t(r) && r.matchContext(Nq) && ((a = r.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = s.sliceString(r.from, r.to);
        n.has(o) || (n.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
const Fq = (s) => (e) => {
  let { state: t, pos: i } = e, n = Ie(t).resolveInner(i, -1), r = n.type.isError && n.from == n.to - 1 && t.doc.sliceString(n.from, n.to) == "-";
  if (n.name == "PropertyName" || (r || n.name == "TagName") && /^(Block|Styles)$/.test(n.resolve(n.to).name))
    return { from: n.from, options: Ru(), validFor: ls };
  if (n.name == "ValueName")
    return { from: n.from, options: Ab, validFor: ls };
  if (n.name == "PseudoClassName")
    return { from: n.from, options: Cb, validFor: ls };
  if (s(n) || (e.explicit || r) && Zq(n, t.doc))
    return {
      from: s(n) || r ? n.from : i,
      options: mk(t.doc, Vq(n), s),
      validFor: Yq
    };
  if (n.name == "TagName") {
    for (let { parent: l } = n; l; l = l.parent)
      if (l.name == "Block")
        return { from: n.from, options: Ru(), validFor: ls };
    return { from: n.from, options: Bq, validFor: ls };
  }
  if (n.name == "AtKeyword")
    return { from: n.from, options: Wq, validFor: ls };
  if (!e.explicit)
    return null;
  let a = n.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: Cb, validFor: ls } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: Ab, validFor: ls } : a.name == "Block" || a.name == "Styles" ? { from: i, options: Ru(), validFor: ls } : null;
}, jq = /* @__PURE__ */ Fq((s) => s.name == "VariableName"), Xc = /* @__PURE__ */ Ei.define({
  name: "css",
  parser: /* @__PURE__ */ Dq.configure({
    props: [
      /* @__PURE__ */ rs.add({
        Declaration: /* @__PURE__ */ xn()
      }),
      /* @__PURE__ */ Li.add({
        "Block KeyframeList": ko
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Ok() {
  return new is(Xc, Xc.data.of({ autocomplete: jq }));
}
const Kr = ["_blank", "_self", "_top", "_parent"], Eu = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Xu = ["get", "post", "put", "delete"], Mu = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ht = ["true", "false"], le = {}, Hq = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Kr,
      hreflang: null
    }
  },
  abbr: le,
  address: le,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: le,
  aside: le,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: le,
  base: { attrs: { href: null, target: Kr } },
  bdi: le,
  bdo: le,
  blockquote: { attrs: { cite: null } },
  body: le,
  br: le,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Mu,
      formmethod: Xu,
      formnovalidate: ["novalidate"],
      formtarget: Kr,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: le,
  center: le,
  cite: le,
  code: le,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: le,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: le,
  div: le,
  dl: le,
  dt: le,
  em: le,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: le,
  figure: le,
  footer: le,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Eu,
      autocomplete: ["on", "off"],
      enctype: Mu,
      method: Xu,
      novalidate: ["novalidate"],
      target: Kr
    }
  },
  h1: le,
  h2: le,
  h3: le,
  h4: le,
  h5: le,
  h6: le,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: le,
  hgroup: le,
  hr: le,
  html: {
    attrs: { manifest: null }
  },
  i: le,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Mu,
      formmethod: Xu,
      formnovalidate: ["novalidate"],
      formtarget: Kr,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: le,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: le,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: le,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Eu,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: le,
  noscript: le,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: le,
  param: { attrs: { name: null, value: null } },
  pre: le,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: le,
  rt: le,
  ruby: le,
  samp: le,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Eu
    }
  },
  section: le,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: le,
  source: { attrs: { src: null, type: null, media: null } },
  span: le,
  strong: le,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: le,
  summary: le,
  sup: le,
  table: le,
  tbody: le,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: le,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: le,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: le,
  time: { attrs: { datetime: null } },
  title: le,
  tr: le,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: le,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: le
}, xk = {
  accesskey: null,
  class: null,
  contenteditable: Ht,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ht,
  autocorrect: Ht,
  autocapitalize: Ht,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ht,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ht,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ht,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ht,
  "aria-hidden": Ht,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ht,
  "aria-multiselectable": Ht,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ht,
  "aria-relevant": null,
  "aria-required": Ht,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, bk = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((s) => "on" + s);
for (let s of bk)
  xk[s] = null;
class eo {
  constructor(e, t) {
    this.tags = Object.assign(Object.assign({}, Hq), e), this.globalAttrs = Object.assign(Object.assign({}, xk), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
eo.default = /* @__PURE__ */ new eo();
function br(s, e, t = s.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? s.sliceString(n.from, Math.min(n.to, t)) : "";
}
function yr(s, e = !1) {
  for (; s; s = s.parent)
    if (s.name == "Element")
      if (e)
        e = !1;
      else
        return s;
  return null;
}
function yk(s, e, t) {
  let i = t.tags[br(s, yr(e))];
  return i?.children || t.allTags;
}
function _g(s, e) {
  let t = [];
  for (let i = yr(e); i && !i.type.isTop; i = yr(i.parent)) {
    let n = br(s, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && t.indexOf(n) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(n);
  }
  return t;
}
const vk = /^[:\-\.\w\u00b7-\uffff]*$/;
function $b(s, e, t, i, n) {
  let r = /\s*>/.test(s.sliceDoc(n, n + 5)) ? "" : ">", a = yr(t, !0);
  return {
    from: i,
    to: n,
    options: yk(s.doc, a, e).map((o) => ({ label: o, type: "type" })).concat(_g(s.doc, t).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + r,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Rb(s, e, t, i) {
  let n = /\s*>/.test(s.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: _g(s.doc, e).map((r, a) => ({ label: r, apply: r + n, type: "type", boost: 99 - a })),
    validFor: vk
  };
}
function Uq(s, e, t, i) {
  let n = [], r = 0;
  for (let a of yk(s.doc, t, e))
    n.push({ label: "<" + a, type: "type" });
  for (let a of _g(s.doc, t))
    n.push({ label: "</" + a + ">", type: "type", boost: 99 - r++ });
  return { from: i, to: i, options: n, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function Gq(s, e, t, i, n) {
  let r = yr(t), a = r ? e.tags[br(s.doc, r)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], l = a && a.globalAttrs === !1 ? o : o.length ? o.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: n,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: vk
  };
}
function Kq(s, e, t, i, n) {
  var r;
  let a = (r = t.parent) === null || r === void 0 ? void 0 : r.getChild("AttributeName"), o = [], l;
  if (a) {
    let c = s.sliceDoc(a.from, a.to), h = e.globalAttrs[c];
    if (!h) {
      let u = yr(t), d = u ? e.tags[br(s.doc, u)] : null;
      h = d?.attrs && d.attrs[c];
    }
    if (h) {
      let u = s.sliceDoc(i, n).toLowerCase(), d = '"', f = '"';
      /^['"]/.test(u) ? (l = u[0] == '"' ? /^[^"]*$/ : /^[^']*$/, d = "", f = s.sliceDoc(n, n + 1) == u[0] ? "" : u[0], u = u.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let p of h)
        o.push({ label: p, apply: d + p + f, type: "constant" });
    }
  }
  return { from: i, to: n, options: o, validFor: l };
}
function wk(s, e) {
  let { state: t, pos: i } = e, n = Ie(t).resolveInner(i, -1), r = n.resolve(i);
  for (let a = i, o; r == n && (o = n.childBefore(a)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    r = n = o, a = l.from;
  }
  return n.name == "TagName" ? n.parent && /CloseTag$/.test(n.parent.name) ? Rb(t, n, n.from, i) : $b(t, s, n, n.from, i) : n.name == "StartTag" ? $b(t, s, n, i, i) : n.name == "StartCloseTag" || n.name == "IncompleteCloseTag" ? Rb(t, n, i, i) : n.name == "OpenTag" || n.name == "SelfClosingTag" || n.name == "AttributeName" ? Gq(t, s, n, n.name == "AttributeName" ? n.from : i, i) : n.name == "Is" || n.name == "AttributeValue" || n.name == "UnquotedAttributeValue" ? Kq(t, s, n, n.name == "Is" ? i : n.from, i) : e.explicit && (r.name == "Element" || r.name == "Text" || r.name == "Document") ? Uq(t, s, n, i) : null;
}
function Jq(s) {
  return wk(eo.default, s);
}
function eD(s) {
  let { extraTags: e, extraGlobalAttributes: t } = s, i = t || e ? new eo(e, t) : eo.default;
  return (n) => wk(i, n);
}
const tD = /* @__PURE__ */ Ji.parser.configure({ top: "SingleExpression" }), Sk = [
  {
    tag: "script",
    attrs: (s) => s.type == "text/typescript" || s.lang == "ts",
    parser: AS.parser
  },
  {
    tag: "script",
    attrs: (s) => s.type == "text/babel" || s.type == "text/jsx",
    parser: TS.parser
  },
  {
    tag: "script",
    attrs: (s) => s.type == "text/typescript-jsx",
    parser: $S.parser
  },
  {
    tag: "script",
    attrs(s) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(s.type);
    },
    parser: tD
  },
  {
    tag: "script",
    attrs(s) {
      return !s.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(s.type);
    },
    parser: Ji.parser
  },
  {
    tag: "style",
    attrs(s) {
      return (!s.lang || s.lang == "css") && (!s.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(s.type));
    },
    parser: Xc.parser
  }
], kk = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ Xc.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ bk.map((s) => ({ name: s, parser: Ji.parser }))), Pk = /* @__PURE__ */ Ei.define({
  name: "html",
  parser: /* @__PURE__ */ bq.configure({
    props: [
      /* @__PURE__ */ rs.add({
        Element(s) {
          let e = /^(\s*)(<\/)?/.exec(s.textAfter);
          return s.node.to <= s.pos + e[0].length ? s.continue() : s.lineIndent(s.node.from) + (e[2] ? 0 : s.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(s) {
          return s.column(s.node.from) + s.unit;
        },
        Document(s) {
          if (s.pos + /\s*/.exec(s.textAfter)[0].length < s.node.to)
            return s.continue();
          let e = null, t;
          for (let i = s.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            e = i = n;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? s.lineIndent(e.from) + s.unit : null;
        }
      }),
      /* @__PURE__ */ Li.add({
        Element(s) {
          let e = s.firstChild, t = s.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : s.to };
        }
      }),
      /* @__PURE__ */ dg.add({
        "OpenTag CloseTag": (s) => s.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), _l = /* @__PURE__ */ Pk.configure({
  wrap: /* @__PURE__ */ dk(Sk, kk)
});
function Qk(s = {}) {
  let e = "", t;
  s.matchClosingTags === !1 && (e = "noMatch"), s.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (s.nestedLanguages && s.nestedLanguages.length || s.nestedAttributes && s.nestedAttributes.length) && (t = dk((s.nestedLanguages || []).concat(Sk), (s.nestedAttributes || []).concat(kk)));
  let i = t ? Pk.configure({ wrap: t, dialect: e }) : e ? _l.configure({ dialect: e }) : _l;
  return new is(i, [
    _l.data.of({ autocomplete: eD(s) }),
    s.autoCloseTags !== !1 ? iD : [],
    XS().support,
    Ok().support
  ]);
}
const Eb = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), iD = /* @__PURE__ */ J.inputHandler.of((s, e, t, i, n) => {
  if (s.composing || s.state.readOnly || e != t || i != ">" && i != "/" || !_l.isActiveAt(s.state, e, -1))
    return !1;
  let r = n(), { state: a } = r, o = a.changeByRange((l) => {
    var c, h, u;
    let d = a.doc.sliceString(l.from - 1, l.to) == i, { head: f } = l, p = Ie(a).resolveInner(f, -1), g;
    if (d && i == ">" && p.name == "EndTag") {
      let m = p.parent;
      if (((h = (c = m.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (g = br(a.doc, m.parent, f)) && !Eb.has(g)) {
        let O = f + (a.doc.sliceString(f, f + 1) === ">" ? 1 : 0), x = `</${g}>`;
        return { range: l, changes: { from: f, to: O, insert: x } };
      }
    } else if (d && i == "/" && p.name == "IncompleteCloseTag") {
      let m = p.parent;
      if (p.from == f - 2 && ((u = m.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (g = br(a.doc, m, f)) && !Eb.has(g)) {
        let O = f + (a.doc.sliceString(f, f + 1) === ">" ? 1 : 0), x = `${g}>`;
        return {
          range: D.cursor(f + x.length, -1),
          changes: { from: f, to: O, insert: x }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (s.dispatch([
    r,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), Ck = /* @__PURE__ */ lg({ commentTokens: { block: { open: "<!--", close: "-->" } } }), Ak = /* @__PURE__ */ new me(), Tk = /* @__PURE__ */ wI.configure({
  props: [
    /* @__PURE__ */ Li.add((s) => !s.is("Block") || s.is("Document") || Nf(s) != null || sD(s) ? void 0 : (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })),
    /* @__PURE__ */ Ak.add(Nf),
    /* @__PURE__ */ rs.add({
      Document: () => null
    }),
    /* @__PURE__ */ un.add({
      Document: Ck
    })
  ]
});
function Nf(s) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(s.name);
  return e ? +e[1] : void 0;
}
function sD(s) {
  return s.name == "OrderedList" || s.name == "BulletList";
}
function nD(s, e) {
  let t = s;
  for (; ; ) {
    let i = t.nextSibling, n;
    if (!i || (n = Nf(i.type)) != null && n <= e)
      break;
    t = i;
  }
  return t.to;
}
const rD = /* @__PURE__ */ c1.of((s, e, t) => {
  for (let i = Ie(s).resolveInner(t, -1); i && !(i.from < e); i = i.parent) {
    let n = i.type.prop(Ak);
    if (n == null)
      continue;
    let r = nD(i, n);
    if (r > t)
      return { from: t, to: r };
  }
  return null;
});
function Lg(s) {
  return new ui(Ck, s, [rD], "markdown");
}
const aD = /* @__PURE__ */ Lg(Tk), oD = /* @__PURE__ */ Tk.configure([XI, _I, MI, LI, {
  props: [
    /* @__PURE__ */ Li.add({
      Table: (s, e) => ({ from: e.doc.lineAt(s.from).to, to: s.to })
    })
  ]
}]), $k = /* @__PURE__ */ Lg(oD);
function lD(s, e) {
  return (t) => {
    if (t && s) {
      let i = null;
      if (t = /\S*/.exec(t)[0], typeof s == "function" ? i = s(t) : i = gc.matchLanguageName(s, t, !0), i instanceof gc)
        return i.support ? i.support.language.parser : Ya.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return e ? e.parser : null;
  };
}
let _u = class {
  constructor(e, t, i, n, r, a, o) {
    this.node = e, this.from = t, this.to = i, this.spaceBefore = n, this.spaceAfter = r, this.type = a, this.item = o;
  }
  blank(e, t = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; i.length < e; )
        i += " ";
      return i;
    } else {
      for (let n = this.to - this.from - i.length - this.spaceAfter.length; n > 0; n--)
        i += " ";
      return i + (t ? this.spaceAfter : "");
    }
  }
  marker(e, t) {
    let i = this.node.name == "OrderedList" ? String(+Ek(this.item, e)[2] + t) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
};
function Rk(s, e) {
  let t = [], i = [];
  for (let n = s; n; n = n.parent) {
    if (n.name == "FencedCode")
      return i;
    (n.name == "ListItem" || n.name == "Blockquote") && t.push(n);
  }
  for (let n = t.length - 1; n >= 0; n--) {
    let r = t[n], a, o = e.lineAt(r.from), l = r.from - o.from;
    if (r.name == "Blockquote" && (a = /^ *>( ?)/.exec(o.text.slice(l))))
      i.push(new _u(r, l, l + a[0].length, "", a[1], ">", null));
    else if (r.name == "ListItem" && r.parent.name == "OrderedList" && (a = /^( *)\d+([.)])( *)/.exec(o.text.slice(l)))) {
      let c = a[3], h = a[0].length;
      c.length >= 4 && (c = c.slice(0, c.length - 4), h -= 4), i.push(new _u(r.parent, l, l + h, a[1], c, a[2], r));
    } else if (r.name == "ListItem" && r.parent.name == "BulletList" && (a = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(o.text.slice(l)))) {
      let c = a[4], h = a[0].length;
      c.length > 4 && (c = c.slice(0, c.length - 4), h -= 4);
      let u = a[2];
      a[3] && (u += a[3].replace(/[xX]/, " ")), i.push(new _u(r.parent, l, l + h, a[1], c, u, r));
    }
  }
  return i;
}
function Ek(s, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(s.from, s.from + 10));
}
function Lu(s, e, t, i = 0) {
  for (let n = -1, r = s; ; ) {
    if (r.name == "ListItem") {
      let o = Ek(r, e), l = +o[2];
      if (n >= 0) {
        if (l != n + 1)
          return;
        t.push({ from: r.from + o[1].length, to: r.from + o[0].length, insert: String(n + 2 + i) });
      }
      n = l;
    }
    let a = r.nextSibling;
    if (!a)
      break;
    r = a;
  }
}
function zg(s, e) {
  let t = /^[ \t]*/.exec(s)[0].length;
  if (!t || e.facet(So) != "	")
    return s;
  let i = Ti(s, 4, t), n = "";
  for (let r = i; r > 0; )
    r >= 4 ? (n += "	", r -= 4) : (n += " ", r--);
  return n + s.slice(t);
}
const cD = ({ state: s, dispatch: e }) => {
  let t = Ie(s), { doc: i } = s, n = null, r = s.changeByRange((a) => {
    if (!a.empty || !$k.isActiveAt(s, a.from, 0))
      return n = { range: a };
    let o = a.from, l = i.lineAt(o), c = Rk(t.resolveInner(o, -1), i);
    for (; c.length && c[c.length - 1].from > o - l.from; )
      c.pop();
    if (!c.length)
      return n = { range: a };
    let h = c[c.length - 1];
    if (h.to - h.spaceAfter.length > o - l.from)
      return n = { range: a };
    let u = o >= h.to - h.spaceAfter.length && !/\S/.test(l.text.slice(h.to));
    if (h.item && u) {
      let m = h.node.firstChild, O = h.node.getChild("ListItem", "ListItem");
      if (m.to >= o || O && O.to < o || l.from > 0 && !/[^\s>]/.test(i.lineAt(l.from - 1).text)) {
        let x = c.length > 1 ? c[c.length - 2] : null, b, v = "";
        x && x.item ? (b = l.from + x.from, v = x.marker(i, 1)) : b = l.from + (x ? x.to : 0);
        let y = [{ from: b, to: o, insert: v }];
        return h.node.name == "OrderedList" && Lu(h.item, i, y, -2), x && x.node.name == "OrderedList" && Lu(x.item, i, y), { range: D.cursor(b + v.length), changes: y };
      } else {
        let x = Mb(c, s, l);
        return {
          range: D.cursor(o + x.length + 1),
          changes: { from: l.from, insert: x + s.lineBreak }
        };
      }
    }
    if (h.node.name == "Blockquote" && u && l.from) {
      let m = i.lineAt(l.from - 1), O = />\s*$/.exec(m.text);
      if (O && O.index == h.from) {
        let x = s.changes([
          { from: m.from + O.index, to: m.to },
          { from: l.from + h.from, to: l.to }
        ]);
        return { range: a.map(x), changes: x };
      }
    }
    let d = [];
    h.node.name == "OrderedList" && Lu(h.item, i, d);
    let f = h.item && h.item.from < l.from, p = "";
    if (!f || /^[\s\d.)\-+*>]*/.exec(l.text)[0].length >= h.to)
      for (let m = 0, O = c.length - 1; m <= O; m++)
        p += m == O && !f ? c[m].marker(i, 1) : c[m].blank(m < O ? Ti(l.text, 4, c[m + 1].from) - p.length : null);
    let g = o;
    for (; g > l.from && /\s/.test(l.text.charAt(g - l.from - 1)); )
      g--;
    return p = zg(p, s), hD(h.node, s.doc) && (p = Mb(c, s, l) + s.lineBreak + p), d.push({ from: g, to: o, insert: s.lineBreak + p }), { range: D.cursor(g + p.length + 1), changes: d };
  });
  return n ? !1 : (e(s.update(r, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function Xb(s) {
  return s.name == "QuoteMark" || s.name == "ListMark";
}
function hD(s, e) {
  if (s.name != "OrderedList" && s.name != "BulletList")
    return !1;
  let t = s.firstChild, i = s.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let n = e.lineAt(t.to), r = e.lineAt(i.from), a = /^[\s>]*$/.test(n.text);
  return n.number + (a ? 0 : 1) < r.number;
}
function Mb(s, e, t) {
  let i = "";
  for (let n = 0, r = s.length - 2; n <= r; n++)
    i += s[n].blank(n < r ? Ti(t.text, 4, Math.min(t.text.length, s[n + 1].from)) - i.length : null, n < r);
  return zg(i, e);
}
function uD(s, e) {
  let t = s.resolveInner(e, -1), i = e;
  Xb(t) && (i = t.from, t = t.parent);
  for (let n; n = t.childBefore(i); )
    if (Xb(n))
      i = n.from;
    else if (n.name == "OrderedList" || n.name == "BulletList")
      t = n.lastChild, i = t.to;
    else
      break;
  return t;
}
const dD = ({ state: s, dispatch: e }) => {
  let t = Ie(s), i = null, n = s.changeByRange((r) => {
    let a = r.from, { doc: o } = s;
    if (r.empty && $k.isActiveAt(s, r.from)) {
      let l = o.lineAt(a), c = Rk(uD(t, a), o);
      if (c.length) {
        let h = c[c.length - 1], u = h.to - h.spaceAfter.length + (h.spaceAfter ? 1 : 0);
        if (a - l.from > u && !/\S/.test(l.text.slice(u, a - l.from)))
          return {
            range: D.cursor(l.from + u),
            changes: { from: l.from + u, to: a }
          };
        if (a - l.from == u && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!h.item || l.from <= h.item.from || !/\S/.test(l.text.slice(0, h.to)))) {
          let d = l.from + h.from;
          if (h.item && h.node.from < h.item.from && /\S/.test(l.text.slice(h.from, h.to))) {
            let f = h.blank(Ti(l.text, 4, h.to) - Ti(l.text, 4, h.from));
            return d == l.from && (f = zg(f, s)), {
              range: D.cursor(d + f.length),
              changes: { from: d, to: l.from + h.to, insert: f }
            };
          }
          if (d < a)
            return { range: D.cursor(d), changes: { from: d, to: a } };
        }
      }
    }
    return i = { range: r };
  });
  return i ? !1 : (e(s.update(n, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, fD = [
  { key: "Enter", run: cD },
  { key: "Backspace", run: dD }
], Xk = /* @__PURE__ */ Qk({ matchClosingTags: !1 });
function pD(s = {}) {
  let { codeLanguages: e, defaultCodeLanguage: t, addKeymap: i = !0, base: { parser: n } = aD, completeHTMLTags: r = !0, htmlTagLanguage: a = Xk } = s;
  if (!(n instanceof hh))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let o = s.extensions ? [s.extensions] : [], l = [a.support], c;
  t instanceof is ? (l.push(t.support), c = t.language) : t && (c = t);
  let h = e || c ? lD(e, c) : void 0;
  o.push(kI({ codeParser: h, htmlParser: a.language.parser })), i && l.push(Qs.high(yo.of(fD)));
  let u = Lg(n.configure(o));
  return r && l.push(u.data.of({ autocomplete: gD })), new is(u, l);
}
function gD(s) {
  let { state: e, pos: t } = s, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(t - 25, t));
  if (!i)
    return null;
  let n = Ie(e).resolveInner(t, -1);
  for (; n && !n.type.isTop; ) {
    if (n.name == "CodeBlock" || n.name == "FencedCode" || n.name == "ProcessingInstructionBlock" || n.name == "CommentBlock" || n.name == "Link" || n.name == "Image")
      return null;
    n = n.parent;
  }
  return {
    from: t - i[0].length,
    to: t,
    options: mD(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let zu = null;
function mD() {
  if (zu)
    return zu;
  let s = Jq(new yg(Ce.create({ extensions: Xk }), 0, !0));
  return zu = s ? s.options : [];
}
const OD = 36, _b = 1, xD = 2, Wn = 3, Iu = 4, bD = 5, yD = 6, vD = 7, wD = 8, SD = 9, kD = 10, PD = 11, QD = 12, CD = 13, AD = 14, TD = 15, $D = 16, RD = 17, Lb = 18, ED = 19, Mk = 20, _k = 21, zb = 22, XD = 23, MD = 24;
function Vf(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122 || s >= 48 && s <= 57;
}
function _D(s) {
  return s >= 48 && s <= 57 || s >= 97 && s <= 102 || s >= 65 && s <= 70;
}
function en(s, e, t) {
  for (let i = !1; ; ) {
    if (s.next < 0)
      return;
    if (s.next == e && !i) {
      s.advance();
      return;
    }
    i = t && !i && s.next == 92, s.advance();
  }
}
function LD(s, e) {
  e: for (; ; ) {
    if (s.next < 0)
      return;
    if (s.next == 36) {
      s.advance();
      for (let t = 0; t < e.length; t++) {
        if (s.next != e.charCodeAt(t))
          continue e;
        s.advance();
      }
      if (s.next == 36) {
        s.advance();
        return;
      }
    } else
      s.advance();
  }
}
function zD(s, e) {
  let t = "[{<(".indexOf(String.fromCharCode(e)), i = t < 0 ? e : "]}>)".charCodeAt(t);
  for (; ; ) {
    if (s.next < 0)
      return;
    if (s.next == i && s.peek(1) == 39) {
      s.advance(2);
      return;
    }
    s.advance();
  }
}
function Ff(s, e) {
  for (; !(s.next != 95 && !Vf(s.next)); )
    e != null && (e += String.fromCharCode(s.next)), s.advance();
  return e;
}
function ID(s) {
  if (s.next == 39 || s.next == 34 || s.next == 96) {
    let e = s.next;
    s.advance(), en(s, e, !1);
  } else
    Ff(s);
}
function Ib(s, e) {
  for (; s.next == 48 || s.next == 49; )
    s.advance();
  e && s.next == e && s.advance();
}
function qb(s, e) {
  for (; ; ) {
    if (s.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (s.next < 48 || s.next > 57)
      break;
    s.advance();
  }
  if (s.next == 69 || s.next == 101)
    for (s.advance(), (s.next == 43 || s.next == 45) && s.advance(); s.next >= 48 && s.next <= 57; )
      s.advance();
}
function Db(s) {
  for (; !(s.next < 0 || s.next == 10); )
    s.advance();
}
function Gs(s, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == s)
      return !0;
  return !1;
}
const qu = ` 	\r
`;
function Lk(s, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = bD, i.null = i.unknown = yD;
  for (let n of s.split(" "))
    n && (i[n] = Mk);
  for (let n of e.split(" "))
    n && (i[n] = _k);
  for (let n of (t || "").split(" "))
    n && (i[n] = MD);
  return i;
}
const qD = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", DD = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", jf = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ Lk(DD, qD)
};
function BD(s, e, t, i) {
  let n = {};
  for (let r in jf)
    n[r] = (s.hasOwnProperty(r) ? s : jf)[r];
  return e && (n.words = Lk(e, t || "", i)), n;
}
function zk(s) {
  return new tt((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), Gs(i, qu)) {
      for (; Gs(e.next, qu); )
        e.advance();
      e.acceptToken(OD);
    } else if (i == 36 && s.doubleDollarQuotedStrings) {
      let n = Ff(e, "");
      e.next == 36 && (e.advance(), LD(e, n), e.acceptToken(Wn));
    } else if (i == 39 || i == 34 && s.doubleQuotedStrings)
      en(e, i, s.backslashEscapes), e.acceptToken(Wn);
    else if (i == 35 && s.hashComments || i == 47 && e.next == 47 && s.slashComments)
      Db(e), e.acceptToken(_b);
    else if (i == 45 && e.next == 45 && (!s.spaceAfterDashes || e.peek(1) == 32))
      Db(e), e.acceptToken(_b);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let n = 1; ; ) {
        let r = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), r == 42 && e.next == 47) {
          if (n--, e.advance(), !n)
            break;
        } else r == 47 && e.next == 42 && (n++, e.advance());
      }
      e.acceptToken(xD);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), en(e, 39, !0), e.acceptToken(Wn);
    else if ((i == 110 || i == 78) && e.next == 39 && s.charSetCasts)
      e.advance(), en(e, 39, s.backslashEscapes), e.acceptToken(Wn);
    else if (i == 95 && s.charSetCasts)
      for (let n = 0; ; n++) {
        if (e.next == 39 && n > 1) {
          e.advance(), en(e, 39, s.backslashEscapes), e.acceptToken(Wn);
          break;
        }
        if (!Vf(e.next))
          break;
        e.advance();
      }
    else if (s.plsqlQuotingMechanism && (i == 113 || i == 81) && e.next == 39 && e.peek(1) > 0 && !Gs(e.peek(1), qu)) {
      let n = e.peek(1);
      e.advance(2), zD(e, n), e.acceptToken(Wn);
    } else if (i == 40)
      e.acceptToken(vD);
    else if (i == 41)
      e.acceptToken(wD);
    else if (i == 123)
      e.acceptToken(SD);
    else if (i == 125)
      e.acceptToken(kD);
    else if (i == 91)
      e.acceptToken(PD);
    else if (i == 93)
      e.acceptToken(QD);
    else if (i == 59)
      e.acceptToken(CD);
    else if (s.unquotedBitLiterals && i == 48 && e.next == 98)
      e.advance(), Ib(e), e.acceptToken(zb);
    else if ((i == 98 || i == 66) && (e.next == 39 || e.next == 34)) {
      const n = e.next;
      e.advance(), s.treatBitsAsBytes ? (en(e, n, s.backslashEscapes), e.acceptToken(XD)) : (Ib(e, n), e.acceptToken(zb));
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); _D(e.next); )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(Iu);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      qb(e, !0), e.acceptToken(Iu);
    else if (i == 46)
      e.acceptToken(AD);
    else if (i >= 48 && i <= 57)
      qb(e, !1), e.acceptToken(Iu);
    else if (Gs(i, s.operatorChars)) {
      for (; Gs(e.next, s.operatorChars); )
        e.advance();
      e.acceptToken(TD);
    } else if (Gs(i, s.specialVar))
      e.next == i && e.advance(), ID(e), e.acceptToken(RD);
    else if (Gs(i, s.identifierQuotes))
      en(e, i, !1), e.acceptToken(ED);
    else if (i == 58 || i == 44)
      e.acceptToken($D);
    else if (Vf(i)) {
      let n = Ff(e, String.fromCharCode(i));
      e.acceptToken(e.next == 46 || e.peek(-n.length - 1) == 46 ? Lb : (t = s.words[n.toLowerCase()]) !== null && t !== void 0 ? t : Lb);
    }
  });
}
const Ik = /* @__PURE__ */ zk(jf), WD = /* @__PURE__ */ Xi.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, Ik],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function Hf(s) {
  let e = s.cursor().moveTo(s.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function to(s, e) {
  let t = s.sliceString(e.from, e.to), i = /^([`'"])(.*)\1$/.exec(t);
  return i ? i[2] : t;
}
function Mc(s) {
  return s && (s.name == "Identifier" || s.name == "QuotedIdentifier");
}
function YD(s, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      Mc(i) && t.push(to(s, i));
    return t;
  }
  return [to(s, e)];
}
function Bb(s, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = Hf(e);
    if (!Mc(i))
      return t;
    t.unshift(to(s, i)), e = Hf(i);
  }
}
function ZD(s, e) {
  let t = Ie(s).resolveInner(e, -1), i = VD(s.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? s.doc.sliceString(t.from, t.from + 1) : null,
    parents: Bb(s.doc, Hf(t)),
    aliases: i
  } : t.name == "." ? { from: e, quoted: null, parents: Bb(s.doc, t), aliases: i } : { from: e, quoted: null, parents: [], empty: !0, aliases: i };
}
const ND = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function VD(s, e) {
  let t;
  for (let n = e; !t; n = n.parent) {
    if (!n)
      return null;
    n.name == "Statement" && (t = n);
  }
  let i = null;
  for (let n = t.firstChild, r = !1, a = null; n; n = n.nextSibling) {
    let o = n.name == "Keyword" ? s.sliceString(n.from, n.to).toLowerCase() : null, l = null;
    if (!r)
      r = o == "from";
    else if (o == "as" && a && Mc(n.nextSibling))
      l = to(s, n.nextSibling);
    else {
      if (o && ND.has(o))
        break;
      a && Mc(n) && (l = to(s, n));
    }
    l && (i || (i = /* @__PURE__ */ Object.create(null)), i[l] = YD(s, a)), a = /Identifier$/.test(n.name) ? n : null;
  }
  return i;
}
function FD(s, e) {
  return s ? e.map((t) => Object.assign(Object.assign({}, t), { label: t.label[0] == s ? t.label : s + t.label + s, apply: void 0 })) : e;
}
const jD = /^\w*$/, HD = /^[`'"]?\w*[`'"]?$/;
function Wb(s) {
  return s.self && typeof s.self.label == "string";
}
class Ig {
  constructor(e, t) {
    this.idQuote = e, this.idCaseInsensitive = t, this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null)), i = t[e];
    return i || (e && !this.list.some((n) => n.label == e) && this.list.push(Yb(e, "type", this.idQuote, this.idCaseInsensitive)), t[e] = new Ig(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let t = this.list.findIndex((i) => i.label == e.label);
    t > -1 ? this.list[t] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let t of e)
      this.addCompletion(typeof t == "string" ? Yb(t, "property", this.idQuote, this.idCaseInsensitive) : t);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : Wb(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let t of Object.keys(e)) {
      let i = e[t], n = null, r = t.replace(/\\?\./g, (o) => o == "." ? "\0" : o).split("\0"), a = this;
      Wb(i) && (n = i.self, i = i.children);
      for (let o = 0; o < r.length; o++)
        n && o == r.length - 1 && a.addCompletion(n), a = a.child(r[o].replace(/\\\./g, "."));
      a.addNamespace(i);
    }
  }
}
function Yb(s, e, t, i) {
  return new RegExp("^[a-z_][a-z_\\d]*$", i ? "i" : "").test(s) ? { label: s, type: e } : { label: s, type: e, apply: t + s + t };
}
function UD(s, e, t, i, n, r) {
  var a;
  let o = ((a = r?.spec.identifierQuotes) === null || a === void 0 ? void 0 : a[0]) || '"', l = new Ig(o, !!r?.spec.caseInsensitiveIdentifiers), c = n ? l.child(n) : null;
  return l.addNamespace(s), e && (c || l).addCompletions(e), t && l.addCompletions(t), c && l.addCompletions(c.list), i && l.addCompletions((c || l).child(i).list), (h) => {
    let { parents: u, from: d, quoted: f, empty: p, aliases: g } = ZD(h.state, h.pos);
    if (p && !h.explicit)
      return null;
    g && u.length == 1 && (u = g[u[0]] || u);
    let m = l;
    for (let b of u) {
      for (; !m.children || !m.children[b]; )
        if (m == l && c)
          m = c;
        else if (m == c && i)
          m = m.child(i);
        else
          return null;
      let v = m.maybeChild(b);
      if (!v)
        return null;
      m = v;
    }
    let O = f && h.state.sliceDoc(h.pos, h.pos + 1) == f, x = m.list;
    return m == l && g && (x = x.concat(Object.keys(g).map((b) => ({ label: b, type: "constant" })))), {
      from: d,
      to: O ? h.pos + 1 : void 0,
      options: FD(f, x),
      validFor: f ? HD : jD
    };
  };
}
function GD(s) {
  return s == _k ? "type" : s == Mk ? "keyword" : "variable";
}
function KD(s, e, t) {
  let i = Object.keys(s).map((n) => t(e ? n.toUpperCase() : n, GD(s[n])));
  return vg(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], lh(i));
}
let JD = /* @__PURE__ */ WD.configure({
  props: [
    /* @__PURE__ */ rs.add({
      Statement: /* @__PURE__ */ xn()
    }),
    /* @__PURE__ */ Li.add({
      Statement(s, e) {
        return { from: Math.min(s.from + 100, e.doc.lineAt(s.from).to), to: s.to };
      },
      BlockComment(s) {
        return { from: s.from + 2, to: s.to - 2 };
      }
    }),
    /* @__PURE__ */ _i({
      Keyword: Q.keyword,
      Type: Q.typeName,
      Builtin: /* @__PURE__ */ Q.standard(Q.name),
      Bits: Q.number,
      Bytes: Q.string,
      Bool: Q.bool,
      Null: Q.null,
      Number: Q.number,
      String: Q.string,
      Identifier: Q.name,
      QuotedIdentifier: /* @__PURE__ */ Q.special(Q.string),
      SpecialVar: /* @__PURE__ */ Q.special(Q.name),
      LineComment: Q.lineComment,
      BlockComment: Q.blockComment,
      Operator: Q.operator,
      "Semi Punctuation": Q.punctuation,
      "( )": Q.paren,
      "{ }": Q.brace,
      "[ ]": Q.squareBracket
    })
  ]
});
class qg {
  constructor(e, t, i) {
    this.dialect = e, this.language = t, this.spec = i;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = BD(e, e.keywords, e.types, e.builtin), i = Ei.define({
      name: "sql",
      parser: JD.configure({
        tokenizers: [{ from: Ik, to: zk(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new qg(t, i, e);
  }
}
function eB(s, e) {
  return { label: s, type: e, boost: -1 };
}
function tB(s, e = !1, t) {
  return KD(s.dialect.words, e, t || eB);
}
function iB(s) {
  return s.schema ? UD(s.schema, s.tables, s.schemas, s.defaultTable, s.defaultSchema, s.dialect || Dg) : () => null;
}
function sB(s) {
  return s.schema ? (s.dialect || Dg).language.data.of({
    autocomplete: iB(s)
  }) : [];
}
function nB(s = {}) {
  let e = s.dialect || Dg;
  return new is(e.language, [
    sB(s),
    e.language.data.of({
      autocomplete: tB(e, s.upperCaseKeywords, s.keywordCompletion)
    })
  ]);
}
const Dg = /* @__PURE__ */ qg.define({}), rB = 1, qk = 194, Dk = 195, aB = 196, Zb = 197, oB = 198, lB = 199, cB = 200, hB = 2, Bk = 3, Nb = 201, uB = 24, dB = 25, fB = 49, pB = 50, gB = 55, mB = 56, OB = 57, xB = 59, bB = 60, yB = 61, vB = 62, wB = 63, SB = 65, kB = 238, PB = 71, QB = 241, CB = 242, AB = 243, TB = 244, $B = 245, RB = 246, EB = 247, XB = 248, Wk = 72, MB = 249, _B = 250, LB = 251, zB = 252, IB = 253, qB = 254, DB = 255, BB = 256, WB = 73, YB = 77, ZB = 263, NB = 112, VB = 130, FB = 151, jB = 152, HB = 155, Rn = 10, io = 13, Bg = 32, uh = 9, Wg = 35, UB = 40, GB = 46, Uf = 123, Vb = 125, Yk = 39, Zk = 34, Fb = 92, KB = 111, JB = 120, eW = 78, tW = 117, iW = 85, sW = /* @__PURE__ */ new Set([
  dB,
  fB,
  pB,
  ZB,
  SB,
  VB,
  mB,
  OB,
  kB,
  vB,
  wB,
  Wk,
  WB,
  YB,
  bB,
  yB,
  FB,
  jB,
  HB,
  NB
]);
function Du(s) {
  return s == Rn || s == io;
}
function Bu(s) {
  return s >= 48 && s <= 57 || s >= 65 && s <= 70 || s >= 97 && s <= 102;
}
const nW = new tt((s, e) => {
  let t;
  if (s.next < 0)
    s.acceptToken(lB);
  else if (e.context.flags & Ll)
    Du(s.next) && s.acceptToken(oB, 1);
  else if (((t = s.peek(-1)) < 0 || Du(t)) && e.canShift(Zb)) {
    let i = 0;
    for (; s.next == Bg || s.next == uh; )
      s.advance(), i++;
    (s.next == Rn || s.next == io || s.next == Wg) && s.acceptToken(Zb, -i);
  } else Du(s.next) && s.acceptToken(aB, 1);
}, { contextual: !0 }), rW = new tt((s, e) => {
  let t = e.context;
  if (t.flags) return;
  let i = s.peek(-1);
  if (i == Rn || i == io) {
    let n = 0, r = 0;
    for (; ; ) {
      if (s.next == Bg) n++;
      else if (s.next == uh) n += 8 - n % 8;
      else break;
      s.advance(), r++;
    }
    n != t.indent && s.next != Rn && s.next != io && s.next != Wg && (n < t.indent ? s.acceptToken(Dk, -r) : s.acceptToken(qk));
  }
}), Ll = 1, Nk = 2, cs = 4, hs = 8, us = 16, ds = 32;
function zl(s, e, t) {
  this.parent = s, this.indent = e, this.flags = t, this.hash = (s ? s.hash + s.hash << 8 : 0) + e + (e << 4) + t + (t << 6);
}
const aW = new zl(null, 0, 0);
function oW(s) {
  let e = 0;
  for (let t = 0; t < s.length; t++)
    e += s.charCodeAt(t) == uh ? 8 - e % 8 : 1;
  return e;
}
const jb = new Map([
  [QB, 0],
  [CB, cs],
  [AB, hs],
  [TB, hs | cs],
  [$B, us],
  [RB, us | cs],
  [EB, us | hs],
  [XB, us | hs | cs],
  [MB, ds],
  [_B, ds | cs],
  [LB, ds | hs],
  [zB, ds | hs | cs],
  [IB, ds | us],
  [qB, ds | us | cs],
  [DB, ds | us | hs],
  [BB, ds | us | hs | cs]
].map(([s, e]) => [s, e | Nk])), lW = new To({
  start: aW,
  reduce(s, e, t, i) {
    return s.flags & Ll && sW.has(e) || (e == PB || e == Wk) && s.flags & Nk ? s.parent : s;
  },
  shift(s, e, t, i) {
    return e == qk ? new zl(s, oW(i.read(i.pos, t.pos)), 0) : e == Dk ? s.parent : e == uB || e == gB || e == xB || e == Bk ? new zl(s, 0, Ll) : jb.has(e) ? new zl(s, 0, jb.get(e) | s.flags & Ll) : s;
  },
  hash(s) {
    return s.hash;
  }
}), cW = new tt((s) => {
  for (let e = 0; e < 5; e++) {
    if (s.next != "print".charCodeAt(e)) return;
    s.advance();
  }
  if (!/\w/.test(String.fromCharCode(s.next)))
    for (let e = 0; ; e++) {
      let t = s.peek(e);
      if (!(t == Bg || t == uh)) {
        t != UB && t != GB && t != Rn && t != io && t != Wg && s.acceptToken(rB);
        return;
      }
    }
}), hW = new tt((s, e) => {
  let { flags: t } = e.context, i = t & cs ? Zk : Yk, n = (t & hs) > 0, r = !(t & us), a = (t & ds) > 0, o = s.pos;
  for (; !(s.next < 0); )
    if (a && s.next == Uf)
      if (s.peek(1) == Uf)
        s.advance(2);
      else {
        if (s.pos == o) {
          s.acceptToken(Bk, 1);
          return;
        }
        break;
      }
    else if (r && s.next == Fb) {
      if (s.pos == o) {
        s.advance();
        let l = s.next;
        l >= 0 && (s.advance(), uW(s, l)), s.acceptToken(hB);
        return;
      }
      break;
    } else if (s.next == Fb && !r && s.peek(1) > -1)
      s.advance(2);
    else if (s.next == i && (!n || s.peek(1) == i && s.peek(2) == i)) {
      if (s.pos == o) {
        s.acceptToken(Nb, n ? 3 : 1);
        return;
      }
      break;
    } else if (s.next == Rn) {
      if (n)
        s.advance();
      else if (s.pos == o) {
        s.acceptToken(Nb);
        return;
      }
      break;
    } else
      s.advance();
  s.pos > o && s.acceptToken(cB);
});
function uW(s, e) {
  if (e == KB)
    for (let t = 0; t < 2 && s.next >= 48 && s.next <= 55; t++) s.advance();
  else if (e == JB)
    for (let t = 0; t < 2 && Bu(s.next); t++) s.advance();
  else if (e == tW)
    for (let t = 0; t < 4 && Bu(s.next); t++) s.advance();
  else if (e == iW)
    for (let t = 0; t < 8 && Bu(s.next); t++) s.advance();
  else if (e == eW && s.next == Uf) {
    for (s.advance(); s.next >= 0 && s.next != Vb && s.next != Yk && s.next != Zk && s.next != Rn; ) s.advance();
    s.next == Vb && s.advance();
  }
}
const dW = _i({
  'async "*" "**" FormatConversion FormatSpec': Q.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": Q.controlKeyword,
  "in not and or is del": Q.operatorKeyword,
  "from def class global nonlocal lambda": Q.definitionKeyword,
  import: Q.moduleKeyword,
  "with as print": Q.keyword,
  Boolean: Q.bool,
  None: Q.null,
  VariableName: Q.variableName,
  "CallExpression/VariableName": Q.function(Q.variableName),
  "FunctionDefinition/VariableName": Q.function(Q.definition(Q.variableName)),
  "ClassDefinition/VariableName": Q.definition(Q.className),
  PropertyName: Q.propertyName,
  "CallExpression/MemberExpression/PropertyName": Q.function(Q.propertyName),
  Comment: Q.lineComment,
  Number: Q.number,
  String: Q.string,
  FormatString: Q.special(Q.string),
  Escape: Q.escape,
  UpdateOp: Q.updateOperator,
  "ArithOp!": Q.arithmeticOperator,
  BitOp: Q.bitwiseOperator,
  CompareOp: Q.compareOperator,
  AssignOp: Q.definitionOperator,
  Ellipsis: Q.punctuation,
  At: Q.meta,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace,
  ".": Q.derefOperator,
  ", ;": Q.separator
}), fW = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 }, pW = Xi.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: "⚠ print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: lW,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [dW],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [cW, rW, nW, hW, 0, 1, 2, 3, 4],
  topRules: { Script: [0, 5] },
  specialized: [{ term: 221, get: (s) => fW[s] || -1 }],
  tokenPrec: 7668
}), Hb = /* @__PURE__ */ new ag(), Vk = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function ll(s) {
  return (e, t, i) => {
    if (i)
      return !1;
    let n = e.node.getChild("VariableName");
    return n && t(n, s), !0;
  };
}
const gW = {
  FunctionDefinition: /* @__PURE__ */ ll("function"),
  ClassDefinition: /* @__PURE__ */ ll("class"),
  ForStatement(s, e, t) {
    if (t) {
      for (let i = s.node.firstChild; i; i = i.nextSibling)
        if (i.name == "VariableName")
          e(i, "variable");
        else if (i.name == "in")
          break;
    }
  },
  ImportStatement(s, e) {
    var t, i;
    let { node: n } = s, r = ((t = n.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let a = n.getChild("import"); a; a = a.nextSibling)
      a.name == "VariableName" && ((i = a.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && e(a, r ? "variable" : "namespace");
  },
  AssignStatement(s, e) {
    for (let t = s.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(s, e) {
    for (let t = null, i = s.node.firstChild; i; i = i.nextSibling)
      i.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(i, "variable"), t = i;
  },
  CapturePattern: /* @__PURE__ */ ll("variable"),
  AsPattern: /* @__PURE__ */ ll("variable"),
  __proto__: null
};
function Fk(s, e) {
  let t = Hb.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function r(a, o) {
    let l = s.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return e.cursor(Ze.IncludeAnonymous).iterate((a) => {
    if (a.name) {
      let o = gW[a.name];
      if (o && o(a, r, n) || !n && Vk.has(a.name))
        return !1;
      n = !1;
    } else if (a.to - a.from > 8192) {
      for (let o of Fk(s, a.node))
        i.push(o);
      return !1;
    }
  }), Hb.set(e, i), i;
}
const Ub = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, jk = ["String", "FormatString", "Comment", "PropertyName"];
function mW(s) {
  let e = Ie(s.state).resolveInner(s.pos, -1);
  if (jk.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && Ub.test(s.state.sliceDoc(e.from, e.to));
  if (!t && !s.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    Vk.has(n.name) && (i = i.concat(Fk(s.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : s.pos,
    validFor: Ub
  };
}
const OW = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((s) => ({ label: s, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((s) => ({ label: s, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((s) => ({ label: s, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((s) => ({ label: s, type: "function" }))), xW = [
  /* @__PURE__ */ et("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ et("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ et("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ et("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ et(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ et("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ et("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ et("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ et("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], bW = /* @__PURE__ */ vg(jk, /* @__PURE__ */ lh(/* @__PURE__ */ OW.concat(xW)));
function Wu(s) {
  let { node: e, pos: t } = s, i = s.lineIndent(t, -1), n = null;
  for (; ; ) {
    let r = e.childBefore(t);
    if (r)
      if (r.name == "Comment")
        t = r.from;
      else if (r.name == "Body" || r.name == "MatchBody")
        s.baseIndentFor(r) + s.unit <= i && (n = r), e = r;
      else if (r.name == "MatchClause")
        e = r;
      else if (r.type.is("Statement"))
        e = r;
      else
        break;
    else break;
  }
  return n;
}
function Yu(s, e) {
  let t = s.baseIndentFor(e), i = s.lineAt(s.pos, -1), n = i.from + i.text.length;
  return /^\s*($|#)/.test(i.text) && s.node.to < n + 100 && !/\S/.test(s.state.sliceDoc(n, s.node.to)) && s.lineIndent(s.pos, -1) <= t || /^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(s.textAfter) && s.lineIndent(s.pos, -1) > t ? null : t + s.unit;
}
const Zu = /* @__PURE__ */ Ei.define({
  name: "python",
  parser: /* @__PURE__ */ pW.configure({
    props: [
      /* @__PURE__ */ rs.add({
        Body: (s) => {
          var e;
          let t = /^\s*(#|$)/.test(s.textAfter) && Wu(s) || s.node;
          return (e = Yu(s, t)) !== null && e !== void 0 ? e : s.continue();
        },
        MatchBody: (s) => {
          var e;
          let t = Wu(s);
          return (e = Yu(s, t || s.node)) !== null && e !== void 0 ? e : s.continue();
        },
        IfStatement: (s) => /^\s*(else:|elif )/.test(s.textAfter) ? s.baseIndent : s.continue(),
        "ForStatement WhileStatement": (s) => /^\s*else:/.test(s.textAfter) ? s.baseIndent : s.continue(),
        TryStatement: (s) => /^\s*(except[ :]|finally:|else:)/.test(s.textAfter) ? s.baseIndent : s.continue(),
        MatchStatement: (s) => /^\s*case /.test(s.textAfter) ? s.baseIndent + s.unit : s.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ nr({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ nr({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ nr({ closing: "]" }),
        MemberExpression: (s) => s.baseIndent + s.unit,
        "String FormatString": () => null,
        Script: (s) => {
          var e;
          let t = Wu(s);
          return (e = t && Yu(s, t)) !== null && e !== void 0 ? e : s.continue();
        }
      }),
      /* @__PURE__ */ Li.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": ko,
        Body: (s, e) => ({ from: s.from + 1, to: s.to - (s.to == e.doc.length ? 0 : 1) }),
        "String FormatString": (s, e) => ({ from: e.doc.lineAt(s.from).to, to: s.to })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    // Indent logic logic are triggered upon below input patterns
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function yW() {
  return new is(Zu, [
    Zu.data.of({ autocomplete: mW }),
    Zu.data.of({ autocomplete: bW })
  ]);
}
const Fn = 63, Gb = 64, vW = 1, wW = 2, Hk = 3, SW = 4, Uk = 5, kW = 6, PW = 7, Gk = 65, QW = 66, CW = 8, AW = 9, TW = 10, $W = 11, RW = 12, Kk = 13, EW = 19, XW = 20, MW = 29, _W = 33, LW = 34, zW = 47, IW = 0, Yg = 1, Gf = 2, so = 3, Kf = 4;
class an {
  constructor(e, t, i) {
    this.parent = e, this.depth = t, this.type = i, this.hash = (e ? e.hash + e.hash << 8 : 0) + t + (t << 4) + i;
  }
}
an.top = new an(null, -1, IW);
function ya(s, e) {
  for (let t = 0, i = e - s.pos - 1; ; i--, t++) {
    let n = s.peek(i);
    if (ks(n) || n == -1) return t;
  }
}
function Jf(s) {
  return s == 32 || s == 9;
}
function ks(s) {
  return s == 10 || s == 13;
}
function Jk(s) {
  return Jf(s) || ks(s);
}
function fn(s) {
  return s < 0 || Jk(s);
}
const qW = new To({
  start: an.top,
  reduce(s, e) {
    return s.type == so && (e == XW || e == LW) ? s.parent : s;
  },
  shift(s, e, t, i) {
    if (e == Hk)
      return new an(s, ya(i, i.pos), Yg);
    if (e == Gk || e == Uk)
      return new an(s, ya(i, i.pos), Gf);
    if (e == Fn)
      return s.parent;
    if (e == EW || e == _W)
      return new an(s, 0, so);
    if (e == Kk && s.type == Kf)
      return s.parent;
    if (e == zW) {
      let n = /[1-9]/.exec(i.read(i.pos, t.pos));
      if (n) return new an(s, s.depth + +n[0], Kf);
    }
    return s;
  },
  hash(s) {
    return s.hash;
  }
});
function vr(s, e, t = 0) {
  return s.peek(t) == e && s.peek(t + 1) == e && s.peek(t + 2) == e && fn(s.peek(t + 3));
}
const DW = new tt((s, e) => {
  if (s.next == -1 && e.canShift(Gb))
    return s.acceptToken(Gb);
  let t = s.peek(-1);
  if ((ks(t) || t < 0) && e.context.type != so) {
    if (vr(
      s,
      45
      /* '-' */
    ))
      if (e.canShift(Fn)) s.acceptToken(Fn);
      else return s.acceptToken(vW, 3);
    if (vr(
      s,
      46
      /* '.' */
    ))
      if (e.canShift(Fn)) s.acceptToken(Fn);
      else return s.acceptToken(wW, 3);
    let i = 0;
    for (; s.next == 32; )
      i++, s.advance();
    (i < e.context.depth || i == e.context.depth && e.context.type == Yg && (s.next != 45 || !fn(s.peek(1)))) && // Not blank
    s.next != -1 && !ks(s.next) && s.next != 35 && s.acceptToken(Fn, -i);
  }
}, { contextual: !0 }), BW = new tt((s, e) => {
  if (e.context.type == so) {
    s.next == 63 && (s.advance(), fn(s.next) && s.acceptToken(PW));
    return;
  }
  if (s.next == 45)
    s.advance(), fn(s.next) && s.acceptToken(e.context.type == Yg && e.context.depth == ya(s, s.pos - 1) ? SW : Hk);
  else if (s.next == 63)
    s.advance(), fn(s.next) && s.acceptToken(e.context.type == Gf && e.context.depth == ya(s, s.pos - 1) ? kW : Uk);
  else {
    let t = s.pos;
    for (; ; )
      if (Jf(s.next)) {
        if (s.pos == t) return;
        s.advance();
      } else if (s.next == 33)
        eP(s);
      else if (s.next == 38)
        ep(s);
      else if (s.next == 42) {
        ep(s);
        break;
      } else if (s.next == 39 || s.next == 34) {
        if (Zg(s, !0)) break;
        return;
      } else if (s.next == 91 || s.next == 123) {
        if (!YW(s)) return;
        break;
      } else {
        tP(s, !0, !1, 0);
        break;
      }
    for (; Jf(s.next); ) s.advance();
    if (s.next == 58) {
      if (s.pos == t && e.canShift(MW)) return;
      let i = s.peek(1);
      fn(i) && s.acceptTokenTo(e.context.type == Gf && e.context.depth == ya(s, t) ? QW : Gk, t);
    }
  }
}, { contextual: !0 });
function WW(s) {
  return s > 32 && s < 127 && s != 34 && s != 37 && s != 44 && s != 60 && s != 62 && s != 92 && s != 94 && s != 96 && s != 123 && s != 124 && s != 125;
}
function Kb(s) {
  return s >= 48 && s <= 57 || s >= 97 && s <= 102 || s >= 65 && s <= 70;
}
function Jb(s, e) {
  return s.next == 37 ? (s.advance(), Kb(s.next) && s.advance(), Kb(s.next) && s.advance(), !0) : WW(s.next) || e && s.next == 44 ? (s.advance(), !0) : !1;
}
function eP(s) {
  if (s.advance(), s.next == 60) {
    for (s.advance(); ; )
      if (!Jb(s, !0)) {
        s.next == 62 && s.advance();
        break;
      }
  } else
    for (; Jb(s, !1); )
      ;
}
function ep(s) {
  for (s.advance(); !fn(s.next) && _c(s.tag) != "f"; ) s.advance();
}
function Zg(s, e) {
  let t = s.next, i = !1, n = s.pos;
  for (s.advance(); ; ) {
    let r = s.next;
    if (r < 0) break;
    if (s.advance(), r == t)
      if (r == 39)
        if (s.next == 39) s.advance();
        else break;
      else
        break;
    else if (r == 92 && t == 34)
      s.next >= 0 && s.advance();
    else if (ks(r)) {
      if (e) return !1;
      i = !0;
    } else if (e && s.pos >= n + 1024)
      return !1;
  }
  return !i;
}
function YW(s) {
  for (let e = [], t = s.pos + 1024; ; )
    if (s.next == 91 || s.next == 123)
      e.push(s.next), s.advance();
    else if (s.next == 39 || s.next == 34) {
      if (!Zg(s, !0)) return !1;
    } else if (s.next == 93 || s.next == 125) {
      if (e[e.length - 1] != s.next - 2) return !1;
      if (e.pop(), s.advance(), !e.length) return !0;
    } else {
      if (s.next < 0 || s.pos > t || ks(s.next))
        return !1;
      s.advance();
    }
}
const ZW = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function _c(s) {
  return s < 33 ? "u" : s > 125 ? "s" : ZW[s - 33];
}
function Nu(s, e) {
  let t = _c(s);
  return t != "u" && !(e && t == "f");
}
function tP(s, e, t, i) {
  if (_c(s.next) == "s" || (s.next == 63 || s.next == 58 || s.next == 45) && Nu(s.peek(1), t))
    s.advance();
  else
    return !1;
  let n = s.pos;
  for (; ; ) {
    let r = s.next, a = 0, o = i + 1;
    for (; Jk(r); ) {
      if (ks(r)) {
        if (e) return !1;
        o = 0;
      } else
        o++;
      r = s.peek(++a);
    }
    if (!(r >= 0 && (r == 58 ? Nu(s.peek(a + 1), t) : r == 35 ? s.peek(a - 1) != 32 : Nu(r, t))) || !t && o <= i || o == 0 && !t && (vr(s, 45, a) || vr(s, 46, a)))
      break;
    if (e && _c(r) == "f") return !1;
    for (let c = a; c >= 0; c--) s.advance();
    if (e && s.pos > n + 1024) return !1;
  }
  return !0;
}
const NW = new tt((s, e) => {
  if (s.next == 33)
    eP(s), s.acceptToken(RW);
  else if (s.next == 38 || s.next == 42) {
    let t = s.next == 38 ? TW : $W;
    ep(s), s.acceptToken(t);
  } else s.next == 39 || s.next == 34 ? (Zg(s, !1), s.acceptToken(AW)) : tP(s, !1, e.context.type == so, e.context.depth) && s.acceptToken(CW);
}), VW = new tt((s, e) => {
  let t = e.context.type == Kf ? e.context.depth : -1, i = s.pos;
  e: for (; ; ) {
    let n = 0, r = s.next;
    for (; r == 32; ) r = s.peek(++n);
    if (!n && (vr(s, 45, n) || vr(s, 46, n)) || !ks(r) && (t < 0 && (t = Math.max(e.context.depth + 1, n)), n < t))
      break;
    for (; ; ) {
      if (s.next < 0) break e;
      let a = ks(s.next);
      if (s.advance(), a) continue e;
      i = s.pos;
    }
  }
  s.acceptTokenTo(Kk, i);
}), FW = _i({
  DirectiveName: Q.keyword,
  DirectiveContent: Q.attributeValue,
  "DirectiveEnd DocEnd": Q.meta,
  QuotedLiteral: Q.string,
  BlockLiteralHeader: Q.special(Q.string),
  BlockLiteralContent: Q.content,
  Literal: Q.content,
  "Key/Literal Key/QuotedLiteral": Q.definition(Q.propertyName),
  "Anchor Alias": Q.labelName,
  Tag: Q.typeName,
  Comment: Q.lineComment,
  ": , -": Q.separator,
  "?": Q.punctuation,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
}), jW = Xi.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: "⚠ DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: qW,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [FW],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [DW, BW, NW, VW, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), HW = /* @__PURE__ */ Ei.define({
  name: "yaml",
  parser: /* @__PURE__ */ jW.configure({
    props: [
      /* @__PURE__ */ rs.add({
        Stream: (s) => {
          for (let e = s.node.resolve(s.pos, -1); e && e.to >= s.pos; e = e.parent) {
            if (e.name == "BlockLiteralContent" && e.from < e.to)
              return s.baseIndentFor(e);
            if (e.name == "BlockLiteral")
              return s.baseIndentFor(e) + s.unit;
            if (e.name == "BlockSequence" || e.name == "BlockMapping")
              return s.column(e.from, 1);
            if (e.name == "QuotedLiteral")
              return null;
            if (e.name == "Literal") {
              let t = s.column(e.from, 1);
              if (t == s.lineIndent(e.from, 1))
                return t;
              if (e.to > s.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ nr({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ nr({ closing: "]" })
      }),
      /* @__PURE__ */ Li.add({
        "FlowMapping FlowSequence": ko,
        "Item Pair BlockLiteral": (s, e) => ({ from: e.doc.lineAt(s.from).to, to: s.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function UW() {
  return new is(HW);
}
const tp = 1, GW = 2, KW = 3, JW = 4, eY = 5, tY = 36, iY = 37, sY = 38, nY = 11, rY = 13;
function aY(s) {
  return s == 45 || s == 46 || s == 58 || s >= 65 && s <= 90 || s == 95 || s >= 97 && s <= 122 || s >= 161;
}
function oY(s) {
  return s == 9 || s == 10 || s == 13 || s == 32;
}
let e0 = null, t0 = null, i0 = 0;
function ip(s, e) {
  let t = s.pos + e;
  if (t0 == s && i0 == t) return e0;
  for (; oY(s.peek(e)); ) e++;
  let i = "";
  for (; ; ) {
    let n = s.peek(e);
    if (!aY(n)) break;
    i += String.fromCharCode(n), e++;
  }
  return t0 = s, i0 = t, e0 = i || null;
}
function s0(s, e) {
  this.name = s, this.parent = e;
}
const lY = new To({
  start: null,
  shift(s, e, t, i) {
    return e == tp ? new s0(ip(i, 1) || "", s) : s;
  },
  reduce(s, e) {
    return e == nY && s ? s.parent : s;
  },
  reuse(s, e, t, i) {
    let n = e.type.id;
    return n == tp || n == rY ? new s0(ip(i, 1) || "", s) : s;
  },
  strict: !1
}), cY = new tt((s, e) => {
  if (s.next == 60) {
    if (s.advance(), s.next == 47) {
      s.advance();
      let t = ip(s, 0);
      if (!t) return s.acceptToken(eY);
      if (e.context && t == e.context.name) return s.acceptToken(GW);
      for (let i = e.context; i; i = i.parent) if (i.name == t) return s.acceptToken(KW, -2);
      s.acceptToken(JW);
    } else if (s.next != 33 && s.next != 63)
      return s.acceptToken(tp);
  }
}, { contextual: !0 });
function Ng(s, e) {
  return new tt((t) => {
    let i = 0, n = e.charCodeAt(0);
    e: for (; !(t.next < 0); t.advance(), i++)
      if (t.next == n) {
        for (let r = 1; r < e.length; r++)
          if (t.peek(r) != e.charCodeAt(r)) continue e;
        break;
      }
    i && t.acceptToken(s);
  });
}
const hY = Ng(tY, "-->"), uY = Ng(iY, "?>"), dY = Ng(sY, "]]>"), fY = _i({
  Text: Q.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": Q.angleBracket,
  TagName: Q.tagName,
  "MismatchedCloseTag/TagName": [Q.tagName, Q.invalid],
  AttributeName: Q.attributeName,
  AttributeValue: Q.attributeValue,
  Is: Q.definitionOperator,
  "EntityReference CharacterReference": Q.character,
  Comment: Q.blockComment,
  ProcessingInst: Q.processingInstruction,
  DoctypeDecl: Q.documentMeta,
  Cdata: Q.special(Q.string)
}), pY = Xi.deserialize({
  version: 14,
  states: ",lOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DT'#DTOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C|'#C|O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C}'#C}O$dOrO,59^OOOP,59^,59^OOOS'#DO'#DOO$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6z-E6zOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6{-E6{OOOP1G.x1G.xOOOS-E6|-E6|OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'mO!bO,59eOOOO-E6w-E6wO'{OpO1G.uO'{OpO1G.uOOOP1G.u1G.uO(TOpO7+$fOOOP7+$f7+$fO(]O!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(hO#tO'#CnO(vO&jO'#CnOOOO1G.q1G.qO)UOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO)^O#tO,59YOOOO,59Y,59YOOOO'#C{'#C{O)lO&jO,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.tOOOO-E6y-E6y",
  stateData: ")z~OPQOSVOTWOVWOWWOXWOiXOyPO!QTO!SUO~OvZOx]O~O^`Oz^O~OPQOQcOSVOTWOVWOWWOXWOyPO!QTO!SUO~ORdO~P!SOteO!PgO~OuhO!RjO~O^lOz^O~OvZOxoO~O^qOz^O~O[vO`sOdwOz^O~ORyO~P!SO^{Oz^O~OteO!P}O~OuhO!R!PO~O^!QOz^O~O[!SOz^O~O[!VO`sOd!WOz^O~Oa!YOz^O~Oz^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oz^O~O[!_Oz^O~O[!aOz^O~O[!cO`sOd!dOz^O~O[!cO`sOd!dO~Oa!eOz^O~Oz^O{!gO}!hO~Oz^O[ma`madma~O[!kOz^O~O[!lOz^O~O[!mO`sOd!nO~OW!qOX!qO{!sO|!qO~OW!tOX!tO}!sO!O!tO~O[!vOz^O~OW!qOX!qO{!yO|!qO~OW!tOX!tO}!yO!O!tO~O",
  goto: "%cxPPPPPPPPPPyyP!PP!VPP!`!jP!pyyyP!v!|#S$[$k$q$w$}%TPPPP%ZXWORYbXRORYb_t`qru!T!U!bQ!i!YS!p!e!fR!w!oQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!j!oQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!j!]R!o!eQu`S!UqrU![u!U!bR!b!TQ!r!gR!x!rQ!u!hR!z!uQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 50,
  context: lY,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"],
    ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]
  ],
  propSources: [fY],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!)v~R!YOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs*vsv$qvw+fwx/ix}$q}!O0[!O!P$q!P!Q2z!Q![$q![!]4n!]!^$q!^!_8U!_!`!#t!`!a!$l!a!b!%d!b!c$q!c!}4n!}#P$q#P#Q!'W#Q#R$q#R#S4n#S#T$q#T#o4n#o%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U$q4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qi$zXVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qa%nVVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%gP&YTVPOv&Tw!^&T!_;'S&T;'S;=`&i<%lO&TP&lP;=`<%l&T`&tS!O`Ov&ox;'S&o;'S;=`'Q<%lO&o`'TP;=`<%l&oa'ZP;=`<%l%gX'eWVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^W(ST|WOr'}sv'}w;'S'};'S;=`(c<%lO'}W(fP;=`<%l'}X(lP;=`<%l'^h(vV|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oh)`P;=`<%l(oi)fP;=`<%l$qo)t`VP|W!O`zUOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk+PV{YVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%g~+iast,n![!]-r!c!}-r#R#S-r#T#o-r%W%o-r%p&a-r&b1p-r4U4d-r4e$IS-r$I`$Ib-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~,qQ!Q![,w#l#m-V~,zQ!Q![,w!]!^-Q~-VOX~~-YR!Q![-c!c!i-c#T#Z-c~-fS!Q![-c!]!^-Q!c!i-c#T#Z-c~-ug}!O-r!O!P-r!Q![-r![!]-r!]!^/^!c!}-r#R#S-r#T#o-r$}%O-r%W%o-r%p&a-r&b1p-r1p4U-r4U4d-r4e$IS-r$I`$Ib-r$Je$Jg-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~/cOW~~/fP;=`<%l-rk/rW}bVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^k0eZVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O1W!O!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk1aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a2S!a;'S$q;'S;=`)c<%lO$qk2_X!PQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qm3TZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a3v!a;'S$q;'S;=`)c<%lO$qm4RXdSVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo4{!P`S^QVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O4n!O!P4n!P!Q$q!Q![4n![!]4n!]!^$q!^!_(o!_!c$q!c!}4n!}#R$q#R#S4n#S#T$q#T#o4n#o$}$q$}%O4n%O%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U4n4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Je$q$Je$Jg4n$Jg$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qo8RP;=`<%l4ni8]Y|W!O`Oq(oqr8{rs&osv(owx'}x!a(o!a!b!#U!b;'S(o;'S;=`)]<%lO(oi9S_|W!O`Or(ors&osv(owx'}x}(o}!O:R!O!f(o!f!g;e!g!}(o!}#ODh#O#W(o#W#XLp#X;'S(o;'S;=`)]<%lO(oi:YX|W!O`Or(ors&osv(owx'}x}(o}!O:u!O;'S(o;'S;=`)]<%lO(oi;OV!QP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oi;lX|W!O`Or(ors&osv(owx'}x!q(o!q!r<X!r;'S(o;'S;=`)]<%lO(oi<`X|W!O`Or(ors&osv(owx'}x!e(o!e!f<{!f;'S(o;'S;=`)]<%lO(oi=SX|W!O`Or(ors&osv(owx'}x!v(o!v!w=o!w;'S(o;'S;=`)]<%lO(oi=vX|W!O`Or(ors&osv(owx'}x!{(o!{!|>c!|;'S(o;'S;=`)]<%lO(oi>jX|W!O`Or(ors&osv(owx'}x!r(o!r!s?V!s;'S(o;'S;=`)]<%lO(oi?^X|W!O`Or(ors&osv(owx'}x!g(o!g!h?y!h;'S(o;'S;=`)]<%lO(oi@QY|W!O`Or?yrs@psv?yvwA[wxBdx!`?y!`!aCr!a;'S?y;'S;=`Db<%lO?ya@uV!O`Ov@pvxA[x!`@p!`!aAy!a;'S@p;'S;=`B^<%lO@pPA_TO!`A[!`!aAn!a;'SA[;'S;=`As<%lOA[PAsOiPPAvP;=`<%lA[aBQSiP!O`Ov&ox;'S&o;'S;=`'Q<%lO&oaBaP;=`<%l@pXBiX|WOrBdrsA[svBdvwA[w!`Bd!`!aCU!a;'SBd;'S;=`Cl<%lOBdXC]TiP|WOr'}sv'}w;'S'};'S;=`(c<%lO'}XCoP;=`<%lBdiC{ViP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiDeP;=`<%l?yiDoZ|W!O`Or(ors&osv(owx'}x!e(o!e!fEb!f#V(o#V#WIr#W;'S(o;'S;=`)]<%lO(oiEiX|W!O`Or(ors&osv(owx'}x!f(o!f!gFU!g;'S(o;'S;=`)]<%lO(oiF]X|W!O`Or(ors&osv(owx'}x!c(o!c!dFx!d;'S(o;'S;=`)]<%lO(oiGPX|W!O`Or(ors&osv(owx'}x!v(o!v!wGl!w;'S(o;'S;=`)]<%lO(oiGsX|W!O`Or(ors&osv(owx'}x!c(o!c!dH`!d;'S(o;'S;=`)]<%lO(oiHgX|W!O`Or(ors&osv(owx'}x!}(o!}#OIS#O;'S(o;'S;=`)]<%lO(oiI]V|W!O`yPOr(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiIyX|W!O`Or(ors&osv(owx'}x#W(o#W#XJf#X;'S(o;'S;=`)]<%lO(oiJmX|W!O`Or(ors&osv(owx'}x#T(o#T#UKY#U;'S(o;'S;=`)]<%lO(oiKaX|W!O`Or(ors&osv(owx'}x#h(o#h#iK|#i;'S(o;'S;=`)]<%lO(oiLTX|W!O`Or(ors&osv(owx'}x#T(o#T#UH`#U;'S(o;'S;=`)]<%lO(oiLwX|W!O`Or(ors&osv(owx'}x#c(o#c#dMd#d;'S(o;'S;=`)]<%lO(oiMkX|W!O`Or(ors&osv(owx'}x#V(o#V#WNW#W;'S(o;'S;=`)]<%lO(oiN_X|W!O`Or(ors&osv(owx'}x#h(o#h#iNz#i;'S(o;'S;=`)]<%lO(oi! RX|W!O`Or(ors&osv(owx'}x#m(o#m#n! n#n;'S(o;'S;=`)]<%lO(oi! uX|W!O`Or(ors&osv(owx'}x#d(o#d#e!!b#e;'S(o;'S;=`)]<%lO(oi!!iX|W!O`Or(ors&osv(owx'}x#X(o#X#Y?y#Y;'S(o;'S;=`)]<%lO(oi!#_V!SP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(ok!$PXaQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo!$wX[UVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!%mZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!&`!a;'S$q;'S;=`)c<%lO$qk!&kX!RQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!'aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_#P$q#P#Q!(S#Q;'S$q;'S;=`)c<%lO$qk!(]ZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!)O!a;'S$q;'S;=`)c<%lO$qk!)ZXxQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$q",
  tokenizers: [cY, hY, uY, dY, 0, 1, 2, 3, 4],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function Il(s, e) {
  let t = e && e.getChild("TagName");
  return t ? s.sliceString(t.from, t.to) : "";
}
function Vu(s, e) {
  let t = e && e.firstChild;
  return !t || t.name != "OpenTag" ? "" : Il(s, t);
}
function gY(s, e, t) {
  let i = e && e.getChildren("Attribute").find((r) => r.from <= t && r.to >= t), n = i && i.getChild("AttributeName");
  return n ? s.sliceString(n.from, n.to) : "";
}
function Fu(s) {
  for (let e = s && s.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function mY(s, e) {
  var t;
  let i = Ie(s).resolveInner(e, -1), n = null;
  for (let r = i; !n && r.parent; r = r.parent)
    (r.name == "OpenTag" || r.name == "CloseTag" || r.name == "SelfClosingTag" || r.name == "MismatchedCloseTag") && (n = r);
  if (n && (n.to > e || n.lastChild.type.isError)) {
    let r = n.parent;
    if (i.name == "TagName")
      return n.name == "CloseTag" || n.name == "MismatchedCloseTag" ? { type: "closeTag", from: i.from, context: r } : { type: "openTag", from: i.from, context: Fu(r) };
    if (i.name == "AttributeName")
      return { type: "attrName", from: i.from, context: n };
    if (i.name == "AttributeValue")
      return { type: "attrValue", from: i.from, context: n };
    let a = i == n || i.name == "Attribute" ? i.childBefore(e) : i;
    return a?.name == "StartTag" ? { type: "openTag", from: e, context: Fu(r) } : a?.name == "StartCloseTag" && a.to <= e ? { type: "closeTag", from: e, context: r } : a?.name == "Is" ? { type: "attrValue", from: e, context: n } : a ? { type: "attrName", from: e, context: n } : null;
  } else if (i.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: i.parent };
  for (; i.parent && i.to == e && !(!((t = i.lastChild) === null || t === void 0) && t.type.isError); )
    i = i.parent;
  return i.name == "Element" || i.name == "Text" || i.name == "Document" ? { type: "tag", from: e, context: i.name == "Element" ? i : Fu(i) } : null;
}
let OY = class {
  constructor(e, t, i) {
    this.attrs = t, this.attrValues = i, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((n) => ({ label: n, type: "text" })) : [];
  }
};
const ju = /^[:\-\.\w\u00b7-\uffff]*$/;
function n0(s) {
  return Object.assign(Object.assign({ type: "property" }, s.completion || {}), { label: s.name });
}
function r0(s) {
  return typeof s == "string" ? { label: `"${s}"`, type: "constant" } : /^"/.test(s.label) ? s : Object.assign(Object.assign({}, s), { label: `"${s.label}"` });
}
function xY(s, e) {
  let t = [], i = [], n = /* @__PURE__ */ Object.create(null);
  for (let l of e) {
    let c = n0(l);
    t.push(c), l.global && i.push(c), l.values && (n[l.name] = l.values.map(r0));
  }
  let r = [], a = [], o = /* @__PURE__ */ Object.create(null);
  for (let l of s) {
    let c = i, h = n;
    l.attributes && (c = c.concat(l.attributes.map((d) => typeof d == "string" ? t.find((f) => f.label == d) || { label: d, type: "property" } : (d.values && (h == n && (h = Object.create(h)), h[d.name] = d.values.map(r0)), n0(d)))));
    let u = new OY(l, c, h);
    o[u.name] = u, r.push(u), l.top && a.push(u);
  }
  a.length || (a = r);
  for (let l = 0; l < r.length; l++) {
    let c = s[l], h = r[l];
    if (c.children)
      for (let u of c.children)
        o[u] && h.children.push(o[u]);
    else
      h.children = r;
  }
  return (l) => {
    var c;
    let { doc: h } = l.state, u = mY(l.state, l.pos);
    if (!u || u.type == "tag" && !l.explicit)
      return null;
    let { type: d, from: f, context: p } = u;
    if (d == "openTag") {
      let g = a, m = Vu(h, p);
      if (m) {
        let O = o[m];
        g = O?.children || r;
      }
      return {
        from: f,
        options: g.map((O) => O.completion),
        validFor: ju
      };
    } else if (d == "closeTag") {
      let g = Vu(h, p);
      return g ? {
        from: f,
        to: l.pos + (h.sliceString(l.pos, l.pos + 1) == ">" ? 1 : 0),
        options: [((c = o[g]) === null || c === void 0 ? void 0 : c.closeNameCompletion) || { label: g + ">", type: "type" }],
        validFor: ju
      } : null;
    } else if (d == "attrName") {
      let g = o[Il(h, p)];
      return {
        from: f,
        options: g?.attrs || i,
        validFor: ju
      };
    } else if (d == "attrValue") {
      let g = gY(h, p, f);
      if (!g)
        return null;
      let m = o[Il(h, p)], O = (m?.attrValues || n)[g];
      return !O || !O.length ? null : {
        from: f,
        to: l.pos + (h.sliceString(l.pos, l.pos + 1) == '"' ? 1 : 0),
        options: O,
        validFor: /^"[^"]*"?$/
      };
    } else if (d == "tag") {
      let g = Vu(h, p), m = o[g], O = [], x = p && p.lastChild;
      g && (!x || x.name != "CloseTag" || Il(h, x) != g) && O.push(m ? m.closeCompletion : { label: "</" + g + ">", type: "type", boost: 2 });
      let b = O.concat((m?.children || (p ? r : a)).map((v) => v.openCompletion));
      if (p && m?.text.length) {
        let v = p.firstChild;
        v.to > l.pos - 20 && !/\S/.test(l.state.sliceDoc(v.to, l.pos)) && (b = b.concat(m.text));
      }
      return {
        from: f,
        options: b,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
const sp = /* @__PURE__ */ Ei.define({
  name: "xml",
  parser: /* @__PURE__ */ pY.configure({
    props: [
      /* @__PURE__ */ rs.add({
        Element(s) {
          let e = /^\s*<\//.test(s.textAfter);
          return s.lineIndent(s.node.from) + (e ? 0 : s.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(s) {
          return s.column(s.node.from) + s.unit;
        }
      }),
      /* @__PURE__ */ Li.add({
        Element(s) {
          let e = s.firstChild, t = s.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : s.to };
        }
      }),
      /* @__PURE__ */ dg.add({
        "OpenTag CloseTag": (s) => s.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function bY(s = {}) {
  let e = [sp.data.of({
    autocomplete: xY(s.elements || [], s.attributes || [])
  })];
  return s.autoCloseTags !== !1 && e.push(yY), new is(sp, e);
}
function a0(s, e, t = s.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? s.sliceString(n.from, Math.min(n.to, t)) : "";
}
const yY = /* @__PURE__ */ J.inputHandler.of((s, e, t, i, n) => {
  if (s.composing || s.state.readOnly || e != t || i != ">" && i != "/" || !sp.isActiveAt(s.state, e, -1))
    return !1;
  let r = n(), { state: a } = r, o = a.changeByRange((l) => {
    var c, h, u;
    let { head: d } = l, f = a.doc.sliceString(d - 1, d) == i, p = Ie(a).resolveInner(d, -1), g;
    if (f && i == ">" && p.name == "EndTag") {
      let m = p.parent;
      if (((h = (c = m.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (g = a0(a.doc, m.parent, d))) {
        let O = d + (a.doc.sliceString(d, d + 1) === ">" ? 1 : 0), x = `</${g}>`;
        return { range: l, changes: { from: d, to: O, insert: x } };
      }
    } else if (f && i == "/" && p.name == "StartCloseTag") {
      let m = p.parent;
      if (p.from == d - 2 && ((u = m.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (g = a0(a.doc, m, d))) {
        let O = d + (a.doc.sliceString(d, d + 1) === ">" ? 1 : 0), x = `${g}>`;
        return {
          range: D.cursor(d + x.length, -1),
          changes: { from: d, to: O, insert: x }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (s.dispatch([
    r,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), vY = _i({
  String: Q.string,
  Number: Q.number,
  "True False": Q.bool,
  PropertyName: Q.propertyName,
  Null: Q.null,
  ", :": Q.separator,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
}), wY = Xi.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [vY],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), SY = /* @__PURE__ */ Ei.define({
  name: "json",
  parser: /* @__PURE__ */ wY.configure({
    props: [
      /* @__PURE__ */ rs.add({
        Object: /* @__PURE__ */ xn({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ xn({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Li.add({
        "Object Array": ko
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function kY() {
  return new is(SY);
}
function PY(s) {
  switch (s.split(".").pop()?.toLowerCase()) {
    case "js":
    case "ts":
    case "tsx":
    case "jsx":
    case "cjs":
    case "mjs":
    case "ejs":
    case "prisma":
      return XS();
    case "json":
      return kY();
    case "html":
    case "hbs":
      return Qk();
    case "css":
      return Ok();
    case "md":
      return pD();
    case "xml":
      return bY();
    case "py":
      return yW();
    case "yml":
    case "yaml":
      return UW();
    case "sql":
      return nB();
    //case "hbs":
    //return handlebarsLanguage();
    default:
      return [];
  }
}
const QY = J.theme(
  {
    "&": {
      backgroundColor: "#171717",
      height: "100%",
      color: "#f5f5f5"
    },
    ".cm-content": {
      caretColor: "#f4f4f5"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: "#f4f4f5"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#3f3f46"
    },
    ".cm-gutters": {
      backgroundColor: "#171717",
      color: "#a3a3a3",
      border: "none"
    }
  },
  { dark: !0 }
), CY = J.theme(
  {
    "&": {
      backgroundColor: "#ffffff",
      height: "100%",
      color: "#1f2937"
    },
    ".cm-content": {
      caretColor: "#111827"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: "#111827"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#e5e7eb"
    },
    ".cm-gutters": {
      backgroundColor: "#f9fafb",
      color: "#9ca3af",
      border: "none"
    }
  },
  { dark: !1 }
), AY = Er.define([
  { tag: Q.keyword, color: "#22d3ee" },
  { tag: [Q.name, Q.deleted, Q.character, Q.propertyName], color: "#f87171" },
  { tag: [Q.variableName], color: "#e4e4e7" },
  { tag: [Q.string, Q.meta], color: "#86efac" },
  { tag: [Q.function(Q.variableName)], color: "#c4b5fd" },
  { tag: [Q.number], color: "#facc15" },
  { tag: [Q.comment], color: "#71717a", fontStyle: "italic" }
]), TY = Er.define([
  { tag: Q.keyword, color: "#0ea5e9" },
  { tag: [Q.name, Q.deleted, Q.character, Q.propertyName], color: "#b91c1c" },
  { tag: [Q.variableName], color: "#374151" },
  { tag: [Q.string, Q.meta], color: "#16a34a" },
  { tag: [Q.function(Q.variableName)], color: "#7c3aed" },
  { tag: [Q.number], color: "#ca8a04" },
  { tag: [Q.comment], color: "#6b7280", fontStyle: "italic" }
]);
function $Y(s) {
  return [
    s === "dark" ? QY : CY,
    x1(s === "dark" ? AY : TY)
  ];
}
function iP(s, e) {
  return function() {
    return s.apply(e, arguments);
  };
}
const { toString: RY } = Object.prototype, { getPrototypeOf: Vg } = Object, { iterator: dh, toStringTag: sP } = Symbol, fh = /* @__PURE__ */ ((s) => (e) => {
  const t = RY.call(e);
  return s[t] || (s[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ii = (s) => (s = s.toLowerCase(), (e) => fh(e) === s), ph = (s) => (e) => typeof e === s, { isArray: Lr } = Array, no = ph("undefined");
function EY(s) {
  return s !== null && !no(s) && s.constructor !== null && !no(s.constructor) && Zt(s.constructor.isBuffer) && s.constructor.isBuffer(s);
}
const nP = Ii("ArrayBuffer");
function XY(s) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(s) : e = s && s.buffer && nP(s.buffer), e;
}
const MY = ph("string"), Zt = ph("function"), rP = ph("number"), gh = (s) => s !== null && typeof s == "object", _Y = (s) => s === !0 || s === !1, ql = (s) => {
  if (fh(s) !== "object")
    return !1;
  const e = Vg(s);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(sP in s) && !(dh in s);
}, LY = Ii("Date"), zY = Ii("File"), IY = Ii("Blob"), qY = Ii("FileList"), DY = (s) => gh(s) && Zt(s.pipe), BY = (s) => {
  let e;
  return s && (typeof FormData == "function" && s instanceof FormData || Zt(s.append) && ((e = fh(s)) === "formdata" || // detect form-data instance
  e === "object" && Zt(s.toString) && s.toString() === "[object FormData]"));
}, WY = Ii("URLSearchParams"), [YY, ZY, NY, VY] = ["ReadableStream", "Request", "Response", "Headers"].map(Ii), FY = (s) => s.trim ? s.trim() : s.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function $o(s, e, { allOwnKeys: t = !1 } = {}) {
  if (s === null || typeof s > "u")
    return;
  let i, n;
  if (typeof s != "object" && (s = [s]), Lr(s))
    for (i = 0, n = s.length; i < n; i++)
      e.call(null, s[i], i, s);
  else {
    const r = t ? Object.getOwnPropertyNames(s) : Object.keys(s), a = r.length;
    let o;
    for (i = 0; i < a; i++)
      o = r[i], e.call(null, s[o], o, s);
  }
}
function aP(s, e) {
  e = e.toLowerCase();
  const t = Object.keys(s);
  let i = t.length, n;
  for (; i-- > 0; )
    if (n = t[i], e === n.toLowerCase())
      return n;
  return null;
}
const pn = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, oP = (s) => !no(s) && s !== pn;
function np() {
  const { caseless: s } = oP(this) && this || {}, e = {}, t = (i, n) => {
    const r = s && aP(e, n) || n;
    ql(e[r]) && ql(i) ? e[r] = np(e[r], i) : ql(i) ? e[r] = np({}, i) : Lr(i) ? e[r] = i.slice() : e[r] = i;
  };
  for (let i = 0, n = arguments.length; i < n; i++)
    arguments[i] && $o(arguments[i], t);
  return e;
}
const jY = (s, e, t, { allOwnKeys: i } = {}) => ($o(e, (n, r) => {
  t && Zt(n) ? s[r] = iP(n, t) : s[r] = n;
}, { allOwnKeys: i }), s), HY = (s) => (s.charCodeAt(0) === 65279 && (s = s.slice(1)), s), UY = (s, e, t, i) => {
  s.prototype = Object.create(e.prototype, i), s.prototype.constructor = s, Object.defineProperty(s, "super", {
    value: e.prototype
  }), t && Object.assign(s.prototype, t);
}, GY = (s, e, t, i) => {
  let n, r, a;
  const o = {};
  if (e = e || {}, s == null) return e;
  do {
    for (n = Object.getOwnPropertyNames(s), r = n.length; r-- > 0; )
      a = n[r], (!i || i(a, s, e)) && !o[a] && (e[a] = s[a], o[a] = !0);
    s = t !== !1 && Vg(s);
  } while (s && (!t || t(s, e)) && s !== Object.prototype);
  return e;
}, KY = (s, e, t) => {
  s = String(s), (t === void 0 || t > s.length) && (t = s.length), t -= e.length;
  const i = s.indexOf(e, t);
  return i !== -1 && i === t;
}, JY = (s) => {
  if (!s) return null;
  if (Lr(s)) return s;
  let e = s.length;
  if (!rP(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = s[e];
  return t;
}, e4 = /* @__PURE__ */ ((s) => (e) => s && e instanceof s)(typeof Uint8Array < "u" && Vg(Uint8Array)), t4 = (s, e) => {
  const i = (s && s[dh]).call(s);
  let n;
  for (; (n = i.next()) && !n.done; ) {
    const r = n.value;
    e.call(s, r[0], r[1]);
  }
}, i4 = (s, e) => {
  let t;
  const i = [];
  for (; (t = s.exec(e)) !== null; )
    i.push(t);
  return i;
}, s4 = Ii("HTMLFormElement"), n4 = (s) => s.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, i, n) {
    return i.toUpperCase() + n;
  }
), o0 = (({ hasOwnProperty: s }) => (e, t) => s.call(e, t))(Object.prototype), r4 = Ii("RegExp"), lP = (s, e) => {
  const t = Object.getOwnPropertyDescriptors(s), i = {};
  $o(t, (n, r) => {
    let a;
    (a = e(n, r, s)) !== !1 && (i[r] = a || n);
  }), Object.defineProperties(s, i);
}, a4 = (s) => {
  lP(s, (e, t) => {
    if (Zt(s) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const i = s[t];
    if (Zt(i)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, o4 = (s, e) => {
  const t = {}, i = (n) => {
    n.forEach((r) => {
      t[r] = !0;
    });
  };
  return Lr(s) ? i(s) : i(String(s).split(e)), t;
}, l4 = () => {
}, c4 = (s, e) => s != null && Number.isFinite(s = +s) ? s : e;
function h4(s) {
  return !!(s && Zt(s.append) && s[sP] === "FormData" && s[dh]);
}
const u4 = (s) => {
  const e = new Array(10), t = (i, n) => {
    if (gh(i)) {
      if (e.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        e[n] = i;
        const r = Lr(i) ? [] : {};
        return $o(i, (a, o) => {
          const l = t(a, n + 1);
          !no(l) && (r[o] = l);
        }), e[n] = void 0, r;
      }
    }
    return i;
  };
  return t(s, 0);
}, d4 = Ii("AsyncFunction"), f4 = (s) => s && (gh(s) || Zt(s)) && Zt(s.then) && Zt(s.catch), cP = ((s, e) => s ? setImmediate : e ? ((t, i) => (pn.addEventListener("message", ({ source: n, data: r }) => {
  n === pn && r === t && i.length && i.shift()();
}, !1), (n) => {
  i.push(n), pn.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(
  typeof setImmediate == "function",
  Zt(pn.postMessage)
), p4 = typeof queueMicrotask < "u" ? queueMicrotask.bind(pn) : typeof process < "u" && process.nextTick || cP, g4 = (s) => s != null && Zt(s[dh]), L = {
  isArray: Lr,
  isArrayBuffer: nP,
  isBuffer: EY,
  isFormData: BY,
  isArrayBufferView: XY,
  isString: MY,
  isNumber: rP,
  isBoolean: _Y,
  isObject: gh,
  isPlainObject: ql,
  isReadableStream: YY,
  isRequest: ZY,
  isResponse: NY,
  isHeaders: VY,
  isUndefined: no,
  isDate: LY,
  isFile: zY,
  isBlob: IY,
  isRegExp: r4,
  isFunction: Zt,
  isStream: DY,
  isURLSearchParams: WY,
  isTypedArray: e4,
  isFileList: qY,
  forEach: $o,
  merge: np,
  extend: jY,
  trim: FY,
  stripBOM: HY,
  inherits: UY,
  toFlatObject: GY,
  kindOf: fh,
  kindOfTest: Ii,
  endsWith: KY,
  toArray: JY,
  forEachEntry: t4,
  matchAll: i4,
  isHTMLForm: s4,
  hasOwnProperty: o0,
  hasOwnProp: o0,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: lP,
  freezeMethods: a4,
  toObjectSet: o4,
  toCamelCase: n4,
  noop: l4,
  toFiniteNumber: c4,
  findKey: aP,
  global: pn,
  isContextDefined: oP,
  isSpecCompliantForm: h4,
  toJSONObject: u4,
  isAsyncFn: d4,
  isThenable: f4,
  setImmediate: cP,
  asap: p4,
  isIterable: g4
};
function ye(s, e, t, i, n) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = s, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), i && (this.request = i), n && (this.response = n, this.status = n.status ? n.status : null);
}
L.inherits(ye, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: L.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const hP = ye.prototype, uP = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((s) => {
  uP[s] = { value: s };
});
Object.defineProperties(ye, uP);
Object.defineProperty(hP, "isAxiosError", { value: !0 });
ye.from = (s, e, t, i, n, r) => {
  const a = Object.create(hP);
  return L.toFlatObject(s, a, function(l) {
    return l !== Error.prototype;
  }, (o) => o !== "isAxiosError"), ye.call(a, s.message, e, t, i, n), a.cause = s, a.name = s.name, r && Object.assign(a, r), a;
};
const m4 = null;
function rp(s) {
  return L.isPlainObject(s) || L.isArray(s);
}
function dP(s) {
  return L.endsWith(s, "[]") ? s.slice(0, -2) : s;
}
function l0(s, e, t) {
  return s ? s.concat(e).map(function(n, r) {
    return n = dP(n), !t && r ? "[" + n + "]" : n;
  }).join(t ? "." : "") : e;
}
function O4(s) {
  return L.isArray(s) && !s.some(rp);
}
const x4 = L.toFlatObject(L, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function mh(s, e, t) {
  if (!L.isObject(s))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = L.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, m) {
    return !L.isUndefined(m[g]);
  });
  const i = t.metaTokens, n = t.visitor || h, r = t.dots, a = t.indexes, l = (t.Blob || typeof Blob < "u" && Blob) && L.isSpecCompliantForm(e);
  if (!L.isFunction(n))
    throw new TypeError("visitor must be a function");
  function c(p) {
    if (p === null) return "";
    if (L.isDate(p))
      return p.toISOString();
    if (!l && L.isBlob(p))
      throw new ye("Blob is not supported. Use a Buffer instead.");
    return L.isArrayBuffer(p) || L.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function h(p, g, m) {
    let O = p;
    if (p && !m && typeof p == "object") {
      if (L.endsWith(g, "{}"))
        g = i ? g : g.slice(0, -2), p = JSON.stringify(p);
      else if (L.isArray(p) && O4(p) || (L.isFileList(p) || L.endsWith(g, "[]")) && (O = L.toArray(p)))
        return g = dP(g), O.forEach(function(b, v) {
          !(L.isUndefined(b) || b === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? l0([g], v, r) : a === null ? g : g + "[]",
            c(b)
          );
        }), !1;
    }
    return rp(p) ? !0 : (e.append(l0(m, g, r), c(p)), !1);
  }
  const u = [], d = Object.assign(x4, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: rp
  });
  function f(p, g) {
    if (!L.isUndefined(p)) {
      if (u.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      u.push(p), L.forEach(p, function(O, x) {
        (!(L.isUndefined(O) || O === null) && n.call(
          e,
          O,
          L.isString(x) ? x.trim() : x,
          g,
          d
        )) === !0 && f(O, g ? g.concat(x) : [x]);
      }), u.pop();
    }
  }
  if (!L.isObject(s))
    throw new TypeError("data must be an object");
  return f(s), e;
}
function c0(s) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(s).replace(/[!'()~]|%20|%00/g, function(i) {
    return e[i];
  });
}
function Fg(s, e) {
  this._pairs = [], s && mh(s, this, e);
}
const fP = Fg.prototype;
fP.append = function(e, t) {
  this._pairs.push([e, t]);
};
fP.toString = function(e) {
  const t = e ? function(i) {
    return e.call(this, i, c0);
  } : c0;
  return this._pairs.map(function(n) {
    return t(n[0]) + "=" + t(n[1]);
  }, "").join("&");
};
function b4(s) {
  return encodeURIComponent(s).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function pP(s, e, t) {
  if (!e)
    return s;
  const i = t && t.encode || b4;
  L.isFunction(t) && (t = {
    serialize: t
  });
  const n = t && t.serialize;
  let r;
  if (n ? r = n(e, t) : r = L.isURLSearchParams(e) ? e.toString() : new Fg(e, t).toString(i), r) {
    const a = s.indexOf("#");
    a !== -1 && (s = s.slice(0, a)), s += (s.indexOf("?") === -1 ? "?" : "&") + r;
  }
  return s;
}
class h0 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, i) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    L.forEach(this.handlers, function(i) {
      i !== null && e(i);
    });
  }
}
const gP = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, y4 = typeof URLSearchParams < "u" ? URLSearchParams : Fg, v4 = typeof FormData < "u" ? FormData : null, w4 = typeof Blob < "u" ? Blob : null, S4 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: y4,
    FormData: v4,
    Blob: w4
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, jg = typeof window < "u" && typeof document < "u", ap = typeof navigator == "object" && navigator || void 0, k4 = jg && (!ap || ["ReactNative", "NativeScript", "NS"].indexOf(ap.product) < 0), P4 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Q4 = jg && window.location.href || "http://localhost", C4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: jg,
  hasStandardBrowserEnv: k4,
  hasStandardBrowserWebWorkerEnv: P4,
  navigator: ap,
  origin: Q4
}, Symbol.toStringTag, { value: "Module" })), At = {
  ...C4,
  ...S4
};
function A4(s, e) {
  return mh(s, new At.classes.URLSearchParams(), Object.assign({
    visitor: function(t, i, n, r) {
      return At.isNode && L.isBuffer(t) ? (this.append(i, t.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function T4(s) {
  return L.matchAll(/\w+|\[(\w*)]/g, s).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function $4(s) {
  const e = {}, t = Object.keys(s);
  let i;
  const n = t.length;
  let r;
  for (i = 0; i < n; i++)
    r = t[i], e[r] = s[r];
  return e;
}
function mP(s) {
  function e(t, i, n, r) {
    let a = t[r++];
    if (a === "__proto__") return !0;
    const o = Number.isFinite(+a), l = r >= t.length;
    return a = !a && L.isArray(n) ? n.length : a, l ? (L.hasOwnProp(n, a) ? n[a] = [n[a], i] : n[a] = i, !o) : ((!n[a] || !L.isObject(n[a])) && (n[a] = []), e(t, i, n[a], r) && L.isArray(n[a]) && (n[a] = $4(n[a])), !o);
  }
  if (L.isFormData(s) && L.isFunction(s.entries)) {
    const t = {};
    return L.forEachEntry(s, (i, n) => {
      e(T4(i), n, t, 0);
    }), t;
  }
  return null;
}
function R4(s, e, t) {
  if (L.isString(s))
    try {
      return (e || JSON.parse)(s), L.trim(s);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (t || JSON.stringify)(s);
}
const Ro = {
  transitional: gP,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const i = t.getContentType() || "", n = i.indexOf("application/json") > -1, r = L.isObject(e);
    if (r && L.isHTMLForm(e) && (e = new FormData(e)), L.isFormData(e))
      return n ? JSON.stringify(mP(e)) : e;
    if (L.isArrayBuffer(e) || L.isBuffer(e) || L.isStream(e) || L.isFile(e) || L.isBlob(e) || L.isReadableStream(e))
      return e;
    if (L.isArrayBufferView(e))
      return e.buffer;
    if (L.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (r) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return A4(e, this.formSerializer).toString();
      if ((o = L.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return mh(
          o ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return r || n ? (t.setContentType("application/json", !1), R4(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Ro.transitional, i = t && t.forcedJSONParsing, n = this.responseType === "json";
    if (L.isResponse(e) || L.isReadableStream(e))
      return e;
    if (e && L.isString(e) && (i && !this.responseType || n)) {
      const a = !(t && t.silentJSONParsing) && n;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (a)
          throw o.name === "SyntaxError" ? ye.from(o, ye.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: At.classes.FormData,
    Blob: At.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
L.forEach(["delete", "get", "head", "post", "put", "patch"], (s) => {
  Ro.headers[s] = {};
});
const E4 = L.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), X4 = (s) => {
  const e = {};
  let t, i, n;
  return s && s.split(`
`).forEach(function(a) {
    n = a.indexOf(":"), t = a.substring(0, n).trim().toLowerCase(), i = a.substring(n + 1).trim(), !(!t || e[t] && E4[t]) && (t === "set-cookie" ? e[t] ? e[t].push(i) : e[t] = [i] : e[t] = e[t] ? e[t] + ", " + i : i);
  }), e;
}, u0 = Symbol("internals");
function Jr(s) {
  return s && String(s).trim().toLowerCase();
}
function Dl(s) {
  return s === !1 || s == null ? s : L.isArray(s) ? s.map(Dl) : String(s);
}
function M4(s) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = t.exec(s); )
    e[i[1]] = i[2];
  return e;
}
const _4 = (s) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(s.trim());
function Hu(s, e, t, i, n) {
  if (L.isFunction(i))
    return i.call(this, e, t);
  if (n && (e = t), !!L.isString(e)) {
    if (L.isString(i))
      return e.indexOf(i) !== -1;
    if (L.isRegExp(i))
      return i.test(e);
  }
}
function L4(s) {
  return s.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function z4(s, e) {
  const t = L.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(s, i + t, {
      value: function(n, r, a) {
        return this[i].call(this, e, n, r, a);
      },
      configurable: !0
    });
  });
}
let Nt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const n = this;
    function r(o, l, c) {
      const h = Jr(l);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const u = L.findKey(n, h);
      (!u || n[u] === void 0 || c === !0 || c === void 0 && n[u] !== !1) && (n[u || l] = Dl(o));
    }
    const a = (o, l) => L.forEach(o, (c, h) => r(c, h, l));
    if (L.isPlainObject(e) || e instanceof this.constructor)
      a(e, t);
    else if (L.isString(e) && (e = e.trim()) && !_4(e))
      a(X4(e), t);
    else if (L.isObject(e) && L.isIterable(e)) {
      let o = {}, l, c;
      for (const h of e) {
        if (!L.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        o[c = h[0]] = (l = o[c]) ? L.isArray(l) ? [...l, h[1]] : [l, h[1]] : h[1];
      }
      a(o, t);
    } else
      e != null && r(t, e, i);
    return this;
  }
  get(e, t) {
    if (e = Jr(e), e) {
      const i = L.findKey(this, e);
      if (i) {
        const n = this[i];
        if (!t)
          return n;
        if (t === !0)
          return M4(n);
        if (L.isFunction(t))
          return t.call(this, n, i);
        if (L.isRegExp(t))
          return t.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Jr(e), e) {
      const i = L.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || Hu(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let n = !1;
    function r(a) {
      if (a = Jr(a), a) {
        const o = L.findKey(i, a);
        o && (!t || Hu(i, i[o], o, t)) && (delete i[o], n = !0);
      }
    }
    return L.isArray(e) ? e.forEach(r) : r(e), n;
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length, n = !1;
    for (; i--; ) {
      const r = t[i];
      (!e || Hu(this, this[r], r, e, !0)) && (delete this[r], n = !0);
    }
    return n;
  }
  normalize(e) {
    const t = this, i = {};
    return L.forEach(this, (n, r) => {
      const a = L.findKey(i, r);
      if (a) {
        t[a] = Dl(n), delete t[r];
        return;
      }
      const o = e ? L4(r) : String(r).trim();
      o !== r && delete t[r], t[o] = Dl(n), i[o] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return L.forEach(this, (i, n) => {
      i != null && i !== !1 && (t[n] = e && L.isArray(i) ? i.join(", ") : i);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const i = new this(e);
    return t.forEach((n) => i.set(n)), i;
  }
  static accessor(e) {
    const i = (this[u0] = this[u0] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function r(a) {
      const o = Jr(a);
      i[o] || (z4(n, a), i[o] = !0);
    }
    return L.isArray(e) ? e.forEach(r) : r(e), this;
  }
};
Nt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
L.reduceDescriptors(Nt.prototype, ({ value: s }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => s,
    set(i) {
      this[t] = i;
    }
  };
});
L.freezeMethods(Nt);
function Uu(s, e) {
  const t = this || Ro, i = e || t, n = Nt.from(i.headers);
  let r = i.data;
  return L.forEach(s, function(o) {
    r = o.call(t, r, n.normalize(), e ? e.status : void 0);
  }), n.normalize(), r;
}
function OP(s) {
  return !!(s && s.__CANCEL__);
}
function zr(s, e, t) {
  ye.call(this, s ?? "canceled", ye.ERR_CANCELED, e, t), this.name = "CanceledError";
}
L.inherits(zr, ye, {
  __CANCEL__: !0
});
function xP(s, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status) ? s(t) : e(new ye(
    "Request failed with status code " + t.status,
    [ye.ERR_BAD_REQUEST, ye.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
function I4(s) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(s);
  return e && e[1] || "";
}
function q4(s, e) {
  s = s || 10;
  const t = new Array(s), i = new Array(s);
  let n = 0, r = 0, a;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const c = Date.now(), h = i[r];
    a || (a = c), t[n] = l, i[n] = c;
    let u = r, d = 0;
    for (; u !== n; )
      d += t[u++], u = u % s;
    if (n = (n + 1) % s, n === r && (r = (r + 1) % s), c - a < e)
      return;
    const f = h && c - h;
    return f ? Math.round(d * 1e3 / f) : void 0;
  };
}
function D4(s, e) {
  let t = 0, i = 1e3 / e, n, r;
  const a = (c, h = Date.now()) => {
    t = h, n = null, r && (clearTimeout(r), r = null), s.apply(null, c);
  };
  return [(...c) => {
    const h = Date.now(), u = h - t;
    u >= i ? a(c, h) : (n = c, r || (r = setTimeout(() => {
      r = null, a(n);
    }, i - u)));
  }, () => n && a(n)];
}
const Lc = (s, e, t = 3) => {
  let i = 0;
  const n = q4(50, 250);
  return D4((r) => {
    const a = r.loaded, o = r.lengthComputable ? r.total : void 0, l = a - i, c = n(l), h = a <= o;
    i = a;
    const u = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && o && h ? (o - a) / c : void 0,
      event: r,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    s(u);
  }, t);
}, d0 = (s, e) => {
  const t = s != null;
  return [(i) => e[0]({
    lengthComputable: t,
    total: s,
    loaded: i
  }), e[1]];
}, f0 = (s) => (...e) => L.asap(() => s(...e)), B4 = At.hasStandardBrowserEnv ? /* @__PURE__ */ ((s, e) => (t) => (t = new URL(t, At.origin), s.protocol === t.protocol && s.host === t.host && (e || s.port === t.port)))(
  new URL(At.origin),
  At.navigator && /(msie|trident)/i.test(At.navigator.userAgent)
) : () => !0, W4 = At.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(s, e, t, i, n, r) {
      const a = [s + "=" + encodeURIComponent(e)];
      L.isNumber(t) && a.push("expires=" + new Date(t).toGMTString()), L.isString(i) && a.push("path=" + i), L.isString(n) && a.push("domain=" + n), r === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(s) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + s + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(s) {
      this.write(s, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function Y4(s) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(s);
}
function Z4(s, e) {
  return e ? s.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : s;
}
function bP(s, e, t) {
  let i = !Y4(e);
  return s && (i || t == !1) ? Z4(s, e) : e;
}
const p0 = (s) => s instanceof Nt ? { ...s } : s;
function En(s, e) {
  e = e || {};
  const t = {};
  function i(c, h, u, d) {
    return L.isPlainObject(c) && L.isPlainObject(h) ? L.merge.call({ caseless: d }, c, h) : L.isPlainObject(h) ? L.merge({}, h) : L.isArray(h) ? h.slice() : h;
  }
  function n(c, h, u, d) {
    if (L.isUndefined(h)) {
      if (!L.isUndefined(c))
        return i(void 0, c, u, d);
    } else return i(c, h, u, d);
  }
  function r(c, h) {
    if (!L.isUndefined(h))
      return i(void 0, h);
  }
  function a(c, h) {
    if (L.isUndefined(h)) {
      if (!L.isUndefined(c))
        return i(void 0, c);
    } else return i(void 0, h);
  }
  function o(c, h, u) {
    if (u in e)
      return i(c, h);
    if (u in s)
      return i(void 0, c);
  }
  const l = {
    url: r,
    method: r,
    data: r,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (c, h, u) => n(p0(c), p0(h), u, !0)
  };
  return L.forEach(Object.keys(Object.assign({}, s, e)), function(h) {
    const u = l[h] || n, d = u(s[h], e[h], h);
    L.isUndefined(d) && u !== o || (t[h] = d);
  }), t;
}
const yP = (s) => {
  const e = En({}, s);
  let { data: t, withXSRFToken: i, xsrfHeaderName: n, xsrfCookieName: r, headers: a, auth: o } = e;
  e.headers = a = Nt.from(a), e.url = pP(bP(e.baseURL, e.url, e.allowAbsoluteUrls), s.params, s.paramsSerializer), o && a.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let l;
  if (L.isFormData(t)) {
    if (At.hasStandardBrowserEnv || At.hasStandardBrowserWebWorkerEnv)
      a.setContentType(void 0);
    else if ((l = a.getContentType()) !== !1) {
      const [c, ...h] = l ? l.split(";").map((u) => u.trim()).filter(Boolean) : [];
      a.setContentType([c || "multipart/form-data", ...h].join("; "));
    }
  }
  if (At.hasStandardBrowserEnv && (i && L.isFunction(i) && (i = i(e)), i || i !== !1 && B4(e.url))) {
    const c = n && r && W4.read(r);
    c && a.set(n, c);
  }
  return e;
}, N4 = typeof XMLHttpRequest < "u", V4 = N4 && function(s) {
  return new Promise(function(t, i) {
    const n = yP(s);
    let r = n.data;
    const a = Nt.from(n.headers).normalize();
    let { responseType: o, onUploadProgress: l, onDownloadProgress: c } = n, h, u, d, f, p;
    function g() {
      f && f(), p && p(), n.cancelToken && n.cancelToken.unsubscribe(h), n.signal && n.signal.removeEventListener("abort", h);
    }
    let m = new XMLHttpRequest();
    m.open(n.method.toUpperCase(), n.url, !0), m.timeout = n.timeout;
    function O() {
      if (!m)
        return;
      const b = Nt.from(
        "getAllResponseHeaders" in m && m.getAllResponseHeaders()
      ), y = {
        data: !o || o === "text" || o === "json" ? m.responseText : m.response,
        status: m.status,
        statusText: m.statusText,
        headers: b,
        config: s,
        request: m
      };
      xP(function(S) {
        t(S), g();
      }, function(S) {
        i(S), g();
      }, y), m = null;
    }
    "onloadend" in m ? m.onloadend = O : m.onreadystatechange = function() {
      !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(O);
    }, m.onabort = function() {
      m && (i(new ye("Request aborted", ye.ECONNABORTED, s, m)), m = null);
    }, m.onerror = function() {
      i(new ye("Network Error", ye.ERR_NETWORK, s, m)), m = null;
    }, m.ontimeout = function() {
      let v = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const y = n.transitional || gP;
      n.timeoutErrorMessage && (v = n.timeoutErrorMessage), i(new ye(
        v,
        y.clarifyTimeoutError ? ye.ETIMEDOUT : ye.ECONNABORTED,
        s,
        m
      )), m = null;
    }, r === void 0 && a.setContentType(null), "setRequestHeader" in m && L.forEach(a.toJSON(), function(v, y) {
      m.setRequestHeader(y, v);
    }), L.isUndefined(n.withCredentials) || (m.withCredentials = !!n.withCredentials), o && o !== "json" && (m.responseType = n.responseType), c && ([d, p] = Lc(c, !0), m.addEventListener("progress", d)), l && m.upload && ([u, f] = Lc(l), m.upload.addEventListener("progress", u), m.upload.addEventListener("loadend", f)), (n.cancelToken || n.signal) && (h = (b) => {
      m && (i(!b || b.type ? new zr(null, s, m) : b), m.abort(), m = null);
    }, n.cancelToken && n.cancelToken.subscribe(h), n.signal && (n.signal.aborted ? h() : n.signal.addEventListener("abort", h)));
    const x = I4(n.url);
    if (x && At.protocols.indexOf(x) === -1) {
      i(new ye("Unsupported protocol " + x + ":", ye.ERR_BAD_REQUEST, s));
      return;
    }
    m.send(r || null);
  });
}, F4 = (s, e) => {
  const { length: t } = s = s ? s.filter(Boolean) : [];
  if (e || t) {
    let i = new AbortController(), n;
    const r = function(c) {
      if (!n) {
        n = !0, o();
        const h = c instanceof Error ? c : this.reason;
        i.abort(h instanceof ye ? h : new zr(h instanceof Error ? h.message : h));
      }
    };
    let a = e && setTimeout(() => {
      a = null, r(new ye(`timeout ${e} of ms exceeded`, ye.ETIMEDOUT));
    }, e);
    const o = () => {
      s && (a && clearTimeout(a), a = null, s.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(r) : c.removeEventListener("abort", r);
      }), s = null);
    };
    s.forEach((c) => c.addEventListener("abort", r));
    const { signal: l } = i;
    return l.unsubscribe = () => L.asap(o), l;
  }
}, j4 = function* (s, e) {
  let t = s.byteLength;
  if (t < e) {
    yield s;
    return;
  }
  let i = 0, n;
  for (; i < t; )
    n = i + e, yield s.slice(i, n), i = n;
}, H4 = async function* (s, e) {
  for await (const t of U4(s))
    yield* j4(t, e);
}, U4 = async function* (s) {
  if (s[Symbol.asyncIterator]) {
    yield* s;
    return;
  }
  const e = s.getReader();
  try {
    for (; ; ) {
      const { done: t, value: i } = await e.read();
      if (t)
        break;
      yield i;
    }
  } finally {
    await e.cancel();
  }
}, g0 = (s, e, t, i) => {
  const n = H4(s, e);
  let r = 0, a, o = (l) => {
    a || (a = !0, i && i(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: h } = await n.next();
        if (c) {
          o(), l.close();
          return;
        }
        let u = h.byteLength;
        if (t) {
          let d = r += u;
          t(d);
        }
        l.enqueue(new Uint8Array(h));
      } catch (c) {
        throw o(c), c;
      }
    },
    cancel(l) {
      return o(l), n.return();
    }
  }, {
    highWaterMark: 2
  });
}, Oh = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", vP = Oh && typeof ReadableStream == "function", G4 = Oh && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((s) => (e) => s.encode(e))(new TextEncoder()) : async (s) => new Uint8Array(await new Response(s).arrayBuffer())), wP = (s, ...e) => {
  try {
    return !!s(...e);
  } catch {
    return !1;
  }
}, K4 = vP && wP(() => {
  let s = !1;
  const e = new Request(At.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return s = !0, "half";
    }
  }).headers.has("Content-Type");
  return s && !e;
}), m0 = 64 * 1024, op = vP && wP(() => L.isReadableStream(new Response("").body)), zc = {
  stream: op && ((s) => s.body)
};
Oh && ((s) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !zc[e] && (zc[e] = L.isFunction(s[e]) ? (t) => t[e]() : (t, i) => {
      throw new ye(`Response type '${e}' is not supported`, ye.ERR_NOT_SUPPORT, i);
    });
  });
})(new Response());
const J4 = async (s) => {
  if (s == null)
    return 0;
  if (L.isBlob(s))
    return s.size;
  if (L.isSpecCompliantForm(s))
    return (await new Request(At.origin, {
      method: "POST",
      body: s
    }).arrayBuffer()).byteLength;
  if (L.isArrayBufferView(s) || L.isArrayBuffer(s))
    return s.byteLength;
  if (L.isURLSearchParams(s) && (s = s + ""), L.isString(s))
    return (await G4(s)).byteLength;
}, eZ = async (s, e) => {
  const t = L.toFiniteNumber(s.getContentLength());
  return t ?? J4(e);
}, tZ = Oh && (async (s) => {
  let {
    url: e,
    method: t,
    data: i,
    signal: n,
    cancelToken: r,
    timeout: a,
    onDownloadProgress: o,
    onUploadProgress: l,
    responseType: c,
    headers: h,
    withCredentials: u = "same-origin",
    fetchOptions: d
  } = yP(s);
  c = c ? (c + "").toLowerCase() : "text";
  let f = F4([n, r && r.toAbortSignal()], a), p;
  const g = f && f.unsubscribe && (() => {
    f.unsubscribe();
  });
  let m;
  try {
    if (l && K4 && t !== "get" && t !== "head" && (m = await eZ(h, i)) !== 0) {
      let y = new Request(e, {
        method: "POST",
        body: i,
        duplex: "half"
      }), w;
      if (L.isFormData(i) && (w = y.headers.get("content-type")) && h.setContentType(w), y.body) {
        const [S, k] = d0(
          m,
          Lc(f0(l))
        );
        i = g0(y.body, m0, S, k);
      }
    }
    L.isString(u) || (u = u ? "include" : "omit");
    const O = "credentials" in Request.prototype;
    p = new Request(e, {
      ...d,
      signal: f,
      method: t.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: i,
      duplex: "half",
      credentials: O ? u : void 0
    });
    let x = await fetch(p);
    const b = op && (c === "stream" || c === "response");
    if (op && (o || b && g)) {
      const y = {};
      ["status", "statusText", "headers"].forEach((A) => {
        y[A] = x[A];
      });
      const w = L.toFiniteNumber(x.headers.get("content-length")), [S, k] = o && d0(
        w,
        Lc(f0(o), !0)
      ) || [];
      x = new Response(
        g0(x.body, m0, S, () => {
          k && k(), g && g();
        }),
        y
      );
    }
    c = c || "text";
    let v = await zc[L.findKey(zc, c) || "text"](x, s);
    return !b && g && g(), await new Promise((y, w) => {
      xP(y, w, {
        data: v,
        headers: Nt.from(x.headers),
        status: x.status,
        statusText: x.statusText,
        config: s,
        request: p
      });
    });
  } catch (O) {
    throw g && g(), O && O.name === "TypeError" && /Load failed|fetch/i.test(O.message) ? Object.assign(
      new ye("Network Error", ye.ERR_NETWORK, s, p),
      {
        cause: O.cause || O
      }
    ) : ye.from(O, O && O.code, s, p);
  }
}), lp = {
  http: m4,
  xhr: V4,
  fetch: tZ
};
L.forEach(lp, (s, e) => {
  if (s) {
    try {
      Object.defineProperty(s, "name", { value: e });
    } catch {
    }
    Object.defineProperty(s, "adapterName", { value: e });
  }
});
const O0 = (s) => `- ${s}`, iZ = (s) => L.isFunction(s) || s === null || s === !1, SP = {
  getAdapter: (s) => {
    s = L.isArray(s) ? s : [s];
    const { length: e } = s;
    let t, i;
    const n = {};
    for (let r = 0; r < e; r++) {
      t = s[r];
      let a;
      if (i = t, !iZ(t) && (i = lp[(a = String(t)).toLowerCase()], i === void 0))
        throw new ye(`Unknown adapter '${a}'`);
      if (i)
        break;
      n[a || "#" + r] = i;
    }
    if (!i) {
      const r = Object.entries(n).map(
        ([o, l]) => `adapter ${o} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = e ? r.length > 1 ? `since :
` + r.map(O0).join(`
`) : " " + O0(r[0]) : "as no adapter specified";
      throw new ye(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return i;
  },
  adapters: lp
};
function Gu(s) {
  if (s.cancelToken && s.cancelToken.throwIfRequested(), s.signal && s.signal.aborted)
    throw new zr(null, s);
}
function x0(s) {
  return Gu(s), s.headers = Nt.from(s.headers), s.data = Uu.call(
    s,
    s.transformRequest
  ), ["post", "put", "patch"].indexOf(s.method) !== -1 && s.headers.setContentType("application/x-www-form-urlencoded", !1), SP.getAdapter(s.adapter || Ro.adapter)(s).then(function(i) {
    return Gu(s), i.data = Uu.call(
      s,
      s.transformResponse,
      i
    ), i.headers = Nt.from(i.headers), i;
  }, function(i) {
    return OP(i) || (Gu(s), i && i.response && (i.response.data = Uu.call(
      s,
      s.transformResponse,
      i.response
    ), i.response.headers = Nt.from(i.response.headers))), Promise.reject(i);
  });
}
const kP = "1.9.0", xh = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((s, e) => {
  xh[s] = function(i) {
    return typeof i === s || "a" + (e < 1 ? "n " : " ") + s;
  };
});
const b0 = {};
xh.transitional = function(e, t, i) {
  function n(r, a) {
    return "[Axios v" + kP + "] Transitional option '" + r + "'" + a + (i ? ". " + i : "");
  }
  return (r, a, o) => {
    if (e === !1)
      throw new ye(
        n(a, " has been removed" + (t ? " in " + t : "")),
        ye.ERR_DEPRECATED
      );
    return t && !b0[a] && (b0[a] = !0, console.warn(
      n(
        a,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(r, a, o) : !0;
  };
};
xh.spelling = function(e) {
  return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0);
};
function sZ(s, e, t) {
  if (typeof s != "object")
    throw new ye("options must be an object", ye.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(s);
  let n = i.length;
  for (; n-- > 0; ) {
    const r = i[n], a = e[r];
    if (a) {
      const o = s[r], l = o === void 0 || a(o, r, s);
      if (l !== !0)
        throw new ye("option " + r + " must be " + l, ye.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new ye("Unknown option " + r, ye.ERR_BAD_OPTION);
  }
}
const Bl = {
  assertOptions: sZ,
  validators: xh
}, Wi = Bl.validators;
let yn = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new h0(),
      response: new h0()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (i) {
      if (i instanceof Error) {
        let n = {};
        Error.captureStackTrace ? Error.captureStackTrace(n) : n = new Error();
        const r = n.stack ? n.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? r && !String(i.stack).endsWith(r.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + r) : i.stack = r;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = En(this.defaults, t);
    const { transitional: i, paramsSerializer: n, headers: r } = t;
    i !== void 0 && Bl.assertOptions(i, {
      silentJSONParsing: Wi.transitional(Wi.boolean),
      forcedJSONParsing: Wi.transitional(Wi.boolean),
      clarifyTimeoutError: Wi.transitional(Wi.boolean)
    }, !1), n != null && (L.isFunction(n) ? t.paramsSerializer = {
      serialize: n
    } : Bl.assertOptions(n, {
      encode: Wi.function,
      serialize: Wi.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Bl.assertOptions(t, {
      baseUrl: Wi.spelling("baseURL"),
      withXsrfToken: Wi.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let a = r && L.merge(
      r.common,
      r[t.method]
    );
    r && L.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete r[p];
      }
    ), t.headers = Nt.concat(a, r);
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(t) === !1 || (l = l && g.synchronous, o.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(g) {
      c.push(g.fulfilled, g.rejected);
    });
    let h, u = 0, d;
    if (!l) {
      const p = [x0.bind(this), void 0];
      for (p.unshift.apply(p, o), p.push.apply(p, c), d = p.length, h = Promise.resolve(t); u < d; )
        h = h.then(p[u++], p[u++]);
      return h;
    }
    d = o.length;
    let f = t;
    for (u = 0; u < d; ) {
      const p = o[u++], g = o[u++];
      try {
        f = p(f);
      } catch (m) {
        g.call(this, m);
        break;
      }
    }
    try {
      h = x0.call(this, f);
    } catch (p) {
      return Promise.reject(p);
    }
    for (u = 0, d = c.length; u < d; )
      h = h.then(c[u++], c[u++]);
    return h;
  }
  getUri(e) {
    e = En(this.defaults, e);
    const t = bP(e.baseURL, e.url, e.allowAbsoluteUrls);
    return pP(t, e.params, e.paramsSerializer);
  }
};
L.forEach(["delete", "get", "head", "options"], function(e) {
  yn.prototype[e] = function(t, i) {
    return this.request(En(i || {}, {
      method: e,
      url: t,
      data: (i || {}).data
    }));
  };
});
L.forEach(["post", "put", "patch"], function(e) {
  function t(i) {
    return function(r, a, o) {
      return this.request(En(o || {}, {
        method: e,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: r,
        data: a
      }));
    };
  }
  yn.prototype[e] = t(), yn.prototype[e + "Form"] = t(!0);
});
let nZ = class PP {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(r) {
      t = r;
    });
    const i = this;
    this.promise.then((n) => {
      if (!i._listeners) return;
      let r = i._listeners.length;
      for (; r-- > 0; )
        i._listeners[r](n);
      i._listeners = null;
    }), this.promise.then = (n) => {
      let r;
      const a = new Promise((o) => {
        i.subscribe(o), r = o;
      }).then(n);
      return a.cancel = function() {
        i.unsubscribe(r);
      }, a;
    }, e(function(r, a, o) {
      i.reason || (i.reason = new zr(r, a, o), t(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (i) => {
      e.abort(i);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new PP(function(n) {
        e = n;
      }),
      cancel: e
    };
  }
};
function rZ(s) {
  return function(t) {
    return s.apply(null, t);
  };
}
function aZ(s) {
  return L.isObject(s) && s.isAxiosError === !0;
}
const cp = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(cp).forEach(([s, e]) => {
  cp[e] = s;
});
function QP(s) {
  const e = new yn(s), t = iP(yn.prototype.request, e);
  return L.extend(t, yn.prototype, e, { allOwnKeys: !0 }), L.extend(t, e, null, { allOwnKeys: !0 }), t.create = function(n) {
    return QP(En(s, n));
  }, t;
}
const rt = QP(Ro);
rt.Axios = yn;
rt.CanceledError = zr;
rt.CancelToken = nZ;
rt.isCancel = OP;
rt.VERSION = kP;
rt.toFormData = mh;
rt.AxiosError = ye;
rt.Cancel = rt.CanceledError;
rt.all = function(e) {
  return Promise.all(e);
};
rt.spread = rZ;
rt.isAxiosError = aZ;
rt.mergeConfig = En;
rt.AxiosHeaders = Nt;
rt.formToJSON = (s) => mP(L.isHTMLForm(s) ? new FormData(s) : s);
rt.getAdapter = SP.getAdapter;
rt.HttpStatusCode = cp;
rt.default = rt;
const {
  Axios: iN,
  AxiosError: sN,
  CanceledError: nN,
  isCancel: rN,
  CancelToken: aN,
  VERSION: oN,
  all: lN,
  Cancel: cN,
  isAxiosError: hN,
  spread: uN,
  toFormData: dN,
  AxiosHeaders: fN,
  HttpStatusCode: pN,
  formToJSON: gN,
  getAdapter: mN,
  mergeConfig: ON
} = rt, ro = rt.create({
  baseURL: Sn || "http://localhost:5000/api",
  headers: {
    "Content-Type": "application/json"
  },
  // Include credentials (cookies) with every request
  withCredentials: !0
});
ro.interceptors.request.use(
  (s) => s,
  (s) => Promise.reject(s)
);
var oZ = /* @__PURE__ */ K('<div class="h-full relative"><div class="absolute top-0 right-0 z-10 w-full"><div class="flex justify-between align-center"><div class=mb-1><button class="flex cursor-alias items-center gap-4 px-4 pb-2 pt-1 mt-1 bg-neutral-900 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 rounded-t-lg border-l border-t border-neutral-700"> </button></div><div class="flex align-center"><button class="flex cursor-alias gap-2 px-2 py-1 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 "> </button><button class="flex cursor-alias px-2 py-1 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 "></button></div></div></div><div class="h-full w-full pt-10">'), lZ = /* @__PURE__ */ K('<p class="text-red-600 p-4">');
const cZ = (s) => {
  let e, t = null;
  const [i, n] = re(""), [r, a] = re(!0), [o, l] = re(!1), [c, h] = re(""), u = async () => {
    a(!0);
    try {
      const p = new FormData();
      p.append("filePath", s.filePath);
      const g = await ro.post("/file/read", p);
      if (!g.data?.data) throw new Error("Failed to load file");
      const m = g.data.data;
      n(m), d(m);
    } catch (p) {
      h(p.message);
    } finally {
      a(!1);
    }
  }, d = (p) => {
    t && (t.destroy(), t = null);
    const g = s.theme === "light" ? "light" : "dark", m = Ce.create({
      doc: p,
      extensions: [mz, PY(s.filePath), ...$Y(g), J.updateListener.of((O) => {
        O.docChanged && n(O.state.doc.toString());
      })]
    });
    t = new J({
      state: m,
      parent: e
    });
  }, f = async () => {
    l(!0);
    try {
      const p = new FormData();
      if (p.append("filePath", s.filePath), p.append("content", i()), !(await ro.post("/file/write", p)).data.success) throw new Error("Failed to save file");
      rm("File saved successfully.", "success");
    } catch (p) {
      rm("Error saving file: " + p.message, "error");
    } finally {
      l(!1);
    }
  };
  return wr(u), Jt(() => {
    u();
  }), ii(() => {
    t && t.destroy();
  }), (() => {
    var p = oZ(), g = p.firstChild, m = g.firstChild, O = m.firstChild, x = O.firstChild, b = x.firstChild, v = O.nextSibling, y = v.firstChild, w = y.firstChild, S = y.nextSibling, k = g.nextSibling;
    W(x, () => s.filePath?.split("/").pop(), b), W(x, B(Pi, {
      icon: "mdi:close",
      width: "18",
      height: "18"
    }), null), y.$$click = f, W(y, B(Pi, {
      icon: "mdi:content-save",
      width: "20",
      height: "20"
    }), w), W(y, () => o() ? "Saving..." : "Save", null), W(S, B(Pi, {
      icon: "mdi:menu",
      width: "20",
      height: "20"
    })), W(p, (() => {
      var T = Yt(() => !!r());
      return () => T() && B(Dp, {});
    })(), k), W(p, (() => {
      var T = Yt(() => !!c());
      return () => T() && (() => {
        var C = lZ();
        return W(C, c), C;
      })();
    })(), k);
    var A = e;
    return typeof A == "function" ? wi(A, k) : e = k, Ae((T) => {
      var C = s.filePath, P = o();
      return C !== T.e && Fe(x, "title", T.e = C), P !== T.t && (y.disabled = T.t = P), T;
    }, {
      e: void 0,
      t: void 0
    }), p;
  })();
};
_t(["click"]);
var hZ = /* @__PURE__ */ K('<div class=ml-2><div class="cursor-pointer font-semibold text-yellow-500"> </div><div class="pl-3 border-l border-gray-300 transition-all duration-200 origin-top">'), uZ = /* @__PURE__ */ K("<div>Loading..."), dZ = /* @__PURE__ */ K("<div>No files found.");
const fZ = async () => {
  const s = await ro.get("/file/list?directory=./&recursive=true");
  if (!s.data) throw new Error("Failed to load files");
  return s.data;
};
function pZ(s) {
  const e = /* @__PURE__ */ new Map();
  for (const i of s)
    e.set(i.path, {
      ...i,
      children: i.children || []
    });
  const t = [];
  for (const i of e.values()) {
    const n = i.path.split("/");
    if (n.length === 1)
      t.push(i);
    else {
      const r = n.slice(0, -1).join("/"), a = e.get(r);
      a && a.children.push(i);
    }
  }
  return t;
}
const CP = (s) => {
  const [e, t] = re(!1), i = s.file.isDirectory && s.file.children.length > 0, n = () => {
    i && t(!e());
  };
  return (() => {
    var r = hZ(), a = r.firstChild, o = a.firstChild, l = a.nextSibling;
    return a.$$click = () => i ? n() : s.onSelect(s.file.path), W(a, () => i ? e() ? "📂" : "📁" : "📄", o), W(a, () => s.file.name, null), W(l, B(Gi, {
      get each() {
        return s.file.children;
      },
      children: (c) => B(CP, {
        file: c,
        get onSelect() {
          return s.onSelect;
        }
      })
    })), Ae((c) => (c = e() ? "block" : "none") != null ? l.style.setProperty("display", c) : l.style.removeProperty("display")), r;
  })();
};
function gZ(s) {
  const [e] = P0(fZ);
  return B(vi, {
    get when() {
      return e();
    },
    get fallback() {
      return uZ();
    },
    get children() {
      return B(Gi, {
        get each() {
          return pZ(e());
        },
        get fallback() {
          return dZ();
        },
        children: (t) => B(CP, {
          file: t,
          get onSelect() {
            return s.onFileSelect;
          }
        })
      });
    }
  });
}
_t(["click"]);
var mZ = /* @__PURE__ */ K('<div class="flex h-screen flex-col bg-white dark:bg-neutral-900 dark:text-white"><div class="flex flex-1 overflow-hidden relative pb-8"><div class="h-full overflow-y-auto border-r dark:border-neutral-700 px-2 pt-10 pb-4 shadow-sm"><div class="absolute top-0 left-0 right-0 z-10 w-full dark:bg-neutral-800 border-b dark:border-neutral-700"><div class="flex justify-between align-center"><div><button class="flex cursor-alias items-center gap-2 px-2 py-1 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 leading-0 text-sm uppercase tracking-widest"> File Explorer</button></div></div></div></div><div class="flex-1 h-full overflow-hidden"></div></div><div class="fixed h-8 dark:bg-neutral-900 w-screen bottom-0 z-10 border-t dark:border-neutral-700 shadow-md"><div class="flex justify-between align-center"><div><button class="flex cursor-alias items-center gap-2 px-2 py-1 text-left text-neutral-800 dark:text-neutral-100 dark:hover:text-yellow-500"aria-label="Open Terminal">');
function OZ() {
  const [s, e] = re(window.innerWidth / 4.4), [t, i] = re("./README.md"), [n, r] = re(""), [a, o] = re(!0);
  wr(async () => {
    await l(t());
  });
  const l = async (c) => {
    try {
      o(!0);
      const h = new FormData();
      h.append("filePath", c);
      const u = await ro.post("/file/read", h);
      if (!u.data) throw new Error("Failed to load file");
      const d = u.data;
      i(c), r(d.data);
    } catch (h) {
      console.error(`Error loading file "${c}":`, h);
    } finally {
      o(!1);
    }
  };
  return (() => {
    var c = mZ(), h = c.firstChild, u = h.firstChild, d = u.firstChild, f = d.firstChild, p = f.firstChild, g = p.firstChild, m = g.firstChild, O = u.nextSibling, x = h.nextSibling, b = x.firstChild, v = b.firstChild, y = v.firstChild;
    return W(c, B(Mn, {}), h), u.style.setProperty("minWidth", "180px"), W(g, B(Pi, {
      icon: "mdi:file",
      width: "22",
      height: "22"
    }), m), W(u, B(gZ, {
      onFileSelect: l
    }), null), W(O, (() => {
      var w = Yt(() => !a());
      return () => w() && B(cZ, {
        theme: "dark",
        get filePath() {
          return t();
        },
        get content() {
          return n();
        },
        language: "typescript"
      });
    })()), y.$$click = () => window.location.href = "/terminal", W(y, B(Pi, {
      icon: "mdi:terminal",
      width: "22",
      height: "22"
    })), Ae((w) => (w = `${s()}px`) != null ? u.style.setProperty("width", w) : u.style.removeProperty("width")), c;
  })();
}
_t(["click"]);
var xZ = /* @__PURE__ */ K("<button>");
function Ku(s) {
  const [e, t] = dp(s, ["class", "disabled", "children"]);
  return (() => {
    var i = xZ();
    return Wc(i, wn({
      get class() {
        return `inline-flex items-center justify-center px-4 py-2 rounded-md text-white font-medium transition-colors
        bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed
        focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
        ${e.class || ""}`;
      },
      get disabled() {
        return e.disabled;
      }
    }, t), !1, !0), W(i, () => e.children), i;
  })();
}
var bZ = /* @__PURE__ */ K('<div class="bg-white dark:bg-neutral-900 h-screen w-full"><div class="flex min-h-screen items-center justify-center"><div class="w-full max-w-3xl mx-auto p-6 bg-white rounded-2xl shadow-lg space-y-4 dark:bg-neutral-950 border dark:border-neutral-600"><h2 class="text-2xl font-bold dark:text-neutral-400">Generate TTS Audio</h2><textarea rows=4 class="w-full p-3 min-h-[200px] border border-neutral-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-neutral-700 dark:text-neutral-100"placeholder="Enter your prompt here..."></textarea><div><label class="block mb-1 text-sm font-medium text-neutral-700 dark:text-neutral-300">Language</label><select class="w-full p-2 border rounded-md dark:bg-neutral-700 dark:text-white"></select></div><div class=space-y-2><label class="block font-medium text-neutral-800 dark:text-neutral-200">Speakers'), y0 = /* @__PURE__ */ K("<option>"), yZ = /* @__PURE__ */ K('<input type=text class="w-full p-2 border rounded-md dark:bg-neutral-700 dark:text-white"placeholder="Enter custom voice name">'), vZ = /* @__PURE__ */ K('<div class="flex flex-col gap-2"><div class="flex items-center gap-2"><input type=text class="w-1/2 p-2 border rounded-md dark:bg-neutral-700 dark:text-white"placeholder="Speaker name"><select class="w-1/2 p-2 border rounded-md dark:bg-neutral-700 dark:text-white">'), wZ = /* @__PURE__ */ K("<p class=text-red-500>"), SZ = /* @__PURE__ */ K('<audio controls class="w-full mt-4 rounded-lg shadow-lg"><source type=audio/wav>Your browser does not support the audio element.');
const kZ = [{
  label: "Arabic (Egyptian)",
  code: "ar-EG"
}, {
  label: "German (Germany)",
  code: "de-DE"
}, {
  label: "English (US)",
  code: "en-US"
}, {
  label: "Spanish (US)",
  code: "es-US"
}, {
  label: "French (France)",
  code: "fr-FR"
}, {
  label: "Hindi (India)",
  code: "hi-IN"
}, {
  label: "Indonesian (Indonesia)",
  code: "id-ID"
}, {
  label: "Italian (Italy)",
  code: "it-IT"
}, {
  label: "Japanese (Japan)",
  code: "ja-JP"
}, {
  label: "Korean (Korea)",
  code: "ko-KR"
}, {
  label: "Portuguese (Brazil)",
  code: "pt-BR"
}, {
  label: "Russian (Russia)",
  code: "ru-RU"
}, {
  label: "Dutch (Netherlands)",
  code: "nl-NL"
}, {
  label: "Polish (Poland)",
  code: "pl-PL"
}, {
  label: "Thai (Thailand)",
  code: "th-TH"
}, {
  label: "Turkish (Turkey)",
  code: "tr-TR"
}, {
  label: "Vietnamese (Vietnam)",
  code: "vi-VN"
}, {
  label: "Romanian (Romania)",
  code: "ro-RO"
}, {
  label: "Ukrainian (Ukraine)",
  code: "uk-UA"
}, {
  label: "Bengali (Bangladesh)",
  code: "bn-BD"
}, {
  label: "English (India)",
  code: "en-IN"
}, {
  label: "Marathi (India)",
  code: "mr-IN"
}, {
  label: "Tamil (India)",
  code: "ta-IN"
}, {
  label: "Telugu (India)",
  code: "te-IN"
}], v0 = [{
  name: "Zephyr",
  tone: "Bright"
}, {
  name: "Puck",
  tone: "Upbeat"
}, {
  name: "Charon",
  tone: "Informative"
}, {
  name: "Kore",
  tone: "Firm"
}, {
  name: "Fenrir",
  tone: "Excitable"
}, {
  name: "Leda",
  tone: "Youthful"
}, {
  name: "Orus",
  tone: "Firm"
}, {
  name: "Aoede",
  tone: "Breezy"
}, {
  name: "Callirrhoe",
  tone: "Easy-going"
}, {
  name: "Autonoe",
  tone: "Bright"
}, {
  name: "Enceladus",
  tone: "Breathy"
}, {
  name: "Iapetus",
  tone: "Clear"
}, {
  name: "Umbriel",
  tone: "Easy-going"
}, {
  name: "Algieba",
  tone: "Smooth"
}, {
  name: "Despina",
  tone: "Smooth"
}, {
  name: "Erinome",
  tone: "Clear"
}, {
  name: "Algenib",
  tone: "Gravelly"
}, {
  name: "Rasalgethi",
  tone: "Informative"
}, {
  name: "Laomedeia",
  tone: "Upbeat"
}, {
  name: "Achernar",
  tone: "Soft"
}, {
  name: "Alnilam",
  tone: "Firm"
}, {
  name: "Schedar",
  tone: "Even"
}, {
  name: "Gacrux",
  tone: "Mature"
}, {
  name: "Pulcherrima",
  tone: "Forward"
}, {
  name: "Achird",
  tone: "Friendly"
}, {
  name: "Zubenelgenubi",
  tone: "Casual"
}, {
  name: "Vindemiatrix",
  tone: "Gentle"
}, {
  name: "Sadachbia",
  tone: "Lively"
}, {
  name: "Sadaltager",
  tone: "Knowledgeable"
}, {
  name: "Sulafat",
  tone: "Warm"
}];
function PZ() {
  const [s, e] = re(""), [t, i] = re("en-US"), [n, r] = re("en-US"), [a, o] = re([{
    speaker: "Eddie",
    voiceName: "Kore"
  }, {
    speaker: "Marionette",
    voiceName: "Puck"
  }]), [l, c] = re(null), [h, u] = re(!1), [d, f] = re(""), p = (x, b, v) => {
    const y = [...a()];
    y[x][b] = v, o(y);
  }, g = () => o([...a(), {
    speaker: "",
    voiceName: v0[0].name
  }]), m = (x) => {
    const b = [...a()];
    b.splice(x, 1), o(b);
  }, O = async () => {
    u(!0), f(""), c(null);
    try {
      const x = await fetch("/api/google-tts/generate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          prompt: s(),
          languageCode: n(),
          speakers: a()
          // if applicable
        })
      });
      if (!x.ok) throw new Error("Failed to generate audio");
      const b = await x.blob(), v = URL.createObjectURL(b);
      c(v);
    } catch (x) {
      f(x.message || "Unexpected error");
    } finally {
      u(!1);
    }
  };
  return (() => {
    var x = bZ(), b = x.firstChild, v = b.firstChild, y = v.firstChild, w = y.nextSibling, S = w.nextSibling, k = S.firstChild, A = k.nextSibling, T = S.nextSibling;
    return T.firstChild, W(x, B(Mn, {}), b), w.$$input = (C) => e(C.currentTarget.value), A.addEventListener("change", (C) => r(C.currentTarget.value)), W(A, B(Gi, {
      each: kZ,
      children: (C) => (() => {
        var P = y0();
        return W(P, () => C.label), Ae(() => P.value = C.code), P;
      })()
    })), W(T, B(Gi, {
      get each() {
        return a();
      },
      children: (C, P) => (() => {
        var $ = vZ(), R = $.firstChild, X = R.firstChild, M = X.nextSibling;
        return X.$$input = (z) => p(P(), "speaker", z.currentTarget.value), M.addEventListener("change", (z) => p(P(), "voiceName", z.currentTarget.value)), W(M, B(Gi, {
          each: v0,
          children: (z) => (() => {
            var I = y0();
            return W(I, () => z.name === "Custom" ? "Custom (manual)" : `${z.name} (${z.tone})`), Ae(() => I.value = z.name), I;
          })()
        })), W(R, B(Ku, {
          onClick: () => m(P()),
          class: "px-2 py-1 text-sm",
          children: "✕"
        }), null), W($, B(vi, {
          get when() {
            return C.voiceName === "Custom";
          },
          get children() {
            var z = yZ();
            return z.$$input = (I) => p(P(), "voiceName", I.currentTarget.value), z;
          }
        }), null), Ae(() => X.value = C.speaker), Ae(() => M.value = C.voiceName), $;
      })()
    }), null), W(T, B(Ku, {
      onClick: g,
      class: "text-sm",
      children: "+ Add Speaker"
    }), null), W(v, B(Ku, {
      class: "w-full flex items-center gap-2 px-2 py-2 uppercase tracking-widest",
      onClick: O,
      get disabled() {
        return h();
      },
      get children() {
        return [B(ri, {
          path: gy,
          class: "h-6"
        }), Yt(() => h() ? "Generating..." : "Generate Audio")];
      }
    }), null), W(v, (() => {
      var C = Yt(() => !!d());
      return () => C() && (() => {
        var P = wZ();
        return W(P, d), P;
      })();
    })(), null), W(v, (() => {
      var C = Yt(() => !!l());
      return () => C() && (() => {
        var P = SZ(), $ = P.firstChild;
        return Ae(() => Fe($, "src", l())), P;
      })();
    })(), null), Ae(() => w.value = s()), Ae(() => A.value = n()), x;
  })();
}
_t(["input"]);
const QZ = () => B(LQ, {
  root: (e) => B(BQ, {
    get children() {
      return B(VP, {
        get children() {
          return e.children;
        }
      });
    }
  }),
  get children() {
    return [B(os, {
      path: "/",
      component: () => B(In, {
        isAuthenticated: !1,
        get children() {
          return B(J2, {});
        }
      })
    }), B(os, {
      path: "/dashboard",
      component: () => B(In, {
        isAuthenticated: !1,
        get children() {
          return B(I2, {});
        }
      })
    }), B(os, {
      path: "/terminal",
      component: () => B(In, {
        isAuthenticated: !1,
        get children() {
          return B(dT, {});
        }
      })
    }), B(os, {
      path: "/settings",
      component: () => B(In, {
        isAuthenticated: !1,
        get children() {
          return B(D2, {});
        }
      })
    }), B(os, {
      path: "/profile",
      component: () => B(In, {
        isAuthenticated: !1,
        get children() {
          return B(W2, {});
        }
      })
    }), B(os, {
      path: "/tts",
      component: () => B(In, {
        isAuthenticated: !1,
        get children() {
          return B(PZ, {});
        }
      })
    }), B(os, {
      path: "/editor",
      component: () => [B(W0, {}), B(OZ, {})]
    }), B(os, {
      path: "/logout",
      component: () => B(pR, {})
    }), B(os, {
      path: "/login",
      component: () => B(cR, {})
    })];
  }
}), CZ = document.getElementById("root");
iQ(() => B(QZ, {}), CZ);
