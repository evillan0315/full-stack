const ce = {
  context: void 0,
  registry: void 0,
  effects: void 0,
  done: !1,
  getContextId() {
    return wd(this.context.count);
  },
  getNextContextId() {
    return wd(this.context.count++);
  }
};
function wd(i) {
  const e = String(i), t = e.length - 1;
  return ce.context.id + (t ? String.fromCharCode(96 + t) : "") + e;
}
function Ei(i) {
  ce.context = i;
}
const km = !1, By = (i, e) => i === e, Ut = Symbol("solid-proxy"), Cm = typeof Proxy == "function", nh = Symbol("solid-track"), wa = {
  equals: By
};
let Qm = Em;
const jt = 1, On = 2, Pm = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
}, Nl = {};
var pe = null;
let J = null, qy = null, ye = null, st = null, et = null, Ol = 0;
function Kr(i, e) {
  const t = ye, r = pe, s = i.length === 0, n = e === void 0 ? r : e, o = s ? Pm : {
    owned: null,
    cleanups: null,
    context: n ? n.context : null,
    owner: n
  }, a = s ? i : () => i(() => ot(() => tr(o)));
  pe = o, ye = null;
  try {
    return Tt(a, !0);
  } finally {
    ye = t, pe = r;
  }
}
function se(i, e) {
  e = e ? Object.assign({}, wa, e) : wa;
  const t = {
    value: i,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, r = (s) => (typeof s == "function" && (J && J.running && J.sources.has(t) ? s = s(t.tValue) : s = s(t.value)), Rm(t, s));
  return [$m.bind(t), r];
}
function xd(i, e, t) {
  const r = pl(i, e, !0, jt);
  bs(r);
}
function Oe(i, e, t) {
  const r = pl(i, e, !1, jt);
  bs(r);
}
function Yn(i, e, t) {
  Qm = Vy;
  const r = pl(i, e, !1, jt), s = Pr && Br(Pr);
  s && (r.suspense = s), r.user = !0, et ? et.push(r) : bs(r);
}
function Re(i, e, t) {
  t = t ? Object.assign({}, wa, t) : wa;
  const r = pl(i, e, !0, 0);
  return r.observers = null, r.observerSlots = null, r.comparator = t.equals || void 0, bs(r), $m.bind(r);
}
function Xy(i) {
  return i && typeof i == "object" && "then" in i;
}
function Gu(i, e, t) {
  let r, s, n;
  typeof e == "function" ? (r = i, s = e, n = {}) : (r = !0, s = i, n = e || {});
  let o = null, a = Nl, l = null, c = !1, h = !1, u = "initialValue" in n, d = typeof r == "function" && Re(r);
  const O = /* @__PURE__ */ new Set(), [v, S] = (n.storage || se)(n.initialValue), [f, p] = se(void 0), [g, m] = se(void 0, {
    equals: !1
  }), [_, b] = se(u ? "ready" : "unresolved");
  ce.context && (l = ce.getNextContextId(), n.ssrLoadFrom === "initial" ? a = n.initialValue : ce.load && ce.has(l) && (a = ce.load(l)));
  function w(R, T, A, M) {
    return o === R && (o = null, M !== void 0 && (u = !0), (R === a || T === a) && n.onHydrated && queueMicrotask(() => n.onHydrated(M, {
      value: T
    })), a = Nl, J && R && c ? (J.promises.delete(R), c = !1, Tt(() => {
      J.running = !0, x(T, A);
    }, !1)) : x(T, A)), T;
  }
  function x(R, T) {
    Tt(() => {
      T === void 0 && S(() => R), b(T !== void 0 ? "errored" : u ? "ready" : "unresolved"), p(T);
      for (const A of O.keys()) A.decrement();
      O.clear();
    }, !1);
  }
  function y() {
    const R = Pr && Br(Pr), T = v(), A = f();
    if (A !== void 0 && !o) throw A;
    return ye && !ye.user && R && xd(() => {
      g(), o && (R.resolved && J && c ? J.promises.add(o) : O.has(R) || (R.increment(), O.add(R)));
    }), T;
  }
  function k(R = !0) {
    if (R !== !1 && h) return;
    h = !1;
    const T = d ? d() : r;
    if (c = J && J.running, T == null || T === !1) {
      w(o, ot(v));
      return;
    }
    J && o && J.promises.delete(o);
    let A;
    const M = a !== Nl ? a : ot(() => {
      try {
        return s(T, {
          value: v(),
          refetching: R
        });
      } catch (B) {
        A = B;
      }
    });
    if (A !== void 0) {
      w(o, void 0, Fo(A), T);
      return;
    } else if (!Xy(M))
      return w(o, M, void 0, T), M;
    return o = M, "v" in M ? (M.s === 1 ? w(o, M.v, void 0, T) : w(o, void 0, Fo(M.v), T), M) : (h = !0, queueMicrotask(() => h = !1), Tt(() => {
      b(u ? "refreshing" : "pending"), m();
    }, !1), M.then((B) => w(M, B, void 0, T), (B) => w(M, void 0, Fo(B), T)));
  }
  Object.defineProperties(y, {
    state: {
      get: () => _()
    },
    error: {
      get: () => f()
    },
    loading: {
      get() {
        const R = _();
        return R === "pending" || R === "refreshing";
      }
    },
    latest: {
      get() {
        if (!u) return y();
        const R = f();
        if (R && !o) throw R;
        return v();
      }
    }
  });
  let $ = pe;
  return d ? xd(() => ($ = pe, k(!1))) : k(!1), [y, {
    refetch: (R) => Ju($, () => k(R)),
    mutate: S
  }];
}
function Tm(i) {
  return Tt(i, !1);
}
function ot(i) {
  if (ye === null) return i();
  const e = ye;
  ye = null;
  try {
    return i();
  } finally {
    ye = e;
  }
}
function Ku(i, e, t) {
  const r = Array.isArray(i);
  let s, n = t && t.defer;
  return (o) => {
    let a;
    if (r) {
      a = Array(i.length);
      for (let c = 0; c < i.length; c++) a[c] = i[c]();
    } else a = i();
    if (n)
      return n = !1, o;
    const l = ot(() => e(a, s, o));
    return s = a, l;
  };
}
function Di(i) {
  Yn(() => ot(i));
}
function ft(i) {
  return pe === null || (pe.cleanups === null ? pe.cleanups = [i] : pe.cleanups.push(i)), i;
}
function oh() {
  return ye;
}
function Fn() {
  return pe;
}
function Ju(i, e) {
  const t = pe, r = ye;
  pe = i, ye = null;
  try {
    return Tt(e, !0);
  } catch (s) {
    tf(s);
  } finally {
    pe = t, ye = r;
  }
}
function Iy(i) {
  if (J && J.running)
    return i(), J.done;
  const e = ye, t = pe;
  return Promise.resolve().then(() => {
    ye = e, pe = t;
    let r;
    return Pr && (r = J || (J = {
      sources: /* @__PURE__ */ new Set(),
      effects: [],
      promises: /* @__PURE__ */ new Set(),
      disposed: /* @__PURE__ */ new Set(),
      queue: /* @__PURE__ */ new Set(),
      running: !0
    }), r.done || (r.done = new Promise((s) => r.resolve = s)), r.running = !0), Tt(i, !1), ye = pe = null, r ? r.done : void 0;
  });
}
const [O3, kd] = /* @__PURE__ */ se(!1);
function Zy(i) {
  et.push.apply(et, i), i.length = 0;
}
function Hn(i, e) {
  const t = Symbol("context");
  return {
    id: t,
    Provider: Uy(t),
    defaultValue: i
  };
}
function Br(i) {
  let e;
  return pe && pe.context && (e = pe.context[i.id]) !== void 0 ? e : i.defaultValue;
}
function ef(i) {
  const e = Re(i), t = Re(() => ah(e()));
  return t.toArray = () => {
    const r = t();
    return Array.isArray(r) ? r : r != null ? [r] : [];
  }, t;
}
let Pr;
function Wy() {
  return Pr || (Pr = Hn());
}
function $m() {
  const i = J && J.running;
  if (this.sources && (i ? this.tState : this.state))
    if ((i ? this.tState : this.state) === jt) bs(this);
    else {
      const e = st;
      st = null, Tt(() => ka(this), !1), st = e;
    }
  if (ye) {
    const e = this.observers ? this.observers.length : 0;
    ye.sources ? (ye.sources.push(this), ye.sourceSlots.push(e)) : (ye.sources = [this], ye.sourceSlots = [e]), this.observers ? (this.observers.push(ye), this.observerSlots.push(ye.sources.length - 1)) : (this.observers = [ye], this.observerSlots = [ye.sources.length - 1]);
  }
  return i && J.sources.has(this) ? this.tValue : this.value;
}
function Rm(i, e, t) {
  let r = J && J.running && J.sources.has(i) ? i.tValue : i.value;
  if (!i.comparator || !i.comparator(r, e)) {
    if (J) {
      const s = J.running;
      (s || !t && J.sources.has(i)) && (J.sources.add(i), i.tValue = e), s || (i.value = e);
    } else i.value = e;
    i.observers && i.observers.length && Tt(() => {
      for (let s = 0; s < i.observers.length; s += 1) {
        const n = i.observers[s], o = J && J.running;
        o && J.disposed.has(n) || ((o ? !n.tState : !n.state) && (n.pure ? st.push(n) : et.push(n), n.observers && Am(n)), o ? n.tState = jt : n.state = jt);
      }
      if (st.length > 1e6)
        throw st = [], new Error();
    }, !1);
  }
  return e;
}
function bs(i) {
  if (!i.fn) return;
  tr(i);
  const e = Ol;
  Cd(i, J && J.running && J.sources.has(i) ? i.tValue : i.value, e), J && !J.running && J.sources.has(i) && queueMicrotask(() => {
    Tt(() => {
      J && (J.running = !0), ye = pe = i, Cd(i, i.tValue, e), ye = pe = null;
    }, !1);
  });
}
function Cd(i, e, t) {
  let r;
  const s = pe, n = ye;
  ye = pe = i;
  try {
    r = i.fn(e);
  } catch (o) {
    return i.pure && (J && J.running ? (i.tState = jt, i.tOwned && i.tOwned.forEach(tr), i.tOwned = void 0) : (i.state = jt, i.owned && i.owned.forEach(tr), i.owned = null)), i.updatedAt = t + 1, tf(o);
  } finally {
    ye = n, pe = s;
  }
  (!i.updatedAt || i.updatedAt <= t) && (i.updatedAt != null && "observers" in i ? Rm(i, r, !0) : J && J.running && i.pure ? (J.sources.add(i), i.tValue = r) : i.value = r, i.updatedAt = t);
}
function pl(i, e, t, r = jt, s) {
  const n = {
    fn: i,
    state: r,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: pe,
    context: pe ? pe.context : null,
    pure: t
  };
  return J && J.running && (n.state = 0, n.tState = r), pe === null || pe !== Pm && (J && J.running && pe.pure ? pe.tOwned ? pe.tOwned.push(n) : pe.tOwned = [n] : pe.owned ? pe.owned.push(n) : pe.owned = [n]), n;
}
function xa(i) {
  const e = J && J.running;
  if ((e ? i.tState : i.state) === 0) return;
  if ((e ? i.tState : i.state) === On) return ka(i);
  if (i.suspense && ot(i.suspense.inFallback)) return i.suspense.effects.push(i);
  const t = [i];
  for (; (i = i.owner) && (!i.updatedAt || i.updatedAt < Ol); ) {
    if (e && J.disposed.has(i)) return;
    (e ? i.tState : i.state) && t.push(i);
  }
  for (let r = t.length - 1; r >= 0; r--) {
    if (i = t[r], e) {
      let s = i, n = t[r + 1];
      for (; (s = s.owner) && s !== n; )
        if (J.disposed.has(s)) return;
    }
    if ((e ? i.tState : i.state) === jt)
      bs(i);
    else if ((e ? i.tState : i.state) === On) {
      const s = st;
      st = null, Tt(() => ka(i, t[0]), !1), st = s;
    }
  }
}
function Tt(i, e) {
  if (st) return i();
  let t = !1;
  e || (st = []), et ? t = !0 : et = [], Ol++;
  try {
    const r = i();
    return zy(t), r;
  } catch (r) {
    t || (et = null), st = null, tf(r);
  }
}
function zy(i) {
  if (st && (Em(st), st = null), i) return;
  let e;
  if (J) {
    if (!J.promises.size && !J.queue.size) {
      const r = J.sources, s = J.disposed;
      et.push.apply(et, J.effects), e = J.resolve;
      for (const n of et)
        "tState" in n && (n.state = n.tState), delete n.tState;
      J = null, Tt(() => {
        for (const n of s) tr(n);
        for (const n of r) {
          if (n.value = n.tValue, n.owned)
            for (let o = 0, a = n.owned.length; o < a; o++) tr(n.owned[o]);
          n.tOwned && (n.owned = n.tOwned), delete n.tValue, delete n.tOwned, n.tState = 0;
        }
        kd(!1);
      }, !1);
    } else if (J.running) {
      J.running = !1, J.effects.push.apply(J.effects, et), et = null, kd(!0);
      return;
    }
  }
  const t = et;
  et = null, t.length && Tt(() => Qm(t), !1), e && e();
}
function Em(i) {
  for (let e = 0; e < i.length; e++) xa(i[e]);
}
function Vy(i) {
  let e, t = 0;
  for (e = 0; e < i.length; e++) {
    const r = i[e];
    r.user ? i[t++] = r : xa(r);
  }
  if (ce.context) {
    if (ce.count) {
      ce.effects || (ce.effects = []), ce.effects.push(...i.slice(0, t));
      return;
    }
    Ei();
  }
  for (ce.effects && (ce.done || !ce.count) && (i = [...ce.effects, ...i], t += ce.effects.length, delete ce.effects), e = 0; e < t; e++) xa(i[e]);
}
function ka(i, e) {
  const t = J && J.running;
  t ? i.tState = 0 : i.state = 0;
  for (let r = 0; r < i.sources.length; r += 1) {
    const s = i.sources[r];
    if (s.sources) {
      const n = t ? s.tState : s.state;
      n === jt ? s !== e && (!s.updatedAt || s.updatedAt < Ol) && xa(s) : n === On && ka(s, e);
    }
  }
}
function Am(i) {
  const e = J && J.running;
  for (let t = 0; t < i.observers.length; t += 1) {
    const r = i.observers[t];
    (e ? !r.tState : !r.state) && (e ? r.tState = On : r.state = On, r.pure ? st.push(r) : et.push(r), r.observers && Am(r));
  }
}
function tr(i) {
  let e;
  if (i.sources)
    for (; i.sources.length; ) {
      const t = i.sources.pop(), r = i.sourceSlots.pop(), s = t.observers;
      if (s && s.length) {
        const n = s.pop(), o = t.observerSlots.pop();
        r < s.length && (n.sourceSlots[o] = r, s[r] = n, t.observerSlots[r] = o);
      }
    }
  if (i.tOwned) {
    for (e = i.tOwned.length - 1; e >= 0; e--) tr(i.tOwned[e]);
    delete i.tOwned;
  }
  if (J && J.running && i.pure)
    Lm(i, !0);
  else if (i.owned) {
    for (e = i.owned.length - 1; e >= 0; e--) tr(i.owned[e]);
    i.owned = null;
  }
  if (i.cleanups) {
    for (e = i.cleanups.length - 1; e >= 0; e--) i.cleanups[e]();
    i.cleanups = null;
  }
  J && J.running ? i.tState = 0 : i.state = 0;
}
function Lm(i, e) {
  if (e || (i.tState = 0, J.disposed.add(i)), i.owned)
    for (let t = 0; t < i.owned.length; t++) Lm(i.owned[t]);
}
function Fo(i) {
  return i instanceof Error ? i : new Error(typeof i == "string" ? i : "Unknown error", {
    cause: i
  });
}
function tf(i, e = pe) {
  throw Fo(i);
}
function ah(i) {
  if (typeof i == "function" && !i.length) return ah(i());
  if (Array.isArray(i)) {
    const e = [];
    for (let t = 0; t < i.length; t++) {
      const r = ah(i[t]);
      Array.isArray(r) ? e.push.apply(e, r) : e.push(r);
    }
    return e;
  }
  return i;
}
function Uy(i, e) {
  return function(r) {
    let s;
    return Oe(() => s = ot(() => (pe.context = {
      ...pe.context,
      [i]: r.value
    }, ef(() => r.children))), void 0), s;
  };
}
const jy = Symbol("fallback");
function Qd(i) {
  for (let e = 0; e < i.length; e++) i[e]();
}
function Ny(i, e, t = {}) {
  let r = [], s = [], n = [], o = 0, a = e.length > 1 ? [] : null;
  return ft(() => Qd(n)), () => {
    let l = i() || [], c = l.length, h, u;
    return l[nh], ot(() => {
      let O, v, S, f, p, g, m, _, b;
      if (c === 0)
        o !== 0 && (Qd(n), n = [], r = [], s = [], o = 0, a && (a = [])), t.fallback && (r = [jy], s[0] = Kr((w) => (n[0] = w, t.fallback())), o = 1);
      else if (o === 0) {
        for (s = new Array(c), u = 0; u < c; u++)
          r[u] = l[u], s[u] = Kr(d);
        o = c;
      } else {
        for (S = new Array(c), f = new Array(c), a && (p = new Array(c)), g = 0, m = Math.min(o, c); g < m && r[g] === l[g]; g++) ;
        for (m = o - 1, _ = c - 1; m >= g && _ >= g && r[m] === l[_]; m--, _--)
          S[_] = s[m], f[_] = n[m], a && (p[_] = a[m]);
        for (O = /* @__PURE__ */ new Map(), v = new Array(_ + 1), u = _; u >= g; u--)
          b = l[u], h = O.get(b), v[u] = h === void 0 ? -1 : h, O.set(b, u);
        for (h = g; h <= m; h++)
          b = r[h], u = O.get(b), u !== void 0 && u !== -1 ? (S[u] = s[h], f[u] = n[h], a && (p[u] = a[h]), u = v[u], O.set(b, u)) : n[h]();
        for (u = g; u < c; u++)
          u in S ? (s[u] = S[u], n[u] = f[u], a && (a[u] = p[u], a[u](u))) : s[u] = Kr(d);
        s = s.slice(0, o = c), r = l.slice(0);
      }
      return s;
    });
    function d(O) {
      if (n[u] = O, a) {
        const [v, S] = se(u);
        return a[u] = S, e(l[u], v);
      }
      return e(l[u]);
    }
  };
}
function Z(i, e) {
  return ot(() => i(e || {}));
}
function So() {
  return !0;
}
const lh = {
  get(i, e, t) {
    return e === Ut ? t : i.get(e);
  },
  has(i, e) {
    return e === Ut ? !0 : i.has(e);
  },
  set: So,
  deleteProperty: So,
  getOwnPropertyDescriptor(i, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return i.get(e);
      },
      set: So,
      deleteProperty: So
    };
  },
  ownKeys(i) {
    return i.keys();
  }
};
function Yl(i) {
  return (i = typeof i == "function" ? i() : i) ? i : {};
}
function Yy() {
  for (let i = 0, e = this.length; i < e; ++i) {
    const t = this[i]();
    if (t !== void 0) return t;
  }
}
function Ca(...i) {
  let e = !1;
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    e = e || !!a && Ut in a, i[o] = typeof a == "function" ? (e = !0, Re(a)) : a;
  }
  if (Cm && e)
    return new Proxy({
      get(o) {
        for (let a = i.length - 1; a >= 0; a--) {
          const l = Yl(i[a])[o];
          if (l !== void 0) return l;
        }
      },
      has(o) {
        for (let a = i.length - 1; a >= 0; a--)
          if (o in Yl(i[a])) return !0;
        return !1;
      },
      keys() {
        const o = [];
        for (let a = 0; a < i.length; a++) o.push(...Object.keys(Yl(i[a])));
        return [...new Set(o)];
      }
    }, lh);
  const t = {}, r = /* @__PURE__ */ Object.create(null);
  for (let o = i.length - 1; o >= 0; o--) {
    const a = i[o];
    if (!a) continue;
    const l = Object.getOwnPropertyNames(a);
    for (let c = l.length - 1; c >= 0; c--) {
      const h = l[c];
      if (h === "__proto__" || h === "constructor") continue;
      const u = Object.getOwnPropertyDescriptor(a, h);
      if (!r[h])
        r[h] = u.get ? {
          enumerable: !0,
          configurable: !0,
          get: Yy.bind(t[h] = [u.get.bind(a)])
        } : u.value !== void 0 ? u : void 0;
      else {
        const d = t[h];
        d && (u.get ? d.push(u.get.bind(a)) : u.value !== void 0 && d.push(() => u.value));
      }
    }
  }
  const s = {}, n = Object.keys(r);
  for (let o = n.length - 1; o >= 0; o--) {
    const a = n[o], l = r[a];
    l && l.get ? Object.defineProperty(s, a, l) : s[a] = l ? l.value : void 0;
  }
  return s;
}
function Dm(i, ...e) {
  if (Cm && Ut in i) {
    const s = new Set(e.length > 1 ? e.flat() : e[0]), n = e.map((o) => new Proxy({
      get(a) {
        return o.includes(a) ? i[a] : void 0;
      },
      has(a) {
        return o.includes(a) && a in i;
      },
      keys() {
        return o.filter((a) => a in i);
      }
    }, lh));
    return n.push(new Proxy({
      get(o) {
        return s.has(o) ? void 0 : i[o];
      },
      has(o) {
        return s.has(o) ? !1 : o in i;
      },
      keys() {
        return Object.keys(i).filter((o) => !s.has(o));
      }
    }, lh)), n;
  }
  const t = {}, r = e.map(() => ({}));
  for (const s of Object.getOwnPropertyNames(i)) {
    const n = Object.getOwnPropertyDescriptor(i, s), o = !n.get && !n.set && n.enumerable && n.writable && n.configurable;
    let a = !1, l = 0;
    for (const c of e)
      c.includes(s) && (a = !0, o ? r[l][s] = n.value : Object.defineProperty(r[l], s, n)), ++l;
    a || (o ? t[s] = n.value : Object.defineProperty(t, s, n));
  }
  return [...r, t];
}
function Fy(i) {
  let e, t;
  const r = (s) => {
    const n = ce.context;
    if (n) {
      const [a, l] = se();
      ce.count || (ce.count = 0), ce.count++, (t || (t = i())).then((c) => {
        !ce.done && Ei(n), ce.count--, l(() => c.default), Ei();
      }), e = a;
    } else if (!e) {
      const [a] = Gu(() => (t || (t = i())).then((l) => l.default));
      e = a;
    }
    let o;
    return Re(() => (o = e()) ? ot(() => {
      if (!n || ce.done) return o(s);
      const a = ce.context;
      Ei(n);
      const l = o(s);
      return Ei(a), l;
    }) : "");
  };
  return r.preload = () => t || ((t = i()).then((s) => e = () => s.default), t), r;
}
const Hy = (i) => `Stale read from <${i}>.`;
function _t(i) {
  const e = "fallback" in i && {
    fallback: () => i.fallback
  };
  return Re(Ny(() => i.each, i.children, e || void 0));
}
function $e(i) {
  const e = i.keyed, t = Re(() => i.when, void 0, void 0), r = e ? t : Re(t, void 0, {
    equals: (s, n) => !s == !n
  });
  return Re(() => {
    const s = r();
    if (s) {
      const n = i.children;
      return typeof n == "function" && n.length > 0 ? ot(() => n(e ? s : () => {
        if (!ot(r)) throw Hy("Show");
        return t();
      })) : n;
    }
    return i.fallback;
  }, void 0, void 0);
}
const Gy = /* @__PURE__ */ Hn();
function Ky(i) {
  let e = 0, t, r, s, n, o;
  const [a, l] = se(!1), c = Wy(), h = {
    increment: () => {
      ++e === 1 && l(!0);
    },
    decrement: () => {
      --e === 0 && l(!1);
    },
    inFallback: a,
    effects: [],
    resolved: !1
  }, u = Fn();
  if (ce.context && ce.load) {
    const v = ce.getContextId();
    let S = ce.load(v);
    if (S && (typeof S != "object" || S.s !== 1 ? s = S : ce.gather(v)), s && s !== "$$f") {
      const [f, p] = se(void 0, {
        equals: !1
      });
      n = f, s.then(() => {
        if (ce.done) return p();
        ce.gather(v), Ei(r), p(), Ei();
      }, (g) => {
        o = g, p();
      });
    }
  }
  const d = Br(Gy);
  d && (t = d.register(h.inFallback));
  let O;
  return ft(() => O && O()), Z(c.Provider, {
    value: h,
    get children() {
      return Re(() => {
        if (o) throw o;
        if (r = ce.context, n)
          return n(), n = void 0;
        r && s === "$$f" && Ei();
        const v = Re(() => i.children);
        return Re((S) => {
          const f = h.inFallback(), {
            showContent: p = !0,
            showFallback: g = !0
          } = t ? t() : {};
          if ((!f || s && s !== "$$f") && p)
            return h.resolved = !0, O && O(), O = r = s = void 0, Zy(h.effects), v();
          if (g)
            return O ? S : Kr((m) => (O = m, r && (Ei({
              id: r.id + "F",
              count: 0
            }), r = void 0), i.fallback), u);
        });
      });
    }
  });
}
const Jy = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"], e1 = /* @__PURE__ */ new Set(["className", "value", "readOnly", "noValidate", "formNoValidate", "isMap", "noModule", "playsInline", ...Jy]), t1 = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]), i1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
}), r1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  novalidate: {
    $: "noValidate",
    FORM: 1
  },
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function s1(i, e) {
  const t = r1[i];
  return typeof t == "object" ? t[e] ? t.$ : void 0 : t;
}
const n1 = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]), bt = (i) => Re(() => i());
function o1(i, e, t) {
  let r = t.length, s = e.length, n = r, o = 0, a = 0, l = e[s - 1].nextSibling, c = null;
  for (; o < s || a < n; ) {
    if (e[o] === t[a]) {
      o++, a++;
      continue;
    }
    for (; e[s - 1] === t[n - 1]; )
      s--, n--;
    if (s === o) {
      const h = n < r ? a ? t[a - 1].nextSibling : t[n - a] : l;
      for (; a < n; ) i.insertBefore(t[a++], h);
    } else if (n === a)
      for (; o < s; )
        (!c || !c.has(e[o])) && e[o].remove(), o++;
    else if (e[o] === t[n - 1] && t[a] === e[s - 1]) {
      const h = e[--s].nextSibling;
      i.insertBefore(t[a++], e[o++].nextSibling), i.insertBefore(t[--n], h), e[s] = t[n];
    } else {
      if (!c) {
        c = /* @__PURE__ */ new Map();
        let u = a;
        for (; u < n; ) c.set(t[u], u++);
      }
      const h = c.get(e[o]);
      if (h != null)
        if (a < h && h < n) {
          let u = o, d = 1, O;
          for (; ++u < s && u < n && !((O = c.get(e[u])) == null || O !== h + d); )
            d++;
          if (d > h - a) {
            const v = e[o];
            for (; a < h; ) i.insertBefore(t[a++], v);
          } else i.replaceChild(t[a++], e[o++]);
        } else o++;
      else e[o++].remove();
    }
  }
}
const Pd = "_$DX_DELEGATE";
function a1(i, e, t, r = {}) {
  let s;
  return Kr((n) => {
    s = n, e === document ? i() : X(e, i(), e.firstChild ? null : void 0, t);
  }, r.owner), () => {
    s(), e.textContent = "";
  };
}
function H(i, e, t, r) {
  let s;
  const n = () => {
    const a = r ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
    return a.innerHTML = i, t ? a.content.firstChild.firstChild : r ? a.firstChild : a.content.firstChild;
  }, o = e ? () => ot(() => document.importNode(s || (s = n()), !0)) : () => (s || (s = n())).cloneNode(!0);
  return o.cloneNode = o, o;
}
function dt(i, e = window.document) {
  const t = e[Pd] || (e[Pd] = /* @__PURE__ */ new Set());
  for (let r = 0, s = i.length; r < s; r++) {
    const n = i[r];
    t.has(n) || (t.add(n), e.addEventListener(n, u1));
  }
}
function Ae(i, e, t) {
  Gn(i) || (t == null ? i.removeAttribute(e) : i.setAttribute(e, t));
}
function l1(i, e, t) {
  Gn(i) || (t ? i.setAttribute(e, "") : i.removeAttribute(e));
}
function Vt(i, e) {
  Gn(i) || (e == null ? i.removeAttribute("class") : i.className = e);
}
function Mm(i, e, t, r) {
  if (r)
    Array.isArray(t) ? (i[`$$${e}`] = t[0], i[`$$${e}Data`] = t[1]) : i[`$$${e}`] = t;
  else if (Array.isArray(t)) {
    const s = t[0];
    i.addEventListener(e, t[0] = (n) => s.call(i, t[1], n));
  } else i.addEventListener(e, t, typeof t != "function" && t);
}
function pn(i, e, t = {}) {
  const r = Object.keys(e || {}), s = Object.keys(t);
  let n, o;
  for (n = 0, o = s.length; n < o; n++) {
    const a = s[n];
    !a || a === "undefined" || e[a] || (Td(i, a, !1), delete t[a]);
  }
  for (n = 0, o = r.length; n < o; n++) {
    const a = r[n], l = !!e[a];
    !a || a === "undefined" || t[a] === l || !l || (Td(i, a, !0), t[a] = l);
  }
  return t;
}
function Qa(i, e, t) {
  if (!e) return t ? Ae(i, "style") : e;
  const r = i.style;
  if (typeof e == "string") return r.cssText = e;
  typeof t == "string" && (r.cssText = t = void 0), t || (t = {}), e || (e = {});
  let s, n;
  for (n in t)
    e[n] == null && r.removeProperty(n), delete t[n];
  for (n in e)
    s = e[n], s !== t[n] && (r.setProperty(n, s), t[n] = s);
  return t;
}
function rf(i, e = {}, t, r) {
  const s = {};
  return r || Oe(() => s.children = gn(i, e.children, s.children)), Oe(() => typeof e.ref == "function" && Tr(e.ref, i)), Oe(() => c1(i, e, t, !0, s, !0)), s;
}
function Tr(i, e, t) {
  return ot(() => i(e, t));
}
function X(i, e, t, r) {
  if (t !== void 0 && !r && (r = []), typeof e != "function") return gn(i, e, r, t);
  Oe((s) => gn(i, e(), s, t), r);
}
function c1(i, e, t, r, s = {}, n = !1) {
  e || (e = {});
  for (const o in s)
    if (!(o in e)) {
      if (o === "children") continue;
      s[o] = $d(i, o, null, s[o], t, n, e);
    }
  for (const o in e) {
    if (o === "children")
      continue;
    const a = e[o];
    s[o] = $d(i, o, a, s[o], t, n, e);
  }
}
function Gn(i) {
  return !!ce.context && !ce.done && (!i || i.isConnected);
}
function h1(i) {
  return i.toLowerCase().replace(/-([a-z])/g, (e, t) => t.toUpperCase());
}
function Td(i, e, t) {
  const r = e.trim().split(/\s+/);
  for (let s = 0, n = r.length; s < n; s++) i.classList.toggle(r[s], t);
}
function $d(i, e, t, r, s, n, o) {
  let a, l, c, h, u;
  if (e === "style") return Qa(i, t, r);
  if (e === "classList") return pn(i, t, r);
  if (t === r) return r;
  if (e === "ref")
    n || t(i);
  else if (e.slice(0, 3) === "on:") {
    const d = e.slice(3);
    r && i.removeEventListener(d, r, typeof r != "function" && r), t && i.addEventListener(d, t, typeof t != "function" && t);
  } else if (e.slice(0, 10) === "oncapture:") {
    const d = e.slice(10);
    r && i.removeEventListener(d, r, !0), t && i.addEventListener(d, t, !0);
  } else if (e.slice(0, 2) === "on") {
    const d = e.slice(2).toLowerCase(), O = n1.has(d);
    if (!O && r) {
      const v = Array.isArray(r) ? r[0] : r;
      i.removeEventListener(d, v);
    }
    (O || t) && (Mm(i, d, t, O), O && dt([d]));
  } else if (e.slice(0, 5) === "attr:")
    Ae(i, e.slice(5), t);
  else if (e.slice(0, 5) === "bool:")
    l1(i, e.slice(5), t);
  else if ((u = e.slice(0, 5) === "prop:") || (c = t1.has(e)) || (h = s1(e, i.tagName)) || (l = e1.has(e)) || (a = i.nodeName.includes("-") || "is" in o)) {
    if (u)
      e = e.slice(5), l = !0;
    else if (Gn(i)) return t;
    e === "class" || e === "className" ? Vt(i, t) : a && !l && !c ? i[h1(e)] = t : i[h || e] = t;
  } else
    Ae(i, i1[e] || e, t);
  return t;
}
function u1(i) {
  if (ce.registry && ce.events && ce.events.find(([l, c]) => c === i))
    return;
  let e = i.target;
  const t = `$$${i.type}`, r = i.target, s = i.currentTarget, n = (l) => Object.defineProperty(i, "target", {
    configurable: !0,
    value: l
  }), o = () => {
    const l = e[t];
    if (l && !e.disabled) {
      const c = e[`${t}Data`];
      if (c !== void 0 ? l.call(e, c, i) : l.call(e, i), i.cancelBubble) return;
    }
    return e.host && typeof e.host != "string" && !e.host._$host && e.contains(i.target) && n(e.host), !0;
  }, a = () => {
    for (; o() && (e = e._$host || e.parentNode || e.host); ) ;
  };
  if (Object.defineProperty(i, "currentTarget", {
    configurable: !0,
    get() {
      return e || document;
    }
  }), ce.registry && !ce.done && (ce.done = _$HY.done = !0), i.composedPath) {
    const l = i.composedPath();
    n(l[0]);
    for (let c = 0; c < l.length - 2 && (e = l[c], !!o()); c++) {
      if (e._$host) {
        e = e._$host, a();
        break;
      }
      if (e.parentNode === s)
        break;
    }
  } else a();
  n(r);
}
function gn(i, e, t, r, s) {
  const n = Gn(i);
  if (n) {
    !t && (t = [...i.childNodes]);
    let l = [];
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.nodeType === 8 && h.data.slice(0, 2) === "!$" ? h.remove() : l.push(h);
    }
    t = l;
  }
  for (; typeof t == "function"; ) t = t();
  if (e === t) return t;
  const o = typeof e, a = r !== void 0;
  if (i = a && t[0] && t[0].parentNode || i, o === "string" || o === "number") {
    if (n || o === "number" && (e = e.toString(), e === t))
      return t;
    if (a) {
      let l = t[0];
      l && l.nodeType === 3 ? l.data !== e && (l.data = e) : l = document.createTextNode(e), t = Xr(i, t, r, l);
    } else
      t !== "" && typeof t == "string" ? t = i.firstChild.data = e : t = i.textContent = e;
  } else if (e == null || o === "boolean") {
    if (n) return t;
    t = Xr(i, t, r);
  } else {
    if (o === "function")
      return Oe(() => {
        let l = e();
        for (; typeof l == "function"; ) l = l();
        t = gn(i, l, t, r);
      }), () => t;
    if (Array.isArray(e)) {
      const l = [], c = t && Array.isArray(t);
      if (ch(l, e, t, s))
        return Oe(() => t = gn(i, l, t, r, !0)), () => t;
      if (n) {
        if (!l.length) return t;
        if (r === void 0) return t = [...i.childNodes];
        let h = l[0];
        if (h.parentNode !== i) return t;
        const u = [h];
        for (; (h = h.nextSibling) !== r; ) u.push(h);
        return t = u;
      }
      if (l.length === 0) {
        if (t = Xr(i, t, r), a) return t;
      } else c ? t.length === 0 ? Rd(i, l, r) : o1(i, t, l) : (t && Xr(i), Rd(i, l));
      t = l;
    } else if (e.nodeType) {
      if (n && e.parentNode) return t = a ? [e] : e;
      if (Array.isArray(t)) {
        if (a) return t = Xr(i, t, r, e);
        Xr(i, t, null, e);
      } else t == null || t === "" || !i.firstChild ? i.appendChild(e) : i.replaceChild(e, i.firstChild);
      t = e;
    }
  }
  return t;
}
function ch(i, e, t, r) {
  let s = !1;
  for (let n = 0, o = e.length; n < o; n++) {
    let a = e[n], l = t && t[i.length], c;
    if (!(a == null || a === !0 || a === !1)) if ((c = typeof a) == "object" && a.nodeType)
      i.push(a);
    else if (Array.isArray(a))
      s = ch(i, a, l) || s;
    else if (c === "function")
      if (r) {
        for (; typeof a == "function"; ) a = a();
        s = ch(i, Array.isArray(a) ? a : [a], Array.isArray(l) ? l : [l]) || s;
      } else
        i.push(a), s = !0;
    else {
      const h = String(a);
      l && l.nodeType === 3 && l.data === h ? i.push(l) : i.push(document.createTextNode(h));
    }
  }
  return s;
}
function Rd(i, e, t = null) {
  for (let r = 0, s = e.length; r < s; r++) i.insertBefore(e[r], t);
}
function Xr(i, e, t, r) {
  if (t === void 0) return i.textContent = "";
  const s = r || document.createTextNode("");
  if (e.length) {
    let n = !1;
    for (let o = e.length - 1; o >= 0; o--) {
      const a = e[o];
      if (s !== a) {
        const l = a.parentNode === i;
        !n && !o ? l ? i.replaceChild(s, a) : i.insertBefore(s, t) : l && a.remove();
      } else n = !0;
    }
  } else i.insertBefore(s, t);
  return [s];
}
const f1 = !1;
function Bm() {
  let i = /* @__PURE__ */ new Set();
  function e(s) {
    return i.add(s), () => i.delete(s);
  }
  let t = !1;
  function r(s, n) {
    if (t)
      return !(t = !1);
    const o = {
      to: s,
      options: n,
      defaultPrevented: !1,
      preventDefault: () => o.defaultPrevented = !0
    };
    for (const a of i)
      a.listener({
        ...o,
        from: a.location,
        retry: (l) => {
          l && (t = !0), a.navigate(s, { ...n, resolve: !1 });
        }
      });
    return !o.defaultPrevented;
  }
  return {
    subscribe: e,
    confirm: r
  };
}
let hh;
function sf() {
  (!window.history.state || window.history.state._depth == null) && window.history.replaceState({ ...window.history.state, _depth: window.history.length - 1 }, ""), hh = window.history.state._depth;
}
sf();
function d1(i) {
  return {
    ...i,
    _depth: window.history.state && window.history.state._depth
  };
}
function O1(i, e) {
  let t = !1;
  return () => {
    const r = hh;
    sf();
    const s = r == null ? null : hh - r;
    if (t) {
      t = !1;
      return;
    }
    s && e(s) ? (t = !0, window.history.go(-s)) : i();
  };
}
const p1 = /^(?:[a-z0-9]+:)?\/\//i, g1 = /^\/+|(\/)\/+$/g, qm = "http://sr";
function xr(i, e = !1) {
  const t = i.replace(g1, "$1");
  return t ? e || /^[?#]/.test(t) ? t : "/" + t : "";
}
function Ho(i, e, t) {
  if (p1.test(e))
    return;
  const r = xr(i), s = t && xr(t);
  let n = "";
  return !s || e.startsWith("/") ? n = r : s.toLowerCase().indexOf(r.toLowerCase()) !== 0 ? n = r + s : n = s, (n || "/") + xr(e, !n);
}
function m1(i, e) {
  if (i == null)
    throw new Error(e);
  return i;
}
function S1(i, e) {
  return xr(i).replace(/\/*(\*.*)?$/g, "") + xr(e);
}
function Xm(i) {
  const e = {};
  return i.searchParams.forEach((t, r) => {
    r in e ? Array.isArray(e[r]) ? e[r].push(t) : e[r] = [e[r], t] : e[r] = t;
  }), e;
}
function v1(i, e, t) {
  const [r, s] = i.split("/*", 2), n = r.split("/").filter(Boolean), o = n.length;
  return (a) => {
    const l = a.split("/").filter(Boolean), c = l.length - o;
    if (c < 0 || c > 0 && s === void 0 && !e)
      return null;
    const h = {
      path: o ? "" : "/",
      params: {}
    }, u = (d) => t === void 0 ? void 0 : t[d];
    for (let d = 0; d < o; d++) {
      const O = n[d], v = O[0] === ":", S = v ? l[d] : l[d].toLowerCase(), f = v ? O.slice(1) : O.toLowerCase();
      if (v && Fl(S, u(f)))
        h.params[f] = S;
      else if (v || !Fl(S, f))
        return null;
      h.path += `/${S}`;
    }
    if (s) {
      const d = c ? l.slice(-c).join("/") : "";
      if (Fl(d, u(s)))
        h.params[s] = d;
      else
        return null;
    }
    return h;
  };
}
function Fl(i, e) {
  const t = (r) => r === i;
  return e === void 0 ? !0 : typeof e == "string" ? t(e) : typeof e == "function" ? e(i) : Array.isArray(e) ? e.some(t) : e instanceof RegExp ? e.test(i) : !1;
}
function _1(i) {
  const [e, t] = i.pattern.split("/*", 2), r = e.split("/").filter(Boolean);
  return r.reduce((s, n) => s + (n.startsWith(":") ? 2 : 3), r.length - (t === void 0 ? 0 : 1));
}
function Im(i) {
  const e = /* @__PURE__ */ new Map(), t = Fn();
  return new Proxy({}, {
    get(r, s) {
      return e.has(s) || Ju(t, () => e.set(s, Re(() => i()[s]))), e.get(s)();
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    },
    ownKeys() {
      return Reflect.ownKeys(i());
    }
  });
}
function Zm(i) {
  let e = /(\/?\:[^\/]+)\?/.exec(i);
  if (!e)
    return [i];
  let t = i.slice(0, e.index), r = i.slice(e.index + e[0].length);
  const s = [t, t += e[1]];
  for (; e = /^(\/\:[^\/]+)\?/.exec(r); )
    s.push(t += e[1]), r = r.slice(e[0].length);
  return Zm(r).reduce((n, o) => [...n, ...s.map((a) => a + o)], []);
}
const b1 = 100, Wm = Hn(), nf = Hn(), Kn = () => m1(Br(Wm), "<A> and 'use' router primitives can be only used inside a Route."), y1 = () => Br(nf) || Kn().base, w1 = (i) => {
  const e = y1();
  return Re(() => e.resolvePath(i()));
}, x1 = (i) => {
  const e = Kn();
  return Re(() => {
    const t = i();
    return t !== void 0 ? e.renderPath(t) : t;
  });
}, zm = () => Kn().navigatorFactory(), Vm = () => Kn().location, p3 = () => Kn().params;
function k1(i, e = "") {
  const { component: t, preload: r, load: s, children: n, info: o } = i, a = !n || Array.isArray(n) && !n.length, l = {
    key: i,
    component: t,
    preload: r || s,
    info: o
  };
  return Um(i.path).reduce((c, h) => {
    for (const u of Zm(h)) {
      const d = S1(e, u);
      let O = a ? d : d.split("/*", 1)[0];
      O = O.split("/").map((v) => v.startsWith(":") || v.startsWith("*") ? v : encodeURIComponent(v)).join("/"), c.push({
        ...l,
        originalPath: h,
        pattern: O,
        matcher: v1(O, !a, i.matchFilters)
      });
    }
    return c;
  }, []);
}
function C1(i, e = 0) {
  return {
    routes: i,
    score: _1(i[i.length - 1]) * 1e4 - e,
    matcher(t) {
      const r = [];
      for (let s = i.length - 1; s >= 0; s--) {
        const n = i[s], o = n.matcher(t);
        if (!o)
          return null;
        r.unshift({
          ...o,
          route: n
        });
      }
      return r;
    }
  };
}
function Um(i) {
  return Array.isArray(i) ? i : [i];
}
function jm(i, e = "", t = [], r = []) {
  const s = Um(i);
  for (let n = 0, o = s.length; n < o; n++) {
    const a = s[n];
    if (a && typeof a == "object") {
      a.hasOwnProperty("path") || (a.path = "");
      const l = k1(a, e);
      for (const c of l) {
        t.push(c);
        const h = Array.isArray(a.children) && a.children.length === 0;
        if (a.children && !h)
          jm(a.children, c.pattern, t, r);
        else {
          const u = C1([...t], r.length);
          r.push(u);
        }
        t.pop();
      }
    }
  }
  return t.length ? r : r.sort((n, o) => o.score - n.score);
}
function Hl(i, e) {
  for (let t = 0, r = i.length; t < r; t++) {
    const s = i[t].matcher(e);
    if (s)
      return s;
  }
  return [];
}
function Q1(i, e, t) {
  const r = new URL(qm), s = Re((h) => {
    const u = i();
    try {
      return new URL(u, r);
    } catch {
      return console.error(`Invalid path ${u}`), h;
    }
  }, r, {
    equals: (h, u) => h.href === u.href
  }), n = Re(() => s().pathname), o = Re(() => s().search, !0), a = Re(() => s().hash), l = () => "", c = Ku(o, () => Xm(s()));
  return {
    get pathname() {
      return n();
    },
    get search() {
      return o();
    },
    get hash() {
      return a();
    },
    get state() {
      return e();
    },
    get key() {
      return l();
    },
    query: t ? t(c) : Im(c)
  };
}
let pr;
function P1() {
  return pr;
}
function T1(i, e, t, r = {}) {
  const { signal: [s, n], utils: o = {} } = i, a = o.parsePath || ((M) => M), l = o.renderPath || ((M) => M), c = o.beforeLeave || Bm(), h = Ho("", r.base || "");
  if (h === void 0)
    throw new Error(`${h} is not a valid base path`);
  h && !s().value && n({ value: h, replace: !0, scroll: !1 });
  const [u, d] = se(!1);
  let O;
  const v = (M, B) => {
    B.value === S() && B.state === p() || (O === void 0 && d(!0), pr = M, O = B, Iy(() => {
      O === B && (f(O.value), g(O.state), b[1]((W) => W.filter((z) => z.pending)));
    }).finally(() => {
      O === B && Tm(() => {
        pr = void 0, M === "navigate" && T(O), d(!1), O = void 0;
      });
    }));
  }, [S, f] = se(s().value), [p, g] = se(s().state), m = Q1(S, p, o.queryWrapper), _ = [], b = se([]), w = Re(() => typeof r.transformUrl == "function" ? Hl(e(), r.transformUrl(m.pathname)) : Hl(e(), m.pathname)), x = () => {
    const M = w(), B = {};
    for (let W = 0; W < M.length; W++)
      Object.assign(B, M[W].params);
    return B;
  }, y = o.paramsWrapper ? o.paramsWrapper(x, e) : Im(x), k = {
    pattern: h,
    path: () => h,
    outlet: () => null,
    resolvePath(M) {
      return Ho(h, M);
    }
  };
  return Oe(Ku(s, (M) => v("native", M), { defer: !0 })), {
    base: k,
    location: m,
    params: y,
    isRouting: u,
    renderPath: l,
    parsePath: a,
    navigatorFactory: R,
    matches: w,
    beforeLeave: c,
    preloadRoute: A,
    singleFlight: r.singleFlight === void 0 ? !0 : r.singleFlight,
    submissions: b
  };
  function $(M, B, W) {
    ot(() => {
      if (typeof B == "number") {
        B && (o.go ? o.go(B) : console.warn("Router integration does not support relative routing"));
        return;
      }
      const z = !B || B[0] === "?", { replace: Q, resolve: E, scroll: L, state: D } = {
        replace: !1,
        resolve: !z,
        scroll: !0,
        ...W
      }, U = E ? M.resolvePath(B) : Ho(z && m.pathname || "", B);
      if (U === void 0)
        throw new Error(`Path '${B}' is not a routable path`);
      if (_.length >= b1)
        throw new Error("Too many redirects");
      const Y = S();
      (U !== Y || D !== p()) && (f1 || c.confirm(U, W) && (_.push({ value: Y, replace: Q, scroll: L, state: p() }), v("navigate", {
        value: U,
        state: D
      })));
    });
  }
  function R(M) {
    return M = M || Br(nf) || k, (B, W) => $(M, B, W);
  }
  function T(M) {
    const B = _[0];
    B && (n({
      ...M,
      replace: B.replace,
      scroll: B.scroll
    }), _.length = 0);
  }
  function A(M, B) {
    const W = Hl(e(), M.pathname), z = pr;
    pr = "preload";
    for (let Q in W) {
      const { route: E, params: L } = W[Q];
      E.component && E.component.preload && E.component.preload();
      const { preload: D } = E;
      B && D && Ju(t(), () => D({
        params: L,
        location: {
          pathname: M.pathname,
          search: M.search,
          hash: M.hash,
          query: Xm(M),
          state: null,
          key: ""
        },
        intent: "preload"
      }));
    }
    pr = z;
  }
}
function $1(i, e, t, r) {
  const { base: s, location: n, params: o } = i, { pattern: a, component: l, preload: c } = r().route, h = Re(() => r().path);
  l && l.preload && l.preload();
  const u = c ? c({ params: o, location: n, intent: pr || "initial" }) : void 0;
  return {
    parent: e,
    pattern: a,
    path: h,
    outlet: () => l ? Z(l, {
      params: o,
      location: n,
      data: u,
      get children() {
        return t();
      }
    }) : t(),
    resolvePath(O) {
      return Ho(s.path(), O, h());
    }
  };
}
const R1 = (i) => (e) => {
  const {
    base: t
  } = e, r = ef(() => e.children), s = Re(() => jm(r(), e.base || ""));
  let n;
  const o = T1(i, s, () => n, {
    base: t,
    singleFlight: e.singleFlight,
    transformUrl: e.transformUrl
  });
  return i.create && i.create(o), Z(Wm.Provider, {
    value: o,
    get children() {
      return Z(E1, {
        routerState: o,
        get root() {
          return e.root;
        },
        get preload() {
          return e.rootPreload || e.rootLoad;
        },
        get children() {
          return [bt(() => (n = Fn()) && null), Z(A1, {
            routerState: o,
            get branches() {
              return s();
            }
          })];
        }
      });
    }
  });
};
function E1(i) {
  const e = i.routerState.location, t = i.routerState.params, r = Re(() => i.preload && ot(() => {
    i.preload({
      params: t,
      location: e,
      intent: P1() || "initial"
    });
  }));
  return Z($e, {
    get when() {
      return i.root;
    },
    keyed: !0,
    get fallback() {
      return i.children;
    },
    children: (s) => Z(s, {
      params: t,
      location: e,
      get data() {
        return r();
      },
      get children() {
        return i.children;
      }
    })
  });
}
function A1(i) {
  const e = [];
  let t;
  const r = Re(Ku(i.routerState.matches, (s, n, o) => {
    let a = n && s.length === n.length;
    const l = [];
    for (let c = 0, h = s.length; c < h; c++) {
      const u = n && n[c], d = s[c];
      o && u && d.route.key === u.route.key ? l[c] = o[c] : (a = !1, e[c] && e[c](), Kr((O) => {
        e[c] = O, l[c] = $1(i.routerState, l[c - 1] || i.routerState.base, Ed(() => r()[c + 1]), () => i.routerState.matches()[c]);
      }));
    }
    return e.splice(s.length).forEach((c) => c()), o && a ? o : (t = l[0], l);
  }));
  return Ed(() => r() && t)();
}
const Ed = (i) => () => Z($e, {
  get when() {
    return i();
  },
  keyed: !0,
  children: (e) => Z(nf.Provider, {
    value: e,
    get children() {
      return e.outlet();
    }
  })
}), wi = (i) => {
  const e = ef(() => i.children);
  return Ca(i, {
    get children() {
      return e();
    }
  });
};
function L1([i, e], t, r) {
  return [i, r ? (s) => e(r(s)) : e];
}
function D1(i) {
  let e = !1;
  const t = (s) => typeof s == "string" ? { value: s } : s, r = L1(se(t(i.get()), {
    equals: (s, n) => s.value === n.value && s.state === n.state
  }), void 0, (s) => (!e && i.set(s), ce.registry && !ce.done && (ce.done = !0), s));
  return i.init && ft(i.init((s = i.get()) => {
    e = !0, r[1](t(s)), e = !1;
  })), R1({
    signal: r,
    create: i.create,
    utils: i.utils
  });
}
function M1(i, e, t) {
  return i.addEventListener(e, t), () => i.removeEventListener(e, t);
}
function B1(i, e) {
  const t = i && document.getElementById(i);
  t ? t.scrollIntoView() : e && window.scrollTo(0, 0);
}
const q1 = /* @__PURE__ */ new Map();
function X1(i = !0, e = !1, t = "/_server", r) {
  return (s) => {
    const n = s.base.path(), o = s.navigatorFactory(s.base);
    let a, l;
    function c(S) {
      return S.namespaceURI === "http://www.w3.org/2000/svg";
    }
    function h(S) {
      if (S.defaultPrevented || S.button !== 0 || S.metaKey || S.altKey || S.ctrlKey || S.shiftKey)
        return;
      const f = S.composedPath().find((w) => w instanceof Node && w.nodeName.toUpperCase() === "A");
      if (!f || e && !f.hasAttribute("link"))
        return;
      const p = c(f), g = p ? f.href.baseVal : f.href;
      if ((p ? f.target.baseVal : f.target) || !g && !f.hasAttribute("state"))
        return;
      const _ = (f.getAttribute("rel") || "").split(/\s+/);
      if (f.hasAttribute("download") || _ && _.includes("external"))
        return;
      const b = p ? new URL(g, document.baseURI) : new URL(g);
      if (!(b.origin !== window.location.origin || n && b.pathname && !b.pathname.toLowerCase().startsWith(n.toLowerCase())))
        return [f, b];
    }
    function u(S) {
      const f = h(S);
      if (!f)
        return;
      const [p, g] = f, m = s.parsePath(g.pathname + g.search + g.hash), _ = p.getAttribute("state");
      S.preventDefault(), o(m, {
        resolve: !1,
        replace: p.hasAttribute("replace"),
        scroll: !p.hasAttribute("noscroll"),
        state: _ ? JSON.parse(_) : void 0
      });
    }
    function d(S) {
      const f = h(S);
      if (!f)
        return;
      const [p, g] = f;
      r && (g.pathname = r(g.pathname)), s.preloadRoute(g, p.getAttribute("preload") !== "false");
    }
    function O(S) {
      clearTimeout(a);
      const f = h(S);
      if (!f)
        return l = null;
      const [p, g] = f;
      l !== p && (r && (g.pathname = r(g.pathname)), a = setTimeout(() => {
        s.preloadRoute(g, p.getAttribute("preload") !== "false"), l = p;
      }, 20));
    }
    function v(S) {
      if (S.defaultPrevented)
        return;
      let f = S.submitter && S.submitter.hasAttribute("formaction") ? S.submitter.getAttribute("formaction") : S.target.getAttribute("action");
      if (!f)
        return;
      if (!f.startsWith("https://action/")) {
        const g = new URL(f, qm);
        if (f = s.parsePath(g.pathname + g.search), !f.startsWith(t))
          return;
      }
      if (S.target.method.toUpperCase() !== "POST")
        throw new Error("Only POST forms are supported for Actions");
      const p = q1.get(f);
      if (p) {
        S.preventDefault();
        const g = new FormData(S.target, S.submitter);
        p.call({ r: s, f: S.target }, S.target.enctype === "multipart/form-data" ? g : new URLSearchParams(g));
      }
    }
    dt(["click", "submit"]), document.addEventListener("click", u), i && (document.addEventListener("mousemove", O, { passive: !0 }), document.addEventListener("focusin", d, { passive: !0 }), document.addEventListener("touchstart", d, { passive: !0 })), document.addEventListener("submit", v), ft(() => {
      document.removeEventListener("click", u), i && (document.removeEventListener("mousemove", O), document.removeEventListener("focusin", d), document.removeEventListener("touchstart", d)), document.removeEventListener("submit", v);
    });
  };
}
function I1(i) {
  const e = () => {
    const r = window.location.pathname.replace(/^\/+/, "/") + window.location.search, s = window.history.state && window.history.state._depth && Object.keys(window.history.state).length === 1 ? void 0 : window.history.state;
    return {
      value: r + window.location.hash,
      state: s
    };
  }, t = Bm();
  return D1({
    get: e,
    set({ value: r, replace: s, scroll: n, state: o }) {
      s ? window.history.replaceState(d1(o), "", r) : window.history.pushState(o, "", r), B1(decodeURIComponent(window.location.hash.slice(1)), n), sf();
    },
    init: (r) => M1(window, "popstate", O1(r, (s) => {
      if (s && s < 0)
        return !t.confirm(s);
      {
        const n = e();
        return !t.confirm(n.value, { state: n.state });
      }
    })),
    create: X1(i.preload, i.explicitLinks, i.actionBase, i.transformUrl),
    utils: {
      go: (r) => window.history.go(r),
      beforeLeave: t
    }
  })(i);
}
var Z1 = /* @__PURE__ */ H("<a>");
function Nm(i) {
  i = Ca({
    inactiveClass: "inactive",
    activeClass: "active"
  }, i);
  const [, e] = Dm(i, ["href", "state", "class", "activeClass", "inactiveClass", "end"]), t = w1(() => i.href), r = x1(t), s = Vm(), n = Re(() => {
    const o = t();
    if (o === void 0) return [!1, !1];
    const a = xr(o.split(/[?#]/, 1)[0]).toLowerCase(), l = decodeURI(xr(s.pathname).toLowerCase());
    return [i.end ? a === l : l.startsWith(a + "/") || l === a, a === l];
  });
  return (() => {
    var o = Z1();
    return rf(o, Ca(e, {
      get href() {
        return r() || i.href;
      },
      get state() {
        return JSON.stringify(i.state);
      },
      get classList() {
        return {
          ...i.class && {
            [i.class]: !0
          },
          [i.inactiveClass]: !n()[0],
          [i.activeClass]: n()[0],
          ...e.classList
        };
      },
      link: "",
      get "aria-current"() {
        return n()[1] ? "page" : void 0;
      }
    }), !1, !1), o;
  })();
}
const uh = Symbol("store-raw"), Jr = Symbol("store-node"), Ti = Symbol("store-has"), Ym = Symbol("store-self");
function Fm(i) {
  let e = i[Ut];
  if (!e && (Object.defineProperty(i, Ut, {
    value: e = new Proxy(i, V1)
  }), !Array.isArray(i))) {
    const t = Object.keys(i), r = Object.getOwnPropertyDescriptors(i);
    for (let s = 0, n = t.length; s < n; s++) {
      const o = t[s];
      r[o].get && Object.defineProperty(i, o, {
        enumerable: r[o].enumerable,
        get: r[o].get.bind(e)
      });
    }
  }
  return e;
}
function ir(i) {
  let e;
  return i != null && typeof i == "object" && (i[Ut] || !(e = Object.getPrototypeOf(i)) || e === Object.prototype || Array.isArray(i));
}
function cs(i, e = /* @__PURE__ */ new Set()) {
  let t, r, s, n;
  if (t = i != null && i[uh]) return t;
  if (!ir(i) || e.has(i)) return i;
  if (Array.isArray(i)) {
    Object.isFrozen(i) ? i = i.slice(0) : e.add(i);
    for (let o = 0, a = i.length; o < a; o++)
      s = i[o], (r = cs(s, e)) !== s && (i[o] = r);
  } else {
    Object.isFrozen(i) ? i = Object.assign({}, i) : e.add(i);
    const o = Object.keys(i), a = Object.getOwnPropertyDescriptors(i);
    for (let l = 0, c = o.length; l < c; l++)
      n = o[l], !a[n].get && (s = i[n], (r = cs(s, e)) !== s && (i[n] = r));
  }
  return i;
}
function Pa(i, e) {
  let t = i[e];
  return t || Object.defineProperty(i, e, {
    value: t = /* @__PURE__ */ Object.create(null)
  }), t;
}
function mn(i, e, t) {
  if (i[e]) return i[e];
  const [r, s] = se(t, {
    equals: !1,
    internal: !0
  });
  return r.$ = s, i[e] = r;
}
function W1(i, e) {
  const t = Reflect.getOwnPropertyDescriptor(i, e);
  return !t || t.get || !t.configurable || e === Ut || e === Jr || (delete t.value, delete t.writable, t.get = () => i[Ut][e]), t;
}
function Hm(i) {
  oh() && mn(Pa(i, Jr), Ym)();
}
function z1(i) {
  return Hm(i), Reflect.ownKeys(i);
}
const V1 = {
  get(i, e, t) {
    if (e === uh) return i;
    if (e === Ut) return t;
    if (e === nh)
      return Hm(i), t;
    const r = Pa(i, Jr), s = r[e];
    let n = s ? s() : i[e];
    if (e === Jr || e === Ti || e === "__proto__") return n;
    if (!s) {
      const o = Object.getOwnPropertyDescriptor(i, e);
      oh() && (typeof n != "function" || i.hasOwnProperty(e)) && !(o && o.get) && (n = mn(r, e, n)());
    }
    return ir(n) ? Fm(n) : n;
  },
  has(i, e) {
    return e === uh || e === Ut || e === nh || e === Jr || e === Ti || e === "__proto__" ? !0 : (oh() && mn(Pa(i, Ti), e)(), e in i);
  },
  set() {
    return !0;
  },
  deleteProperty() {
    return !0;
  },
  ownKeys: z1,
  getOwnPropertyDescriptor: W1
};
function Rt(i, e, t, r = !1) {
  if (!r && i[e] === t) return;
  const s = i[e], n = i.length;
  t === void 0 ? (delete i[e], i[Ti] && i[Ti][e] && s !== void 0 && i[Ti][e].$()) : (i[e] = t, i[Ti] && i[Ti][e] && s === void 0 && i[Ti][e].$());
  let o = Pa(i, Jr), a;
  if ((a = mn(o, e, s)) && a.$(() => t), Array.isArray(i) && i.length !== n) {
    for (let l = i.length; l < n; l++) (a = o[l]) && a.$();
    (a = mn(o, "length", n)) && a.$(i.length);
  }
  (a = o[Ym]) && a.$();
}
function Gm(i, e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r += 1) {
    const s = t[r];
    Rt(i, s, e[s]);
  }
}
function U1(i, e) {
  if (typeof e == "function" && (e = e(i)), e = cs(e), Array.isArray(e)) {
    if (i === e) return;
    let t = 0, r = e.length;
    for (; t < r; t++) {
      const s = e[t];
      i[t] !== s && Rt(i, t, s);
    }
    Rt(i, "length", r);
  } else Gm(i, e);
}
function Ns(i, e, t = []) {
  let r, s = i;
  if (e.length > 1) {
    r = e.shift();
    const o = typeof r, a = Array.isArray(i);
    if (Array.isArray(r)) {
      for (let l = 0; l < r.length; l++)
        Ns(i, [r[l]].concat(e), t);
      return;
    } else if (a && o === "function") {
      for (let l = 0; l < i.length; l++)
        r(i[l], l) && Ns(i, [l].concat(e), t);
      return;
    } else if (a && o === "object") {
      const {
        from: l = 0,
        to: c = i.length - 1,
        by: h = 1
      } = r;
      for (let u = l; u <= c; u += h)
        Ns(i, [u].concat(e), t);
      return;
    } else if (e.length > 1) {
      Ns(i[r], e, [r].concat(t));
      return;
    }
    s = i[r], t = [r].concat(t);
  }
  let n = e[0];
  typeof n == "function" && (n = n(s, t), n === s) || r === void 0 && n == null || (n = cs(n), r === void 0 || ir(s) && ir(n) && !Array.isArray(n) ? Gm(s, n) : Rt(i, r, n));
}
function Km(...[i, e]) {
  const t = cs(i || {}), r = Array.isArray(t), s = Fm(t);
  function n(...o) {
    Tm(() => {
      r && o.length === 1 ? U1(t, o[0]) : Ns(t, o);
    });
  }
  return [s, n];
}
const fh = Symbol("store-root");
function zr(i, e, t, r, s) {
  const n = e[t];
  if (i === n) return;
  const o = Array.isArray(i);
  if (t !== fh && (!ir(i) || !ir(n) || o !== Array.isArray(n) || s && i[s] !== n[s])) {
    Rt(e, t, i);
    return;
  }
  if (o) {
    if (i.length && n.length && (!r || s && i[0] && i[0][s] != null)) {
      let c, h, u, d, O, v, S, f;
      for (u = 0, d = Math.min(n.length, i.length); u < d && (n[u] === i[u] || s && n[u] && i[u] && n[u][s] === i[u][s]); u++)
        zr(i[u], n, u, r, s);
      const p = new Array(i.length), g = /* @__PURE__ */ new Map();
      for (d = n.length - 1, O = i.length - 1; d >= u && O >= u && (n[d] === i[O] || s && n[d] && i[O] && n[d][s] === i[O][s]); d--, O--)
        p[O] = n[d];
      if (u > O || u > d) {
        for (h = u; h <= O; h++) Rt(n, h, i[h]);
        for (; h < i.length; h++)
          Rt(n, h, p[h]), zr(i[h], n, h, r, s);
        n.length > i.length && Rt(n, "length", i.length);
        return;
      }
      for (S = new Array(O + 1), h = O; h >= u; h--)
        v = i[h], f = s && v ? v[s] : v, c = g.get(f), S[h] = c === void 0 ? -1 : c, g.set(f, h);
      for (c = u; c <= d; c++)
        v = n[c], f = s && v ? v[s] : v, h = g.get(f), h !== void 0 && h !== -1 && (p[h] = n[c], h = S[h], g.set(f, h));
      for (h = u; h < i.length; h++)
        h in p ? (Rt(n, h, p[h]), zr(i[h], n, h, r, s)) : Rt(n, h, i[h]);
    } else
      for (let c = 0, h = i.length; c < h; c++)
        zr(i[c], n, c, r, s);
    n.length > i.length && Rt(n, "length", i.length);
    return;
  }
  const a = Object.keys(i);
  for (let c = 0, h = a.length; c < h; c++)
    zr(i[a[c]], n, a[c], r, s);
  const l = Object.keys(n);
  for (let c = 0, h = l.length; c < h; c++)
    i[l[c]] === void 0 && Rt(n, l[c], void 0);
}
function j1(i, e = {}) {
  const {
    merge: t,
    key: r = "id"
  } = e, s = cs(i);
  return (n) => {
    if (!ir(n) || !ir(s)) return s;
    const o = zr(s, {
      [fh]: n
    }, fh, t, r);
    return o === void 0 ? n : o;
  };
}
let dh = Symbol("clean"), Wt = [], ji = 0;
const vo = 4;
let N1 = (i) => {
  let e = [], t = {
    get() {
      return t.lc || t.listen(() => {
      })(), t.value;
    },
    lc: 0,
    listen(r) {
      return t.lc = e.push(r), () => {
        for (let n = ji + vo; n < Wt.length; )
          Wt[n] === r ? Wt.splice(n, vo) : n += vo;
        let s = e.indexOf(r);
        ~s && (e.splice(s, 1), --t.lc || t.off());
      };
    },
    notify(r, s) {
      let n = !Wt.length;
      for (let o of e)
        Wt.push(o, t.value, r, s);
      if (n) {
        for (ji = 0; ji < Wt.length; ji += vo)
          Wt[ji](
            Wt[ji + 1],
            Wt[ji + 2],
            Wt[ji + 3]
          );
        Wt.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(r) {
      let s = t.value;
      s !== r && (t.value = r, t.notify(s));
    },
    subscribe(r) {
      let s = t.listen(r);
      return r(t.value), s;
    },
    value: i
  };
  return process.env.NODE_ENV !== "production" && (t[dh] = () => {
    e = [], t.lc = 0, t.off();
  }), t;
};
const Y1 = 5, Ir = 6, _o = 10;
let F1 = (i, e, t, r) => (i.events = i.events || {}, i.events[t + _o] || (i.events[t + _o] = r((s) => {
  i.events[t].reduceRight((n, o) => (o(n), n), {
    shared: {},
    ...s
  });
})), i.events[t] = i.events[t] || [], i.events[t].push(e), () => {
  let s = i.events[t], n = s.indexOf(e);
  s.splice(n, 1), s.length || (delete i.events[t], i.events[t + _o](), delete i.events[t + _o]);
}), H1 = 1e3, G1 = (i, e) => F1(i, (r) => {
  let s = e(r);
  s && i.events[Ir].push(s);
}, Y1, (r) => {
  let s = i.listen;
  i.listen = (...o) => (!i.lc && !i.active && (i.active = !0, r()), s(...o));
  let n = i.off;
  if (i.events[Ir] = [], i.off = () => {
    n(), setTimeout(() => {
      if (i.active && !i.lc) {
        i.active = !1;
        for (let o of i.events[Ir]) o();
        i.events[Ir] = [];
      }
    }, H1);
  }, process.env.NODE_ENV !== "production") {
    let o = i[dh];
    i[dh] = () => {
      for (let a of i.events[Ir]) a();
      i.events[Ir] = [], i.active = !1, o();
    };
  }
  return () => {
    i.listen = s, i.off = n;
  };
}), Ad = (i) => i, Vr = {}, Oh = { addEventListener() {
}, removeEventListener() {
} };
function K1() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
K1() && (Vr = localStorage);
let J1 = {
  addEventListener(i, e, t) {
    window.addEventListener("storage", e), window.addEventListener("pageshow", t);
  },
  removeEventListener(i, e, t) {
    window.removeEventListener("storage", e), window.removeEventListener("pageshow", t);
  }
};
typeof window < "u" && (Oh = J1);
function ew(i, e = void 0, t = {}) {
  let r = t.encode || Ad, s = t.decode || Ad, n = N1(e), o = n.set;
  n.set = (c) => {
    typeof c > "u" ? delete Vr[i] : Vr[i] = r(c), o(c);
  };
  function a(c) {
    c.key === i ? c.newValue === null ? o(void 0) : o(s(c.newValue)) : Vr[i] || o(void 0);
  }
  function l() {
    n.set(Vr[i] ? s(Vr[i]) : e);
  }
  return G1(n, () => {
    if (l(), t.listen !== !1)
      return Oh.addEventListener(i, a, l), () => {
        Oh.removeEventListener(i, a, l);
      };
  }), n;
}
const tw = () => typeof window > "u" || !window.matchMedia ? "light" : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light", iw = (() => {
  try {
    const i = localStorage.getItem("theme");
    if (i) return JSON.parse(i);
  } catch {
  }
  return tw();
})(), Ta = ew("theme", iw, {
  encode: JSON.stringify,
  decode: JSON.parse
});
function rw() {
  const i = Ta.get();
  Ta.set(i === "dark" ? "light" : "dark");
}
function Jm(i) {
  const e = Ta.subscribe((t) => {
    const r = document.documentElement, s = document.body;
    r.style.transition = "background-color 0.3s ease, color 0.3s ease", s.style.transition = "background-color 0.3s ease, color 0.3s ease", r.classList.remove("light", "dark"), s.classList.remove("light", "dark"), r.classList.add(t), s.classList.add(t);
  });
  return ft(() => {
    e(), document.documentElement.style.transition = "", document.body.style.transition = "";
  }), i.children;
}
function e0(i, e) {
  return function() {
    return i.apply(e, arguments);
  };
}
const { toString: sw } = Object.prototype, { getPrototypeOf: of } = Object, { iterator: gl, toStringTag: t0 } = Symbol, ml = /* @__PURE__ */ ((i) => (e) => {
  const t = sw.call(e);
  return i[t] || (i[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Kt = (i) => (i = i.toLowerCase(), (e) => ml(e) === i), Sl = (i) => (e) => typeof e === i, { isArray: ys } = Array, Sn = Sl("undefined");
function nw(i) {
  return i !== null && !Sn(i) && i.constructor !== null && !Sn(i.constructor) && yt(i.constructor.isBuffer) && i.constructor.isBuffer(i);
}
const i0 = Kt("ArrayBuffer");
function ow(i) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(i) : e = i && i.buffer && i0(i.buffer), e;
}
const aw = Sl("string"), yt = Sl("function"), r0 = Sl("number"), vl = (i) => i !== null && typeof i == "object", lw = (i) => i === !0 || i === !1, Go = (i) => {
  if (ml(i) !== "object")
    return !1;
  const e = of(i);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(t0 in i) && !(gl in i);
}, cw = Kt("Date"), hw = Kt("File"), uw = Kt("Blob"), fw = Kt("FileList"), dw = (i) => vl(i) && yt(i.pipe), Ow = (i) => {
  let e;
  return i && (typeof FormData == "function" && i instanceof FormData || yt(i.append) && ((e = ml(i)) === "formdata" || // detect form-data instance
  e === "object" && yt(i.toString) && i.toString() === "[object FormData]"));
}, pw = Kt("URLSearchParams"), [gw, mw, Sw, vw] = ["ReadableStream", "Request", "Response", "Headers"].map(Kt), _w = (i) => i.trim ? i.trim() : i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Jn(i, e, { allOwnKeys: t = !1 } = {}) {
  if (i === null || typeof i > "u")
    return;
  let r, s;
  if (typeof i != "object" && (i = [i]), ys(i))
    for (r = 0, s = i.length; r < s; r++)
      e.call(null, i[r], r, i);
  else {
    const n = t ? Object.getOwnPropertyNames(i) : Object.keys(i), o = n.length;
    let a;
    for (r = 0; r < o; r++)
      a = n[r], e.call(null, i[a], a, i);
  }
}
function s0(i, e) {
  e = e.toLowerCase();
  const t = Object.keys(i);
  let r = t.length, s;
  for (; r-- > 0; )
    if (s = t[r], e === s.toLowerCase())
      return s;
  return null;
}
const vr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, n0 = (i) => !Sn(i) && i !== vr;
function ph() {
  const { caseless: i } = n0(this) && this || {}, e = {}, t = (r, s) => {
    const n = i && s0(e, s) || s;
    Go(e[n]) && Go(r) ? e[n] = ph(e[n], r) : Go(r) ? e[n] = ph({}, r) : ys(r) ? e[n] = r.slice() : e[n] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && Jn(arguments[r], t);
  return e;
}
const bw = (i, e, t, { allOwnKeys: r } = {}) => (Jn(e, (s, n) => {
  t && yt(s) ? i[n] = e0(s, t) : i[n] = s;
}, { allOwnKeys: r }), i), yw = (i) => (i.charCodeAt(0) === 65279 && (i = i.slice(1)), i), ww = (i, e, t, r) => {
  i.prototype = Object.create(e.prototype, r), i.prototype.constructor = i, Object.defineProperty(i, "super", {
    value: e.prototype
  }), t && Object.assign(i.prototype, t);
}, xw = (i, e, t, r) => {
  let s, n, o;
  const a = {};
  if (e = e || {}, i == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(i), n = s.length; n-- > 0; )
      o = s[n], (!r || r(o, i, e)) && !a[o] && (e[o] = i[o], a[o] = !0);
    i = t !== !1 && of(i);
  } while (i && (!t || t(i, e)) && i !== Object.prototype);
  return e;
}, kw = (i, e, t) => {
  i = String(i), (t === void 0 || t > i.length) && (t = i.length), t -= e.length;
  const r = i.indexOf(e, t);
  return r !== -1 && r === t;
}, Cw = (i) => {
  if (!i) return null;
  if (ys(i)) return i;
  let e = i.length;
  if (!r0(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = i[e];
  return t;
}, Qw = /* @__PURE__ */ ((i) => (e) => i && e instanceof i)(typeof Uint8Array < "u" && of(Uint8Array)), Pw = (i, e) => {
  const r = (i && i[gl]).call(i);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const n = s.value;
    e.call(i, n[0], n[1]);
  }
}, Tw = (i, e) => {
  let t;
  const r = [];
  for (; (t = i.exec(e)) !== null; )
    r.push(t);
  return r;
}, $w = Kt("HTMLFormElement"), Rw = (i) => i.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, s) {
    return r.toUpperCase() + s;
  }
), Ld = (({ hasOwnProperty: i }) => (e, t) => i.call(e, t))(Object.prototype), Ew = Kt("RegExp"), o0 = (i, e) => {
  const t = Object.getOwnPropertyDescriptors(i), r = {};
  Jn(t, (s, n) => {
    let o;
    (o = e(s, n, i)) !== !1 && (r[n] = o || s);
  }), Object.defineProperties(i, r);
}, Aw = (i) => {
  o0(i, (e, t) => {
    if (yt(i) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const r = i[t];
    if (yt(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, Lw = (i, e) => {
  const t = {}, r = (s) => {
    s.forEach((n) => {
      t[n] = !0;
    });
  };
  return ys(i) ? r(i) : r(String(i).split(e)), t;
}, Dw = () => {
}, Mw = (i, e) => i != null && Number.isFinite(i = +i) ? i : e;
function Bw(i) {
  return !!(i && yt(i.append) && i[t0] === "FormData" && i[gl]);
}
const qw = (i) => {
  const e = new Array(10), t = (r, s) => {
    if (vl(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const n = ys(r) ? [] : {};
        return Jn(r, (o, a) => {
          const l = t(o, s + 1);
          !Sn(l) && (n[a] = l);
        }), e[s] = void 0, n;
      }
    }
    return r;
  };
  return t(i, 0);
}, Xw = Kt("AsyncFunction"), Iw = (i) => i && (vl(i) || yt(i)) && yt(i.then) && yt(i.catch), a0 = ((i, e) => i ? setImmediate : e ? ((t, r) => (vr.addEventListener("message", ({ source: s, data: n }) => {
  s === vr && n === t && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), vr.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(
  typeof setImmediate == "function",
  yt(vr.postMessage)
), Zw = typeof queueMicrotask < "u" ? queueMicrotask.bind(vr) : typeof process < "u" && process.nextTick || a0, Ww = (i) => i != null && yt(i[gl]), I = {
  isArray: ys,
  isArrayBuffer: i0,
  isBuffer: nw,
  isFormData: Ow,
  isArrayBufferView: ow,
  isString: aw,
  isNumber: r0,
  isBoolean: lw,
  isObject: vl,
  isPlainObject: Go,
  isReadableStream: gw,
  isRequest: mw,
  isResponse: Sw,
  isHeaders: vw,
  isUndefined: Sn,
  isDate: cw,
  isFile: hw,
  isBlob: uw,
  isRegExp: Ew,
  isFunction: yt,
  isStream: dw,
  isURLSearchParams: pw,
  isTypedArray: Qw,
  isFileList: fw,
  forEach: Jn,
  merge: ph,
  extend: bw,
  trim: _w,
  stripBOM: yw,
  inherits: ww,
  toFlatObject: xw,
  kindOf: ml,
  kindOfTest: Kt,
  endsWith: kw,
  toArray: Cw,
  forEachEntry: Pw,
  matchAll: Tw,
  isHTMLForm: $w,
  hasOwnProperty: Ld,
  hasOwnProp: Ld,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: o0,
  freezeMethods: Aw,
  toObjectSet: Lw,
  toCamelCase: Rw,
  noop: Dw,
  toFiniteNumber: Mw,
  findKey: s0,
  global: vr,
  isContextDefined: n0,
  isSpecCompliantForm: Bw,
  toJSONObject: qw,
  isAsyncFn: Xw,
  isThenable: Iw,
  setImmediate: a0,
  asap: Zw,
  isIterable: Ww
};
function ue(i, e, t, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = i, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
I.inherits(ue, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: I.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const l0 = ue.prototype, c0 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((i) => {
  c0[i] = { value: i };
});
Object.defineProperties(ue, c0);
Object.defineProperty(l0, "isAxiosError", { value: !0 });
ue.from = (i, e, t, r, s, n) => {
  const o = Object.create(l0);
  return I.toFlatObject(i, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), ue.call(o, i.message, e, t, r, s), o.cause = i, o.name = i.name, n && Object.assign(o, n), o;
};
const zw = null;
function gh(i) {
  return I.isPlainObject(i) || I.isArray(i);
}
function h0(i) {
  return I.endsWith(i, "[]") ? i.slice(0, -2) : i;
}
function Dd(i, e, t) {
  return i ? i.concat(e).map(function(s, n) {
    return s = h0(s), !t && n ? "[" + s + "]" : s;
  }).join(t ? "." : "") : e;
}
function Vw(i) {
  return I.isArray(i) && !i.some(gh);
}
const Uw = I.toFlatObject(I, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function _l(i, e, t) {
  if (!I.isObject(i))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = I.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(S, f) {
    return !I.isUndefined(f[S]);
  });
  const r = t.metaTokens, s = t.visitor || h, n = t.dots, o = t.indexes, l = (t.Blob || typeof Blob < "u" && Blob) && I.isSpecCompliantForm(e);
  if (!I.isFunction(s))
    throw new TypeError("visitor must be a function");
  function c(v) {
    if (v === null) return "";
    if (I.isDate(v))
      return v.toISOString();
    if (!l && I.isBlob(v))
      throw new ue("Blob is not supported. Use a Buffer instead.");
    return I.isArrayBuffer(v) || I.isTypedArray(v) ? l && typeof Blob == "function" ? new Blob([v]) : Buffer.from(v) : v;
  }
  function h(v, S, f) {
    let p = v;
    if (v && !f && typeof v == "object") {
      if (I.endsWith(S, "{}"))
        S = r ? S : S.slice(0, -2), v = JSON.stringify(v);
      else if (I.isArray(v) && Vw(v) || (I.isFileList(v) || I.endsWith(S, "[]")) && (p = I.toArray(v)))
        return S = h0(S), p.forEach(function(m, _) {
          !(I.isUndefined(m) || m === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Dd([S], _, n) : o === null ? S : S + "[]",
            c(m)
          );
        }), !1;
    }
    return gh(v) ? !0 : (e.append(Dd(f, S, n), c(v)), !1);
  }
  const u = [], d = Object.assign(Uw, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: gh
  });
  function O(v, S) {
    if (!I.isUndefined(v)) {
      if (u.indexOf(v) !== -1)
        throw Error("Circular reference detected in " + S.join("."));
      u.push(v), I.forEach(v, function(p, g) {
        (!(I.isUndefined(p) || p === null) && s.call(
          e,
          p,
          I.isString(g) ? g.trim() : g,
          S,
          d
        )) === !0 && O(p, S ? S.concat(g) : [g]);
      }), u.pop();
    }
  }
  if (!I.isObject(i))
    throw new TypeError("data must be an object");
  return O(i), e;
}
function Md(i) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(i).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function af(i, e) {
  this._pairs = [], i && _l(i, this, e);
}
const u0 = af.prototype;
u0.append = function(e, t) {
  this._pairs.push([e, t]);
};
u0.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, Md);
  } : Md;
  return this._pairs.map(function(s) {
    return t(s[0]) + "=" + t(s[1]);
  }, "").join("&");
};
function jw(i) {
  return encodeURIComponent(i).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function f0(i, e, t) {
  if (!e)
    return i;
  const r = t && t.encode || jw;
  I.isFunction(t) && (t = {
    serialize: t
  });
  const s = t && t.serialize;
  let n;
  if (s ? n = s(e, t) : n = I.isURLSearchParams(e) ? e.toString() : new af(e, t).toString(r), n) {
    const o = i.indexOf("#");
    o !== -1 && (i = i.slice(0, o)), i += (i.indexOf("?") === -1 ? "?" : "&") + n;
  }
  return i;
}
class Bd {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    I.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const d0 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Nw = typeof URLSearchParams < "u" ? URLSearchParams : af, Yw = typeof FormData < "u" ? FormData : null, Fw = typeof Blob < "u" ? Blob : null, Hw = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Nw,
    FormData: Yw,
    Blob: Fw
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, lf = typeof window < "u" && typeof document < "u", mh = typeof navigator == "object" && navigator || void 0, Gw = lf && (!mh || ["ReactNative", "NativeScript", "NS"].indexOf(mh.product) < 0), Kw = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Jw = lf && window.location.href || "http://localhost", ex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: lf,
  hasStandardBrowserEnv: Gw,
  hasStandardBrowserWebWorkerEnv: Kw,
  navigator: mh,
  origin: Jw
}, Symbol.toStringTag, { value: "Module" })), it = {
  ...ex,
  ...Hw
};
function tx(i, e) {
  return _l(i, new it.classes.URLSearchParams(), Object.assign({
    visitor: function(t, r, s, n) {
      return it.isNode && I.isBuffer(t) ? (this.append(r, t.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function ix(i) {
  return I.matchAll(/\w+|\[(\w*)]/g, i).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function rx(i) {
  const e = {}, t = Object.keys(i);
  let r;
  const s = t.length;
  let n;
  for (r = 0; r < s; r++)
    n = t[r], e[n] = i[n];
  return e;
}
function O0(i) {
  function e(t, r, s, n) {
    let o = t[n++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), l = n >= t.length;
    return o = !o && I.isArray(s) ? s.length : o, l ? (I.hasOwnProp(s, o) ? s[o] = [s[o], r] : s[o] = r, !a) : ((!s[o] || !I.isObject(s[o])) && (s[o] = []), e(t, r, s[o], n) && I.isArray(s[o]) && (s[o] = rx(s[o])), !a);
  }
  if (I.isFormData(i) && I.isFunction(i.entries)) {
    const t = {};
    return I.forEachEntry(i, (r, s) => {
      e(ix(r), s, t, 0);
    }), t;
  }
  return null;
}
function sx(i, e, t) {
  if (I.isString(i))
    try {
      return (e || JSON.parse)(i), I.trim(i);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (t || JSON.stringify)(i);
}
const eo = {
  transitional: d0,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", s = r.indexOf("application/json") > -1, n = I.isObject(e);
    if (n && I.isHTMLForm(e) && (e = new FormData(e)), I.isFormData(e))
      return s ? JSON.stringify(O0(e)) : e;
    if (I.isArrayBuffer(e) || I.isBuffer(e) || I.isStream(e) || I.isFile(e) || I.isBlob(e) || I.isReadableStream(e))
      return e;
    if (I.isArrayBufferView(e))
      return e.buffer;
    if (I.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (n) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return tx(e, this.formSerializer).toString();
      if ((a = I.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return _l(
          a ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return n || s ? (t.setContentType("application/json", !1), sx(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || eo.transitional, r = t && t.forcedJSONParsing, s = this.responseType === "json";
    if (I.isResponse(e) || I.isReadableStream(e))
      return e;
    if (e && I.isString(e) && (r && !this.responseType || s)) {
      const o = !(t && t.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? ue.from(a, ue.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: it.classes.FormData,
    Blob: it.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
I.forEach(["delete", "get", "head", "post", "put", "patch"], (i) => {
  eo.headers[i] = {};
});
const nx = I.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), ox = (i) => {
  const e = {};
  let t, r, s;
  return i && i.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), t = o.substring(0, s).trim().toLowerCase(), r = o.substring(s + 1).trim(), !(!t || e[t] && nx[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r);
  }), e;
}, qd = Symbol("internals");
function As(i) {
  return i && String(i).trim().toLowerCase();
}
function Ko(i) {
  return i === !1 || i == null ? i : I.isArray(i) ? i.map(Ko) : String(i);
}
function ax(i) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = t.exec(i); )
    e[r[1]] = r[2];
  return e;
}
const lx = (i) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(i.trim());
function Gl(i, e, t, r, s) {
  if (I.isFunction(r))
    return r.call(this, e, t);
  if (s && (e = t), !!I.isString(e)) {
    if (I.isString(r))
      return e.indexOf(r) !== -1;
    if (I.isRegExp(r))
      return r.test(e);
  }
}
function cx(i) {
  return i.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r);
}
function hx(i, e) {
  const t = I.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(i, r + t, {
      value: function(s, n, o) {
        return this[r].call(this, e, s, n, o);
      },
      configurable: !0
    });
  });
}
let wt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, r) {
    const s = this;
    function n(a, l, c) {
      const h = As(l);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const u = I.findKey(s, h);
      (!u || s[u] === void 0 || c === !0 || c === void 0 && s[u] !== !1) && (s[u || l] = Ko(a));
    }
    const o = (a, l) => I.forEach(a, (c, h) => n(c, h, l));
    if (I.isPlainObject(e) || e instanceof this.constructor)
      o(e, t);
    else if (I.isString(e) && (e = e.trim()) && !lx(e))
      o(ox(e), t);
    else if (I.isObject(e) && I.isIterable(e)) {
      let a = {}, l, c;
      for (const h of e) {
        if (!I.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        a[c = h[0]] = (l = a[c]) ? I.isArray(l) ? [...l, h[1]] : [l, h[1]] : h[1];
      }
      o(a, t);
    } else
      e != null && n(t, e, r);
    return this;
  }
  get(e, t) {
    if (e = As(e), e) {
      const r = I.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!t)
          return s;
        if (t === !0)
          return ax(s);
        if (I.isFunction(t))
          return t.call(this, s, r);
        if (I.isRegExp(t))
          return t.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = As(e), e) {
      const r = I.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!t || Gl(this, this[r], r, t)));
    }
    return !1;
  }
  delete(e, t) {
    const r = this;
    let s = !1;
    function n(o) {
      if (o = As(o), o) {
        const a = I.findKey(r, o);
        a && (!t || Gl(r, r[a], a, t)) && (delete r[a], s = !0);
      }
    }
    return I.isArray(e) ? e.forEach(n) : n(e), s;
  }
  clear(e) {
    const t = Object.keys(this);
    let r = t.length, s = !1;
    for (; r--; ) {
      const n = t[r];
      (!e || Gl(this, this[n], n, e, !0)) && (delete this[n], s = !0);
    }
    return s;
  }
  normalize(e) {
    const t = this, r = {};
    return I.forEach(this, (s, n) => {
      const o = I.findKey(r, n);
      if (o) {
        t[o] = Ko(s), delete t[n];
        return;
      }
      const a = e ? cx(n) : String(n).trim();
      a !== n && delete t[n], t[a] = Ko(s), r[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return I.forEach(this, (r, s) => {
      r != null && r !== !1 && (t[s] = e && I.isArray(r) ? r.join(", ") : r);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const r = new this(e);
    return t.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[qd] = this[qd] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function n(o) {
      const a = As(o);
      r[a] || (hx(s, o), r[a] = !0);
    }
    return I.isArray(e) ? e.forEach(n) : n(e), this;
  }
};
wt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
I.reduceDescriptors(wt.prototype, ({ value: i }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => i,
    set(r) {
      this[t] = r;
    }
  };
});
I.freezeMethods(wt);
function Kl(i, e) {
  const t = this || eo, r = e || t, s = wt.from(r.headers);
  let n = r.data;
  return I.forEach(i, function(a) {
    n = a.call(t, n, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), n;
}
function p0(i) {
  return !!(i && i.__CANCEL__);
}
function ws(i, e, t) {
  ue.call(this, i ?? "canceled", ue.ERR_CANCELED, e, t), this.name = "CanceledError";
}
I.inherits(ws, ue, {
  __CANCEL__: !0
});
function g0(i, e, t) {
  const r = t.config.validateStatus;
  !t.status || !r || r(t.status) ? i(t) : e(new ue(
    "Request failed with status code " + t.status,
    [ue.ERR_BAD_REQUEST, ue.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
function ux(i) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(i);
  return e && e[1] || "";
}
function fx(i, e) {
  i = i || 10;
  const t = new Array(i), r = new Array(i);
  let s = 0, n = 0, o;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const c = Date.now(), h = r[n];
    o || (o = c), t[s] = l, r[s] = c;
    let u = n, d = 0;
    for (; u !== s; )
      d += t[u++], u = u % i;
    if (s = (s + 1) % i, s === n && (n = (n + 1) % i), c - o < e)
      return;
    const O = h && c - h;
    return O ? Math.round(d * 1e3 / O) : void 0;
  };
}
function dx(i, e) {
  let t = 0, r = 1e3 / e, s, n;
  const o = (c, h = Date.now()) => {
    t = h, s = null, n && (clearTimeout(n), n = null), i.apply(null, c);
  };
  return [(...c) => {
    const h = Date.now(), u = h - t;
    u >= r ? o(c, h) : (s = c, n || (n = setTimeout(() => {
      n = null, o(s);
    }, r - u)));
  }, () => s && o(s)];
}
const $a = (i, e, t = 3) => {
  let r = 0;
  const s = fx(50, 250);
  return dx((n) => {
    const o = n.loaded, a = n.lengthComputable ? n.total : void 0, l = o - r, c = s(l), h = o <= a;
    r = o;
    const u = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && a && h ? (a - o) / c : void 0,
      event: n,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    i(u);
  }, t);
}, Xd = (i, e) => {
  const t = i != null;
  return [(r) => e[0]({
    lengthComputable: t,
    total: i,
    loaded: r
  }), e[1]];
}, Id = (i) => (...e) => I.asap(() => i(...e)), Ox = it.hasStandardBrowserEnv ? /* @__PURE__ */ ((i, e) => (t) => (t = new URL(t, it.origin), i.protocol === t.protocol && i.host === t.host && (e || i.port === t.port)))(
  new URL(it.origin),
  it.navigator && /(msie|trident)/i.test(it.navigator.userAgent)
) : () => !0, px = it.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(i, e, t, r, s, n) {
      const o = [i + "=" + encodeURIComponent(e)];
      I.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()), I.isString(r) && o.push("path=" + r), I.isString(s) && o.push("domain=" + s), n === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(i) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + i + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(i) {
      this.write(i, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function gx(i) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(i);
}
function mx(i, e) {
  return e ? i.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : i;
}
function m0(i, e, t) {
  let r = !gx(e);
  return i && (r || t == !1) ? mx(i, e) : e;
}
const Zd = (i) => i instanceof wt ? { ...i } : i;
function $r(i, e) {
  e = e || {};
  const t = {};
  function r(c, h, u, d) {
    return I.isPlainObject(c) && I.isPlainObject(h) ? I.merge.call({ caseless: d }, c, h) : I.isPlainObject(h) ? I.merge({}, h) : I.isArray(h) ? h.slice() : h;
  }
  function s(c, h, u, d) {
    if (I.isUndefined(h)) {
      if (!I.isUndefined(c))
        return r(void 0, c, u, d);
    } else return r(c, h, u, d);
  }
  function n(c, h) {
    if (!I.isUndefined(h))
      return r(void 0, h);
  }
  function o(c, h) {
    if (I.isUndefined(h)) {
      if (!I.isUndefined(c))
        return r(void 0, c);
    } else return r(void 0, h);
  }
  function a(c, h, u) {
    if (u in e)
      return r(c, h);
    if (u in i)
      return r(void 0, c);
  }
  const l = {
    url: n,
    method: n,
    data: n,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, h, u) => s(Zd(c), Zd(h), u, !0)
  };
  return I.forEach(Object.keys(Object.assign({}, i, e)), function(h) {
    const u = l[h] || s, d = u(i[h], e[h], h);
    I.isUndefined(d) && u !== a || (t[h] = d);
  }), t;
}
const S0 = (i) => {
  const e = $r({}, i);
  let { data: t, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: n, headers: o, auth: a } = e;
  e.headers = o = wt.from(o), e.url = f0(m0(e.baseURL, e.url, e.allowAbsoluteUrls), i.params, i.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let l;
  if (I.isFormData(t)) {
    if (it.hasStandardBrowserEnv || it.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((l = o.getContentType()) !== !1) {
      const [c, ...h] = l ? l.split(";").map((u) => u.trim()).filter(Boolean) : [];
      o.setContentType([c || "multipart/form-data", ...h].join("; "));
    }
  }
  if (it.hasStandardBrowserEnv && (r && I.isFunction(r) && (r = r(e)), r || r !== !1 && Ox(e.url))) {
    const c = s && n && px.read(n);
    c && o.set(s, c);
  }
  return e;
}, Sx = typeof XMLHttpRequest < "u", vx = Sx && function(i) {
  return new Promise(function(t, r) {
    const s = S0(i);
    let n = s.data;
    const o = wt.from(s.headers).normalize();
    let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = s, h, u, d, O, v;
    function S() {
      O && O(), v && v(), s.cancelToken && s.cancelToken.unsubscribe(h), s.signal && s.signal.removeEventListener("abort", h);
    }
    let f = new XMLHttpRequest();
    f.open(s.method.toUpperCase(), s.url, !0), f.timeout = s.timeout;
    function p() {
      if (!f)
        return;
      const m = wt.from(
        "getAllResponseHeaders" in f && f.getAllResponseHeaders()
      ), b = {
        data: !a || a === "text" || a === "json" ? f.responseText : f.response,
        status: f.status,
        statusText: f.statusText,
        headers: m,
        config: i,
        request: f
      };
      g0(function(x) {
        t(x), S();
      }, function(x) {
        r(x), S();
      }, b), f = null;
    }
    "onloadend" in f ? f.onloadend = p : f.onreadystatechange = function() {
      !f || f.readyState !== 4 || f.status === 0 && !(f.responseURL && f.responseURL.indexOf("file:") === 0) || setTimeout(p);
    }, f.onabort = function() {
      f && (r(new ue("Request aborted", ue.ECONNABORTED, i, f)), f = null);
    }, f.onerror = function() {
      r(new ue("Network Error", ue.ERR_NETWORK, i, f)), f = null;
    }, f.ontimeout = function() {
      let _ = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const b = s.transitional || d0;
      s.timeoutErrorMessage && (_ = s.timeoutErrorMessage), r(new ue(
        _,
        b.clarifyTimeoutError ? ue.ETIMEDOUT : ue.ECONNABORTED,
        i,
        f
      )), f = null;
    }, n === void 0 && o.setContentType(null), "setRequestHeader" in f && I.forEach(o.toJSON(), function(_, b) {
      f.setRequestHeader(b, _);
    }), I.isUndefined(s.withCredentials) || (f.withCredentials = !!s.withCredentials), a && a !== "json" && (f.responseType = s.responseType), c && ([d, v] = $a(c, !0), f.addEventListener("progress", d)), l && f.upload && ([u, O] = $a(l), f.upload.addEventListener("progress", u), f.upload.addEventListener("loadend", O)), (s.cancelToken || s.signal) && (h = (m) => {
      f && (r(!m || m.type ? new ws(null, i, f) : m), f.abort(), f = null);
    }, s.cancelToken && s.cancelToken.subscribe(h), s.signal && (s.signal.aborted ? h() : s.signal.addEventListener("abort", h)));
    const g = ux(s.url);
    if (g && it.protocols.indexOf(g) === -1) {
      r(new ue("Unsupported protocol " + g + ":", ue.ERR_BAD_REQUEST, i));
      return;
    }
    f.send(n || null);
  });
}, _x = (i, e) => {
  const { length: t } = i = i ? i.filter(Boolean) : [];
  if (e || t) {
    let r = new AbortController(), s;
    const n = function(c) {
      if (!s) {
        s = !0, a();
        const h = c instanceof Error ? c : this.reason;
        r.abort(h instanceof ue ? h : new ws(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, n(new ue(`timeout ${e} of ms exceeded`, ue.ETIMEDOUT));
    }, e);
    const a = () => {
      i && (o && clearTimeout(o), o = null, i.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(n) : c.removeEventListener("abort", n);
      }), i = null);
    };
    i.forEach((c) => c.addEventListener("abort", n));
    const { signal: l } = r;
    return l.unsubscribe = () => I.asap(a), l;
  }
}, bx = function* (i, e) {
  let t = i.byteLength;
  if (t < e) {
    yield i;
    return;
  }
  let r = 0, s;
  for (; r < t; )
    s = r + e, yield i.slice(r, s), r = s;
}, yx = async function* (i, e) {
  for await (const t of wx(i))
    yield* bx(t, e);
}, wx = async function* (i) {
  if (i[Symbol.asyncIterator]) {
    yield* i;
    return;
  }
  const e = i.getReader();
  try {
    for (; ; ) {
      const { done: t, value: r } = await e.read();
      if (t)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, Wd = (i, e, t, r) => {
  const s = yx(i, e);
  let n = 0, o, a = (l) => {
    o || (o = !0, r && r(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: h } = await s.next();
        if (c) {
          a(), l.close();
          return;
        }
        let u = h.byteLength;
        if (t) {
          let d = n += u;
          t(d);
        }
        l.enqueue(new Uint8Array(h));
      } catch (c) {
        throw a(c), c;
      }
    },
    cancel(l) {
      return a(l), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, bl = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", v0 = bl && typeof ReadableStream == "function", xx = bl && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((i) => (e) => i.encode(e))(new TextEncoder()) : async (i) => new Uint8Array(await new Response(i).arrayBuffer())), _0 = (i, ...e) => {
  try {
    return !!i(...e);
  } catch {
    return !1;
  }
}, kx = v0 && _0(() => {
  let i = !1;
  const e = new Request(it.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return i = !0, "half";
    }
  }).headers.has("Content-Type");
  return i && !e;
}), zd = 64 * 1024, Sh = v0 && _0(() => I.isReadableStream(new Response("").body)), Ra = {
  stream: Sh && ((i) => i.body)
};
bl && ((i) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Ra[e] && (Ra[e] = I.isFunction(i[e]) ? (t) => t[e]() : (t, r) => {
      throw new ue(`Response type '${e}' is not supported`, ue.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const Cx = async (i) => {
  if (i == null)
    return 0;
  if (I.isBlob(i))
    return i.size;
  if (I.isSpecCompliantForm(i))
    return (await new Request(it.origin, {
      method: "POST",
      body: i
    }).arrayBuffer()).byteLength;
  if (I.isArrayBufferView(i) || I.isArrayBuffer(i))
    return i.byteLength;
  if (I.isURLSearchParams(i) && (i = i + ""), I.isString(i))
    return (await xx(i)).byteLength;
}, Qx = async (i, e) => {
  const t = I.toFiniteNumber(i.getContentLength());
  return t ?? Cx(e);
}, Px = bl && (async (i) => {
  let {
    url: e,
    method: t,
    data: r,
    signal: s,
    cancelToken: n,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: l,
    responseType: c,
    headers: h,
    withCredentials: u = "same-origin",
    fetchOptions: d
  } = S0(i);
  c = c ? (c + "").toLowerCase() : "text";
  let O = _x([s, n && n.toAbortSignal()], o), v;
  const S = O && O.unsubscribe && (() => {
    O.unsubscribe();
  });
  let f;
  try {
    if (l && kx && t !== "get" && t !== "head" && (f = await Qx(h, r)) !== 0) {
      let b = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), w;
      if (I.isFormData(r) && (w = b.headers.get("content-type")) && h.setContentType(w), b.body) {
        const [x, y] = Xd(
          f,
          $a(Id(l))
        );
        r = Wd(b.body, zd, x, y);
      }
    }
    I.isString(u) || (u = u ? "include" : "omit");
    const p = "credentials" in Request.prototype;
    v = new Request(e, {
      ...d,
      signal: O,
      method: t.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: p ? u : void 0
    });
    let g = await fetch(v);
    const m = Sh && (c === "stream" || c === "response");
    if (Sh && (a || m && S)) {
      const b = {};
      ["status", "statusText", "headers"].forEach((k) => {
        b[k] = g[k];
      });
      const w = I.toFiniteNumber(g.headers.get("content-length")), [x, y] = a && Xd(
        w,
        $a(Id(a), !0)
      ) || [];
      g = new Response(
        Wd(g.body, zd, x, () => {
          y && y(), S && S();
        }),
        b
      );
    }
    c = c || "text";
    let _ = await Ra[I.findKey(Ra, c) || "text"](g, i);
    return !m && S && S(), await new Promise((b, w) => {
      g0(b, w, {
        data: _,
        headers: wt.from(g.headers),
        status: g.status,
        statusText: g.statusText,
        config: i,
        request: v
      });
    });
  } catch (p) {
    throw S && S(), p && p.name === "TypeError" && /Load failed|fetch/i.test(p.message) ? Object.assign(
      new ue("Network Error", ue.ERR_NETWORK, i, v),
      {
        cause: p.cause || p
      }
    ) : ue.from(p, p && p.code, i, v);
  }
}), vh = {
  http: zw,
  xhr: vx,
  fetch: Px
};
I.forEach(vh, (i, e) => {
  if (i) {
    try {
      Object.defineProperty(i, "name", { value: e });
    } catch {
    }
    Object.defineProperty(i, "adapterName", { value: e });
  }
});
const Vd = (i) => `- ${i}`, Tx = (i) => I.isFunction(i) || i === null || i === !1, b0 = {
  getAdapter: (i) => {
    i = I.isArray(i) ? i : [i];
    const { length: e } = i;
    let t, r;
    const s = {};
    for (let n = 0; n < e; n++) {
      t = i[n];
      let o;
      if (r = t, !Tx(t) && (r = vh[(o = String(t)).toLowerCase()], r === void 0))
        throw new ue(`Unknown adapter '${o}'`);
      if (r)
        break;
      s[o || "#" + n] = r;
    }
    if (!r) {
      const n = Object.entries(s).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? n.length > 1 ? `since :
` + n.map(Vd).join(`
`) : " " + Vd(n[0]) : "as no adapter specified";
      throw new ue(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: vh
};
function Jl(i) {
  if (i.cancelToken && i.cancelToken.throwIfRequested(), i.signal && i.signal.aborted)
    throw new ws(null, i);
}
function Ud(i) {
  return Jl(i), i.headers = wt.from(i.headers), i.data = Kl.call(
    i,
    i.transformRequest
  ), ["post", "put", "patch"].indexOf(i.method) !== -1 && i.headers.setContentType("application/x-www-form-urlencoded", !1), b0.getAdapter(i.adapter || eo.adapter)(i).then(function(r) {
    return Jl(i), r.data = Kl.call(
      i,
      i.transformResponse,
      r
    ), r.headers = wt.from(r.headers), r;
  }, function(r) {
    return p0(r) || (Jl(i), r && r.response && (r.response.data = Kl.call(
      i,
      i.transformResponse,
      r.response
    ), r.response.headers = wt.from(r.response.headers))), Promise.reject(r);
  });
}
const y0 = "1.9.0", yl = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((i, e) => {
  yl[i] = function(r) {
    return typeof r === i || "a" + (e < 1 ? "n " : " ") + i;
  };
});
const jd = {};
yl.transitional = function(e, t, r) {
  function s(n, o) {
    return "[Axios v" + y0 + "] Transitional option '" + n + "'" + o + (r ? ". " + r : "");
  }
  return (n, o, a) => {
    if (e === !1)
      throw new ue(
        s(o, " has been removed" + (t ? " in " + t : "")),
        ue.ERR_DEPRECATED
      );
    return t && !jd[o] && (jd[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(n, o, a) : !0;
  };
};
yl.spelling = function(e) {
  return (t, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function $x(i, e, t) {
  if (typeof i != "object")
    throw new ue("options must be an object", ue.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(i);
  let s = r.length;
  for (; s-- > 0; ) {
    const n = r[s], o = e[n];
    if (o) {
      const a = i[n], l = a === void 0 || o(a, n, i);
      if (l !== !0)
        throw new ue("option " + n + " must be " + l, ue.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new ue("Unknown option " + n, ue.ERR_BAD_OPTION);
  }
}
const Jo = {
  assertOptions: $x,
  validators: yl
}, ri = Jo.validators;
let kr = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new Bd(),
      response: new Bd()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (r) {
      if (r instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const n = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? n && !String(r.stack).endsWith(n.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + n) : r.stack = n;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = $r(this.defaults, t);
    const { transitional: r, paramsSerializer: s, headers: n } = t;
    r !== void 0 && Jo.assertOptions(r, {
      silentJSONParsing: ri.transitional(ri.boolean),
      forcedJSONParsing: ri.transitional(ri.boolean),
      clarifyTimeoutError: ri.transitional(ri.boolean)
    }, !1), s != null && (I.isFunction(s) ? t.paramsSerializer = {
      serialize: s
    } : Jo.assertOptions(s, {
      encode: ri.function,
      serialize: ri.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Jo.assertOptions(t, {
      baseUrl: ri.spelling("baseURL"),
      withXsrfToken: ri.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let o = n && I.merge(
      n.common,
      n[t.method]
    );
    n && I.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (v) => {
        delete n[v];
      }
    ), t.headers = wt.concat(o, n);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(S) {
      typeof S.runWhen == "function" && S.runWhen(t) === !1 || (l = l && S.synchronous, a.unshift(S.fulfilled, S.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(S) {
      c.push(S.fulfilled, S.rejected);
    });
    let h, u = 0, d;
    if (!l) {
      const v = [Ud.bind(this), void 0];
      for (v.unshift.apply(v, a), v.push.apply(v, c), d = v.length, h = Promise.resolve(t); u < d; )
        h = h.then(v[u++], v[u++]);
      return h;
    }
    d = a.length;
    let O = t;
    for (u = 0; u < d; ) {
      const v = a[u++], S = a[u++];
      try {
        O = v(O);
      } catch (f) {
        S.call(this, f);
        break;
      }
    }
    try {
      h = Ud.call(this, O);
    } catch (v) {
      return Promise.reject(v);
    }
    for (u = 0, d = c.length; u < d; )
      h = h.then(c[u++], c[u++]);
    return h;
  }
  getUri(e) {
    e = $r(this.defaults, e);
    const t = m0(e.baseURL, e.url, e.allowAbsoluteUrls);
    return f0(t, e.params, e.paramsSerializer);
  }
};
I.forEach(["delete", "get", "head", "options"], function(e) {
  kr.prototype[e] = function(t, r) {
    return this.request($r(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
I.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(n, o, a) {
      return this.request($r(a || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: n,
        data: o
      }));
    };
  }
  kr.prototype[e] = t(), kr.prototype[e + "Form"] = t(!0);
});
let Rx = class w0 {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(n) {
      t = n;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let n = r._listeners.length;
      for (; n-- > 0; )
        r._listeners[n](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let n;
      const o = new Promise((a) => {
        r.subscribe(a), n = a;
      }).then(s);
      return o.cancel = function() {
        r.unsubscribe(n);
      }, o;
    }, e(function(n, o, a) {
      r.reason || (r.reason = new ws(n, o, a), t(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (r) => {
      e.abort(r);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new w0(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function Ex(i) {
  return function(t) {
    return i.apply(null, t);
  };
}
function Ax(i) {
  return I.isObject(i) && i.isAxiosError === !0;
}
const _h = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(_h).forEach(([i, e]) => {
  _h[e] = i;
});
function x0(i) {
  const e = new kr(i), t = e0(kr.prototype.request, e);
  return I.extend(t, kr.prototype, e, { allOwnKeys: !0 }), I.extend(t, e, null, { allOwnKeys: !0 }), t.create = function(s) {
    return x0($r(i, s));
  }, t;
}
const Ie = x0(eo);
Ie.Axios = kr;
Ie.CanceledError = ws;
Ie.CancelToken = Rx;
Ie.isCancel = p0;
Ie.VERSION = y0;
Ie.toFormData = _l;
Ie.AxiosError = ue;
Ie.Cancel = Ie.CanceledError;
Ie.all = function(e) {
  return Promise.all(e);
};
Ie.spread = Ex;
Ie.isAxiosError = Ax;
Ie.mergeConfig = $r;
Ie.AxiosHeaders = wt;
Ie.formToJSON = (i) => O0(I.isHTMLForm(i) ? new FormData(i) : i);
Ie.getAdapter = b0.getAdapter;
Ie.HttpStatusCode = _h;
Ie.default = Ie;
const {
  Axios: S3,
  AxiosError: v3,
  CanceledError: _3,
  isCancel: b3,
  CancelToken: y3,
  VERSION: w3,
  all: x3,
  Cancel: k3,
  isAxiosError: C3,
  spread: Q3,
  toFormData: P3,
  AxiosHeaders: T3,
  HttpStatusCode: $3,
  formToJSON: R3,
  getAdapter: E3,
  mergeConfig: A3
} = Ie, Lx = "http://localhost:5000/api", Dx = localStorage.getItem("token"), rr = Ie.create({
  baseURL: `${Lx}`,
  headers: {
    "Content-Type": "application/json",
    Authorization: `Bearer ${Dx}`
  }
  // Include credentials (cookies) with every request
  //withCredentials: true,
});
rr.interceptors.request.use(
  (i) => i,
  (i) => Promise.reject(i)
);
const k0 = Hn(), Mx = (i) => {
  const [e, t] = se(!1), [r, s] = Km({});
  Di(() => {
    const a = localStorage.getItem("token"), l = localStorage.getItem("user");
    if (a && l)
      try {
        const c = JSON.parse(l);
        s({
          ...c,
          token: a
        }), t(!0);
      } catch {
        console.warn("Failed to parse saved user"), localStorage.removeItem("user"), localStorage.removeItem("token");
      }
  });
  const n = async (a) => {
    const l = await rr.post("/auth/login", a);
    if (!l.data) throw new Error("Login failed");
    const c = await l.data;
    localStorage.setItem("token", c.accessToken);
    const h = await c.user;
    s({
      ...c,
      token: c.accessToken
    }), localStorage.setItem("user", JSON.stringify(h)), t(!0);
  }, o = async () => {
    s({}), t(!1), localStorage.removeItem("token"), localStorage.removeItem("user");
  };
  return Z(k0.Provider, {
    value: {
      isAuthenticated: e,
      user: () => r,
      login: n,
      logout: o
    },
    get children() {
      return i.children;
    }
  });
}, to = () => {
  const i = Br(k0);
  if (!i) throw new Error("useAuth must be used within an AuthProvider");
  return i;
}, cf = [
  { slug: "tts", title: "TextToSpeech", subTitle: "TextToSpeech", show: !0 },
  { slug: "editor", title: "Editor", subTitle: "Editor", show: !0 },
  { slug: "downloader", title: "Downloader", subTitle: "Editor", show: !0 },
  { slug: "privacy", title: "Privacy Policy", subTitle: "Privacy  Policy.", show: !1 },
  { slug: "terms", title: "Terms & Conditions", subTitle: "Terms & Conditions", show: !1 }
];
function Bx(i) {
  let e = i.listen(() => {
  }), [t, r] = Km({ value: i.get() }), s = i.subscribe((n) => {
    r("value", j1(n));
  });
  return ft(() => s()), e(), () => t.value;
}
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 3.0.0
*/
const C0 = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Ea = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), io = Object.freeze({
  ...C0,
  ...Ea
}), bh = Object.freeze({
  ...io,
  body: "",
  hidden: !1
}), qx = Object.freeze({
  width: null,
  height: null
}), Q0 = Object.freeze({
  // Dimensions
  ...qx,
  // Transformations
  ...Ea
});
function Xx(i, e = 0) {
  const t = i.replace(/^-?[0-9.]*/, "");
  function r(s) {
    for (; s < 0; )
      s += 4;
    return s % 4;
  }
  if (t === "") {
    const s = parseInt(i);
    return isNaN(s) ? 0 : r(s);
  } else if (t !== i) {
    let s = 0;
    switch (t) {
      case "%":
        s = 25;
        break;
      case "deg":
        s = 90;
    }
    if (s) {
      let n = parseFloat(i.slice(0, i.length - t.length));
      return isNaN(n) ? 0 : (n = n / s, n % 1 === 0 ? r(n) : 0);
    }
  }
  return e;
}
const Ix = /[\s,]+/;
function Zx(i, e) {
  e.split(Ix).forEach((t) => {
    switch (t.trim()) {
      case "horizontal":
        i.hFlip = !0;
        break;
      case "vertical":
        i.vFlip = !0;
        break;
    }
  });
}
const P0 = {
  ...Q0,
  preserveAspectRatio: ""
};
function Nd(i) {
  const e = {
    ...P0
  }, t = (r, s) => i.getAttribute(r) || s;
  return e.width = t("width", null), e.height = t("height", null), e.rotate = Xx(t("rotate", "")), Zx(e, t("flip", "")), e.preserveAspectRatio = t("preserveAspectRatio", t("preserveaspectratio", "")), e;
}
function Wx(i, e) {
  for (const t in P0)
    if (i[t] !== e[t])
      return !0;
  return !1;
}
const T0 = /^[a-z0-9]+(-[a-z0-9]+)*$/, ro = (i, e, t, r = "") => {
  const s = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (s.length < 2 || s.length > 3)
      return null;
    r = s.shift().slice(1);
  }
  if (s.length > 3 || !s.length)
    return null;
  if (s.length > 1) {
    const a = s.pop(), l = s.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: s.length > 0 ? s[0] : r,
      prefix: l,
      name: a
    };
    return e && !ea(c) ? null : c;
  }
  const n = s[0], o = n.split("-");
  if (o.length > 1) {
    const a = {
      provider: r,
      prefix: o.shift(),
      name: o.join("-")
    };
    return e && !ea(a) ? null : a;
  }
  if (t && r === "") {
    const a = {
      provider: r,
      prefix: "",
      name: n
    };
    return e && !ea(a, t) ? null : a;
  }
  return null;
}, ea = (i, e) => i ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((e && i.prefix === "" || i.prefix) && i.name) : !1;
function zx(i, e) {
  const t = {};
  !i.hFlip != !e.hFlip && (t.hFlip = !0), !i.vFlip != !e.vFlip && (t.vFlip = !0);
  const r = ((i.rotate || 0) + (e.rotate || 0)) % 4;
  return r && (t.rotate = r), t;
}
function Yd(i, e) {
  const t = zx(i, e);
  for (const r in bh)
    r in Ea ? r in i && !(r in t) && (t[r] = Ea[r]) : r in e ? t[r] = e[r] : r in i && (t[r] = i[r]);
  return t;
}
function Vx(i, e) {
  const t = i.icons, r = i.aliases || /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
  function n(o) {
    if (t[o])
      return s[o] = [];
    if (!(o in s)) {
      s[o] = null;
      const a = r[o] && r[o].parent, l = a && n(a);
      l && (s[o] = [a].concat(l));
    }
    return s[o];
  }
  return Object.keys(t).concat(Object.keys(r)).forEach(n), s;
}
function Ux(i, e, t) {
  const r = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null);
  let n = {};
  function o(a) {
    n = Yd(
      r[a] || s[a],
      n
    );
  }
  return o(e), t.forEach(o), Yd(i, n);
}
function $0(i, e) {
  const t = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return t;
  i.not_found instanceof Array && i.not_found.forEach((s) => {
    e(s, null), t.push(s);
  });
  const r = Vx(i);
  for (const s in r) {
    const n = r[s];
    n && (e(s, Ux(i, s, n)), t.push(s));
  }
  return t;
}
const jx = {
  provider: "",
  aliases: {},
  not_found: {},
  ...C0
};
function ec(i, e) {
  for (const t in e)
    if (t in i && typeof i[t] != typeof e[t])
      return !1;
  return !0;
}
function R0(i) {
  if (typeof i != "object" || i === null)
    return null;
  const e = i;
  if (typeof e.prefix != "string" || !i.icons || typeof i.icons != "object" || !ec(i, jx))
    return null;
  const t = e.icons;
  for (const s in t) {
    const n = t[s];
    if (
      // Name cannot be empty
      !s || // Must have body
      typeof n.body != "string" || // Check other props
      !ec(
        n,
        bh
      )
    )
      return null;
  }
  const r = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const s in r) {
    const n = r[s], o = n.parent;
    if (
      // Name cannot be empty
      !s || // Parent must be set and point to existing icon
      typeof o != "string" || !t[o] && !r[o] || // Check other props
      !ec(
        n,
        bh
      )
    )
      return null;
  }
  return e;
}
const Aa = /* @__PURE__ */ Object.create(null);
function Nx(i, e) {
  return {
    provider: i,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Mi(i, e) {
  const t = Aa[i] || (Aa[i] = /* @__PURE__ */ Object.create(null));
  return t[e] || (t[e] = Nx(i, e));
}
function E0(i, e) {
  return R0(e) ? $0(e, (t, r) => {
    r ? i.icons[t] = r : i.missing.add(t);
  }) : [];
}
function Yx(i, e, t) {
  try {
    if (typeof t.body == "string")
      return i.icons[e] = { ...t }, !0;
  } catch {
  }
  return !1;
}
function Fx(i, e) {
  let t = [];
  return (typeof i == "string" ? [i] : Object.keys(Aa)).forEach((s) => {
    (typeof s == "string" && typeof e == "string" ? [e] : Object.keys(Aa[s] || {})).forEach((o) => {
      const a = Mi(s, o);
      t = t.concat(
        Object.keys(a.icons).map(
          (l) => (s !== "" ? "@" + s + ":" : "") + o + ":" + l
        )
      );
    });
  }), t;
}
let vn = !1;
function A0(i) {
  return typeof i == "boolean" && (vn = i), vn;
}
function _n(i) {
  const e = typeof i == "string" ? ro(i, !0, vn) : i;
  if (e) {
    const t = Mi(e.provider, e.prefix), r = e.name;
    return t.icons[r] || (t.missing.has(r) ? null : void 0);
  }
}
function L0(i, e) {
  const t = ro(i, !0, vn);
  if (!t)
    return !1;
  const r = Mi(t.provider, t.prefix);
  return e ? Yx(r, t.name, e) : (r.missing.add(t.name), !0);
}
function Fd(i, e) {
  if (typeof i != "object")
    return !1;
  if (typeof e != "string" && (e = i.provider || ""), vn && !e && !i.prefix) {
    let s = !1;
    return R0(i) && (i.prefix = "", $0(i, (n, o) => {
      L0(n, o) && (s = !0);
    })), s;
  }
  const t = i.prefix;
  if (!ea({
    prefix: t,
    name: "a"
  }))
    return !1;
  const r = Mi(e, t);
  return !!E0(r, i);
}
function Hx(i) {
  return !!_n(i);
}
function Gx(i) {
  const e = _n(i);
  return e && {
    ...io,
    ...e
  };
}
function Kx(i) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, t = /* @__PURE__ */ Object.create(null);
  i.sort((s, n) => s.provider !== n.provider ? s.provider.localeCompare(n.provider) : s.prefix !== n.prefix ? s.prefix.localeCompare(n.prefix) : s.name.localeCompare(n.name));
  let r = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((s) => {
    if (r.name === s.name && r.prefix === s.prefix && r.provider === s.provider)
      return;
    r = s;
    const n = s.provider, o = s.prefix, a = s.name, l = t[n] || (t[n] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = Mi(n, o));
    let h;
    a in c.icons ? h = e.loaded : o === "" || c.missing.has(a) ? h = e.missing : h = e.pending;
    const u = {
      provider: n,
      prefix: o,
      name: a
    };
    h.push(u);
  }), e;
}
function D0(i, e) {
  i.forEach((t) => {
    const r = t.loaderCallbacks;
    r && (t.loaderCallbacks = r.filter((s) => s.id !== e));
  });
}
function Jx(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = !0, setTimeout(() => {
    i.pendingCallbacksFlag = !1;
    const e = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let t = !1;
    const r = i.provider, s = i.prefix;
    e.forEach((n) => {
      const o = n.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== s)
          return !0;
        const c = l.name;
        if (i.icons[c])
          o.loaded.push({
            provider: r,
            prefix: s,
            name: c
          });
        else if (i.missing.has(c))
          o.missing.push({
            provider: r,
            prefix: s,
            name: c
          });
        else
          return t = !0, !0;
        return !1;
      }), o.pending.length !== a && (t || D0([i], n.id), n.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        n.abort
      ));
    });
  }));
}
let ek = 0;
function tk(i, e, t) {
  const r = ek++, s = D0.bind(null, t, r);
  if (!e.pending.length)
    return s;
  const n = {
    id: r,
    icons: e,
    callback: i,
    abort: s
  };
  return t.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(n);
  }), s;
}
const yh = /* @__PURE__ */ Object.create(null);
function Hd(i, e) {
  yh[i] = e;
}
function wh(i) {
  return yh[i] || yh[""];
}
function ik(i, e = !0, t = !1) {
  const r = [];
  return i.forEach((s) => {
    const n = typeof s == "string" ? ro(s, e, t) : s;
    n && r.push(n);
  }), r;
}
var rk = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function sk(i, e, t, r) {
  const s = i.resources.length, n = i.random ? Math.floor(Math.random() * s) : i.index;
  let o;
  if (i.random) {
    let w = i.resources.slice(0);
    for (o = []; w.length > 1; ) {
      const x = Math.floor(Math.random() * w.length);
      o.push(w[x]), w = w.slice(0, x).concat(w.slice(x + 1));
    }
    o = o.concat(w);
  } else
    o = i.resources.slice(n).concat(i.resources.slice(0, n));
  const a = Date.now();
  let l = "pending", c = 0, h, u = null, d = [], O = [];
  typeof r == "function" && O.push(r);
  function v() {
    u && (clearTimeout(u), u = null);
  }
  function S() {
    l === "pending" && (l = "aborted"), v(), d.forEach((w) => {
      w.status === "pending" && (w.status = "aborted");
    }), d = [];
  }
  function f(w, x) {
    x && (O = []), typeof w == "function" && O.push(w);
  }
  function p() {
    return {
      startTime: a,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: d.length,
      subscribe: f,
      abort: S
    };
  }
  function g() {
    l = "failed", O.forEach((w) => {
      w(void 0, h);
    });
  }
  function m() {
    d.forEach((w) => {
      w.status === "pending" && (w.status = "aborted");
    }), d = [];
  }
  function _(w, x, y) {
    const k = x !== "success";
    switch (d = d.filter(($) => $ !== w), l) {
      case "pending":
        break;
      case "failed":
        if (k || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (x === "abort") {
      h = y, g();
      return;
    }
    if (k) {
      h = y, d.length || (o.length ? b() : g());
      return;
    }
    if (v(), m(), !i.random) {
      const $ = i.resources.indexOf(w.resource);
      $ !== -1 && $ !== i.index && (i.index = $);
    }
    l = "completed", O.forEach(($) => {
      $(y);
    });
  }
  function b() {
    if (l !== "pending")
      return;
    v();
    const w = o.shift();
    if (w === void 0) {
      if (d.length) {
        u = setTimeout(() => {
          v(), l === "pending" && (m(), g());
        }, i.timeout);
        return;
      }
      g();
      return;
    }
    const x = {
      status: "pending",
      resource: w,
      callback: (y, k) => {
        _(x, y, k);
      }
    };
    d.push(x), c++, u = setTimeout(b, i.rotate), t(w, e, x.callback);
  }
  return setTimeout(b), p;
}
function M0(i) {
  const e = {
    ...rk,
    ...i
  };
  let t = [];
  function r() {
    t = t.filter((a) => a().status === "pending");
  }
  function s(a, l, c) {
    const h = sk(
      e,
      a,
      l,
      (u, d) => {
        r(), c && c(u, d);
      }
    );
    return t.push(h), h;
  }
  function n(a) {
    return t.find((l) => a(l)) || null;
  }
  return {
    query: s,
    find: n,
    setIndex: (a) => {
      e.index = a;
    },
    getIndex: () => e.index,
    cleanup: r
  };
}
function hf(i) {
  let e;
  if (typeof i.resources == "string")
    e = [i.resources];
  else if (e = i.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === !0,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== !1
  };
}
const wl = /* @__PURE__ */ Object.create(null), Ls = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], ta = [];
for (; Ls.length > 0; )
  Ls.length === 1 || Math.random() > 0.5 ? ta.push(Ls.shift()) : ta.push(Ls.pop());
wl[""] = hf({
  resources: ["https://api.iconify.design"].concat(ta)
});
function Gd(i, e) {
  const t = hf(e);
  return t === null ? !1 : (wl[i] = t, !0);
}
function xl(i) {
  return wl[i];
}
function nk() {
  return Object.keys(wl);
}
function Kd() {
}
const tc = /* @__PURE__ */ Object.create(null);
function ok(i) {
  if (!tc[i]) {
    const e = xl(i);
    if (!e)
      return;
    const t = M0(e), r = {
      config: e,
      redundancy: t
    };
    tc[i] = r;
  }
  return tc[i];
}
function B0(i, e, t) {
  let r, s;
  if (typeof i == "string") {
    const n = wh(i);
    if (!n)
      return t(void 0, 424), Kd;
    s = n.send;
    const o = ok(i);
    o && (r = o.redundancy);
  } else {
    const n = hf(i);
    if (n) {
      r = M0(n);
      const o = i.resources ? i.resources[0] : "", a = wh(o);
      a && (s = a.send);
    }
  }
  return !r || !s ? (t(void 0, 424), Kd) : r.query(e, s, t)().abort;
}
function Jd() {
}
function ak(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = !0, setTimeout(() => {
    i.iconsLoaderFlag = !1, Jx(i);
  }));
}
function lk(i) {
  const e = [], t = [];
  return i.forEach((r) => {
    (r.match(T0) ? e : t).push(r);
  }), {
    valid: e,
    invalid: t
  };
}
function Ds(i, e, t) {
  function r() {
    const s = i.pendingIcons;
    e.forEach((n) => {
      s && s.delete(n), i.icons[n] || i.missing.add(n);
    });
  }
  if (t && typeof t == "object")
    try {
      if (!E0(i, t).length) {
        r();
        return;
      }
    } catch (s) {
      console.error(s);
    }
  r(), ak(i);
}
function eO(i, e) {
  i instanceof Promise ? i.then((t) => {
    e(t);
  }).catch(() => {
    e(null);
  }) : e(i);
}
function ck(i, e) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(e).sort() : i.iconsToLoad = e, i.iconsQueueFlag || (i.iconsQueueFlag = !0, setTimeout(() => {
    i.iconsQueueFlag = !1;
    const { provider: t, prefix: r } = i, s = i.iconsToLoad;
    if (delete i.iconsToLoad, !s || !s.length)
      return;
    const n = i.loadIcon;
    if (i.loadIcons && (s.length > 1 || !n)) {
      eO(
        i.loadIcons(s, r, t),
        (h) => {
          Ds(i, s, h);
        }
      );
      return;
    }
    if (n) {
      s.forEach((h) => {
        const u = n(h, r, t);
        eO(u, (d) => {
          const O = d ? {
            prefix: r,
            icons: {
              [h]: d
            }
          } : null;
          Ds(i, [h], O);
        });
      });
      return;
    }
    const { valid: o, invalid: a } = lk(s);
    if (a.length && Ds(i, a, null), !o.length)
      return;
    const l = r.match(T0) ? wh(t) : null;
    if (!l) {
      Ds(i, o, null);
      return;
    }
    l.prepare(t, r, o).forEach((h) => {
      B0(t, h, (u) => {
        Ds(i, h.icons, u);
      });
    });
  }));
}
const uf = (i, e) => {
  const t = ik(i, !0, A0()), r = Kx(t);
  if (!r.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        r.loaded,
        r.missing,
        r.pending,
        Jd
      );
    }), () => {
      l = !1;
    };
  }
  const s = /* @__PURE__ */ Object.create(null), n = [];
  let o, a;
  return r.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === a && c === o)
      return;
    o = c, a = h, n.push(Mi(c, h));
    const u = s[c] || (s[c] = /* @__PURE__ */ Object.create(null));
    u[h] || (u[h] = []);
  }), r.pending.forEach((l) => {
    const { provider: c, prefix: h, name: u } = l, d = Mi(c, h), O = d.pendingIcons || (d.pendingIcons = /* @__PURE__ */ new Set());
    O.has(u) || (O.add(u), s[c][h].push(u));
  }), n.forEach((l) => {
    const c = s[l.provider][l.prefix];
    c.length && ck(l, c);
  }), e ? tk(e, r, n) : Jd;
}, hk = (i) => new Promise((e, t) => {
  const r = typeof i == "string" ? ro(i, !0) : i;
  if (!r) {
    t(i);
    return;
  }
  uf([r || i], (s) => {
    if (s.length && r) {
      const n = _n(r);
      if (n) {
        e({
          ...io,
          ...n
        });
        return;
      }
    }
    t(i);
  });
});
function tO(i) {
  try {
    const e = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof e.body == "string")
      return {
        ...e
      };
  } catch {
  }
}
function uk(i, e) {
  if (typeof i == "object")
    return {
      data: tO(i),
      value: i
    };
  if (typeof i != "string")
    return {
      value: i
    };
  if (i.includes("{")) {
    const n = tO(i);
    if (n)
      return {
        data: n,
        value: i
      };
  }
  const t = ro(i, !0, !0);
  if (!t)
    return {
      value: i
    };
  const r = _n(t);
  if (r !== void 0 || !t.prefix)
    return {
      value: i,
      name: t,
      data: r
      // could be 'null' -> icon is missing
    };
  const s = uf([t], () => e(i, t, _n(t)));
  return {
    value: i,
    name: t,
    loading: s
  };
}
let q0 = !1;
try {
  q0 = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function fk(i, e) {
  switch (e) {
    // Force mode
    case "svg":
    case "bg":
    case "mask":
      return e;
  }
  return e !== "style" && (q0 || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
const dk = /(-?[0-9.]*[0-9]+[0-9.]*)/g, Ok = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function xh(i, e, t) {
  if (e === 1)
    return i;
  if (t = t || 100, typeof i == "number")
    return Math.ceil(i * e * t) / t;
  if (typeof i != "string")
    return i;
  const r = i.split(dk);
  if (r === null || !r.length)
    return i;
  const s = [];
  let n = r.shift(), o = Ok.test(n);
  for (; ; ) {
    if (o) {
      const a = parseFloat(n);
      isNaN(a) ? s.push(n) : s.push(Math.ceil(a * e * t) / t);
    } else
      s.push(n);
    if (n = r.shift(), n === void 0)
      return s.join("");
    o = !o;
  }
}
function pk(i, e = "defs") {
  let t = "";
  const r = i.indexOf("<" + e);
  for (; r >= 0; ) {
    const s = i.indexOf(">", r), n = i.indexOf("</" + e);
    if (s === -1 || n === -1)
      break;
    const o = i.indexOf(">", n);
    if (o === -1)
      break;
    t += i.slice(s + 1, n).trim(), i = i.slice(0, r).trim() + i.slice(o + 1);
  }
  return {
    defs: t,
    content: i
  };
}
function gk(i, e) {
  return i ? "<defs>" + i + "</defs>" + e : e;
}
function mk(i, e, t) {
  const r = pk(i);
  return gk(r.defs, e + r.content + t);
}
const Sk = (i) => i === "unset" || i === "undefined" || i === "none";
function X0(i, e) {
  const t = {
    ...io,
    ...i
  }, r = {
    ...Q0,
    ...e
  }, s = {
    left: t.left,
    top: t.top,
    width: t.width,
    height: t.height
  };
  let n = t.body;
  [t, r].forEach((S) => {
    const f = [], p = S.hFlip, g = S.vFlip;
    let m = S.rotate;
    p ? g ? m += 2 : (f.push(
      "translate(" + (s.width + s.left).toString() + " " + (0 - s.top).toString() + ")"
    ), f.push("scale(-1 1)"), s.top = s.left = 0) : g && (f.push(
      "translate(" + (0 - s.left).toString() + " " + (s.height + s.top).toString() + ")"
    ), f.push("scale(1 -1)"), s.top = s.left = 0);
    let _;
    switch (m < 0 && (m -= Math.floor(m / 4) * 4), m = m % 4, m) {
      case 1:
        _ = s.height / 2 + s.top, f.unshift(
          "rotate(90 " + _.toString() + " " + _.toString() + ")"
        );
        break;
      case 2:
        f.unshift(
          "rotate(180 " + (s.width / 2 + s.left).toString() + " " + (s.height / 2 + s.top).toString() + ")"
        );
        break;
      case 3:
        _ = s.width / 2 + s.left, f.unshift(
          "rotate(-90 " + _.toString() + " " + _.toString() + ")"
        );
        break;
    }
    m % 2 === 1 && (s.left !== s.top && (_ = s.left, s.left = s.top, s.top = _), s.width !== s.height && (_ = s.width, s.width = s.height, s.height = _)), f.length && (n = mk(
      n,
      '<g transform="' + f.join(" ") + '">',
      "</g>"
    ));
  });
  const o = r.width, a = r.height, l = s.width, c = s.height;
  let h, u;
  o === null ? (u = a === null ? "1em" : a === "auto" ? c : a, h = xh(u, l / c)) : (h = o === "auto" ? l : o, u = a === null ? xh(h, c / l) : a === "auto" ? c : a);
  const d = {}, O = (S, f) => {
    Sk(f) || (d[S] = f.toString());
  };
  O("width", h), O("height", u);
  const v = [s.left, s.top, l, c];
  return d.viewBox = v.join(" "), {
    attributes: d,
    viewBox: v,
    body: n
  };
}
function ff(i, e) {
  let t = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const r in e)
    t += " " + r + '="' + e[r] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + t + ">" + i + "</svg>";
}
function vk(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function _k(i) {
  return "data:image/svg+xml," + vk(i);
}
function I0(i) {
  return 'url("' + _k(i) + '")';
}
const bk = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
let La = bk();
function yk(i) {
  La = i;
}
function wk() {
  return La;
}
function xk(i, e) {
  const t = xl(i);
  if (!t)
    return 0;
  let r;
  if (!t.maxURL)
    r = 0;
  else {
    let s = 0;
    t.resources.forEach((o) => {
      s = Math.max(s, o.length);
    });
    const n = e + ".json?icons=";
    r = t.maxURL - s - t.path.length - n.length;
  }
  return r;
}
function kk(i) {
  return i === 404;
}
const Ck = (i, e, t) => {
  const r = [], s = xk(i, e), n = "icons";
  let o = {
    type: n,
    provider: i,
    prefix: e,
    icons: []
  }, a = 0;
  return t.forEach((l, c) => {
    a += l.length + 1, a >= s && c > 0 && (r.push(o), o = {
      type: n,
      provider: i,
      prefix: e,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), r.push(o), r;
};
function Qk(i) {
  if (typeof i == "string") {
    const e = xl(i);
    if (e)
      return e.path;
  }
  return "/";
}
const Pk = (i, e, t) => {
  if (!La) {
    t("abort", 424);
    return;
  }
  let r = Qk(e.provider);
  switch (e.type) {
    case "icons": {
      const n = e.prefix, a = e.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      r += n + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const n = e.uri;
      r += n.slice(0, 1) === "/" ? n.slice(1) : n;
      break;
    }
    default:
      t("abort", 400);
      return;
  }
  let s = 503;
  La(i + r).then((n) => {
    const o = n.status;
    if (o !== 200) {
      setTimeout(() => {
        t(kk(o) ? "abort" : "next", o);
      });
      return;
    }
    return s = 501, n.json();
  }).then((n) => {
    if (typeof n != "object" || n === null) {
      setTimeout(() => {
        n === 404 ? t("abort", n) : t("next", s);
      });
      return;
    }
    setTimeout(() => {
      t("success", n);
    });
  }).catch(() => {
    t("next", s);
  });
}, Tk = {
  prepare: Ck,
  send: Pk
};
function $k(i, e, t) {
  Mi(t || "", e).loadIcons = i;
}
function Rk(i, e, t) {
  Mi(t || "", e).loadIcon = i;
}
const ic = "data-style";
let Z0 = "";
function Ek(i) {
  Z0 = i;
}
function iO(i, e) {
  let t = Array.from(i.childNodes).find((r) => r.hasAttribute && r.hasAttribute(ic));
  t || (t = document.createElement("style"), t.setAttribute(ic, ic), i.appendChild(t)), t.textContent = ":host{display:inline-block;vertical-align:" + (e ? "-0.125em" : "0") + "}span,svg{display:block;margin:auto}" + Z0;
}
function W0() {
  Hd("", Tk), A0(!0);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (i.IconifyPreload !== void 0) {
      const t = i.IconifyPreload, r = "Invalid IconifyPreload syntax.";
      typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((s) => {
        try {
          // Check if item is an object and not null/array
          (typeof s != "object" || s === null || s instanceof Array || // Check for 'icons' and 'prefix'
          typeof s.icons != "object" || typeof s.prefix != "string" || // Add icon set
          !Fd(s)) && console.error(r);
        } catch {
          console.error(r);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const t = i.IconifyProviders;
      if (typeof t == "object" && t !== null)
        for (const r in t) {
          const s = "IconifyProviders[" + r + "] is invalid.";
          try {
            const n = t[r];
            if (typeof n != "object" || !n || n.resources === void 0)
              continue;
            Gd(r, n) || console.error(s);
          } catch {
            console.error(s);
          }
        }
    }
  }
  return {
    iconLoaded: Hx,
    getIcon: Gx,
    listIcons: Fx,
    addIcon: L0,
    addCollection: Fd,
    calculateSize: xh,
    buildIcon: X0,
    iconToHTML: ff,
    svgToURL: I0,
    loadIcons: uf,
    loadIcon: hk,
    addAPIProvider: Gd,
    setCustomIconLoader: Rk,
    setCustomIconsLoader: $k,
    appendCustomStyle: Ek,
    _api: {
      getAPIConfig: xl,
      setAPIModule: Hd,
      sendAPIQuery: B0,
      setFetch: yk,
      getFetch: wk,
      listAPIProviders: nk
    }
  };
}
const kh = {
  "background-color": "currentColor"
}, z0 = {
  "background-color": "transparent"
}, rO = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
}, sO = {
  "-webkit-mask": kh,
  mask: kh,
  background: z0
};
for (const i in sO) {
  const e = sO[i];
  for (const t in rO)
    e[i + "-" + t] = rO[t];
}
function nO(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function Ak(i, e, t) {
  const r = document.createElement("span");
  let s = i.body;
  s.indexOf("<a") !== -1 && (s += "<!-- " + Date.now() + " -->");
  const n = i.attributes, o = ff(s, {
    ...n,
    width: e.width + "",
    height: e.height + ""
  }), a = I0(o), l = r.style, c = {
    "--svg": a,
    width: nO(n.width),
    height: nO(n.height),
    ...t ? kh : z0
  };
  for (const h in c)
    l.setProperty(h, c[h]);
  return r;
}
let tn;
function Lk() {
  try {
    tn = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    tn = null;
  }
}
function Dk(i) {
  return tn === void 0 && Lk(), tn ? tn.createHTML(i) : i;
}
function Mk(i) {
  const e = document.createElement("span"), t = i.attributes;
  let r = "";
  t.width || (r = "width: inherit;"), t.height || (r += "height: inherit;"), r && (t.style = r);
  const s = ff(i.body, t);
  return e.innerHTML = Dk(s), e.firstChild;
}
function Ch(i) {
  return Array.from(i.childNodes).find((e) => {
    const t = e.tagName && e.tagName.toUpperCase();
    return t === "SPAN" || t === "SVG";
  });
}
function oO(i, e) {
  const t = e.icon.data, r = e.customisations, s = X0(t, r);
  r.preserveAspectRatio && (s.attributes.preserveAspectRatio = r.preserveAspectRatio);
  const n = e.renderedMode;
  let o;
  switch (n) {
    case "svg":
      o = Mk(s);
      break;
    default:
      o = Ak(s, {
        ...io,
        ...t
      }, n === "mask");
  }
  const a = Ch(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function aO(i, e, t) {
  const r = t && (t.rendered ? t : t.lastRender);
  return {
    rendered: !1,
    inline: e,
    icon: i,
    lastRender: r
  };
}
function Bk(i = "iconify-icon") {
  let e, t;
  try {
    e = window.customElements, t = window.HTMLElement;
  } catch {
    return;
  }
  if (!e || !t)
    return;
  const r = e.get(i);
  if (r)
    return r;
  const s = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "noobserver",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], n = class extends t {
    // Root
    _shadowRoot;
    // Initialised
    _initialised = !1;
    // Icon state
    _state;
    // Attributes check queued
    _checkQueued = !1;
    // Connected
    _connected = !1;
    // Observer
    _observer = null;
    _visible = !0;
    /**
     * Constructor
     */
    constructor() {
      super();
      const a = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), l = this.hasAttribute("inline");
      iO(a, l), this._state = aO({
        value: ""
      }, l), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = !0, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = !1, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return s.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(a) {
      switch (a) {
        case "inline": {
          const l = this.hasAttribute("inline"), c = this._state;
          l !== c.inline && (c.inline = l, iO(this._shadowRoot, l));
          break;
        }
        case "noobserver": {
          this.hasAttribute("noobserver") ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const a = this.getAttribute("icon");
      if (a && a.slice(0, 1) === "{")
        try {
          return JSON.parse(a);
        } catch {
        }
      return a;
    }
    set icon(a) {
      typeof a == "object" && (a = JSON.stringify(a)), this.setAttribute("icon", a);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return this.hasAttribute("inline");
    }
    set inline(a) {
      a ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(a) {
      a ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const a = this._state;
      if (a.rendered) {
        const l = this._shadowRoot;
        if (a.renderedMode === "svg")
          try {
            l.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        oO(l, a);
      }
    }
    /**
     * Get status
     */
    get status() {
      const a = this._state;
      return a.rendered ? "rendered" : a.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = !1;
      const a = this._state, l = this.getAttribute("icon");
      if (l !== a.icon.value) {
        this._iconChanged(l);
        return;
      }
      if (!a.rendered || !this._visible)
        return;
      const c = this.getAttribute("mode"), h = Nd(this);
      (a.attrMode !== c || Wx(a.customisations, h) || !Ch(this._shadowRoot)) && this._renderIcon(a.icon, h, c);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(a) {
      const l = uk(a, (c, h, u) => {
        const d = this._state;
        if (d.rendered || this.getAttribute("icon") !== c)
          return;
        const O = {
          value: c,
          name: h,
          data: u
        };
        O.data ? this._gotIconData(O) : d.icon = O;
      });
      l.data ? this._gotIconData(l) : this._state = aO(l, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const a = Ch(this._shadowRoot);
        a && this._shadowRoot.removeChild(a);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(a) {
      this._checkQueued = !1, this._renderIcon(a, Nd(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(a, l, c) {
      const h = fk(a.data.body, c), u = this._state.inline;
      oO(this._shadowRoot, this._state = {
        rendered: !0,
        icon: a,
        inline: u,
        customisations: l,
        attrMode: c,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer && !this.hasAttribute("noobserver"))
        try {
          this._observer = new IntersectionObserver((a) => {
            const l = a.some((c) => c.isIntersecting);
            l !== this._visible && (this._visible = l, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());
    }
  };
  s.forEach((a) => {
    a in n.prototype || Object.defineProperty(n.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = W0();
  for (const a in o)
    n[a] = n.prototype[a] = o[a];
  return e.define(i, n), n;
}
const qk = Bk() || W0(), { iconLoaded: L3, getIcon: D3, listIcons: M3, addIcon: B3, addCollection: q3, calculateSize: X3, buildIcon: I3, iconToHTML: Z3, svgToURL: W3, loadIcons: z3, loadIcon: V3, setCustomIconLoader: U3, setCustomIconsLoader: j3, addAPIProvider: N3, _api: Y3 } = qk;
var Xk = /* @__PURE__ */ H("<iconify-icon>", !0, !1, !1);
function ct(i) {
  let {
    icon: e,
    mode: t,
    inline: r,
    rotate: s,
    flip: n,
    width: o,
    height: a,
    preserveAspectRatio: l,
    noobserver: c
  } = i;
  return typeof e == "object" && (e = JSON.stringify(e)), // @ts-ignore
  (() => {
    var h = Xk();
    return Ae(h, "icon", e), Ae(h, "mode", t), Ae(h, "inline", r), Ae(h, "rotate", s), Ae(h, "flip", n), Ae(h, "width", o), Ae(h, "height", a), Ae(h, "preserveaspectratio", l), Ae(h, "noobserver", c), rf(h, i, !1, !1), h._$owner = Fn(), h;
  })();
}
var Ik = /* @__PURE__ */ H('<button class="text-sm cursor-alias mt-1 pl-4">');
function Zk() {
  const i = Bx(Ta);
  return (() => {
    var e = Ik();
    return Mm(e, "click", rw, !0), X(e, Z(ct, {
      get icon() {
        return i() === "dark" ? "mdi:alarm-light" : "mdi:alarm-light-outline";
      },
      width: "28",
      height: "28",
      class: "text-sky-500"
    })), e;
  })();
}
dt(["click"]);
var Wk = /* @__PURE__ */ H('<a href=/dashboard class="text-md leading-6 text-white"title=Dashboard>Dashboard'), zk = /* @__PURE__ */ H('<div class="hidden lg:flex lg:flex-1 lg:justify-end pl-8 items-center space-x-4"><span class>Welcome, </span><button class="bg-red-500 hover:bg-red-600 px-4 py-1 rounded-md text-sm">Logout'), Vk = /* @__PURE__ */ H('<nav class="flex items-center justify-between p-6 lg:px-2"aria-label=Global><div class="flex lg:hidden"><button type=button class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5"><span class=sr-only>Open main menu</span><svg class=size-6 fill=none viewBox="0 0 24 24"stroke-width=1.5 stroke=currentColor aria-hidden=true><path stroke-linecap=round stroke-linejoin=round d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-10"></div> '), Uk = /* @__PURE__ */ H('<a class="text-md leading-6">'), jk = /* @__PURE__ */ H('<div class="hidden lg:flex lg:flex-1 lg:justify-end pl-8 items-center gap-4"><a href=/login class="outline outline-offset-2 outline-sky-500 focus:outline-2 leading-6 bg-sky-400 rounded-sm px-4">Log in <span aria-hidden=true>&rarr;');
function Nk() {
  const {
    isAuthenticated: i,
    user: e,
    logout: t
  } = to(), r = zm(), n = Vm().pathname === "/login", o = async () => {
    try {
      await t(), r("/login");
    } catch (a) {
      console.error("Logout failed:", a);
    }
  };
  return (() => {
    var a = Vk(), l = a.firstChild, c = l.nextSibling, h = c.nextSibling;
    return X(c, Z($e, {
      get when() {
        return i();
      },
      get children() {
        return Wk();
      }
    }), null), X(c, Z(_t, {
      each: cf,
      children: (u) => Z($e, {
        get when() {
          return u.show;
        },
        get children() {
          var d = Uk();
          return X(d, () => u.title), Oe((O) => {
            var v = `/${u.slug}`, S = u.title;
            return v !== O.e && Ae(d, "href", O.e = v), S !== O.t && Ae(d, "title", O.t = S), O;
          }, {
            e: void 0,
            t: void 0
          }), d;
        }
      })
    }), null), X(a, Z($e, {
      get when() {
        return i();
      },
      get fallback() {
        return Z($e, {
          when: !n,
          get children() {
            return jk();
          }
        });
      },
      get children() {
        var u = zk(), d = u.firstChild;
        d.firstChild;
        var O = d.nextSibling;
        return X(d, () => e().name || "User", null), O.$$click = o, u;
      }
    }), h), X(a, Z(Zk, {}), h), a;
  })();
}
dt(["click"]);
const bn = {
  name: "Project Board",
  logo: "/logo.svg"
  // You can change this path to your actual logo
};
var Yk = /* @__PURE__ */ H('<a href=/><div class="flex align-center justify-center gap-4"><span class=sr-only></span><div class="mt-1 uppercase tracking-widest font-light text-shadow-2xs "><b class="font-bold text-shadow-black">Project</b> Board'), Fk = /* @__PURE__ */ H("<img>"), Hk = /* @__PURE__ */ H("<div>");
const V0 = (i) => (() => {
  var e = Yk(), t = e.firstChild, r = t.firstChild, s = r.nextSibling;
  return X(r, () => i.name || "Your Company Name"), X(t, (() => {
    var n = bt(() => !!i.logo);
    return () => n() ? (() => {
      var o = Fk();
      return Oe((a) => {
        var l = `h-${i.height || 8} w-${i.width || "auto"}`, c = i.logo, h = i.name;
        return l !== a.e && Vt(o, a.e = l), c !== a.t && Ae(o, "src", a.t = c), h !== a.a && Ae(o, "alt", a.a = h), a;
      }, {
        e: void 0,
        t: void 0,
        a: void 0
      }), o;
    })() : (() => {
      var o = Hk();
      return X(o, () => i.name.charAt(0).toUpperCase()), Oe(() => Vt(o, `bg-sky-600 dark:bg-sky-400 text-gray-950 flex w-8 items-center justify-center font-semibold rounded-lg h-${i.height || 8} w-${i.width || 8}`)), o;
    })();
  })(), s), Oe(() => Vt(e, `-m-1.5 p-1.5 ${i.className || ""}`)), e;
})();
var Gk = /* @__PURE__ */ H('<div class=py-6><a href=/login class="-mx-3 block rounded-lg px-3 py-2.5 text-base font-semibold leading-7 text-gray-900 hover:bg-gray-50">Log in'), Kk = /* @__PURE__ */ H('<div class=lg:hidden role=dialog aria-modal=true><div class="fixed inset-0 z-50"></div><div class="fixed inset-y-0 right-0 z-50 w-full overflow-y-auto bg-white px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10"><div class="flex items-center justify-between"><button type=button class="-m-2.5 rounded-md p-2.5 text-gray-700"><span class=sr-only>Close menu</span><svg class=size-6 fill=none viewBox="0 0 24 24"stroke-width=1.5 stroke=currentColor aria-hidden=true><path stroke-linecap=round stroke-linejoin=round d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="mt-6 flow-root"><div class="-my-6 divide-y divide-gray-500/10"><div class="space-y-2 py-6">'), Jk = /* @__PURE__ */ H('<a class="-mx-3 block rounded-lg px-3 py-2 text-base font-semibold leading-7 text-gray-900 hover:bg-gray-50">');
const eC = () => {
  const {
    isAuthenticated: i
  } = to();
  return (() => {
    var e = Kk(), t = e.firstChild, r = t.nextSibling, s = r.firstChild, n = s.firstChild, o = s.nextSibling, a = o.firstChild, l = a.firstChild;
    return X(s, Z(V0, {
      get name() {
        return bn.name;
      },
      get logo() {
        return bn.logo;
      }
    }), n), X(l, Z(_t, {
      each: cf,
      children: (c) => Z($e, {
        get when() {
          return c.show;
        },
        get children() {
          var h = Jk();
          return X(h, () => c.title), Oe((u) => {
            var d = c.slug === "home" ? "/" : `/${c.slug}`, O = c.title;
            return d !== u.e && Ae(h, "href", u.e = d), O !== u.t && Ae(h, "title", u.t = O), u;
          }, {
            e: void 0,
            t: void 0
          }), h;
        }
      })
    })), X(a, Z($e, {
      get when() {
        return !i();
      },
      get children() {
        return Gk();
      }
    }), null), e;
  })();
};
var tC = /* @__PURE__ */ H('<header class="sticky top-0 z-50 h-[3rem] flex items-center justify-between px-4 border-b text-white dark:bg-gray-900 bg-gray-100 dark:border-gray-800"><div class="flex align-center justify-center gap-x-4"></div><nav class="hidden md:flex"></nav><div class=md:hidden>');
function iC() {
  return (() => {
    var i = tC(), e = i.firstChild, t = e.nextSibling, r = t.nextSibling;
    return X(e, Z(V0, {
      get name() {
        return bn.name;
      }
    })), X(t, Z(Nk, {})), X(r, Z(eC, {})), i;
  })();
}
var rC = /* @__PURE__ */ H('<footer class="sticky bottm-4 z-50 h-[2rem] flex items-center justify-start px-4 border-b text-white dark:bg-gray-900 bg-gray-100 dark:border-gray-800"><p> 2025 <!>. All rights reserved.</p><nav class="lg:flex lg:gap-x-6 ml-4">'), sC = /* @__PURE__ */ H('<a class="hover:text-blue-600 dark:hover:text-blue-400">');
const nC = (i) => (() => {
  var e = rC(), t = e.firstChild, r = t.firstChild, s = r.nextSibling;
  s.nextSibling;
  var n = t.nextSibling;
  return X(t, () => bn.name, s), X(n, Z(_t, {
    get each() {
      return i.links;
    },
    children: (o) => Z($e, {
      get when() {
        return o.show;
      },
      get children() {
        var a = sC();
        return X(a, () => o.title), Oe(() => Ae(a, "href", o.slug === "home" ? "/" : `/${o.slug}`)), a;
      }
    })
  })), e;
})();
var oC = /* @__PURE__ */ H('<aside><button class="mx-4 hover:text-gray-400">');
const aC = () => {
  const [i, e] = se(!0);
  return (() => {
    var t = oC(), r = t.firstChild;
    return r.$$click = () => e(!i()), Oe(() => Vt(t, `transition-all duration-300 ${i() ? "w-80" : "w-0"} flex-shrink-0 bg-gray-900 text-white py-4 flex flex-col justify-between items-center border-r dark:border-gray-700`)), t;
  })();
};
dt(["click"]);
var lC = /* @__PURE__ */ H('<aside><button class="text-lg font-medium mx-4 hover:text-gray-400">');
const cC = () => {
  const [i, e] = se(!1);
  return (() => {
    var t = lC(), r = t.firstChild;
    return r.$$click = () => e(!i()), Oe(() => Vt(t, `transition-all duration-300 ${i() ? "w-52" : "w-0"} flex-shrink-0 bg-gray-100 dark:bg-gray-900 text-white dark:text-gray-100 py-4 flex flex-col justify-between items-center`)), t;
  })();
};
dt(["click"]);
var hC = /* @__PURE__ */ H("<div>");
function uC({
  content: i,
  classNames: e = ""
}) {
  return (() => {
    var t = hC();
    return Vt(t, `flex-grow overflow-auto ${e}`), X(t, i), t;
  })();
}
var fC = /* @__PURE__ */ H('<header class="mb-4 pb-2"><h1 class="text-2xl font-semibold">'), dC = /* @__PURE__ */ H('<p class="text-sm text-gray-600">');
const OC = ({
  title: i,
  subTitle: e
}) => (() => {
  var t = fC(), r = t.firstChild;
  return X(r, i), X(t, e && (() => {
    var s = dC();
    return X(s, e), s;
  })(), null), t;
})();
var pC = /* @__PURE__ */ H("<div>");
function gC({
  content: i,
  header: e,
  classNames: t = ""
}) {
  return (() => {
    var r = pC();
    return Vt(r, `flex flex-1 ${t}`), X(r, () => e && (typeof e == "object" && "title" in e ? Z(OC, {
      get title() {
        return e.title;
      },
      get subTitle() {
        return e.subTitle;
      }
    }) : e), null), X(r, Z(uC, {
      content: i
    }), null), r;
  })();
}
var mC = /* @__PURE__ */ H('<div class="flex flex-col h-[calc(100vh)] overflow-hidden"><div class="flex flex-1 overflow-auto">');
function SC({
  title: i,
  menus: e,
  content: t,
  leftSidebar: r = !1,
  rightSidebar: s = !1,
  footer: n = !0
}) {
  return (() => {
    var o = mC(), a = o.firstChild;
    return X(o, Z(iC, {}), a), X(a, Z($e, {
      when: r,
      get children() {
        return Z(aC, {});
      }
    }), null), X(a, Z(gC, {
      content: t
    }), null), X(a, Z($e, {
      when: s,
      get children() {
        return Z(cC, {});
      }
    }), null), X(o, Z($e, {
      when: n,
      get children() {
        return Z(nC, {
          links: e
        });
      }
    }), null), o;
  })();
}
const vC = `# Extending OAuth Support for GitHub in NestJS with Prisma

## 1. Prisma Schema Considerations

Your existing \`Account\` model is already structured to support multiple OAuth providers, including GitHub. No schema changes are required.

## 2. Create DTOs for GitHub Profile and Tokens

Define DTOs to validate and document GitHub profile data and OAuth tokens.

Example:

\`\`\`typescript
// src/auth/dto/github-profile.dto.ts
import { IsString, IsUrl, IsOptional, ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class GitHubProfileDto {
  @ApiProperty({ example: '12345678' })
  @IsString()
  id: string;

  @ApiProperty({ example: 'octocat' })
  @IsString()
  login: string;

  @ApiPropertyOptional({ example: 'The Octocat' })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({ example: 'octocat@github.com' })
  @IsOptional()
  @IsString()
  email?: string;

  @ApiPropertyOptional({ example: 'https://avatars.githubusercontent.com/u/12345678?v=4' })
  @IsOptional()
  @IsUrl()
  avatar_url?: string;
}

export class GitHubTokenDto {
  @ApiProperty()
  @IsString()
  accessToken: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  refreshToken?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  scope?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  tokenType?: string;
}
\`\`\`

## 3. Implement GitHub Passport Strategy

Create a GitHub strategy extending \`passport-github2\`.

\`\`\`typescript
// src/auth/strategies/github.strategy.ts
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { Strategy, VerifyCallback } from 'passport-github2';

@Injectable()
export class GitHubStrategy extends PassportStrategy(Strategy, 'github') {
  constructor() {
    super({
      clientID: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET,
      callbackURL: process.env.GITHUB_CALLBACK_URL,
      scope: ['user:email'],
    });
  }

  async validate(accessToken: string, refreshToken: string, profile: any, done: VerifyCallback): Promise<any> {
    const { id, username, displayName, emails, photos } = profile;

    const user = {
      id,
      login: username,
      name: displayName,
      email: emails?.[0]?.value,
      avatar_url: photos?.[0]?.value,
      accessToken,
      refreshToken,
    };

    done(null, user);
  }
}
\`\`\`

## 4. Create GitHub Auth Guard

\`\`\`typescript
// src/auth/guards/github.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GitHubAuthGuard extends AuthGuard('github') {}
\`\`\`

## 5. Update Auth Service to Validate GitHub Profile

Add a method to validate and persist GitHub profile data, similar to Google:

\`\`\`typescript
async validateGitHubProfile(profile: GitHubProfileDto, tokens: GitHubTokenDto) {
  const { id, email, name, avatar_url } = profile;

  if (!email) {
    throw new Error('GitHub profile does not contain a valid email address.');
  }

  let user = await this.prisma.user.findUnique({ where: { email } });

  if (!user) {
    user = await this.prisma.user.create({
      data: {
        email,
        name,
        image: avatar_url,
        emailVerified: new Date(),
      },
    });
  } else if (!user.image && avatar_url) {
    await this.prisma.user.update({
      where: { id: user.id },
      data: { image: avatar_url },
    });
  }

  await this.prisma.account.upsert({
    where: {
      provider_providerAccountId: {
        provider: 'github',
        providerAccountId: id,
      },
    },
    update: {
      access_token: tokens.accessToken,
      refresh_token: tokens.refreshToken,
      scope: tokens.scope,
      token_type: tokens.tokenType,
    },
    create: {
      provider: 'github',
      providerAccountId: id,
      type: 'oauth',
      access_token: tokens.accessToken,
      refresh_token: tokens.refreshToken,
      scope: tokens.scope,
      token_type: tokens.tokenType,
      createdBy: {
        connect: { id: user.id },
      },
    },
  });

  return user;
}
\`\`\`

## 6. Add Controller Endpoints

Add GitHub OAuth endpoints in your AuthController:

\`\`\`typescript
@Get('github')
@UseGuards(GitHubAuthGuard)
@ApiOperation({ summary: 'Initiate GitHub OAuth2 login' })
@ApiResponse({ status: 302, description: 'Redirects to GitHub login' })
async githubAuth() {
  // Initiates the GitHub OAuth2 login flow
}

@Get('github/callback')
@UseGuards(GitHubAuthGuard)
@ApiOperation({ summary: 'Handle GitHub OAuth2 callback and issue JWT token' })
@ApiResponse({ status: 200, description: 'GitHub login successful with JWT issued' })
@ApiResponse({ status: 401, description: 'Unauthorized or failed login attempt' })
async githubAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {
  const profile = req.user;

  const user = await this.authService.validateGitHubProfile(profile, {
    accessToken: profile.accessToken,
    refreshToken: profile.refreshToken,
    scope: profile.scope,
    tokenType: profile.tokenType,
  });

  const payload = {
    sub: user.id,
    email: user.email,
    role: user.role,
  };

  const accessToken = await this.authService.generateToken(payload);
  res.cookie('accessToken', accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });

  return res.json({
    message: 'GitHub login successful',
    accessToken,
    user,
  });
}
\`\`\`

## 7. Environment Variables

Ensure you have these set in your \`.env\`:

\`\`\`
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
GITHUB_CALLBACK_URL=https://your-domain.com/auth/github/callback
\`\`\`

## 8. Register Strategy and Guard in Module

Import and provide \`GitHubStrategy\` and \`GitHubAuthGuard\` similarly as done for Google.

`, _C = `# Google OAuth2 Integration with NestJS and Prisma  Implementation Documentation

## Overview

This documentation summarizes the design and implementation details of Google OAuth2 integration for authentication within a NestJS application using Prisma ORM. The integration covers:

- Initiating Google OAuth2 login flow
- Validating and persisting Google user profiles and OAuth tokens into the database
- Issuing JWT tokens on successful authentication
- API endpoint documentation with Swagger annotations
- Guard and strategy setup for PassportJS Google OAuth

---

## 1. Prisma Schema Usage

We utilized existing Prisma models to store users, OAuth accounts, and sessions:

- **User**: Stores user data such as email, name, image, email verification timestamp, and related relations.
- **Account**: Stores OAuth provider details and tokens (\`access_token\`, \`refresh_token\`, \`id_token\`, etc.).
- **Session**: (Prepared for future JWT session management).

---

## 2. DTOs (Data Transfer Objects)

### GoogleProfileDto

Validated and documented using \`class-validator\` and \`@nestjs/swagger\` decorators:

- Captures Google user profile fields: \`id\`, \`emails\`, \`name\`, \`photos\`.
- Nested DTOs for \`GoogleNameDto\`, \`GoogleEmailDto\`, \`GooglePhotoDto\` with validation and example data.

### GoogleTokenDto

Contains fields for Google OAuth tokens and metadata:

- \`accessToken\`, \`refreshToken\`, \`idToken\`, \`expiresAt\`, \`scope\`, \`tokenType\`.

---

## 3. Auth Service: \`validateGoogleProfile\` Method

- Extracts user details (\`email\`, \`name\`, \`image\`) from the Google profile.
- Validates presence of an email (throws error if absent).
- Attempts to find an existing user by email.
- If user does not exist, creates a new user record.
- If user exists but \`image\` is null, updates the user record with Google profile image.
- Upserts OAuth account record with latest tokens and provider data linked to the user.

---

## 4. Google OAuth Strategy

- Implemented a Passport strategy extending \`passport-google-oauth20\`.
- Configured with client ID, secret, callback URL, and requested scopes (\`email\`, \`profile\`).
- The \`validate\` method extracts Google profile data and passes it on for further validation and persistence.

---

## 5. Guards

- Created \`GoogleAuthGuard\` extending Passports Google guard to protect OAuth routes.
- Properly typed request objects to include Passports \`logIn\` method to fix type errors.

---

## 6. Controller Endpoints

### \`GET /auth/google\`

- Initiates Google OAuth2 login flow.
- Protected by \`GoogleAuthGuard\`.
- Documented with Swagger annotations (\`@ApiOperation\`, \`@ApiResponse\`).

### \`GET /auth/google/callback\`

- Handles OAuth2 callback.
- Uses \`GoogleAuthGuard\` to validate the callback.
- Uses a strongly typed request interface (\`AuthRequest\`) to access \`req.user\`.
- Calls \`validateGoogleProfile\` to save/update the user and account data.
- Generates JWT token upon successful login.
- Sets an HTTP-only cookie with the JWT token.
- Returns JSON response containing success message, JWT token, and user profile.
- Fully documented with Swagger.

---

## 7. Types and Interfaces

- Defined \`AuthRequest\` interface extending Express \`Request\` to strongly type \`req.user\` with user properties (\`id\`, \`email\`, \`name\`, \`role\`).

---

## 8. Validation and Error Handling

- Used validation decorators (\`class-validator\`) to enforce DTO correctness.
- Throws explicit error if Google profile does not provide an email.

---

## 9. Future Considerations

- Implement session management and JWT refresh tokens.
- Extend OAuth support for additional providers (e.g., GitHub).
- Enhance error handling and logging.
- Consider updating additional user profile fields upon login if missing.

---

## Summary

This implementation enables robust, secure Google OAuth2 authentication with profile persistence and JWT issuance, using NestJS, PassportJS, and Prisma. API endpoints are well-documented with Swagger, enabling ease of use and integration in client applications.
`, bC = `#  \`src/pages/editor.tsx\`  **Editor Page**

The \`Editor\` page is the primary interface for file editing and terminal interaction in the application. It combines a file manager, code editor, and embedded terminal in a responsive, resizable layout.

---

##  **Components & Dependencies**

* **SolidJS**: Reactive UI framework used for state management and component lifecycles.
* **xterm**: Terminal emulation library.
* **Tailwind CSS**: Utility-first CSS framework.
* **Custom Components**:

  * \`EditorComponent\`: The main code editor (likely Monaco-based).
  * \`FileManager\`: Sidebar file tree and file selector.
  * \`GridResizer\`: UI component for resizing panels.
  * \`XTerminal\`: Terminal interface (replaced with \`TerminalDrawer\` in use).
  * \`Drawer\`: Generic drawer container.
  * \`TerminalDrawer\`: Configurable terminal drawer.
  * \`BottomDrawer\`: Example/alternative terminal drawer demo.

---

##  **Signals (Reactive State)**

### Editor

* \`filePath\`, \`fileContent\`: Track selected file and its content.
* \`isLoading\`: Controls loading indicator state.
* \`fileManagerWidth\`, \`containerWidth\`: Track dimensions for layout adjustment.
* \`left\`: Tracks horizontal split ratio between the FileManager and Editor.
* \`isTerminalOpen\`: Controls the visibility of the terminal drawer (toggle pending).

### TerminalDrawer (\`BottomDrawer\` Example)

* \`term\`: Active terminal instance.
* \`isDrawerOpen\`: Controls drawer visibility.
* \`position\`, \`size\`: Drawer configuration.
* \`cmd\`, \`cmdBuffer\`: Stores current user input and history.

---

##  **File Loading**

\`\`\`ts
const loadFile = async (path: string) => { ... }
\`\`\`

* Posts a form to \`/file/read\` using \`api\`.
* Sets \`filePath\` and updates \`fileContent\`.
* Handles errors with try/catch and \`showToast()\` feedback.
* Called on mount and when selecting a file from \`FileManager\`.

---

##  **Layout & Responsiveness**

* FileManager and Editor are laid out using \`flex\`.
* \`GridResizer\` allows dynamic resizing by dragging.
* \`left()\` determines the flex ratio (default \`32.5%\`).
* Responsive to changes in layout dimensions.

---

##  **Terminal Drawer**

* Configured using the \`<TerminalDrawer />\` component.
* Currently always rendered with fixed props:

  \`\`\`tsx
  <TerminalDrawer position="bottom" size="200px" fontSize="12" resizable={true} draggable={false} />
  \`\`\`
* Comments provide roadmap for enhancements (e.g., transitions, configurable styles, color schemes, and command interaction logic).

---

##  **Future Enhancements (TODOs)**

*  Terminal toggle button.
*  Dynamic position, size, and font configuration for terminal.
*  Smooth open/close animations.
*  Custom themes (background, text, input, error coloring).
*  Shell execution integration.
*  Drag/resizing improvements.
*  Overall user experience refinement for a full IDE-like interface.

---

##  **BottomDrawer Component**

A development/demo drawer component showing how to:

* Toggle drawer visibility.
* Hook into \`xterm\` terminal input.
* Manage input and command buffer.
* Render interactive shell output.

Though unused in the main \`Editor\` return tree, it provides a reference for interactive terminal UX patterns.

---

##  **Cleanup & Observers**

* \`onMount\` initializes file loading and widths.
* Resize event listener and \`ResizeObserver\` (commented out) are meant to auto-update layout metrics.
* \`onCleanup\` ensures event listeners are removed.

---

##  **Key UX Notes**

* The interface aims to replicate the experience of Visual Studio Code:

  * Sidebar (FileManager).
  * Central Editor.
  * Bottom Drawer (Terminal).
* Terminal is not open by default to avoid clutter.
* Flex layout enables adaptable screen usage for large or small devices.

---

##  **Exports**

* \`BottomDrawer\`: Exported but unused in main render.
* \`Editor\`: Default export representing the page itself.



`, yC = `# \`TTSForm\` Component

A fully interactive **Text-to-Speech (TTS)** generator form built with **SolidJS**. This component allows users to input prompts, select a language, configure multiple speakers with different voice profiles, and generate downloadable TTS audio using a backend service.

---

##  Features

* **Prompt input** for generating speech content
* **Multilingual support** via a wide range of predefined language codes
* **Dynamic speaker configuration** with customizable voice tones
* **TTS generation** through a RESTful API (\`/google-tts/generate\`)
* **Real-time playback** of generated audio
* **Audio download** capability for local storage

---

##  Props

This component does **not** accept props. It manages all state internally using \`createSignal\`.

---

##  Dependencies

* [\`solid-js\`](https://www.solidjs.com/)
* [\`@iconify-icon/solid\`](https://docs.iconify.design/icon-components/solid/)
* Local \`Button\` UI component
* Local \`api\` service wrapper for HTTP requests

---

##  Language Options

The form includes built-in support for over 20 languages and locales, such as:

* English (US, India)
* Hindi (India)
* Japanese (Japan)
* Arabic (Egyptian)
* French (France)
* ...and more

These are mapped via the \`languageOptions\` array.

---

##  Voice Options

The form offers a variety of voice profiles, each associated with a "tone" (e.g., \`Bright\`, \`Upbeat\`, \`Smooth\`, \`Informative\`). Users may select a predefined voice or enter a **Custom** voice name.

Voice definitions are stored in the \`voiceOptions\` array.

---

##  API Integration

### Endpoint

\`\`\`
POST /google-tts/generate
\`\`\`

### Request Payload

\`\`\`json
{
  "prompt": "Your text input",
  "languageCode": "en-US",
  "speakers": [
    { "speaker": "Eddie", "voiceName": "Kore" },
    { "speaker": "Marionette", "voiceName": "Puck" }
  ]
}
\`\`\`

### Response

* \`200 OK\`: Returns a binary audio stream (\`audio/wav\`)
* On success: Plays the audio and enables download
* On failure: Displays error message

---

##  State Signals

| Signal      | Type              | Purpose                                   |
| ----------- | ----------------- | ----------------------------------------- |
| \`prompt\`    | \`string\`          | Text prompt for TTS generation            |
| \`language\`  | \`string\`          | Language code (e.g., \`en-US\`)             |
| \`speakers\`  | \`SpeakerConfig[]\` | Dynamic speaker/voice pairs               |
| \`audioSrc\`  | \`string \\| null\`  | Object URL for audio playback             |
| \`audioBlob\` | \`Blob \\| null\`    | Raw binary audio for download             |
| \`loading\`   | \`boolean\`         | Controls button state and feedback        |
| \`error\`     | \`string\`          | Displays error message on request failure |

---

##  Component Structure

### Speaker Editor

* Allows multiple speaker inputs
* Supports voice selection or custom override
* Ability to dynamically add/remove speakers

### Submission & Feedback

* Submits via \`handleSubmit()\`
* Uses \`api.post\` to send the form data
* On success: renders \`<audio>\` player and download button
* On failure: displays inline error message

---

##  Example Usage

No props or configuration is required:

\`\`\`tsx
import TTSForm from './components/TTSForm';

function App() {
  return (
    <main>
      <TTSForm />
    </main>
  );
}
\`\`\`

---

##  TODOs / Enhancements

* Support for streaming audio response (WebSockets)
* Voice tone preview/sample playback
* Authentication integration
* Validation schema for speaker config


`, wC = `#  TTSForm Usage Guide

The \`TTSForm\` component is a SolidJS-powered interface for generating high-quality Text-to-Speech (TTS) audio. It enables users to input prompts, configure language and voice options, and retrieve downloadable audio in real-time.

---

##  Component Overview

\`\`\`tsx
import TTSForm from './components/TTSForm';

function App() {
  return (
    <main>
      <TTSForm />
    </main>
  );
}
\`\`\`

> **Note:** This component is **self-contained** and does not accept any props. All state is managed internally via SolidJS signals.

---

##  User Interface Sections

### 1. **Prompt Input**

* A \`textarea\` where users can input the text that should be converted into speech.
* Minimum height: \`160px\` for sufficient input space.

### 2. **Language Selector**

* A dropdown menu listing all supported languages/locales (e.g., \`en-US\`, \`hi-IN\`, \`fr-FR\`).
* Selecting a language ensures appropriate phonetics and voice compatibility.

### 3. **Speaker Configuration**

Each speaker entry includes:

* \`Speaker Name\`: A custom label (e.g., "Narrator", "Eddie", etc.).
* \`Voice Profile\`: Select from predefined tones (e.g., \`Bright\`, \`Informative\`, \`Smooth\`) or choose \`Custom\` to manually specify a voice.
* \`Custom Voice Input\`: When \`Custom\` is selected, an additional field appears for entering a raw voice name.
* \`Remove\` Button: Deletes a speaker block.
* \`+ Add Speaker\` Button: Adds a new speaker to the list.

### 4. **Generate Button**

* Sends the prompt, language, and speaker config to the backend API.
* Disables on loading to prevent duplicate submissions.

### 5. **Audio Output**

* If the request is successful, an HTML \`<audio>\` element appears for playback.
* A separate **Download** button becomes available to save the \`.wav\` file.

### 6. **Error Handling**

* Any errors during API submission will be displayed in red beneath the action buttons.

---

##  API Integration

### Endpoint

\`\`\`
POST /google-tts/generate
\`\`\`

### Payload Format

\`\`\`json
{
  "prompt": "Your text input",
  "languageCode": "en-US",
  "speakers": [
    { "speaker": "Alice", "voiceName": "BrightVoice" },
    { "speaker": "Bob", "voiceName": "CustomVoice" }
  ]
}
\`\`\`

### Response

* **Success**: Returns a binary audio stream (\`audio/wav\`)
* **Failure**: Returns a structured error with message

---

##  Example Workflow

1. Enter a prompt such as:
   \`"Welcome to our interactive tutorial!"\`

2. Choose a language like:
   \`English (United States)\`

3. Add speakers:

   * Speaker 1: \`Host\`, Voice: \`Bright\`
   * Speaker 2: \`Guest\`, Voice: \`Smooth\`

4. Click **Generate Audio**

5. After processing:

   * Use the **audio player** to preview the result
   * Click **Download Audio** to save the file locally

---

##  State Signals

| Signal      | Type              | Description                         |
| ----------- | ----------------- | ----------------------------------- |
| \`prompt\`    | \`string\`          | Text entered for conversion         |
| \`language\`  | \`string\`          | Selected locale code                |
| \`speakers\`  | \`SpeakerConfig[]\` | Array of speaker name & voice pairs |
| \`audioSrc\`  | \`string \\| null\`  | Object URL for audio playback       |
| \`audioBlob\` | \`Blob \\| null\`    | Raw audio blob for file download    |
| \`loading\`   | \`boolean\`         | Controls UI loading state           |
| \`error\`     | \`string\`          | Error message display               |

---

##  Dependencies

Ensure the following packages and components are available:

* \`solid-js\`
* \`@iconify-icon/solid\`
* Local \`Button\` UI component
* Local \`api.ts\` wrapper for RESTful requests

---

##  Tips & Best Practices

* Prefer predefined voices when available to ensure best quality.
* Use short, distinct speaker names for clarity in multi-speaker setups.
* Test different tones for variation (e.g., \`Bright\` vs. \`Calm\`).
* Use the same language for all speakers to avoid phonetic mismatches.

---

##  Planned Enhancements

| Feature                     | Status  |
| --------------------------- | ------- |
| WebSocket streaming         | Planned |
| Voice tone preview playback | Planned |
| Authenticated access        | Planned |
| Schema-based validation     | Planned |

---

##  File Structure (Reference)

\`\`\`
components/
   TTSForm.tsx
services/
   api.ts
\`\`\`

---

`, Qh = /* @__PURE__ */ Object.assign({
  "/src/docs/authentication/github-auth-integration.md": vC,
  "/src/docs/authentication/google-auth-Integration.md": _C,
  "/src/docs/editor-app.md": bC,
  "/src/docs/gemini-tts-implementation.md": yC,
  "/src/docs/text-to-speech-getting-started.md": wC
});
function U0() {
  return Object.keys(Qh).map((i) => {
    const e = i.match(/\/src\/docs\/(.+)\.md$/);
    return e ? (console.log(e[1], "slugMatch"), e[1]) : null;
  }).filter(Boolean);
}
function F3(i) {
  const e = Object.keys(Qh).find((t) => t.endsWith(`${i}.md`));
  return console.log(), e ? Qh[e] : null;
}
var xC = /* @__PURE__ */ H('<div class="p-6 max-w-3xl"><h1 class="text-2xl font-bold mb-4">Documentations</h1><ul class=space-y-2>'), kC = /* @__PURE__ */ H("<li>");
function CC() {
  const i = U0();
  return (() => {
    var e = xC(), t = e.firstChild, r = t.nextSibling;
    return X(r, Z(_t, {
      each: i,
      children: (s) => (() => {
        var n = kC();
        return X(n, Z(Nm, {
          href: `/docs/${s}`,
          class: "text-blue-600 hover:underline",
          children: s
        })), n;
      })()
    })), e;
  })();
}
var QC = /* @__PURE__ */ H('<div class="p-6 border rounded-lg hover:shadow-lg transition cursor-default "><h3 class="text-xl font-semibold mb-2"></h3><p class>');
const lt = (i) => (() => {
  var e = QC(), t = e.firstChild, r = t.nextSibling;
  return X(e, Z(ct, {
    get icon() {
      return i.icon;
    },
    width: "50",
    height: "50",
    class: "text-sky-500 shrink-0"
  }), t), X(t, () => i.title), X(r, () => i.description), e;
})();
var PC = /* @__PURE__ */ H('<section class="text-center py-16 px-4"><h1 class="text-4xl sm:text-5xl font-extrabold leading-tight mb-4"></h1><p class="text-lg sm:text-xl text-gray-700 dark:text-gray-400 mb-6"></p><div class="flex justify-center gap-4 flex-wrap">'), TC = /* @__PURE__ */ H('<div class=mb-8><p class="text-sky-600 dark:text-sky-400 text-lg font-medium"><span>Welcome, <!>!</span></p><p class="text-sm text-gray-600 dark:text-gray-400">Your projects are just a click away.');
const $C = (i) => {
  const e = () => !!i.user, t = (s) => s.showWhen === "authenticated" ? e() : s.showWhen === "unauthenticated" ? !e() : !0, r = (s) => {
    switch (s) {
      case "primary":
        return "rounded-md bg-sky-600 px-6 py-3 text-white font-semibold hover:bg-sky-700 transition";
      case "secondary":
        return "rounded-md bg-sky-500 px-6 py-3 text-gray-950 font-semibold hover:bg-sky-600 dark:hover:bg-gray-900 dark:hover:text-gray-200 transition";
      case "outline":
        return "rounded-md border border-sky-600 px-6 py-3 text-sky-600 font-semibold hover:bg-sky-100 dark:hover:bg-sky-500 transition";
      default:
        return "";
    }
  };
  return (() => {
    var s = PC(), n = s.firstChild, o = n.nextSibling, a = o.nextSibling;
    return X(n, () => i.heading), X(o, () => i.subheading), X(s, (() => {
      var l = bt(() => !!e());
      return () => l() && (() => {
        var c = TC(), h = c.firstChild, u = h.firstChild, d = u.firstChild, O = d.nextSibling;
        return O.nextSibling, X(u, () => i.user?.name ?? "Guest", O), c;
      })();
    })(), a), X(a, () => i.buttons?.filter(t).map((l) => Z(Nm, {
      get href() {
        return l.href;
      },
      get class() {
        return r(l.variant || "primary");
      },
      get children() {
        return l.label;
      }
    }))), s;
  })();
};
var RC = /* @__PURE__ */ H('<div class="flex flex-col "><main class="flex-1 px-6 py-12 md:px-12 lg:px-24"><section class="mt-16 max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></section><section class="mt-20 max-w-5xl mx-auto text-center"><h2 class="text-3xl font-bold mb-2">Powerful Editor Features</h2><p class="text-lg text-gray-600 dark:text-gray-400 mb-10">Designed to feel like a full IDE in the browser, our editor provides a seamless development experience  complete with file navigation, in-browser coding, and an integrated terminal.</p><div class="grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></div></section><section class="mt-24 mb-20 px-6 md:px-12 lg:px-24 text-center"><h2 class="text-4xl md:text-5xl font-extrabold tracking-tight mb-4">Build. Edit. Speak.</h2><p class="text-lg md:text-xl text-gray-600 dark:text-gray-400 mb-8 max-w-3xl mx-auto">From a powerful, resizable code editor to an intelligent text-to-speech engine, our platform gives you everything you need to create, communicate, and deploy content faster than ever.</p><div class="flex justify-center gap-4 flex-wrap"><a href=/editor class="bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-6 rounded-md transition">Launch Editor</a><a href=/tts class="border border-sky-600 text-sky-600 dark:text-sky-400 hover:bg-sky-50 dark:hover:bg-gray-800 font-semibold py-2 px-6 rounded-md transition">Try Text-to-Speech</a></div></section><section class="mt-20 max-w-5xl mx-auto text-center"><h2 class="text-3xl font-bold mb-2">Text-to-Speech Generator</h2><p class="text-lg text-gray-600 dark:text-gray-400 mb-10">Generate realistic speech from text with support for multiple languages and custom voice profiles. Perfect for narration, accessibility, and voice-driven applications.</p><div class="grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></div></section><section class="mt-20 max-w-3xl mx-auto"><h2 class="text-3xl font-bold text-center mb-8">What Our Users Say</h2><div class="relative border rounded-lg p-8 shadow-md"><blockquote class="italic mb-4">&ldquo;<!>&rdquo;</blockquote><p class="font-semibold text-sky-600 dark:text-sky-400"></p><p class=text-sm></p><div class="absolute bottom-2 right-4 flex space-x-2">'), EC = /* @__PURE__ */ H('<span class="text-blue-600 dark:text-sky-400 italic text-7xl">Project'), AC = /* @__PURE__ */ H("<span class=text-light>Board"), LC = /* @__PURE__ */ H("<button>");
const Ms = [{
  name: "Alice Johnson",
  title: "Product Manager",
  quote: "Project Board transformed how our team collaborates and delivered fantastic results!"
}, {
  name: "Mark Lee",
  title: "Software Engineer",
  quote: "The ease of use and customization saved us weeks of development time."
}, {
  name: "Sandra Kim",
  title: "CTO",
  quote: "Reliable and secure, its the backbone of our daily operations."
}], DC = [{
  name: "Basic",
  price: "$9/mo",
  features: ["Up to 5 projects", "Basic support", "Community access"]
}, {
  name: "Pro",
  price: "$29/mo",
  features: ["Unlimited projects", "Priority support", "Advanced analytics"]
}, {
  name: "Enterprise",
  price: "Contact us",
  features: ["Custom solutions", "Dedicated support", "Onboarding assistance"]
}];
function MC() {
  const {
    user: i,
    isAuthenticated: e
  } = to(), [t, r] = se(0), [s, n] = se(DC[0].name);
  return Yn(() => {
    const o = setInterval(() => {
      r((a) => (a + 1) % Ms.length);
    }, 7e3);
    ft(() => clearInterval(o));
  }), (() => {
    var o = RC(), a = o.firstChild, l = a.firstChild, c = l.nextSibling, h = c.firstChild, u = h.nextSibling, d = u.nextSibling, O = c.nextSibling, v = O.nextSibling, S = v.firstChild, f = S.nextSibling, p = f.nextSibling, g = v.nextSibling, m = g.firstChild, _ = m.nextSibling, b = _.firstChild, w = b.firstChild, x = w.nextSibling;
    x.nextSibling;
    var y = b.nextSibling, k = y.nextSibling, $ = k.nextSibling;
    return X(a, Z($C, {
      get user() {
        return bt(() => !!e())() ? {
          name: i()?.name
        } : null;
      },
      get heading() {
        return ["Welcome to ", EC(), " ", AC()];
      },
      subheading: "The best solution to manage your projects efficiently and effortlessly.",
      buttons: [{
        label: "Go to Dashboard",
        href: "/dashboard",
        variant: "primary",
        showWhen: "authenticated"
      }, {
        label: "Get Started",
        href: "/dashboard",
        variant: "secondary",
        showWhen: "unauthenticated"
      }, {
        label: "Learn More",
        href: "/editor",
        variant: "outline",
        showWhen: "always"
      }]
    }), l), X(l, Z(lt, {
      icon: "mdi:hand-okay",
      title: "Easy to Use",
      description: "Intuitive UI that helps you get started quickly without any hassle."
    }), null), X(l, Z(lt, {
      icon: "mdi:secure",
      title: "Secure & Reliable",
      description: "Your data is protected with industry-leading security measures."
    }), null), X(l, Z(lt, {
      icon: "mdi:focus-field",
      title: "Customizable",
      description: "Tailor the platform to your specific needs with flexible options."
    }), null), X(d, Z(lt, {
      icon: "mdi:file-code-outline",
      title: "Integrated Code Editor",
      description: "Edit your files with a fast, Monaco-based editor tailored for developers."
    }), null), X(d, Z(lt, {
      icon: "mdi:file-tree",
      title: "File Manager",
      description: "Navigate your project structure easily with a dynamic file explorer."
    }), null), X(d, Z(lt, {
      icon: "mdi:resize",
      title: "Resizable Panels",
      description: "Adjust the editor and sidebar layout with flexible drag-to-resize functionality."
    }), null), X(d, Z(lt, {
      icon: "mdi:console",
      title: "Embedded Terminal",
      description: "Run commands and interact with your environment directly in the terminal drawer."
    }), null), X(d, Z(lt, {
      icon: "mdi:theme-light-dark",
      title: "Theme & UX Enhancements",
      description: "Customizable themes, smooth transitions, and IDE-like experience."
    }), null), X(d, Z(lt, {
      icon: "mdi:update",
      title: "Live Layout Updates",
      description: "Responsive design with real-time layout adjustment support."
    }), null), X(p, Z(lt, {
      icon: "mdi:text-to-speech",
      title: "Multilingual Input",
      description: "Supports over 20 languages and regional accents using standardized language codes."
    }), null), X(p, Z(lt, {
      icon: "mdi:account-voice",
      title: "Custom Voice Profiles",
      description: "Define multiple speakers with distinct voices and tones like Bright, Smooth, or Informative."
    }), null), X(p, Z(lt, {
      icon: "mdi:music-note",
      title: "Real-Time Playback",
      description: "Instantly listen to generated speech and download high-quality audio files."
    }), null), X(p, Z(lt, {
      icon: "mdi:form-textbox",
      title: "Interactive Form",
      description: "Dynamic speaker fields, inline validation, and easy-to-use controls built with SolidJS."
    }), null), X(p, Z(lt, {
      icon: "mdi:api",
      title: "API Powered",
      description: "Backed by a robust REST API for reliable, scalable TTS generation and playback."
    }), null), X(p, Z(lt, {
      icon: "mdi:progress-clock",
      title: "Future Enhancements",
      description: "Plans include WebSocket streaming, sample previews, and enhanced customization."
    }), null), X(b, () => Ms[t()].quote, x), X(y, () => Ms[t()].name), X(k, () => Ms[t()].title), X($, () => Ms.map((R, T) => (() => {
      var A = LC();
      return A.$$click = () => r(T), Ae(A, "aria-label", `Show testimonial ${T + 1}`), Oe(() => Vt(A, `w-3 h-3 rounded-full transition-colors ${t() === T ? "bg-sky-600 dark:bg-sky-400" : "bg-gray-400 dark:bg-gray-600"}`)), A;
    })())), o;
  })();
}
dt(["click"]);
var BC = /* @__PURE__ */ H('<div class="rounded-2xl px-4 py-8 shadow-md flex items-center space-x-4 border"><div class="flex flex-col"><span class=text-lg></span><span class="text-4xl font-semibold">');
const qC = (i) => (() => {
  var e = BC(), t = e.firstChild, r = t.firstChild, s = r.nextSibling;
  return X(e, Z(ct, {
    get icon() {
      return i.icon;
    },
    width: "50",
    height: "50",
    class: "text-sky-500 shrink-0"
  }), t), X(r, () => i.label), X(s, () => i.value), e;
})();
var XC = /* @__PURE__ */ H('<div class="flex flex-col max-w-7xl mx-auto"><div class="flex-1 scroll-smooth px-4 py-4 space-y-4 mt-2 mb-6"><h1 class="leading-0 uppercase tracking-widest text-2xl mt-6 mb-10 px-4"><b>Dash</b>board</h1><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 px-4 mt-4"></div><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 px-4 mt-4"></div><div class="grid grid-cols-1 px-4 mt-4"><h2 class="leading-0 uppercase tracking-widest text-xl mt-6 mb-10 "><b>App</b>lications</h2><div class="flex space-x-6"><button class="flex flex-col items-center justify-center p-4 rounded-2xl border dark:border-gray-900 shadow-md w-32 hover:bg-gray-700 hover:text-white transition"aria-label="Open Editor">Editor</button><button class="flex flex-col items-center justify-center p-4 rounded-2xl border dark:border-gray-900 shadow-md w-32 hover:bg-gray-700 hover:text-white transition"aria-label="Open Text To Speech">TTS</button><button class="flex flex-col items-center justify-center border dark:border-gray-900 p-4 rounded-2xl shadow-md w-32 hover:bg-gray-700 hover:text-white transition"aria-label="Open Terminal">Terminal'), IC = /* @__PURE__ */ H('<div class="rounded-xl border dark:border-gray-900 p-4 mt-2 shadow-sm"><div class="flex justify-between items-center mb-2"><h2 class="font-semibold text-xl text-sky-500"></h2><span class="text-xs text-muted"></span></div><p class>');
function ZC() {
  const [i] = se([{
    label: "Users Online",
    value: 23,
    icon: "mdi:account"
  }, {
    label: "Server Load",
    value: "47%",
    icon: "mdi:server"
  }, {
    label: "Active Jobs",
    value: 12,
    icon: "tabler:briefcase"
  }, {
    label: "Errors Today",
    value: 0,
    icon: "ic:baseline-error-outline"
  }]), [e] = se([{
    id: 1,
    title: "System Status",
    content: "All systems operational.",
    timestamp: "2025-05-30 09:00"
  }, {
    id: 2,
    title: "User Activity",
    content: "15 users logged in within the last hour.",
    timestamp: "2025-05-30 08:45"
  }, {
    id: 3,
    title: "Error Logs",
    content: "0 critical errors reported today.",
    timestamp: "2025-05-30 08:30"
  }]);
  return (() => {
    var t = XC(), r = t.firstChild, s = r.firstChild, n = s.nextSibling, o = n.nextSibling, a = o.nextSibling, l = a.firstChild, c = l.nextSibling, h = c.firstChild, u = h.firstChild, d = h.nextSibling, O = d.firstChild, v = d.nextSibling, S = v.firstChild;
    return X(n, Z(_t, {
      get each() {
        return i();
      },
      children: (f) => Z(qC, f)
    })), X(o, Z(_t, {
      get each() {
        return e();
      },
      children: (f) => (() => {
        var p = IC(), g = p.firstChild, m = g.firstChild, _ = m.nextSibling, b = g.nextSibling;
        return X(m, () => f.title), X(_, () => f.timestamp), X(b, () => f.content), p;
      })()
    })), h.$$click = () => window.location.href = "/editor", X(h, Z(ct, {
      icon: "mdi:xml",
      width: "50",
      height: "50",
      class: "text-sky-500 shrink-0"
    }), u), d.$$click = () => window.location.href = "/tts", X(d, Z(ct, {
      icon: "mdi:microphone-message",
      width: "50",
      height: "50",
      class: "text-sky-500 shrink-0"
    }), O), v.$$click = () => window.location.href = "/terminal", X(v, Z(ct, {
      icon: "mdi:console",
      width: "50",
      height: "50",
      class: "text-sky-500 shrink-0"
    }), S), t;
  })();
}
dt(["click"]);
let Ph = [], j0 = [];
(() => {
  let i = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < i.length; e++)
    (e % 2 ? j0 : Ph).push(t = t + i[e]);
})();
function WC(i) {
  if (i < 768) return !1;
  for (let e = 0, t = Ph.length; ; ) {
    let r = e + t >> 1;
    if (i < Ph[r]) t = r;
    else if (i >= j0[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function lO(i) {
  return i >= 127462 && i <= 127487;
}
const cO = 8205;
function zC(i, e, t = !0, r = !0) {
  return (t ? N0 : VC)(i, e, r);
}
function N0(i, e, t) {
  if (e == i.length) return e;
  e && Y0(i.charCodeAt(e)) && F0(i.charCodeAt(e - 1)) && e--;
  let r = rc(i, e);
  for (e += hO(r); e < i.length; ) {
    let s = rc(i, e);
    if (r == cO || s == cO || t && WC(s))
      e += hO(s), r = s;
    else if (lO(s)) {
      let n = 0, o = e - 2;
      for (; o >= 0 && lO(rc(i, o)); )
        n++, o -= 2;
      if (n % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function VC(i, e, t) {
  for (; e > 0; ) {
    let r = N0(i, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function rc(i, e) {
  let t = i.charCodeAt(e);
  if (!F0(t) || e + 1 == i.length) return t;
  let r = i.charCodeAt(e + 1);
  return Y0(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function Y0(i) {
  return i >= 56320 && i < 57344;
}
function F0(i) {
  return i >= 55296 && i < 56320;
}
function hO(i) {
  return i < 65536 ? 1 : 2;
}
class _e {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = hs(this, e, t);
    let s = [];
    return this.decompose(
      0,
      e,
      s,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      s,
      1
      /* Open.From */
    ), ci.from(s, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = hs(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), ci.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), s = new rn(this), n = new rn(e);
    for (let o = t, a = t; ; ) {
      if (s.next(o), n.next(o), o = 0, s.lineBreak != n.lineBreak || s.done != n.done || s.value != n.value)
        return !1;
      if (a += s.value.length, s.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new rn(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new H0(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let s = this.line(e).from;
      r = this.iterRange(s, Math.max(s, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new G0(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? _e.empty : e.length <= 32 ? new Xe(e) : ci.from(Xe.split(e, []));
  }
}
class Xe extends _e {
  constructor(e, t = UC(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, s) {
    for (let n = 0; ; n++) {
      let o = this.text[n], a = s + o.length;
      if ((t ? r : a) >= e)
        return new jC(s, a, r, o);
      s = a + 1, r++;
    }
  }
  decompose(e, t, r, s) {
    let n = e <= 0 && t >= this.length ? this : new Xe(uO(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (s & 1) {
      let o = r.pop(), a = ia(n.text, o.text.slice(), 0, n.length);
      if (a.length <= 32)
        r.push(new Xe(a, o.length + n.length));
      else {
        let l = a.length >> 1;
        r.push(new Xe(a.slice(0, l)), new Xe(a.slice(l)));
      }
    } else
      r.push(n);
  }
  replace(e, t, r) {
    if (!(r instanceof Xe))
      return super.replace(e, t, r);
    [e, t] = hs(this, e, t);
    let s = ia(this.text, ia(r.text, uO(this.text, 0, e)), t), n = this.length + r.length - (t - e);
    return s.length <= 32 ? new Xe(s, n) : ci.from(Xe.split(s, []), n);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = hs(this, e, t);
    let s = "";
    for (let n = 0, o = 0; n <= t && o < this.text.length; o++) {
      let a = this.text[o], l = n + a.length;
      n > e && o && (s += r), e < l && t > n && (s += a.slice(Math.max(0, e - n), t - n)), n = l + 1;
    }
    return s;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], s = -1;
    for (let n of e)
      r.push(n), s += n.length + 1, r.length == 32 && (t.push(new Xe(r, s)), r = [], s = -1);
    return s > -1 && t.push(new Xe(r, s)), t;
  }
}
class ci extends _e {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, s) {
    for (let n = 0; ; n++) {
      let o = this.children[n], a = s + o.length, l = r + o.lines - 1;
      if ((t ? l : a) >= e)
        return o.lineInner(e, t, r, s);
      s = a + 1, r = l + 1;
    }
  }
  decompose(e, t, r, s) {
    for (let n = 0, o = 0; o <= t && n < this.children.length; n++) {
      let a = this.children[n], l = o + a.length;
      if (e <= l && t >= o) {
        let c = s & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !c ? r.push(a) : a.decompose(e - o, t - o, r, c);
      }
      o = l + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = hs(this, e, t), r.lines < this.lines)
      for (let s = 0, n = 0; s < this.children.length; s++) {
        let o = this.children[s], a = n + o.length;
        if (e >= n && t <= a) {
          let l = o.replace(e - n, t - n, r), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let h = this.children.slice();
            return h[s] = l, new ci(h, this.length - (t - e) + r.length);
          }
          return super.replace(n, a, l);
        }
        n = a + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = hs(this, e, t);
    let s = "";
    for (let n = 0, o = 0; n < this.children.length && o <= t; n++) {
      let a = this.children[n], l = o + a.length;
      o > e && n && (s += r), e < l && t > o && (s += a.sliceString(e - o, t - o, r)), o = l + 1;
    }
    return s;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof ci))
      return 0;
    let r = 0, [s, n, o, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; s += t, n += t) {
      if (s == o || n == a)
        return r;
      let l = this.children[s], c = e.children[n];
      if (l != c)
        return r + l.scanIdentical(c, t);
      r += l.length + 1;
    }
  }
  static from(e, t = e.reduce((r, s) => r + s.length + 1, -1)) {
    let r = 0;
    for (let O of e)
      r += O.lines;
    if (r < 32) {
      let O = [];
      for (let v of e)
        v.flatten(O);
      return new Xe(O, t);
    }
    let s = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), n = s << 1, o = s >> 1, a = [], l = 0, c = -1, h = [];
    function u(O) {
      let v;
      if (O.lines > n && O instanceof ci)
        for (let S of O.children)
          u(S);
      else O.lines > o && (l > o || !l) ? (d(), a.push(O)) : O instanceof Xe && l && (v = h[h.length - 1]) instanceof Xe && O.lines + v.lines <= 32 ? (l += O.lines, c += O.length + 1, h[h.length - 1] = new Xe(v.text.concat(O.text), v.length + 1 + O.length)) : (l + O.lines > s && d(), l += O.lines, c += O.length + 1, h.push(O));
    }
    function d() {
      l != 0 && (a.push(h.length == 1 ? h[0] : ci.from(h, c)), c = -1, l = h.length = 0);
    }
    for (let O of e)
      u(O);
    return d(), a.length == 1 ? a[0] : new ci(a, t);
  }
}
_e.empty = /* @__PURE__ */ new Xe([""], 0);
function UC(i) {
  let e = -1;
  for (let t of i)
    e += t.length + 1;
  return e;
}
function ia(i, e, t = 0, r = 1e9) {
  for (let s = 0, n = 0, o = !0; n < i.length && s <= r; n++) {
    let a = i[n], l = s + a.length;
    l >= t && (l > r && (a = a.slice(0, r - s)), s < t && (a = a.slice(t - s)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), s = l + 1;
  }
  return e;
}
function uO(i, e, t) {
  return ia(i, [""], e, t);
}
class rn {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof Xe ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, s = this.nodes[r], n = this.offsets[r], o = n >> 1, a = s instanceof Xe ? s.text.length : s.children.length;
      if (o == (t > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (s instanceof Xe) {
        let l = s.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = s.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof Xe ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class H0 {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new rn(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: s } = this.cursor.next(e);
    return this.pos += (s.length + e) * t, this.value = s.length <= r ? s : t < 0 ? s.slice(s.length - r) : s.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class G0 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: s } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (_e.prototype[Symbol.iterator] = function() {
  return this.iter();
}, rn.prototype[Symbol.iterator] = H0.prototype[Symbol.iterator] = G0.prototype[Symbol.iterator] = function() {
  return this;
});
let jC = class {
  /**
  @internal
  */
  constructor(e, t, r, s) {
    this.from = e, this.to = t, this.number = r, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function hs(i, e, t) {
  return e = Math.max(0, Math.min(i.length, e)), [e, Math.max(e, Math.min(i.length, t))];
}
function Je(i, e, t = !0, r = !0) {
  return zC(i, e, t, r);
}
function NC(i) {
  return i >= 56320 && i < 57344;
}
function YC(i) {
  return i >= 55296 && i < 56320;
}
function pt(i, e) {
  let t = i.charCodeAt(e);
  if (!YC(t) || e + 1 == i.length)
    return t;
  let r = i.charCodeAt(e + 1);
  return NC(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function df(i) {
  return i <= 65535 ? String.fromCharCode(i) : (i -= 65536, String.fromCharCode((i >> 10) + 55296, (i & 1023) + 56320));
}
function hi(i) {
  return i < 65536 ? 1 : 2;
}
const Th = /\r\n?|\n/;
var Ke = /* @__PURE__ */ function(i) {
  return i[i.Simple = 0] = "Simple", i[i.TrackDel = 1] = "TrackDel", i[i.TrackBefore = 2] = "TrackBefore", i[i.TrackAfter = 3] = "TrackAfter", i;
}(Ke || (Ke = {}));
class pi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, s = 0; t < this.sections.length; ) {
      let n = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, s, n), s += n) : s += o, r += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    $h(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], s = this.sections[t++];
      s < 0 ? e.push(r, s) : e.push(s, r);
    }
    return new pi(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : K0(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : Rh(this, e, t);
  }
  mapPos(e, t = -1, r = Ke.Simple) {
    let s = 0, n = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = s + a;
      if (l < 0) {
        if (c > e)
          return n + (e - s);
        n += a;
      } else {
        if (r != Ke.Simple && c >= e && (r == Ke.TrackDel && s < e && c > e || r == Ke.TrackBefore && s < e || r == Ke.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !a)
          return e == s || t < 0 ? n : n + l;
        n += l;
      }
      s = c;
    }
    if (e > s)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${s}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, s = 0; r < this.sections.length && s <= t; ) {
      let n = this.sections[r++], o = this.sections[r++], a = s + n;
      if (o >= 0 && s <= t && a >= e)
        return s < e && a > t ? "cover" : !0;
      s = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], s = this.sections[t++];
      e += (e ? " " : "") + r + (s >= 0 ? ":" + s : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new pi(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new pi(e);
  }
}
class Ue extends pi {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return $h(this, (t, r, s, n, o) => e = e.replace(s, s + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return Rh(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let s = 0, n = 0; s < t.length; s += 2) {
      let o = t[s], a = t[s + 1];
      if (a >= 0) {
        t[s] = a, t[s + 1] = o;
        let l = s >> 1;
        for (; r.length < l; )
          r.push(_e.empty);
        r.push(o ? e.slice(n, n + o) : _e.empty);
      }
      n += o;
    }
    return new Ue(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : K0(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : Rh(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    $h(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return pi.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], s = [], n = new yn(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || a == l && n.len == 0; ) {
        if (n.done)
          break e;
        let h = Math.min(n.len, l - a);
        tt(s, h, -1);
        let u = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
        tt(t, h, u), u > 0 && Hi(r, t, n.text), n.forward(h), a += h;
      }
      let c = e[o++];
      for (; a < c; ) {
        if (n.done)
          break e;
        let h = Math.min(n.len, c - a);
        tt(t, h, -1), tt(s, h, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(h), a += h;
      }
    }
    return {
      changes: new Ue(t, r),
      filtered: pi.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], s = this.sections[t + 1];
      s < 0 ? e.push(r) : s == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let s = [], n = [], o = 0, a = null;
    function l(h = !1) {
      if (!h && !s.length)
        return;
      o < t && tt(s, t - o, -1);
      let u = new Ue(s, n);
      a = a ? a.compose(u.map(a)) : u, s = [], n = [], o = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let u of h)
          c(u);
      else if (h instanceof Ue) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), a = a ? a.compose(h.map(a)) : h;
      } else {
        let { from: u, to: d = u, insert: O } = h;
        if (u > d || u < 0 || d > t)
          throw new RangeError(`Invalid change range ${u} to ${d} (in doc of length ${t})`);
        let v = O ? typeof O == "string" ? _e.of(O.split(r || Th)) : O : _e.empty, S = v.length;
        if (u == d && S == 0)
          return;
        u < o && l(), u > o && tt(s, u - o, -1), tt(s, d - u, S), Hi(n, s, v), o = d;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Ue(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let s = 0; s < e.length; s++) {
      let n = e[s];
      if (typeof n == "number")
        t.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          t.push(n[0], 0);
        else {
          for (; r.length < s; )
            r.push(_e.empty);
          r[s] = _e.of(n.slice(1)), t.push(n[0], r[s].length);
        }
      }
    }
    return new Ue(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Ue(e, t);
  }
}
function tt(i, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let s = i.length - 2;
  s >= 0 && t <= 0 && t == i[s + 1] ? i[s] += e : s >= 0 && e == 0 && i[s] == 0 ? i[s + 1] += t : r ? (i[s] += e, i[s + 1] += t) : i.push(e, t);
}
function Hi(i, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < i.length)
    i[i.length - 1] = i[i.length - 1].append(t);
  else {
    for (; i.length < r; )
      i.push(_e.empty);
    i.push(t);
  }
}
function $h(i, e, t) {
  let r = i.inserted;
  for (let s = 0, n = 0, o = 0; o < i.sections.length; ) {
    let a = i.sections[o++], l = i.sections[o++];
    if (l < 0)
      s += a, n += a;
    else {
      let c = s, h = n, u = _e.empty;
      for (; c += a, h += l, l && r && (u = u.append(r[o - 2 >> 1])), !(t || o == i.sections.length || i.sections[o + 1] < 0); )
        a = i.sections[o++], l = i.sections[o++];
      e(s, c, n, h, u), s = c, n = h;
    }
  }
}
function Rh(i, e, t, r = !1) {
  let s = [], n = r ? [] : null, o = new yn(i), a = new yn(e);
  for (let l = -1; ; ) {
    if (o.done && a.len || a.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      tt(s, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !t))) {
      let c = a.len;
      for (tt(s, a.ins, -1); c; ) {
        let h = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= h && (tt(s, 0, o.ins), n && Hi(n, s, o.text), l = o.i), o.forward(h), c -= h;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, h = o.len;
      for (; h; )
        if (a.ins == -1) {
          let u = Math.min(h, a.len);
          c += u, h -= u, a.forward(u);
        } else if (a.ins == 0 && a.len < h)
          h -= a.len, a.next();
        else
          break;
      tt(s, c, l < o.i ? o.ins : 0), n && l < o.i && Hi(n, s, o.text), l = o.i, o.forward(o.len - h);
    } else {
      if (o.done && a.done)
        return n ? Ue.createSet(s, n) : pi.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function K0(i, e, t = !1) {
  let r = [], s = t ? [] : null, n = new yn(i), o = new yn(e);
  for (let a = !1; ; ) {
    if (n.done && o.done)
      return s ? Ue.createSet(r, s) : pi.create(r);
    if (n.ins == 0)
      tt(r, n.len, 0, a), n.next();
    else if (o.len == 0 && !o.done)
      tt(r, 0, o.ins, a), s && Hi(s, r, o.text), o.next();
    else {
      if (n.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(n.len2, o.len), c = r.length;
        if (n.ins == -1) {
          let h = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          tt(r, l, h, a), s && h && Hi(s, r, o.text);
        } else o.ins == -1 ? (tt(r, n.off ? 0 : n.len, l, a), s && Hi(s, r, n.textBit(l))) : (tt(r, n.off ? 0 : n.len, o.off ? 0 : o.ins, a), s && !o.off && Hi(s, r, o.text));
        a = (n.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > c), n.forward2(l), o.forward(l);
      }
    }
  }
}
class yn {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? _e.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? _e.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class _r {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, s;
    return this.empty ? r = s = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), s = e.mapPos(this.to, -1)), r == this.from && s == this.to ? this : new _r(r, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return V.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return V.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return V.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new _r(e, t, r);
  }
}
class V {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : V.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new V([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return V.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, V.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new V(e.ranges.map((t) => _r.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new V([V.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, s = 0; s < e.length; s++) {
      let n = e[s];
      if (n.empty ? n.from <= r : n.from < r)
        return V.normalized(e.slice(), t);
      r = n.to;
    }
    return new V(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, s) {
    return _r.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, s) {
    let n = (r ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return t < e ? _r.create(t, e, 48 | n) : _r.create(e, t, (t > e ? 8 : 0) | n);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((s, n) => s.from - n.from), t = e.indexOf(r);
    for (let s = 1; s < e.length; s++) {
      let n = e[s], o = e[s - 1];
      if (n.empty ? n.from <= o.to : n.from < o.to) {
        let a = o.from, l = Math.max(n.to, o.to);
        s <= t && t--, e.splice(--s, 2, n.anchor > n.head ? V.range(l, a) : V.range(a, l));
      }
    }
    return new V(e, t);
  }
}
function J0(i, e) {
  for (let t of i.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Of = 0;
class ee {
  constructor(e, t, r, s, n) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = s, this.id = Of++, this.default = e([]), this.extensions = typeof n == "function" ? n(this) : n;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ee(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : pf), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new ra([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new ra(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new ra(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function pf(i, e) {
  return i == e || i.length == e.length && i.every((t, r) => t === e[r]);
}
class ra {
  constructor(e, t, r, s) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = s, this.id = Of++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, s = this.facet.compareInput, n = this.id, o = e[n] >> 1, a = this.type == 2, l = !1, c = !1, h = [];
    for (let u of this.dependencies)
      u == "doc" ? l = !0 : u == "selection" ? c = !0 : (((t = e[u.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && h.push(e[u.id]);
    return {
      create(u) {
        return u.values[o] = r(u), 1;
      },
      update(u, d) {
        if (l && d.docChanged || c && (d.docChanged || d.selection) || Eh(u, h)) {
          let O = r(u);
          if (a ? !fO(O, u.values[o], s) : !s(O, u.values[o]))
            return u.values[o] = O, 1;
        }
        return 0;
      },
      reconfigure: (u, d) => {
        let O, v = d.config.address[n];
        if (v != null) {
          let S = Ma(d, v);
          if (this.dependencies.every((f) => f instanceof ee ? d.facet(f) === u.facet(f) : f instanceof Ye ? d.field(f, !1) == u.field(f, !1) : !0) || (a ? fO(O = r(u), S, s) : s(O = r(u), S)))
            return u.values[o] = S, 0;
        } else
          O = r(u);
        return u.values[o] = O, 1;
      }
    };
  }
}
function fO(i, e, t) {
  if (i.length != e.length)
    return !1;
  for (let r = 0; r < i.length; r++)
    if (!t(i[r], e[r]))
      return !1;
  return !0;
}
function Eh(i, e) {
  let t = !1;
  for (let r of e)
    sn(i, r) & 1 && (t = !0);
  return t;
}
function FC(i, e, t) {
  let r = t.map((l) => i[l.id]), s = t.map((l) => l.type), n = r.filter((l) => !(l & 1)), o = i[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let h = 0; h < r.length; h++) {
      let u = Ma(l, r[h]);
      if (s[h] == 2)
        for (let d of u)
          c.push(d);
      else
        c.push(u);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of r)
        sn(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!Eh(l, n))
        return 0;
      let h = a(l);
      return e.compare(h, l.values[o]) ? 0 : (l.values[o] = h, 1);
    },
    reconfigure(l, c) {
      let h = Eh(l, r), u = c.config.facets[e.id], d = c.facet(e);
      if (u && !h && pf(t, u))
        return l.values[o] = d, 0;
      let O = a(l);
      return e.compare(O, d) ? (l.values[o] = d, 0) : (l.values[o] = O, 1);
    }
  };
}
const bo = /* @__PURE__ */ ee.define({ static: !0 });
class Ye {
  constructor(e, t, r, s, n) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = s, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Ye(Of++, e.create, e.update, e.compare || ((r, s) => r === s), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(bo).find((r) => r.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, s) => {
        let n = r.values[t], o = this.updateF(n, s);
        return this.compareF(n, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, s) => {
        let n = r.facet(bo), o = s.facet(bo), a;
        return (a = n.find((l) => l.field == this)) && a != o.find((l) => l.field == this) ? (r.values[t] = a.create(r), 1) : s.config.address[this.id] != null ? (r.values[t] = s.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, bo.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const gr = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Bs(i) {
  return (e) => new eS(e, i);
}
const Zi = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Bs(gr.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Bs(gr.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Bs(gr.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Bs(gr.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Bs(gr.lowest)
};
class eS {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class kl {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Ah(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return kl.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Ah {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Da {
  constructor(e, t, r, s, n, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = s, this.staticValues = n, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let s = [], n = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let d of HC(e, t, o))
      d instanceof Ye ? s.push(d) : (n[d.facet.id] || (n[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let d of s)
      a[d.id] = c.length << 1, c.push((O) => d.slot(O));
    let h = r?.config.facets;
    for (let d in n) {
      let O = n[d], v = O[0].facet, S = h && h[d] || [];
      if (O.every(
        (f) => f.type == 0
        /* Provider.Static */
      ))
        if (a[v.id] = l.length << 1 | 1, pf(S, O))
          l.push(r.facet(v));
        else {
          let f = v.combine(O.map((p) => p.value));
          l.push(r && v.compare(f, r.facet(v)) ? r.facet(v) : f);
        }
      else {
        for (let f of O)
          f.type == 0 ? (a[f.id] = l.length << 1 | 1, l.push(f.value)) : (a[f.id] = c.length << 1, c.push((p) => f.dynamicSlot(p)));
        a[v.id] = c.length << 1, c.push((f) => FC(f, v, O));
      }
    }
    let u = c.map((d) => d(a));
    return new Da(e, o, u, a, l, n);
  }
}
function HC(i, e, t) {
  let r = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function n(o, a) {
    let l = s.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = r[l].indexOf(o);
      c > -1 && r[l].splice(c, 1), o instanceof Ah && t.delete(o.compartment);
    }
    if (s.set(o, a), Array.isArray(o))
      for (let c of o)
        n(c, a);
    else if (o instanceof Ah) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), n(c, a);
    } else if (o instanceof eS)
      n(o.inner, o.prec);
    else if (o instanceof Ye)
      r[a].push(o), o.provides && n(o.provides, a);
    else if (o instanceof ra)
      r[a].push(o), o.facet.extensions && n(o.facet.extensions, gr.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(c, a);
    }
  }
  return n(i, gr.default), r.reduce((o, a) => o.concat(a));
}
function sn(i, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = i.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  i.status[t] = 4;
  let s = i.computeSlot(i, i.config.dynamicSlots[t]);
  return i.status[t] = 2 | s;
}
function Ma(i, e) {
  return e & 1 ? i.config.staticValues[e >> 1] : i.values[e >> 1];
}
const tS = /* @__PURE__ */ ee.define(), Lh = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e),
  static: !0
}), iS = /* @__PURE__ */ ee.define({
  combine: (i) => i.length ? i[0] : void 0,
  static: !0
}), rS = /* @__PURE__ */ ee.define(), sS = /* @__PURE__ */ ee.define(), nS = /* @__PURE__ */ ee.define(), oS = /* @__PURE__ */ ee.define({
  combine: (i) => i.length ? i[0] : !1
});
class Wi {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new GC();
  }
}
class GC {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Wi(this, e);
  }
}
class KC {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new he(this, e);
  }
}
class he {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new he(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new KC(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let s of e) {
      let n = s.map(t);
      n && r.push(n);
    }
    return r;
  }
}
he.reconfigure = /* @__PURE__ */ he.define();
he.appendConfig = /* @__PURE__ */ he.define();
class We {
  constructor(e, t, r, s, n, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = s, this.annotations = n, this.scrollIntoView = o, this._doc = null, this._state = null, r && J0(r, t.newLength), n.some((a) => a.type == We.time) || (this.annotations = n.concat(We.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, s, n, o) {
    return new We(e, t, r, s, n, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(We.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
We.time = /* @__PURE__ */ Wi.define();
We.userEvent = /* @__PURE__ */ Wi.define();
We.addToHistory = /* @__PURE__ */ Wi.define();
We.remote = /* @__PURE__ */ Wi.define();
function JC(i, e) {
  let t = [];
  for (let r = 0, s = 0; ; ) {
    let n, o;
    if (r < i.length && (s == e.length || e[s] >= i[r]))
      n = i[r++], o = i[r++];
    else if (s < e.length)
      n = e[s++], o = e[s++];
    else
      return t;
    !t.length || t[t.length - 1] < n ? t.push(n, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function aS(i, e, t) {
  var r;
  let s, n, o;
  return t ? (s = e.changes, n = Ue.empty(e.changes.length), o = i.changes.compose(e.changes)) : (s = e.changes.map(i.changes), n = i.changes.mapDesc(e.changes, !0), o = i.changes.compose(s)), {
    changes: o,
    selection: e.selection ? e.selection.map(n) : (r = i.selection) === null || r === void 0 ? void 0 : r.map(s),
    effects: he.mapEffects(i.effects, s).concat(he.mapEffects(e.effects, n)),
    annotations: i.annotations.length ? i.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: i.scrollIntoView || e.scrollIntoView
  };
}
function Dh(i, e, t) {
  let r = e.selection, s = es(e.annotations);
  return e.userEvent && (s = s.concat(We.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Ue ? e.changes : Ue.of(e.changes || [], t, i.facet(iS)),
    selection: r && (r instanceof V ? r : V.single(r.anchor, r.head)),
    effects: es(e.effects),
    annotations: s,
    scrollIntoView: !!e.scrollIntoView
  };
}
function lS(i, e, t) {
  let r = Dh(i, e.length ? e[0] : {}, i.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let n = 1; n < e.length; n++) {
    e[n].filter === !1 && (t = !1);
    let o = !!e[n].sequential;
    r = aS(r, Dh(i, e[n], o ? r.changes.newLength : i.doc.length), o);
  }
  let s = We.create(i, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return tQ(t ? eQ(s) : s);
}
function eQ(i) {
  let e = i.startState, t = !0;
  for (let s of e.facet(rS)) {
    let n = s(i);
    if (n === !1) {
      t = !1;
      break;
    }
    Array.isArray(n) && (t = t === !0 ? n : JC(t, n));
  }
  if (t !== !0) {
    let s, n;
    if (t === !1)
      n = i.changes.invertedDesc, s = Ue.empty(e.doc.length);
    else {
      let o = i.changes.filter(t);
      s = o.changes, n = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    i = We.create(e, s, i.selection && i.selection.map(n), he.mapEffects(i.effects, n), i.annotations, i.scrollIntoView);
  }
  let r = e.facet(sS);
  for (let s = r.length - 1; s >= 0; s--) {
    let n = r[s](i);
    n instanceof We ? i = n : Array.isArray(n) && n.length == 1 && n[0] instanceof We ? i = n[0] : i = lS(e, es(n), !1);
  }
  return i;
}
function tQ(i) {
  let e = i.startState, t = e.facet(nS), r = i;
  for (let s = t.length - 1; s >= 0; s--) {
    let n = t[s](i);
    n && Object.keys(n).length && (r = aS(r, Dh(e, n, i.changes.newLength), !0));
  }
  return r == i ? i : We.create(e, i.changes, i.selection, r.effects, r.annotations, r.scrollIntoView);
}
const iQ = [];
function es(i) {
  return i == null ? iQ : Array.isArray(i) ? i : [i];
}
var De = /* @__PURE__ */ function(i) {
  return i[i.Word = 0] = "Word", i[i.Space = 1] = "Space", i[i.Other = 2] = "Other", i;
}(De || (De = {}));
const rQ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Mh;
try {
  Mh = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function sQ(i) {
  if (Mh)
    return Mh.test(i);
  for (let e = 0; e < i.length; e++) {
    let t = i[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || rQ.test(t)))
      return !0;
  }
  return !1;
}
function nQ(i) {
  return (e) => {
    if (!/\S/.test(e))
      return De.Space;
    if (sQ(e))
      return De.Word;
    for (let t = 0; t < i.length; t++)
      if (e.indexOf(i[t]) > -1)
        return De.Word;
    return De.Other;
  };
}
class ve {
  constructor(e, t, r, s, n, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = s, this.status = e.statusTemplate.slice(), this.computeSlot = n, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      sn(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return sn(this, r), Ma(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return lS(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: s } = t;
    for (let a of e.effects)
      a.is(kl.reconfigure) ? (t && (s = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => s.set(c, l)), t = null), s.set(a.value.compartment, a.value.extension)) : a.is(he.reconfigure) ? (t = null, r = a.value) : a.is(he.appendConfig) && (t = null, r = es(r).concat(a.value));
    let n;
    t ? n = e.startState.values.slice() : (t = Da.resolve(r, s, this), n = new ve(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(Lh) ? e.newSelection : e.newSelection.asSingle();
    new ve(t, e.newDoc, o, n, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: V.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), s = this.changes(r.changes), n = [r.range], o = es(r.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), c = this.changes(l.changes), h = c.map(s);
      for (let d = 0; d < a; d++)
        n[d] = n[d].map(h);
      let u = s.mapDesc(c, !0);
      n.push(l.range.map(u)), s = s.compose(h), o = he.mapEffects(o, h).concat(he.mapEffects(es(l.effects), u));
    }
    return {
      changes: s,
      selection: V.create(n, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Ue ? e : Ue.of(e, this.doc.length, this.facet(ve.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return _e.of(e.split(this.facet(ve.lineSeparator) || Th));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (sn(this, t), Ma(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let s = e[r];
        s instanceof Ye && this.config.address[s.id] != null && (t[r] = s.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (r) {
      for (let n in r)
        if (Object.prototype.hasOwnProperty.call(e, n)) {
          let o = r[n], a = e[n];
          s.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return ve.create({
      doc: e.doc,
      selection: V.fromJSON(e.selection),
      extensions: t.extensions ? s.concat([t.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Da.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof _e ? e.doc : _e.of((e.doc || "").split(t.staticFacet(ve.lineSeparator) || Th)), s = e.selection ? e.selection instanceof V ? e.selection : V.single(e.selection.anchor, e.selection.head) : V.single(0);
    return J0(s, r.length), t.staticFacet(Lh) || (s = s.asSingle()), new ve(t, r, s, t.dynamicSlots.map(() => null), (n, o) => o.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ve.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ve.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(oS);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(ve.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, s) => {
      if (s == "$")
        return "$";
      let n = +(s || 1);
      return !n || n > t.length ? r : t[n - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let s = [];
    for (let n of this.facet(tS))
      for (let o of n(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && s.push(o[e]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return nQ(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: s } = this.doc.lineAt(e), n = this.charCategorizer(e), o = e - r, a = e - r;
    for (; o > 0; ) {
      let l = Je(t, o, !1);
      if (n(t.slice(l, o)) != De.Word)
        break;
      o = l;
    }
    for (; a < s; ) {
      let l = Je(t, a);
      if (n(t.slice(a, l)) != De.Word)
        break;
      a = l;
    }
    return o == a ? null : V.range(o + r, a + r);
  }
}
ve.allowMultipleSelections = Lh;
ve.tabSize = /* @__PURE__ */ ee.define({
  combine: (i) => i.length ? i[0] : 4
});
ve.lineSeparator = iS;
ve.readOnly = oS;
ve.phrases = /* @__PURE__ */ ee.define({
  compare(i, e) {
    let t = Object.keys(i), r = Object.keys(e);
    return t.length == r.length && t.every((s) => i[s] == e[s]);
  }
});
ve.languageData = tS;
ve.changeFilter = rS;
ve.transactionFilter = sS;
ve.transactionExtender = nS;
kl.reconfigure = /* @__PURE__ */ he.define();
function _i(i, e, t = {}) {
  let r = {};
  for (let s of i)
    for (let n of Object.keys(s)) {
      let o = s[n], a = r[n];
      if (a === void 0)
        r[n] = o;
      else if (!(a === o || o === void 0)) if (Object.hasOwnProperty.call(t, n))
        r[n] = t[n](a, o);
      else
        throw new Error("Config merge conflict for field " + n);
    }
  for (let s in e)
    r[s] === void 0 && (r[s] = e[s]);
  return r;
}
class Rr {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Bh.create(e, t, this);
  }
}
Rr.prototype.startSide = Rr.prototype.endSide = 0;
Rr.prototype.point = !1;
Rr.prototype.mapMode = Ke.TrackDel;
let Bh = class cS {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new cS(e, t, r);
  }
};
function qh(i, e) {
  return i.from - e.from || i.value.startSide - e.value.startSide;
}
class gf {
  constructor(e, t, r, s) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, s = 0) {
    let n = r ? this.to : this.from;
    for (let o = s, a = n.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = n[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, t, r, s) {
    for (let n = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, n); n < o; n++)
      if (s(this.from[n] + e, this.to[n] + e, this.value[n]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], s = [], n = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], h = this.from[l] + e, u = this.to[l] + e, d, O;
      if (h == u) {
        let v = t.mapPos(h, c.startSide, c.mapMode);
        if (v == null || (d = O = v, c.startSide != c.endSide && (O = t.mapPos(h, c.endSide), O < d)))
          continue;
      } else if (d = t.mapPos(h, c.startSide), O = t.mapPos(u, c.endSide), d > O || d == O && c.startSide > 0 && c.endSide <= 0)
        continue;
      (O - d || c.endSide - c.startSide) < 0 || (o < 0 && (o = d), c.point && (a = Math.max(a, O - d)), r.push(c), s.push(d - o), n.push(O - o));
    }
    return { mapped: r.length ? new gf(s, n, r, a) : null, pos: o };
  }
}
class be {
  constructor(e, t, r, s) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(e, t, r, s) {
    return new be(e, t, r, s);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: s = 0, filterTo: n = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(qh)), this.isEmpty)
      return t.length ? be.of(t) : this;
    let a = new hS(this, null, -1).goto(0), l = 0, c = [], h = new Bi();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let u = t[l++];
        h.addInner(u.from, u.to, u.value) || c.push(u);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!o || s > this.chunkEnd(a.chunkIndex) || n < this.chunkPos[a.chunkIndex]) && h.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || s > a.to || n < a.from || o(a.from, a.to, a.value)) && (h.addInner(a.from, a.to, a.value) || c.push(Bh.create(a.from, a.to, a.value))), a.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? be.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: s, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], s = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        s = Math.max(s, l.maxPoint), t.push(l), r.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: h, pos: u } = l.map(a, e);
        h && (s = Math.max(s, h.maxPoint), t.push(h), r.push(u));
      }
    }
    let n = this.nextLayer.map(e);
    return t.length == 0 ? n : new be(r, t, n || be.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let n = this.chunkPos[s], o = this.chunk[s];
        if (t >= n && e <= n + o.length && o.between(n, e - n, t - n, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return wn.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return wn.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, s, n = -1) {
    let o = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= n), a = t.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= n), l = dO(o, a, r), c = new qs(o, l, n), h = new qs(a, l, n);
    r.iterGaps((u, d, O) => OO(c, u, h, d, O, s)), r.empty && r.length == 0 && OO(c, 0, h, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, s) {
    s == null && (s = 999999999);
    let n = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), o = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (n.length != o.length)
      return !1;
    if (!n.length)
      return !0;
    let a = dO(n, o), l = new qs(n, a, 0).goto(r), c = new qs(o, a, 0).goto(r);
    for (; ; ) {
      if (l.to != c.to || !Xh(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > s)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, s, n = -1) {
    let o = new qs(e, null, n).goto(t), a = t, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let h = o.activeForPoint(o.to), u = o.pointFrom < t ? h.length + 1 : o.point.startSide < 0 ? h.length : Math.min(h.length, l);
        s.point(a, c, o.point, h, u, o.pointRank), l = Math.min(o.openEnd(c), h.length);
      } else c > a && (s.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > r)
        return l + (o.point && o.to > r ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new Bi();
    for (let s of e instanceof Bh ? [e] : t ? oQ(e) : e)
      r.add(s.from, s.to, s.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return be.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let s = e[r]; s != be.empty; s = s.nextLayer)
        t = new be(s.chunkPos, s.chunk, t, Math.max(s.maxPoint, t.maxPoint));
    return t;
  }
}
be.empty = /* @__PURE__ */ new be([], [], null, -1);
function oQ(i) {
  if (i.length > 1)
    for (let e = i[0], t = 1; t < i.length; t++) {
      let r = i[t];
      if (qh(e, r) > 0)
        return i.slice().sort(qh);
      e = r;
    }
  return i;
}
be.empty.nextLayer = be.empty;
class Bi {
  finishChunk(e) {
    this.chunks.push(new gf(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new Bi())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let s = e - this.lastTo || r.startSide - this.last.endSide;
    if (s <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(be.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = be.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function dO(i, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let n of i)
    for (let o = 0; o < n.chunk.length; o++)
      n.chunk[o].maxPoint <= 0 && r.set(n.chunk[o], n.chunkPos[o]);
  let s = /* @__PURE__ */ new Set();
  for (let n of e)
    for (let o = 0; o < n.chunk.length; o++) {
      let a = r.get(n.chunk[o]);
      a != null && (t ? t.mapPos(a) : a) == n.chunkPos[o] && !t?.touchesRange(a, a + n.chunk[o].length) && s.add(n.chunk[o]);
    }
  return s;
}
class hS {
  constructor(e, t, r, s = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < e || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class wn {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let s = [];
    for (let n = 0; n < e.length; n++)
      for (let o = e[n]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && s.push(new hS(o, t, r, n));
    return s.length == 1 ? s[0] : new wn(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      sc(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      sc(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), sc(this.heap, 0);
    }
  }
}
function sc(i, e) {
  for (let t = i[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= i.length)
      break;
    let s = i[r];
    if (r + 1 < i.length && s.compare(i[r + 1]) >= 0 && (s = i[r + 1], r++), t.compare(s) < 0)
      break;
    i[r] = t, i[e] = s, e = r;
  }
}
class qs {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = wn.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    yo(this.active, e), yo(this.activeTo, e), yo(this.activeRank, e), this.minActive = pO(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: s, rank: n } = this.cursor;
    for (; t < this.activeRank.length && (n - this.activeRank[t] || s - this.activeTo[t]) > 0; )
      t++;
    wo(this.active, t, r), wo(this.activeTo, t, s), wo(this.activeRank, t, n), e && wo(e, t, this.cursor.from), this.minActive = pO(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > e) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), r && yo(r, s);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let n = this.cursor.value;
          if (!n.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = n, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = n.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let s = r.length - 1; s >= 0 && r[s] < e; s--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function OO(i, e, t, r, s, n) {
  i.goto(e), t.goto(r);
  let o = r + s, a = r, l = r - e;
  for (; ; ) {
    let c = i.to + l - t.to, h = c || i.endSide - t.endSide, u = h < 0 ? i.to + l : t.to, d = Math.min(u, o);
    if (i.point || t.point ? i.point && t.point && (i.point == t.point || i.point.eq(t.point)) && Xh(i.activeForPoint(i.to), t.activeForPoint(t.to)) || n.comparePoint(a, d, i.point, t.point) : d > a && !Xh(i.active, t.active) && n.compareRange(a, d, i.active, t.active), u > o)
      break;
    (c || i.openEnd != t.openEnd) && n.boundChange && n.boundChange(u), a = u, h <= 0 && i.next(), h >= 0 && t.next();
  }
}
function Xh(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (i[t] != e[t] && !i[t].eq(e[t]))
      return !1;
  return !0;
}
function yo(i, e) {
  for (let t = e, r = i.length - 1; t < r; t++)
    i[t] = i[t + 1];
  i.pop();
}
function wo(i, e, t) {
  for (let r = i.length - 1; r >= e; r--)
    i[r + 1] = i[r];
  i[e] = t;
}
function pO(i, e) {
  let t = -1, r = 1e9;
  for (let s = 0; s < e.length; s++)
    (e[s] - r || i[s].endSide - i[t].endSide) < 0 && (t = s, r = e[s]);
  return t;
}
function Nt(i, e, t = i.length) {
  let r = 0;
  for (let s = 0; s < t && s < i.length; )
    i.charCodeAt(s) == 9 ? (r += e - r % e, s++) : (r++, s = Je(i, s));
  return r;
}
function Ih(i, e, t, r) {
  for (let s = 0, n = 0; ; ) {
    if (n >= e)
      return s;
    if (s == i.length)
      break;
    n += i.charCodeAt(s) == 9 ? t - n % t : 1, s = Je(i, s);
  }
  return r === !0 ? -1 : i.length;
}
const Zh = "", gO = typeof Symbol > "u" ? "__" + Zh : Symbol.for(Zh), Wh = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), mO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class sr {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function s(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function n(o, a, l, c) {
      let h = [], u = /^@(\w+)\b/.exec(o[0]), d = u && u[1] == "keyframes";
      if (u && a == null) return l.push(o[0] + ";");
      for (let O in a) {
        let v = a[O];
        if (/&/.test(O))
          n(
            O.split(/,\s*/).map((S) => o.map((f) => S.replace(/&/, f))).reduce((S, f) => S.concat(f)),
            v,
            l
          );
        else if (v && typeof v == "object") {
          if (!u) throw new RangeError("The value of a property (" + O + ") should be a primitive value.");
          n(s(O), v, h, d);
        } else v != null && h.push(O.replace(/_.*/, "").replace(/[A-Z]/g, (S) => "-" + S.toLowerCase()) + ": " + v + ";");
      }
      (h.length || d) && l.push((r && !u && !c ? o.map(r) : o).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let o in e) n(s(o), e[o], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = mO[gO] || 1;
    return mO[gO] = e + 1, Zh + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let s = e[Wh], n = r && r.nonce;
    s ? n && s.setNonce(n) : s = new aQ(e, n), s.mount(Array.isArray(t) ? t : [t], e);
  }
}
let SO = /* @__PURE__ */ new Map();
class aQ {
  constructor(e, t) {
    let r = e.ownerDocument || e, s = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && s.CSSStyleSheet) {
      let n = SO.get(r);
      if (n) return e[Wh] = n;
      this.sheet = new s.CSSStyleSheet(), SO.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[Wh] = this;
  }
  mount(e, t) {
    let r = this.sheet, s = 0, n = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = this.modules.indexOf(a);
      if (l < n && l > -1 && (this.modules.splice(l, 1), n--, l = -1), l == -1) {
        if (this.modules.splice(n++, 0, a), r) for (let c = 0; c < a.rules.length; c++)
          r.insertRule(a.rules[c], s++);
      } else {
        for (; n < l; ) s += this.modules[n++].rules.length;
        s += a.rules.length, n++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = o;
      let a = t.head || t;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var nr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, xn = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, lQ = typeof navigator < "u" && /Mac/.test(navigator.platform), cQ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Ge = 0; Ge < 10; Ge++) nr[48 + Ge] = nr[96 + Ge] = String(Ge);
for (var Ge = 1; Ge <= 24; Ge++) nr[Ge + 111] = "F" + Ge;
for (var Ge = 65; Ge <= 90; Ge++)
  nr[Ge] = String.fromCharCode(Ge + 32), xn[Ge] = String.fromCharCode(Ge);
for (var nc in nr) xn.hasOwnProperty(nc) || (xn[nc] = nr[nc]);
function hQ(i) {
  var e = lQ && i.metaKey && i.shiftKey && !i.ctrlKey && !i.altKey || cQ && i.shiftKey && i.key && i.key.length == 1 || i.key == "Unidentified", t = !e && i.key || (i.shiftKey ? xn : nr)[i.keyCode] || i.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Ce() {
  var i = arguments[0];
  typeof i == "string" && (i = document.createElement(i));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var s = t[r];
      typeof s == "string" ? i.setAttribute(r, s) : s != null && (i[r] = s);
    }
    e++;
  }
  for (; e < arguments.length; e++) uS(i, arguments[e]);
  return i;
}
function uS(i, e) {
  if (typeof e == "string")
    i.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    i.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) uS(i, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function kn(i) {
  let e;
  return i.nodeType == 11 ? e = i.getSelection ? i : i.ownerDocument : e = i, e.getSelection();
}
function zh(i, e) {
  return e ? i == e || i.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function sa(i, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return zh(i, e.anchorNode);
  } catch {
    return !1;
  }
}
function Cn(i) {
  return i.nodeType == 3 ? Ar(i, 0, i.nodeValue.length).getClientRects() : i.nodeType == 1 ? i.getClientRects() : [];
}
function nn(i, e, t, r) {
  return t ? vO(i, e, t, r, -1) || vO(i, e, t, r, 1) : !1;
}
function Er(i) {
  for (var e = 0; ; e++)
    if (i = i.previousSibling, !i)
      return e;
}
function Ba(i) {
  return i.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(i.nodeName);
}
function vO(i, e, t, r, s) {
  for (; ; ) {
    if (i == t && e == r)
      return !0;
    if (e == (s < 0 ? 0 : mi(i))) {
      if (i.nodeName == "DIV")
        return !1;
      let n = i.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      e = Er(i) + (s < 0 ? 0 : 1), i = n;
    } else if (i.nodeType == 1) {
      if (i = i.childNodes[e + (s < 0 ? -1 : 0)], i.nodeType == 1 && i.contentEditable == "false")
        return !1;
      e = s < 0 ? mi(i) : 0;
    } else
      return !1;
  }
}
function mi(i) {
  return i.nodeType == 3 ? i.nodeValue.length : i.childNodes.length;
}
function Cl(i, e) {
  let t = e ? i.left : i.right;
  return { left: t, right: t, top: i.top, bottom: i.bottom };
}
function uQ(i) {
  let e = i.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: i.innerWidth,
    top: 0,
    bottom: i.innerHeight
  };
}
function fS(i, e) {
  let t = e.width / i.offsetWidth, r = e.height / i.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - i.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - i.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function fQ(i, e, t, r, s, n, o, a) {
  let l = i.ownerDocument, c = l.defaultView || window;
  for (let h = i, u = !1; h && !u; )
    if (h.nodeType == 1) {
      let d, O = h == l.body, v = 1, S = 1;
      if (O)
        d = uQ(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (u = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let g = h.getBoundingClientRect();
        ({ scaleX: v, scaleY: S } = fS(h, g)), d = {
          left: g.left,
          right: g.left + h.clientWidth * v,
          top: g.top,
          bottom: g.top + h.clientHeight * S
        };
      }
      let f = 0, p = 0;
      if (s == "nearest")
        e.top < d.top ? (p = e.top - (d.top + o), t > 0 && e.bottom > d.bottom + p && (p = e.bottom - d.bottom + o)) : e.bottom > d.bottom && (p = e.bottom - d.bottom + o, t < 0 && e.top - p < d.top && (p = e.top - (d.top + o)));
      else {
        let g = e.bottom - e.top, m = d.bottom - d.top;
        p = (s == "center" && g <= m ? e.top + g / 2 - m / 2 : s == "start" || s == "center" && t < 0 ? e.top - o : e.bottom - m + o) - d.top;
      }
      if (r == "nearest" ? e.left < d.left ? (f = e.left - (d.left + n), t > 0 && e.right > d.right + f && (f = e.right - d.right + n)) : e.right > d.right && (f = e.right - d.right + n, t < 0 && e.left < d.left + f && (f = e.left - (d.left + n))) : f = (r == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : r == "start" == a ? e.left - n : e.right - (d.right - d.left) + n) - d.left, f || p)
        if (O)
          c.scrollBy(f, p);
        else {
          let g = 0, m = 0;
          if (p) {
            let _ = h.scrollTop;
            h.scrollTop += p / S, m = (h.scrollTop - _) * S;
          }
          if (f) {
            let _ = h.scrollLeft;
            h.scrollLeft += f / v, g = (h.scrollLeft - _) * v;
          }
          e = {
            left: e.left - g,
            top: e.top - m,
            right: e.right - g,
            bottom: e.bottom - m
          }, g && Math.abs(g - f) < 1 && (r = "nearest"), m && Math.abs(m - p) < 1 && (s = "nearest");
        }
      if (O)
        break;
      (e.top < d.top || e.bottom > d.bottom || e.left < d.left || e.right > d.right) && (e = {
        left: Math.max(e.left, d.left),
        right: Math.min(e.right, d.right),
        top: Math.max(e.top, d.top),
        bottom: Math.min(e.bottom, d.bottom)
      }), h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function dQ(i) {
  let e = i.ownerDocument, t, r;
  for (let s = i.parentNode; s && !(s == e.body || t && r); )
    if (s.nodeType == 1)
      !r && s.scrollHeight > s.clientHeight && (r = s), !t && s.scrollWidth > s.clientWidth && (t = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: t, y: r };
}
class OQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? mi(t) : 0), r, Math.min(e.focusOffset, r ? mi(r) : 0));
  }
  set(e, t, r, s) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = s;
  }
}
let Zr = null;
function dS(i) {
  if (i.setActive)
    return i.setActive();
  if (Zr)
    return i.focus(Zr);
  let e = [];
  for (let t = i; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (i.focus(Zr == null ? {
    get preventScroll() {
      return Zr = { preventScroll: !0 }, !0;
    }
  } : void 0), !Zr) {
    Zr = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], s = e[t++], n = e[t++];
      r.scrollTop != s && (r.scrollTop = s), r.scrollLeft != n && (r.scrollLeft = n);
    }
  }
}
let _O;
function Ar(i, e, t = e) {
  let r = _O || (_O = document.createRange());
  return r.setEnd(i, t), r.setStart(i, e), r;
}
function ts(i, e, t, r) {
  let s = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = r);
  let n = new KeyboardEvent("keydown", s);
  n.synthetic = !0, i.dispatchEvent(n);
  let o = new KeyboardEvent("keyup", s);
  return o.synthetic = !0, i.dispatchEvent(o), n.defaultPrevented || o.defaultPrevented;
}
function pQ(i) {
  for (; i; ) {
    if (i && (i.nodeType == 9 || i.nodeType == 11 && i.host))
      return i;
    i = i.assignedSlot || i.parentNode;
  }
  return null;
}
function OS(i) {
  for (; i.attributes.length; )
    i.removeAttributeNode(i.attributes[0]);
}
function gQ(i, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, mi(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let s = t.childNodes[r - 1];
      s.contentEditable == "false" ? r-- : (t = s, r = mi(t));
    } else {
      if (t == i)
        return !0;
      r = Er(t), t = t.parentNode;
    }
}
function pS(i) {
  return i.scrollTop > Math.max(1, i.scrollHeight - i.clientHeight - 4);
}
function gS(i, e) {
  for (let t = i, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = mi(t);
    } else if (t.parentNode && !Ba(t))
      r = Er(t), t = t.parentNode;
    else
      return null;
  }
}
function mS(i, e) {
  for (let t = i, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !Ba(t))
      r = Er(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class rt {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new rt(e.parentNode, Er(e), t);
  }
  static after(e, t) {
    return new rt(e.parentNode, Er(e) + 1, t);
  }
}
const mf = [];
class Te {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, s = null, n;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (n = s ? s.nextSibling : r.firstChild)) {
            let a = Te.get(n);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(n);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (n = s ? s.nextSibling : r.firstChild, t && !t.written && t.node == r && n != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; n && n != o.dom; )
            n = bO(n);
        else
          r.insertBefore(o.dom, n);
        s = o.dom;
      }
      for (n = s ? s.nextSibling : r.firstChild, n && t && t.node == r && (t.written = !0); n; )
        n = bO(n);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let s = mi(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let n = e.parentNode;
        if (n == this.dom)
          break;
        s == 0 && n.firstChild != n.lastChild && (e == n.firstChild ? s = -1 : s = 1), e = n;
      }
      s < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Te.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let s = 0, n = 0; ; s++) {
      let o = this.children[s];
      if (o.dom == r)
        return n;
      n += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let s = -1, n = -1, o = -1, a = -1;
    for (let l = 0, c = r, h = r; l < this.children.length; l++) {
      let u = this.children[l], d = c + u.length;
      if (c < e && d > t)
        return u.domBoundsAround(e, t, c);
      if (d >= e && s == -1 && (s = l, n = c), c > t && u.dom.parentNode == this.dom) {
        o = l, a = h;
        break;
      }
      h = d, c = d + u.breakAfter;
    }
    return {
      from: n,
      to: a < 0 ? r + this.length : a,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = mf) {
    this.markDirty();
    for (let s = e; s < t; s++) {
      let n = this.children[s];
      n.parent == this && r.indexOf(n) < 0 && n.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let s = 0; s < r.length; s++)
      r[s].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new SS(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, s, n, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Te.prototype.breakAfter = 0;
function bO(i) {
  let e = i.nextSibling;
  return i.parentNode.removeChild(i), e;
}
class SS {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function vS(i, e, t, r, s, n, o, a, l) {
  let { children: c } = i, h = c.length ? c[e] : null, u = n.length ? n[n.length - 1] : null, d = u ? u.breakAfter : o;
  if (!(e == r && h && !o && !d && n.length < 2 && h.merge(t, s, n.length ? u : null, t == 0, a, l))) {
    if (r < c.length) {
      let O = c[r];
      O && (s < O.length || O.breakAfter && u?.breakAfter) ? (e == r && (O = O.split(s), s = 0), !d && u && O.merge(0, s, u, !0, 0, l) ? n[n.length - 1] = O : ((s || O.children.length && !O.children[0].length) && O.merge(0, s, null, !1, 0, l), n.push(O))) : O?.breakAfter && (u ? u.breakAfter = 1 : o = 1), r++;
    }
    for (h && (h.breakAfter = o, t > 0 && (!o && n.length && h.merge(t, h.length, n[0], !1, a, 0) ? h.breakAfter = n.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, a, 0), e++)); e < r && n.length; )
      if (c[r - 1].become(n[n.length - 1]))
        r--, n.pop(), l = n.length ? 0 : a;
      else if (c[e].become(n[0]))
        e++, n.shift(), a = n.length ? 0 : l;
      else
        break;
    !n.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < r || n.length) && i.replaceChildren(e, r, n);
  }
}
function _S(i, e, t, r, s, n) {
  let o = i.childCursor(), { i: a, off: l } = o.findPos(t, 1), { i: c, off: h } = o.findPos(e, -1), u = e - t;
  for (let d of r)
    u += d.length;
  i.length += u, vS(i, c, h, a, l, r, 0, s, n);
}
let gt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Vh = typeof document < "u" ? document : { documentElement: { style: {} } };
const Uh = /* @__PURE__ */ /Edge\/(\d+)/.exec(gt.userAgent), bS = /* @__PURE__ */ /MSIE \d/.test(gt.userAgent), jh = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gt.userAgent), Ql = !!(bS || jh || Uh), yO = !Ql && /* @__PURE__ */ /gecko\/(\d+)/i.test(gt.userAgent), oc = !Ql && /* @__PURE__ */ /Chrome\/(\d+)/.exec(gt.userAgent), mQ = "webkitFontSmoothing" in Vh.documentElement.style, yS = !Ql && /* @__PURE__ */ /Apple Computer/.test(gt.vendor), wO = yS && (/* @__PURE__ */ /Mobile\/\w+/.test(gt.userAgent) || gt.maxTouchPoints > 2);
var ie = {
  mac: wO || /* @__PURE__ */ /Mac/.test(gt.platform),
  windows: /* @__PURE__ */ /Win/.test(gt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(gt.platform),
  ie: Ql,
  ie_version: bS ? Vh.documentMode || 6 : jh ? +jh[1] : Uh ? +Uh[1] : 0,
  gecko: yO,
  gecko_version: yO ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(gt.userAgent) || [0, 0])[1] : 0,
  chrome: !!oc,
  chrome_version: oc ? +oc[1] : 0,
  ios: wO,
  android: /* @__PURE__ */ /Android\b/.test(gt.userAgent),
  safari: yS,
  webkit_version: mQ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(gt.userAgent) || [0, 0])[1] : 0,
  tabSize: Vh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const SQ = 256;
class Yt extends Te {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof Yt) || this.length - (t - e) + r.length > SQ || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Yt(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new rt(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return vQ(this.dom, e, t);
  }
}
class qi extends Te {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let s of t)
      s.setParent(this);
  }
  setAttrs(e) {
    if (OS(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, s, n, o) {
    return r && (!(r instanceof qi && r.mark.eq(this.mark)) || e && n <= 0 || t < this.length && o <= 0) ? !1 : (_S(this, e, t, r ? r.children.slice() : [], n - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, s = -1, n = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && t.push(r < e ? a.split(e - r) : a), s < 0 && r >= e && (s = n), r = l, n++;
    }
    let o = this.length - e;
    return this.length = e, s > -1 && (this.children.length = s, this.markDirty()), new qi(this.mark, t, o);
  }
  domAtPos(e) {
    return wS(this, e);
  }
  coordsAt(e, t) {
    return kS(this, e, t);
  }
}
function vQ(i, e, t) {
  let r = i.nodeValue.length;
  e > r && (e = r);
  let s = e, n = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? ie.chrome || ie.gecko || (e ? (s--, o = 1) : n < r && (n++, o = -1)) : t < 0 ? s-- : n < r && n++;
  let a = Ar(i, s, n).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : t >= 0) ? 0 : a.length - 1];
  return ie.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? Cl(l, o < 0) : l || null;
}
class Gi extends Te {
  static create(e, t, r) {
    return new Gi(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = Gi.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, s, n, o) {
    return r && (!(r instanceof Gi) || !this.widget.compare(r.widget) || e > 0 && n <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Gi && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return _e.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, s = this.posAtStart;
    return r ? r.slice(s, s + this.length) : _e.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? rt.before(this.dom) : rt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let s = this.dom.getClientRects(), n = null;
    if (!s.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? s.length - 1 : 0; n = s[a], !(e > 0 ? a == 0 : a == s.length - 1 || n.top < n.bottom); a += o ? -1 : 1)
      ;
    return Cl(n, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class us extends Te {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof us && e.side == this.side;
  }
  split() {
    return new us(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? rt.before(this.dom) : rt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return _e.empty;
  }
  get isHidden() {
    return !0;
  }
}
Yt.prototype.children = Gi.prototype.children = us.prototype.children = mf;
function wS(i, e) {
  let t = i.dom, { children: r } = i, s = 0;
  for (let n = 0; s < r.length; s++) {
    let o = r[s], a = n + o.length;
    if (!(a == n && o.getSide() <= 0)) {
      if (e > n && e < a && o.dom.parentNode == t)
        return o.domAtPos(e - n);
      if (e <= n)
        break;
      n = a;
    }
  }
  for (let n = s; n > 0; n--) {
    let o = r[n - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let n = s; n < r.length; n++) {
    let o = r[n];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new rt(t, 0);
}
function xS(i, e, t) {
  let r, { children: s } = i;
  t > 0 && e instanceof qi && s.length && (r = s[s.length - 1]) instanceof qi && r.mark.eq(e.mark) ? xS(r, e.children[0], t - 1) : (s.push(e), e.setParent(i)), i.length += e.length;
}
function kS(i, e, t) {
  let r = null, s = -1, n = null, o = -1;
  function a(c, h) {
    for (let u = 0, d = 0; u < c.children.length && d <= h; u++) {
      let O = c.children[u], v = d + O.length;
      v >= h && (O.children.length ? a(O, h - d) : (!n || n.isHidden && (t > 0 || bQ(n, O))) && (v > h || d == v && O.getSide() > 0) ? (n = O, o = h - d) : (d < h || d == v && O.getSide() < 0 && !O.isHidden) && (r = O, s = h - d)), d = v;
    }
  }
  a(i, e);
  let l = (t < 0 ? r : n) || r || n;
  return l ? l.coordsAt(Math.max(0, l == r ? s : o), t) : _Q(i);
}
function _Q(i) {
  let e = i.dom.lastChild;
  if (!e)
    return i.dom.getBoundingClientRect();
  let t = Cn(e);
  return t[t.length - 1] || null;
}
function bQ(i, e) {
  let t = i.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function Nh(i, e) {
  for (let t in i)
    t == "class" && e.class ? e.class += " " + i.class : t == "style" && e.style ? e.style += ";" + i.style : e[t] = i[t];
  return e;
}
const xO = /* @__PURE__ */ Object.create(null);
function qa(i, e, t) {
  if (i == e)
    return !0;
  i || (i = xO), e || (e = xO);
  let r = Object.keys(i), s = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != s.length - (t && s.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let n of r)
    if (n != t && (s.indexOf(n) == -1 || i[n] !== e[n]))
      return !1;
  return !0;
}
function Yh(i, e, t) {
  let r = !1;
  if (e)
    for (let s in e)
      t && s in t || (r = !0, s == "style" ? i.style.cssText = "" : i.removeAttribute(s));
  if (t)
    for (let s in t)
      e && e[s] == t[s] || (r = !0, s == "style" ? i.style.cssText = t[s] : i.setAttribute(s, t[s]));
  return r;
}
function yQ(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < i.attributes.length; t++) {
    let r = i.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
class zi {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var ht = /* @__PURE__ */ function(i) {
  return i[i.Text = 0] = "Text", i[i.WidgetBefore = 1] = "WidgetBefore", i[i.WidgetAfter = 2] = "WidgetAfter", i[i.WidgetRange = 3] = "WidgetRange", i;
}(ht || (ht = {}));
class ae extends Rr {
  constructor(e, t, r, s) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new so(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new or(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, s;
    if (e.isBlockGap)
      r = -5e8, s = 4e8;
    else {
      let { start: n, end: o } = CS(e, t);
      r = (n ? t ? -3e8 : -1 : 5e8) - 1, s = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new or(e, r, s, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new no(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return be.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ae.none = be.empty;
class so extends ae {
  constructor(e) {
    let { start: t, end: r } = CS(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof so && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && qa(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
so.prototype.point = !1;
class no extends ae {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof no && this.spec.class == e.spec.class && qa(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
no.prototype.mapMode = Ke.TrackBefore;
no.prototype.point = !0;
class or extends ae {
  constructor(e, t, r, s, n, o) {
    super(t, r, n, e), this.block = s, this.isReplace = o, this.mapMode = s ? t <= 0 ? Ke.TrackBefore : Ke.TrackAfter : Ke.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? ht.WidgetRange : this.startSide <= 0 ? ht.WidgetBefore : ht.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof or && wQ(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
or.prototype.point = !0;
function CS(i, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = i;
  return t == null && (t = i.inclusive), r == null && (r = i.inclusive), { start: t ?? e, end: r ?? e };
}
function wQ(i, e) {
  return i == e || !!(i && e && i.compare(e));
}
function na(i, e, t, r = 0) {
  let s = t.length - 1;
  s >= 0 && t[s] + r >= i ? t[s] = Math.max(t[s], e) : t.push(i, e);
}
class Ze extends Te {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, s, n, o) {
    if (r) {
      if (!(r instanceof Ze))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return s && this.setDeco(r ? r.attrs : null), _S(this, e, t, r ? r.children.slice() : [], n, o), !0;
  }
  split(e) {
    let t = new Ze();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: s } = this.childPos(e);
    s && (t.append(this.children[r].split(s), 0), this.children[r].merge(s, this.children[r].length, null, !1, 0, 0), r++);
    for (let n = r; n < this.children.length; n++)
      t.append(this.children[n], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    qa(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    xS(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = Nh(t, this.attrs || {})), r && (this.attrs = Nh({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return wS(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (OS(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Yh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let s = this.dom.lastChild;
    for (; s && Te.get(s) instanceof qi; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((r = Te.get(s)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!ie.ios || !this.children.some((n) => n instanceof Yt))) {
      let n = document.createElement("BR");
      n.cmIgnore = !0, this.dom.appendChild(n);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof Yt) || /[^ -~]/.test(r.text))
        return null;
      let s = Cn(r.dom);
      if (s.length != 1)
        return null;
      e += s[0].width, t = s[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = kS(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, n = r.bottom - r.top;
      if (Math.abs(n - s.lineHeight) < 2 && s.textHeight < n) {
        let o = (n - s.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof Ze && this.children.length == 0 && e.children.length == 0 && qa(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, s = 0; r < e.children.length; r++) {
      let n = e.children[r], o = s + n.length;
      if (o >= t) {
        if (n instanceof Ze)
          return n;
        if (o > t)
          break;
      }
      s = o + n.breakAfter;
    }
    return null;
  }
}
class Ai extends Te {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, s, n, o) {
    return r && (!(r instanceof Ai) || !this.widget.compare(r.widget) || e > 0 && n <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? rt.before(this.dom) : rt.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new Ai(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return mf;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _e.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Ai && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof Fh ? null : Cl(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class Fh extends zi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class on {
  constructor(e, t, r, s) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Ai && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Ze()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(xo(new us(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Ai) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: n, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = n, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(xo(new Yt(this.text.slice(this.textOff, this.textOff + s)), t), r), this.atCursorPos = !0, this.textOff += s, e -= s, r = 0;
    }
  }
  span(e, t, r, s) {
    this.buildText(t - e, r, s), this.pos = t, this.openStart < 0 && (this.openStart = s);
  }
  point(e, t, r, s, n, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof or) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (r instanceof or)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Ai(r.widget || fs.block, a, r));
      else {
        let l = Gi.create(r.widget || fs.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && n <= s.length && (e < t || r.startSide > 0), h = !l.isEditable && (e < t || n > s.length || r.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), c && (u.append(xo(new us(1), s), n), n = s.length + Math.max(0, n - s.length)), u.append(xo(l, s), n), this.atCursorPos = h, this.pendingBuffer = h ? e < t || n > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = n);
  }
  static build(e, t, r, s, n) {
    let o = new on(e, t, r, n);
    return o.openEnd = be.spans(s, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function xo(i, e) {
  for (let t of e)
    i = new qi(t, [i], i.length);
  return i;
}
class fs extends zi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
fs.inline = /* @__PURE__ */ new fs("span");
fs.block = /* @__PURE__ */ new fs("div");
var Le = /* @__PURE__ */ function(i) {
  return i[i.LTR = 0] = "LTR", i[i.RTL = 1] = "RTL", i;
}(Le || (Le = {}));
const Lr = Le.LTR, Sf = Le.RTL;
function QS(i) {
  let e = [];
  for (let t = 0; t < i.length; t++)
    e.push(1 << +i[t]);
  return e;
}
const xQ = /* @__PURE__ */ QS("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), kQ = /* @__PURE__ */ QS("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Hh = /* @__PURE__ */ Object.create(null), si = [];
for (let i of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ i.charCodeAt(0), t = /* @__PURE__ */ i.charCodeAt(1);
  Hh[e] = t, Hh[t] = -e;
}
function PS(i) {
  return i <= 247 ? xQ[i] : 1424 <= i && i <= 1524 ? 2 : 1536 <= i && i <= 1785 ? kQ[i - 1536] : 1774 <= i && i <= 2220 ? 4 : 8192 <= i && i <= 8204 ? 256 : 64336 <= i && i <= 65023 ? 4 : 1;
}
const CQ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ki {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Sf : Lr;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, s) {
    let n = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= t && a.to >= t) {
        if (a.level == r)
          return o;
        (n < 0 || (s != 0 ? s < 0 ? a.from < t : a.to > t : e[n].level > a.level)) && (n = o);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}
function TS(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++) {
    let r = i[t], s = e[t];
    if (r.from != s.from || r.to != s.to || r.direction != s.direction || !TS(r.inner, s.inner))
      return !1;
  }
  return !0;
}
const Qe = [];
function QQ(i, e, t, r, s) {
  for (let n = 0; n <= r.length; n++) {
    let o = n ? r[n - 1].to : e, a = n < r.length ? r[n].from : t, l = n ? 256 : s;
    for (let c = o, h = l, u = l; c < a; c++) {
      let d = PS(i.charCodeAt(c));
      d == 512 ? d = h : d == 8 && u == 4 && (d = 16), Qe[c] = d == 4 ? 2 : d, d & 7 && (u = d), h = d;
    }
    for (let c = o, h = l, u = l; c < a; c++) {
      let d = Qe[c];
      if (d == 128)
        c < a - 1 && h == Qe[c + 1] && h & 24 ? d = Qe[c] = h : Qe[c] = 256;
      else if (d == 64) {
        let O = c + 1;
        for (; O < a && Qe[O] == 64; )
          O++;
        let v = c && h == 8 || O < t && Qe[O] == 8 ? u == 1 ? 1 : 8 : 256;
        for (let S = c; S < O; S++)
          Qe[S] = v;
        c = O - 1;
      } else d == 8 && u == 1 && (Qe[c] = 1);
      h = d, d & 7 && (u = d);
    }
  }
}
function PQ(i, e, t, r, s) {
  let n = s == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, h = o < r.length ? r[o].from : t;
    for (let u = c, d, O, v; u < h; u++)
      if (O = Hh[d = i.charCodeAt(u)])
        if (O < 0) {
          for (let S = a - 3; S >= 0; S -= 3)
            if (si[S + 1] == -O) {
              let f = si[S + 2], p = f & 2 ? s : f & 4 ? f & 1 ? n : s : 0;
              p && (Qe[u] = Qe[si[S]] = p), a = S;
              break;
            }
        } else {
          if (si.length == 189)
            break;
          si[a++] = u, si[a++] = d, si[a++] = l;
        }
      else if ((v = Qe[u]) == 2 || v == 1) {
        let S = v == s;
        l = S ? 0 : 1;
        for (let f = a - 3; f >= 0; f -= 3) {
          let p = si[f + 2];
          if (p & 2)
            break;
          if (S)
            si[f + 2] |= 2;
          else {
            if (p & 4)
              break;
            si[f + 2] |= 4;
          }
        }
      }
  }
}
function TQ(i, e, t, r) {
  for (let s = 0, n = r; s <= t.length; s++) {
    let o = s ? t[s - 1].to : i, a = s < t.length ? t[s].from : e;
    for (let l = o; l < a; ) {
      let c = Qe[l];
      if (c == 256) {
        let h = l + 1;
        for (; ; )
          if (h == a) {
            if (s == t.length)
              break;
            h = t[s++].to, a = s < t.length ? t[s].from : e;
          } else if (Qe[h] == 256)
            h++;
          else
            break;
        let u = n == 1, d = (h < e ? Qe[h] : r) == 1, O = u == d ? u ? 1 : 2 : r;
        for (let v = h, S = s, f = S ? t[S - 1].to : i; v > l; )
          v == f && (v = t[--S].from, f = S ? t[S - 1].to : i), Qe[--v] = O;
        l = h;
      } else
        n = c, l++;
    }
  }
}
function Gh(i, e, t, r, s, n, o) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == s % 2)
    for (let l = e, c = 0; l < t; ) {
      let h = !0, u = !1;
      if (c == n.length || l < n[c].from) {
        let S = Qe[l];
        S != a && (h = !1, u = S == 16);
      }
      let d = !h && a == 1 ? [] : null, O = h ? r : r + 1, v = l;
      e: for (; ; )
        if (c < n.length && v == n[c].from) {
          if (u)
            break e;
          let S = n[c];
          if (!h)
            for (let f = S.to, p = c + 1; ; ) {
              if (f == t)
                break e;
              if (p < n.length && n[p].from == f)
                f = n[p++].to;
              else {
                if (Qe[f] == a)
                  break e;
                break;
              }
            }
          if (c++, d)
            d.push(S);
          else {
            S.from > l && o.push(new Ki(l, S.from, O));
            let f = S.direction == Lr != !(O % 2);
            Kh(i, f ? r + 1 : r, s, S.inner, S.from, S.to, o), l = S.to;
          }
          v = S.to;
        } else {
          if (v == t || (h ? Qe[v] != a : Qe[v] == a))
            break;
          v++;
        }
      d ? Gh(i, l, v, r + 1, s, d, o) : l < v && o.push(new Ki(l, v, O)), l = v;
    }
  else
    for (let l = t, c = n.length; l > e; ) {
      let h = !0, u = !1;
      if (!c || l > n[c - 1].to) {
        let S = Qe[l - 1];
        S != a && (h = !1, u = S == 16);
      }
      let d = !h && a == 1 ? [] : null, O = h ? r : r + 1, v = l;
      e: for (; ; )
        if (c && v == n[c - 1].to) {
          if (u)
            break e;
          let S = n[--c];
          if (!h)
            for (let f = S.from, p = c; ; ) {
              if (f == e)
                break e;
              if (p && n[p - 1].to == f)
                f = n[--p].from;
              else {
                if (Qe[f - 1] == a)
                  break e;
                break;
              }
            }
          if (d)
            d.push(S);
          else {
            S.to < l && o.push(new Ki(S.to, l, O));
            let f = S.direction == Lr != !(O % 2);
            Kh(i, f ? r + 1 : r, s, S.inner, S.from, S.to, o), l = S.from;
          }
          v = S.from;
        } else {
          if (v == e || (h ? Qe[v - 1] != a : Qe[v - 1] == a))
            break;
          v--;
        }
      d ? Gh(i, v, l, r + 1, s, d, o) : v < l && o.push(new Ki(v, l, O)), l = v;
    }
}
function Kh(i, e, t, r, s, n, o) {
  let a = e % 2 ? 2 : 1;
  QQ(i, s, n, r, a), PQ(i, s, n, r, a), TQ(s, n, r, a), Gh(i, s, n, e, t, r, o);
}
function $Q(i, e, t) {
  if (!i)
    return [new Ki(0, 0, e == Sf ? 1 : 0)];
  if (e == Lr && !t.length && !CQ.test(i))
    return $S(i.length);
  if (t.length)
    for (; i.length > Qe.length; )
      Qe[Qe.length] = 256;
  let r = [], s = e == Lr ? 0 : 1;
  return Kh(i, s, s, t, 0, i.length, r), r;
}
function $S(i) {
  return [new Ki(0, i, 0)];
}
let RS = "";
function RQ(i, e, t, r, s) {
  var n;
  let o = r.head - i.from, a = Ki.find(e, o, (n = r.bidiLevel) !== null && n !== void 0 ? n : -1, r.assoc), l = e[a], c = l.side(s, t);
  if (o == c) {
    let d = a += s ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[a = d], o = l.side(!s, t), c = l.side(s, t);
  }
  let h = Je(i.text, o, l.forward(s, t));
  (h < l.from || h > l.to) && (h = c), RS = i.text.slice(Math.min(o, h), Math.max(o, h));
  let u = a == (s ? e.length - 1 : 0) ? null : e[a + (s ? 1 : -1)];
  return u && h == c && u.level + (s ? 0 : 1) < l.level ? V.cursor(u.side(!s, t) + i.from, u.forward(s, t) ? 1 : -1, u.level) : V.cursor(h + i.from, l.forward(s, t) ? -1 : 1, l.level);
}
function EQ(i, e, t) {
  for (let r = e; r < t; r++) {
    let s = PS(i.charCodeAt(r));
    if (s == 1)
      return Lr;
    if (s == 2 || s == 4)
      return Sf;
  }
  return Lr;
}
const ES = /* @__PURE__ */ ee.define(), AS = /* @__PURE__ */ ee.define(), LS = /* @__PURE__ */ ee.define(), DS = /* @__PURE__ */ ee.define(), Jh = /* @__PURE__ */ ee.define(), MS = /* @__PURE__ */ ee.define(), BS = /* @__PURE__ */ ee.define(), vf = /* @__PURE__ */ ee.define(), _f = /* @__PURE__ */ ee.define(), qS = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e)
}), XS = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e)
}), IS = /* @__PURE__ */ ee.define();
class is {
  constructor(e, t = "nearest", r = "nearest", s = 5, n = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = s, this.xMargin = n, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new is(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new is(V.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const ko = /* @__PURE__ */ he.define({ map: (i, e) => i.map(e) }), ZS = /* @__PURE__ */ he.define();
function St(i, e, t) {
  let r = i.facet(DS);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Ri = /* @__PURE__ */ ee.define({ combine: (i) => i.length ? i[0] : !0 });
let AQ = 0;
const Fr = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (i[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class Ve {
  constructor(e, t, r, s, n) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = s, this.baseExtensions = n(this), this.extension = this.baseExtensions.concat(Fr.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Fr.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: s, provide: n, decorations: o } = t || {};
    return new Ve(AQ++, e, r, s, (a) => {
      let l = [];
      return o && l.push(Qn.of((c) => {
        let h = c.plugin(a);
        return h ? o(h) : ae.none;
      })), n && l.push(n(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Ve.define((r, s) => new e(r, s), t);
  }
}
class ac {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (St(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        St(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        St(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const WS = /* @__PURE__ */ ee.define(), bf = /* @__PURE__ */ ee.define(), Qn = /* @__PURE__ */ ee.define(), zS = /* @__PURE__ */ ee.define(), yf = /* @__PURE__ */ ee.define(), VS = /* @__PURE__ */ ee.define();
function kO(i, e) {
  let t = i.state.facet(VS);
  if (!t.length)
    return t;
  let r = t.map((n) => n instanceof Function ? n(i) : n), s = [];
  return be.spans(r, e.from, e.to, {
    point() {
    },
    span(n, o, a, l) {
      let c = n - e.from, h = o - e.from, u = s;
      for (let d = a.length - 1; d >= 0; d--, l--) {
        let O = a[d].spec.bidiIsolate, v;
        if (O == null && (O = EQ(e.text, c, h)), l > 0 && u.length && (v = u[u.length - 1]).to == c && v.direction == O)
          v.to = h, u = v.inner;
        else {
          let S = { from: c, to: h, direction: O, inner: [] };
          u.push(S), u = S.inner;
        }
      }
    }
  }), s;
}
const US = /* @__PURE__ */ ee.define();
function wf(i) {
  let e = 0, t = 0, r = 0, s = 0;
  for (let n of i.state.facet(US)) {
    let o = n(i);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (s = Math.max(s, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: s };
}
const Ys = /* @__PURE__ */ ee.define();
class qt {
  constructor(e, t, r, s) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = s;
  }
  join(e) {
    return new qt(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let s = e[t - 1];
      if (!(s.fromA > r.toA)) {
        if (s.toA < r.fromA)
          break;
        r = r.join(s), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let s = 0, n = 0, o = 0, a = 0; ; s++) {
      let l = s == e.length ? null : e[s], c = o - a, h = l ? l.fromB : 1e9;
      for (; n < t.length && t[n] < h; ) {
        let u = t[n], d = t[n + 1], O = Math.max(a, u), v = Math.min(h, d);
        if (O <= v && new qt(O + c, v + c, O, v).addToSet(r), d > h)
          break;
        n += 2;
      }
      if (!l)
        return r;
      new qt(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), o = l.toA, a = l.toB;
    }
  }
}
class Xa {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Ue.empty(this.startState.doc.length);
    for (let n of r)
      this.changes = this.changes.compose(n.changes);
    let s = [];
    this.changes.iterChangedRanges((n, o, a, l) => s.push(new qt(n, o, a, l))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Xa(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class CO extends Te {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ae.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Ze()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new qt(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? s = this.domChanged.newSel.head : !IQ(e.changes, this.hasComposition) && !e.selectionSet && (s = e.state.selection.main.head));
    let n = s > -1 ? DQ(this.view, e.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      r = new qt(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(r.slice());
    }
    this.hasComposition = n ? { from: n.range.fromB, to: n.range.toB } : null, (ie.ie || ie.chrome) && !n && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = qQ(o, a, e.changes);
    return r = qt.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, n), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = ie.chrome || ie.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || s.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let n = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Ai && o.widget instanceof Fh && n.push(o.dom);
    s.updateGaps(n);
  }
  updateChildren(e, t, r) {
    let s = r ? r.range.addToSet(e.slice()) : e, n = this.childCursor(t);
    for (let o = s.length - 1; ; o--) {
      let a = o >= 0 ? s[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: h, toB: u } = a, d, O, v, S;
      if (r && r.range.fromB < u && r.range.toB > h) {
        let _ = on.build(this.view.state.doc, h, r.range.fromB, this.decorations, this.dynamicDecorationMap), b = on.build(this.view.state.doc, r.range.toB, u, this.decorations, this.dynamicDecorationMap);
        O = _.breakAtStart, v = _.openStart, S = b.openEnd;
        let w = this.compositionView(r);
        b.breakAtStart ? w.breakAfter = 1 : b.content.length && w.merge(w.length, w.length, b.content[0], !1, b.openStart, 0) && (w.breakAfter = b.content[0].breakAfter, b.content.shift()), _.content.length && w.merge(0, 0, _.content[_.content.length - 1], !0, 0, _.openEnd) && _.content.pop(), d = _.content.concat(w).concat(b.content);
      } else
        ({ content: d, breakAtStart: O, openStart: v, openEnd: S } = on.build(this.view.state.doc, h, u, this.decorations, this.dynamicDecorationMap));
      let { i: f, off: p } = n.findPos(c, 1), { i: g, off: m } = n.findPos(l, -1);
      vS(this, g, m, f, p, d, O, v, S);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(ZS) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new Yt(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: s } of e.marks)
      t = new qi(s, [t], t.length);
    let r = new Ze();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (n, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = Te.get(n);
      a && a != o && (a.dom = null), o.setDOM(n);
    }, r = this.childPos(e.range.fromB, 1), s = this.children[r.i];
    t(e.line, s);
    for (let n = e.marks.length - 1; n >= -1; n--)
      r = s.childPos(r.off, 1), s = s.children[r.i], t(n >= 0 ? e.marks[n].node : e.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, s = r == this.dom, n = !s && !(this.view.state.facet(Ri) || this.dom.tabIndex > -1) && sa(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(s || t || n))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (ie.gecko && a.empty && !this.hasComposition && LQ(l)) {
      let u = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(u, l.node.childNodes[l.offset] || null)), l = c = new rt(u, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || (!nn(l.node, l.offset, h.anchorNode, h.anchorOffset) || !nn(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, a)) && (this.view.observer.ignore(() => {
      ie.android && ie.chrome && this.dom.contains(h.focusNode) && XQ(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let u = kn(this.view.root);
      if (u) if (a.empty) {
        if (ie.gecko) {
          let d = MQ(l.node, l.offset);
          if (d && d != 3) {
            let O = (d == 1 ? gS : mS)(l.node, l.offset);
            O && (l = new rt(O.node, O.offset));
          }
        }
        u.collapse(l.node, l.offset), a.bidiLevel != null && u.caretBidiLevel !== void 0 && (u.caretBidiLevel = a.bidiLevel);
      } else if (u.extend) {
        u.collapse(l.node, l.offset);
        try {
          u.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        a.anchor > a.head && ([l, c] = [c, l]), d.setEnd(c.node, c.offset), d.setStart(l.node, l.offset), u.removeAllRanges(), u.addRange(d);
      }
      n && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new rt(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new rt(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && nn(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = kn(e.root), { anchorNode: s, anchorOffset: n } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = Ze.find(this, t.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (t.head == a || t.head == a + o.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    r.collapse(h.node, h.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && r.collapse(s, n);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let s = e.offset; !r && s < t.childNodes.length; s++) {
      let n = Te.get(t.childNodes[s]);
      n instanceof Ze && (r = n.domAtPos(0));
    }
    for (let s = e.offset - 1; !r && s >= 0; s--) {
      let n = Te.get(t.childNodes[s]);
      n instanceof Ze && (r = n.domAtPos(n.length));
    }
    return r ? new rt(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = Te.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let s = this.children[t];
      if (r < s.length || s instanceof Ze)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, s = 0;
    for (let n = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = n - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof Ze && !(r instanceof Ze && t >= 0)))
        r = a, s = c;
      else if (r && c == e && l == e && a instanceof Ai && Math.abs(t) < 2) {
        if (a.deco.startSide < 0)
          break;
        o && (r = null);
      }
      n = c;
    }
    return r ? r.coordsAt(e - s, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), s = this.children[t];
    if (!(s instanceof Ze))
      return null;
    for (; s.children.length; ) {
      let { i: a, off: l } = s.childPos(r, 1);
      for (; ; a++) {
        if (a == s.children.length)
          return null;
        if ((s = s.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(s instanceof Yt))
      return null;
    let n = Je(s.text, r);
    if (n == r)
      return null;
    let o = Ar(s.dom, r, n).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: s } = e, n = this.view.contentDOM.clientWidth, o = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Le.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let u = this.children[h], d = c + u.length;
      if (d > s)
        break;
      if (c >= r) {
        let O = u.dom.getBoundingClientRect();
        if (t.push(O.height), o) {
          let v = u.dom.lastChild, S = v ? Cn(v) : [];
          if (S.length) {
            let f = S[S.length - 1], p = l ? f.right - O.left : O.right - f.left;
            p > a && (a = p, this.minWidth = n, this.minWidthFrom = c, this.minWidthTo = d);
          }
        }
      }
      c = d + u.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Le.RTL : Le.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof Ze) {
        let o = n.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, s;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let n = Cn(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = n ? n.width / 27 : 7, s = n ? n.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: s };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new SS(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, s = 0; ; s++) {
      let n = s == t.viewports.length ? null : t.viewports[s], o = n ? n.from - 1 : this.length;
      if (o > r) {
        let a = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(ae.replace({
          widget: new Fh(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!n)
        break;
      r = n.to + 1;
    }
    return ae.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(Qn).map((n) => (this.dynamicDecorationMap[e++] = typeof n == "function") ? n(this.view) : n), r = !1, s = this.view.state.facet(zS).map((n, o) => {
      let a = typeof n == "function";
      return a && (r = !0), a ? n(this.view) : n;
    });
    for (s.length && (this.dynamicDecorationMap[e++] = r, t.push(be.join(s))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(IS))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (h) {
        St(this.view.state, h, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), s;
    if (!r)
      return;
    !t.empty && (s = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, s.left),
      top: Math.min(r.top, s.top),
      right: Math.max(r.right, s.right),
      bottom: Math.max(r.bottom, s.bottom)
    });
    let n = wf(this.view), o = {
      left: r.left - n.left,
      top: r.top - n.top,
      right: r.right + n.right,
      bottom: r.bottom + n.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    fQ(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Le.LTR);
  }
}
function LQ(i) {
  return i.node.nodeType == 1 && i.node.firstChild && (i.offset == 0 || i.node.childNodes[i.offset - 1].contentEditable == "false") && (i.offset == i.node.childNodes.length || i.node.childNodes[i.offset].contentEditable == "false");
}
function jS(i, e) {
  let t = i.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = gS(t.focusNode, t.focusOffset), s = mS(t.focusNode, t.focusOffset), n = r || s;
  if (s && r && s.node != r.node) {
    let a = Te.get(s.node);
    if (!a || a instanceof Yt && a.text != s.node.nodeValue)
      n = s;
    else if (i.docView.lastCompositionAfterCursor) {
      let l = Te.get(r.node);
      !l || l instanceof Yt && l.text != r.node.nodeValue || (n = s);
    }
  }
  if (i.docView.lastCompositionAfterCursor = n != r, !n)
    return null;
  let o = e - n.offset;
  return { from: o, to: o + n.node.nodeValue.length, node: n.node };
}
function DQ(i, e, t) {
  let r = jS(i, t);
  if (!r)
    return null;
  let { node: s, from: n, to: o } = r, a = s.nodeValue;
  if (/[\n\r]/.test(a) || i.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = e.invertedDesc, c = new qt(l.mapPos(n), l.mapPos(o), n, o), h = [];
  for (let u = s.parentNode; ; u = u.parentNode) {
    let d = Te.get(u);
    if (d instanceof qi)
      h.push({ node: u, deco: d.mark });
    else {
      if (d instanceof Ze || u.nodeName == "DIV" && u.parentNode == i.contentDOM)
        return { range: c, text: s, marks: h, line: u };
      if (u != i.contentDOM)
        h.push({ node: u, deco: new so({
          inclusive: !0,
          attributes: yQ(u),
          tagName: u.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function MQ(i, e) {
  return i.nodeType != 1 ? 0 : (e && i.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < i.childNodes.length && i.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let BQ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    na(e, t, this.changes);
  }
  comparePoint(e, t) {
    na(e, t, this.changes);
  }
  boundChange(e) {
    na(e, e, this.changes);
  }
};
function qQ(i, e, t) {
  let r = new BQ();
  return be.compare(i, e, t, r), r.changes;
}
function XQ(i, e) {
  for (let t = i; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function IQ(i, e) {
  let t = !1;
  return e && i.iterChangedRanges((r, s) => {
    r < e.to && s > e.from && (t = !0);
  }), t;
}
function ZQ(i, e, t = 1) {
  let r = i.charCategorizer(e), s = i.doc.lineAt(e), n = e - s.from;
  if (s.length == 0)
    return V.cursor(e);
  n == 0 ? t = 1 : n == s.length && (t = -1);
  let o = n, a = n;
  t < 0 ? o = Je(s.text, n, !1) : a = Je(s.text, n);
  let l = r(s.text.slice(o, a));
  for (; o > 0; ) {
    let c = Je(s.text, o, !1);
    if (r(s.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < s.length; ) {
    let c = Je(s.text, a);
    if (r(s.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return V.range(o + s.from, a + s.from);
}
function WQ(i, e) {
  return e.left > i ? e.left - i : Math.max(0, i - e.right);
}
function zQ(i, e) {
  return e.top > i ? e.top - i : Math.max(0, i - e.bottom);
}
function lc(i, e) {
  return i.top < e.bottom - 1 && i.bottom > e.top + 1;
}
function QO(i, e) {
  return e < i.top ? { top: e, left: i.left, right: i.right, bottom: i.bottom } : i;
}
function PO(i, e) {
  return e > i.bottom ? { top: i.top, left: i.left, right: i.right, bottom: e } : i;
}
function eu(i, e, t) {
  let r, s, n, o, a = !1, l, c, h, u;
  for (let v = i.firstChild; v; v = v.nextSibling) {
    let S = Cn(v);
    for (let f = 0; f < S.length; f++) {
      let p = S[f];
      s && lc(s, p) && (p = QO(PO(p, s.bottom), s.top));
      let g = WQ(e, p), m = zQ(t, p);
      if (g == 0 && m == 0)
        return v.nodeType == 3 ? TO(v, e, t) : eu(v, e, t);
      if (!r || o > m || o == m && n > g) {
        r = v, s = p, n = g, o = m;
        let _ = m ? t < p.top ? -1 : 1 : g ? e < p.left ? -1 : 1 : 0;
        a = !_ || (_ > 0 ? f < S.length - 1 : f > 0);
      }
      g == 0 ? t > p.bottom && (!h || h.bottom < p.bottom) ? (l = v, h = p) : t < p.top && (!u || u.top > p.top) && (c = v, u = p) : h && lc(h, p) ? h = PO(h, p.bottom) : u && lc(u, p) && (u = QO(u, p.top));
    }
  }
  if (h && h.bottom >= t ? (r = l, s = h) : u && u.top <= t && (r = c, s = u), !r)
    return { node: i, offset: 0 };
  let d = Math.max(s.left, Math.min(s.right, e));
  if (r.nodeType == 3)
    return TO(r, d, t);
  if (a && r.contentEditable != "false")
    return eu(r, d, t);
  let O = Array.prototype.indexOf.call(i.childNodes, r) + (e >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: i, offset: O };
}
function TO(i, e, t) {
  let r = i.nodeValue.length, s = -1, n = 1e9, o = 0;
  for (let a = 0; a < r; a++) {
    let l = Ar(i, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let h = l[c];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let u = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && u < n) {
        let d = e >= (h.left + h.right) / 2, O = d;
        if ((ie.chrome || ie.gecko) && Ar(i, a).getBoundingClientRect().left == h.right && (O = !d), u <= 0)
          return { node: i, offset: a + (O ? 1 : 0) };
        s = a + (O ? 1 : 0), n = u;
      }
    }
  }
  return { node: i, offset: s > -1 ? s : o > 0 ? i.nodeValue.length : 0 };
}
function NS(i, e, t, r = -1) {
  var s, n;
  let o = i.contentDOM.getBoundingClientRect(), a = o.top + i.viewState.paddingTop, l, { docHeight: c } = i.viewState, { x: h, y: u } = e, d = u - a;
  if (d < 0)
    return 0;
  if (d > c)
    return i.state.doc.length;
  for (let _ = i.viewState.heightOracle.textHeight / 2, b = !1; l = i.elementAtHeight(d), l.type != ht.Text; )
    for (; d = r > 0 ? l.bottom + _ : l.top - _, !(d >= 0 && d <= c); ) {
      if (b)
        return t ? null : 0;
      b = !0, r = -r;
    }
  u = a + d;
  let O = l.from;
  if (O < i.viewport.from)
    return i.viewport.from == 0 ? 0 : t ? null : $O(i, o, l, h, u);
  if (O > i.viewport.to)
    return i.viewport.to == i.state.doc.length ? i.state.doc.length : t ? null : $O(i, o, l, h, u);
  let v = i.dom.ownerDocument, S = i.root.elementFromPoint ? i.root : v, f = S.elementFromPoint(h, u);
  f && !i.contentDOM.contains(f) && (f = null), f || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), f = S.elementFromPoint(h, u), f && !i.contentDOM.contains(f) && (f = null));
  let p, g = -1;
  if (f && ((s = i.docView.nearest(f)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (v.caretPositionFromPoint) {
      let _ = v.caretPositionFromPoint(h, u);
      _ && ({ offsetNode: p, offset: g } = _);
    } else if (v.caretRangeFromPoint) {
      let _ = v.caretRangeFromPoint(h, u);
      _ && ({ startContainer: p, startOffset: g } = _, (!i.contentDOM.contains(p) || ie.safari && VQ(p, g, h) || ie.chrome && UQ(p, g, h)) && (p = void 0));
    }
    p && (g = Math.min(mi(p), g));
  }
  if (!p || !i.docView.dom.contains(p)) {
    let _ = Ze.find(i.docView, O);
    if (!_)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: p, offset: g } = eu(_.dom, h, u));
  }
  let m = i.docView.nearest(p);
  if (!m)
    return null;
  if (m.isWidget && ((n = m.dom) === null || n === void 0 ? void 0 : n.nodeType) == 1) {
    let _ = m.dom.getBoundingClientRect();
    return e.y < _.top || e.y <= _.bottom && e.x <= (_.left + _.right) / 2 ? m.posAtStart : m.posAtEnd;
  } else
    return m.localPosFromDOM(p, g) + m.posAtStart;
}
function $O(i, e, t, r, s) {
  let n = Math.round((r - e.left) * i.defaultCharacterWidth);
  if (i.lineWrapping && t.height > i.defaultLineHeight * 1.5) {
    let a = i.viewState.heightOracle.textHeight, l = Math.floor((s - t.top - (i.defaultLineHeight - a) * 0.5) / a);
    n += l * i.viewState.heightOracle.lineLength;
  }
  let o = i.state.sliceDoc(t.from, t.to);
  return t.from + Ih(o, n, i.state.tabSize);
}
function VQ(i, e, t) {
  let r;
  if (i.nodeType != 3 || e != (r = i.nodeValue.length))
    return !1;
  for (let s = i.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return Ar(i, r - 1, r).getBoundingClientRect().left > t;
}
function UQ(i, e, t) {
  if (e != 0)
    return !1;
  for (let s = i; ; ) {
    let n = s.parentNode;
    if (!n || n.nodeType != 1 || n.firstChild != s)
      return !1;
    if (n.classList.contains("cm-line"))
      break;
    s = n;
  }
  let r = i.nodeType == 1 ? i.getBoundingClientRect() : Ar(i, 0, Math.max(i.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function tu(i, e, t) {
  let r = i.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let s;
    for (let n of r.type) {
      if (n.from > e)
        break;
      if (!(n.to < e)) {
        if (n.from < e && n.to > e)
          return n;
        (!s || n.type == ht.Text && (s.type != n.type || (t < 0 ? n.from < e : n.to > e))) && (s = n);
      }
    }
    return s || r;
  }
  return r;
}
function jQ(i, e, t, r) {
  let s = tu(i, e.head, e.assoc || -1), n = !r || s.type != ht.Text || !(i.lineWrapping || s.widgetLineBreaks) ? null : i.coordsAtPos(e.assoc < 0 && e.head > s.from ? e.head - 1 : e.head);
  if (n) {
    let o = i.dom.getBoundingClientRect(), a = i.textDirectionAt(s.from), l = i.posAtCoords({
      x: t == (a == Le.LTR) ? o.right - 1 : o.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (l != null)
      return V.cursor(l, t ? -1 : 1);
  }
  return V.cursor(t ? s.to : s.from, t ? -1 : 1);
}
function RO(i, e, t, r) {
  let s = i.state.doc.lineAt(e.head), n = i.bidiSpans(s), o = i.textDirectionAt(s.from);
  for (let a = e, l = null; ; ) {
    let c = RQ(s, n, o, a, t), h = RS;
    if (!c) {
      if (s.number == (t ? i.state.doc.lines : 1))
        return a;
      h = `
`, s = i.state.doc.line(s.number + (t ? 1 : -1)), n = i.bidiSpans(s), c = i.visualLineSide(s, !t);
    }
    if (l) {
      if (!l(h))
        return a;
    } else {
      if (!r)
        return c;
      l = r(h);
    }
    a = c;
  }
}
function NQ(i, e, t) {
  let r = i.state.charCategorizer(e), s = r(t);
  return (n) => {
    let o = r(n);
    return s == De.Space && (s = o), s == o;
  };
}
function YQ(i, e, t, r) {
  let s = e.head, n = t ? 1 : -1;
  if (s == (t ? i.state.doc.length : 0))
    return V.cursor(s, e.assoc);
  let o = e.goalColumn, a, l = i.contentDOM.getBoundingClientRect(), c = i.coordsAtPos(s, e.assoc || -1), h = i.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = n < 0 ? c.top : c.bottom;
  else {
    let O = i.viewState.lineBlockAt(s);
    o == null && (o = Math.min(l.right - l.left, i.defaultCharacterWidth * (s - O.from))), a = (n < 0 ? O.top : O.bottom) + h;
  }
  let u = l.left + o, d = r ?? i.viewState.heightOracle.textHeight >> 1;
  for (let O = 0; ; O += 10) {
    let v = a + (d + O) * n, S = NS(i, { x: u, y: v }, !1, n);
    if (v < l.top || v > l.bottom || (n < 0 ? S < s : S > s)) {
      let f = i.docView.coordsForChar(S), p = !f || v < f.top ? -1 : 1;
      return V.cursor(S, p, void 0, o);
    }
  }
}
function oa(i, e, t) {
  for (; ; ) {
    let r = 0;
    for (let s of i)
      s.between(e - 1, e + 1, (n, o, a) => {
        if (e > n && e < o) {
          let l = r || t || (e - n < o - e ? -1 : 1);
          e = l < 0 ? n : o, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function cc(i, e, t) {
  let r = oa(i.state.facet(yf).map((s) => s(i)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : V.cursor(r, r < t.from ? 1 : -1);
}
const Fs = "";
class FQ {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(ve.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Fs;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let s = e; ; ) {
      this.findPointBefore(r, s);
      let n = this.text.length;
      this.readNode(s);
      let o = s.nextSibling;
      if (o == t)
        break;
      let a = Te.get(s), l = Te.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Ba(s)) || Ba(o) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > n) && this.lineBreak(), s = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, o = 1, a;
      if (this.lineSeparator ? (n = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (a = s.exec(t)) && (n = a.index, o = a[0].length), this.append(t.slice(r, n < 0 ? t.length : n)), n < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      r = n + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Te.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let s = r.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (HQ(e, r.node, r.offset) ? t : 0));
  }
}
function HQ(i, e, t) {
  for (; ; ) {
    if (!e || t < mi(e))
      return !1;
    if (e == i)
      return !0;
    t = Er(e) + 1, e = e.parentNode;
  }
}
class EO {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class GQ {
  constructor(e, t, r, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: n, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let a = n || o ? [] : eP(e), l = new FQ(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = tP(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = n && n.node == a.focusNode && n.offset == a.focusOffset || !zh(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !zh(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), h = e.viewport;
      if ((ie.ios || ie.chrome) && e.state.selection.main.empty && l != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let u = Math.min(l, c), d = Math.max(l, c), O = h.from - u, v = h.to - d;
        (O == 0 || O == 1 || u == 0) && (v == 0 || v == -1 || d == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = V.single(c, l);
    }
  }
}
function YS(i, e) {
  let t, { newSel: r } = e, s = i.state.selection.main, n = i.inputState.lastKeyTime > Date.now() - 100 ? i.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = s.from, c = null;
    (n === 8 || ie.android && e.text.length < a - o) && (l = s.to, c = "end");
    let h = JQ(i.state.doc.sliceString(o, a, Fs), e.text, l - o, c);
    h && (ie.chrome && n == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Fs + Fs && h.toB--, t = {
      from: o + h.from,
      to: o + h.toA,
      insert: _e.of(e.text.slice(h.from, h.toB).split(Fs))
    });
  } else r && (!i.hasFocus && i.state.facet(Ri) || r.main.eq(s)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !s.empty && r && r.main.empty ? t = { from: s.from, to: s.to, insert: i.state.doc.slice(s.from, s.to) } : (ie.mac || ie.android) && t && t.from == t.to && t.from == s.head - 1 && /^\. ?$/.test(t.insert.toString()) && i.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = V.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: _e.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= s.from && t.to <= s.to && (t.from != s.from || t.to != s.to) && s.to - s.from - (t.to - t.from) <= 4 ? t = {
    from: s.from,
    to: s.to,
    insert: i.state.doc.slice(s.from, t.from).append(t.insert).append(i.state.doc.slice(t.to, s.to))
  } : ie.chrome && t && t.from == t.to && t.from == s.head && t.insert.toString() == `
 ` && i.lineWrapping && (r && (r = V.single(r.main.anchor - 1, r.main.head - 1)), t = { from: s.from, to: s.to, insert: _e.of([" "]) }), t)
    return xf(i, t, r, n);
  if (r && !r.main.eq(s)) {
    let o = !1, a = "select";
    return i.inputState.lastSelectionTime > Date.now() - 50 && (i.inputState.lastSelectionOrigin == "select" && (o = !0), a = i.inputState.lastSelectionOrigin), i.dispatch({ selection: r, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function xf(i, e, t, r = -1) {
  if (ie.ios && i.inputState.flushIOSKey(e))
    return !0;
  let s = i.state.selection.main;
  if (ie.android && (e.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == s.from || e.from == s.from - 1 && i.state.sliceDoc(e.from, s.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && ts(i.contentDOM, "Enter", 13) || (e.from == s.from - 1 && e.to == s.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > s.head) && ts(i.contentDOM, "Backspace", 8) || e.from == s.from && e.to == s.to + 1 && e.insert.length == 0 && ts(i.contentDOM, "Delete", 46)))
    return !0;
  let n = e.insert.toString();
  i.inputState.composing >= 0 && i.inputState.composing++;
  let o, a = () => o || (o = KQ(i, e, t));
  return i.state.facet(MS).some((l) => l(i, e.from, e.to, n, a)) || i.dispatch(a()), !0;
}
function KQ(i, e, t) {
  let r, s = i.state, n = s.selection.main;
  if (e.from >= n.from && e.to <= n.to && e.to - e.from >= (n.to - n.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && i.inputState.composing < 0) {
    let a = n.from < e.from ? s.sliceDoc(n.from, e.from) : "", l = n.to > e.to ? s.sliceDoc(e.to, n.to) : "";
    r = s.replaceSelection(i.state.toText(a + e.insert.sliceString(0, void 0, i.state.lineBreak) + l));
  } else {
    let a = s.changes(e), l = t && t.main.to <= a.newLength ? t.main : void 0;
    if (s.selection.ranges.length > 1 && i.inputState.composing >= 0 && e.to <= n.to && e.to >= n.to - 10) {
      let c = i.state.sliceDoc(e.from, e.to), h, u = t && jS(i, t.main.head);
      if (u) {
        let v = e.insert.length - (e.to - e.from);
        h = { from: u.from, to: u.to - v };
      } else
        h = i.state.doc.lineAt(n.head);
      let d = n.to - e.to, O = n.to - n.from;
      r = s.changeByRange((v) => {
        if (v.from == n.from && v.to == n.to)
          return { changes: a, range: l || v.map(a) };
        let S = v.to - d, f = S - c.length;
        if (v.to - v.from != O || i.state.sliceDoc(f, S) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        v.to >= h.from && v.from <= h.to)
          return { range: v };
        let p = s.changes({ from: f, to: S, insert: e.insert }), g = v.to - n.to;
        return {
          changes: p,
          range: l ? V.range(Math.max(0, l.anchor + g), Math.max(0, l.head + g)) : v.map(p)
        };
      });
    } else
      r = {
        changes: a,
        selection: l && s.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (i.composing || i.inputState.compositionPendingChange && i.inputState.compositionEndedAt > Date.now() - 50) && (i.inputState.compositionPendingChange = !1, o += ".compose", i.inputState.compositionFirstChange && (o += ".start", i.inputState.compositionFirstChange = !1)), s.update(r, { userEvent: o, scrollIntoView: !0 });
}
function JQ(i, e, t, r) {
  let s = Math.min(i.length, e.length), n = 0;
  for (; n < s && i.charCodeAt(n) == e.charCodeAt(n); )
    n++;
  if (n == s && i.length == e.length)
    return null;
  let o = i.length, a = e.length;
  for (; o > 0 && a > 0 && i.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (r == "end") {
    let l = Math.max(0, n - Math.min(o, a));
    t -= o + l - n;
  }
  if (o < n && i.length < e.length) {
    let l = t <= n && t >= o ? n - t : 0;
    n -= l, a = n + (a - o), o = n;
  } else if (a < n) {
    let l = t <= n && t >= a ? n - t : 0;
    n -= l, o = n + (o - a), a = n;
  }
  return { from: n, toA: o, toB: a };
}
function eP(i) {
  let e = [];
  if (i.root.activeElement != i.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: s, focusOffset: n } = i.observer.selectionRange;
  return t && (e.push(new EO(t, r)), (s != t || n != r) && e.push(new EO(s, n))), e;
}
function tP(i, e) {
  if (i.length == 0)
    return null;
  let t = i[0].pos, r = i.length == 2 ? i[1].pos : t;
  return t > -1 && r > -1 ? V.single(t + e, r + e) : null;
}
class iP {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ie.safari && e.contentDOM.addEventListener("input", () => null), ie.gecko && SP(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !hP(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let s of r.observers)
        s(this.view, t);
      for (let s of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (s(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = rP(e), r = this.handlers, s = this.view.contentDOM;
    for (let n in t)
      if (n != "scroll") {
        let o = !t[n].handlers.length, a = r[n];
        a && o != !a.handlers.length && (s.removeEventListener(n, this.handleEvent), a = null), a || s.addEventListener(n, this.handleEvent, { passive: o });
      }
    for (let n in r)
      n != "scroll" && !t[n] && s.removeEventListener(n, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && HS.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), ie.android && ie.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return ie.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = FS.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || sP.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ts(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ie.safari && !ie.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function AO(i, e) {
  return (t, r) => {
    try {
      return e.call(i, r, t);
    } catch (s) {
      St(t.state, s);
    }
  };
}
function rP(i) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of i) {
    let s = r.spec, n = s && s.plugin.domEventHandlers, o = s && s.plugin.domEventObservers;
    if (n)
      for (let a in n) {
        let l = n[a];
        l && t(a).handlers.push(AO(r.value, l));
      }
    if (o)
      for (let a in o) {
        let l = o[a];
        l && t(a).observers.push(AO(r.value, l));
      }
  }
  for (let r in Ft)
    t(r).handlers.push(Ft[r]);
  for (let r in Xt)
    t(r).observers.push(Xt[r]);
  return e;
}
const FS = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], sP = "dthko", HS = [16, 17, 18, 20, 91, 92, 224, 225], Co = 6;
function Qo(i) {
  return Math.max(0, i) * 0.7 + 8;
}
function nP(i, e) {
  return Math.max(Math.abs(i.clientX - e.clientX), Math.abs(i.clientY - e.clientY));
}
class oP {
  constructor(e, t, r, s) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = dQ(e.contentDOM), this.atoms = e.state.facet(yf).map((o) => o(e));
    let n = e.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(ve.allowMultipleSelections) && aP(e, t), this.dragging = cP(e, t) && JS(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && nP(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, s = 0, n = 0, o = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: n, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = wf(this.view);
    e.clientX - l.left <= s + Co ? t = -Qo(s - e.clientX) : e.clientX + l.right >= o - Co && (t = Qo(e.clientX - o)), e.clientY - l.top <= n + Co ? r = -Qo(n - e.clientY) : e.clientY + l.bottom >= a - Co && (r = Qo(e.clientY - a)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let s = e.ranges[r], n = null;
      if (s.empty) {
        let o = oa(this.atoms, s.from, 0);
        o != s.from && (n = V.cursor(o, -1));
      } else {
        let o = oa(this.atoms, s.from, -1), a = oa(this.atoms, s.to, 1);
        (o != s.from || a != s.to) && (n = V.range(s.from == s.anchor ? o : a, s.from == s.head ? o : a));
      }
      n && (t || (t = e.ranges.slice()), t[r] = n);
    }
    return t ? V.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function aP(i, e) {
  let t = i.state.facet(ES);
  return t.length ? t[0](e) : ie.mac ? e.metaKey : e.ctrlKey;
}
function lP(i, e) {
  let t = i.state.facet(AS);
  return t.length ? t[0](e) : ie.mac ? !e.altKey : !e.ctrlKey;
}
function cP(i, e) {
  let { main: t } = i.state.selection;
  if (t.empty)
    return !1;
  let r = kn(i.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let s = r.getRangeAt(0).getClientRects();
  for (let n = 0; n < s.length; n++) {
    let o = s[n];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function hP(i, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != i.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = Te.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const Ft = /* @__PURE__ */ Object.create(null), Xt = /* @__PURE__ */ Object.create(null), GS = ie.ie && ie.ie_version < 15 || ie.ios && ie.webkit_version < 604;
function uP(i) {
  let e = i.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    i.focus(), t.remove(), KS(i, t.value);
  }, 50);
}
function Pl(i, e, t) {
  for (let r of i.facet(e))
    t = r(t, i);
  return t;
}
function KS(i, e) {
  e = Pl(i.state, vf, e);
  let { state: t } = i, r, s = 1, n = t.toText(e), o = n.lines == t.selection.ranges.length;
  if (iu != null && t.selection.ranges.every((l) => l.empty) && iu == n.toString()) {
    let l = -1;
    r = t.changeByRange((c) => {
      let h = t.doc.lineAt(c.from);
      if (h.from == l)
        return { range: c };
      l = h.from;
      let u = t.toText((o ? n.line(s++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: V.cursor(c.from + u.length)
      };
    });
  } else o ? r = t.changeByRange((l) => {
    let c = n.line(s++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: V.cursor(l.from + c.length)
    };
  }) : r = t.replaceSelection(n);
  i.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Xt.scroll = (i) => {
  i.inputState.lastScrollTop = i.scrollDOM.scrollTop, i.inputState.lastScrollLeft = i.scrollDOM.scrollLeft;
};
Ft.keydown = (i, e) => (i.inputState.setSelectionOrigin("select"), e.keyCode == 27 && i.inputState.tabFocusMode != 0 && (i.inputState.tabFocusMode = Date.now() + 2e3), !1);
Xt.touchstart = (i, e) => {
  i.inputState.lastTouchTime = Date.now(), i.inputState.setSelectionOrigin("select.pointer");
};
Xt.touchmove = (i) => {
  i.inputState.setSelectionOrigin("select.pointer");
};
Ft.mousedown = (i, e) => {
  if (i.observer.flush(), i.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of i.state.facet(LS))
    if (t = r(i, e), t)
      break;
  if (!t && e.button == 0 && (t = OP(i, e)), t) {
    let r = !i.hasFocus;
    i.inputState.startMouseSelection(new oP(i, e, t, r)), r && i.observer.ignore(() => {
      dS(i.contentDOM);
      let n = i.root.activeElement;
      n && !n.contains(i.contentDOM) && n.blur();
    });
    let s = i.inputState.mouseSelection;
    if (s)
      return s.start(e), s.dragging === !1;
  }
  return !1;
};
function LO(i, e, t, r) {
  if (r == 1)
    return V.cursor(e, t);
  if (r == 2)
    return ZQ(i.state, e, t);
  {
    let s = Ze.find(i.docView, e), n = i.state.doc.lineAt(s ? s.posAtEnd : e), o = s ? s.posAtStart : n.from, a = s ? s.posAtEnd : n.to;
    return a < i.state.doc.length && a == n.to && a++, V.range(o, a);
  }
}
let DO = (i, e, t) => e >= t.top && e <= t.bottom && i >= t.left && i <= t.right;
function fP(i, e, t, r) {
  let s = Ze.find(i.docView, e);
  if (!s)
    return 1;
  let n = e - s.posAtStart;
  if (n == 0)
    return 1;
  if (n == s.length)
    return -1;
  let o = s.coordsAt(n, -1);
  if (o && DO(t, r, o))
    return -1;
  let a = s.coordsAt(n, 1);
  return a && DO(t, r, a) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function MO(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: fP(i, t, e.clientX, e.clientY) };
}
const dP = ie.ie && ie.ie_version <= 11;
let BO = null, qO = 0, XO = 0;
function JS(i) {
  if (!dP)
    return i.detail;
  let e = BO, t = XO;
  return BO = i, XO = Date.now(), qO = !e || t > Date.now() - 400 && Math.abs(e.clientX - i.clientX) < 2 && Math.abs(e.clientY - i.clientY) < 2 ? (qO + 1) % 3 : 1;
}
function OP(i, e) {
  let t = MO(i, e), r = JS(e), s = i.state.selection;
  return {
    update(n) {
      n.docChanged && (t.pos = n.changes.mapPos(t.pos), s = s.map(n.changes));
    },
    get(n, o, a) {
      let l = MO(i, n), c, h = LO(i, l.pos, l.bias, r);
      if (t.pos != l.pos && !o) {
        let u = LO(i, t.pos, t.bias, r), d = Math.min(u.from, h.from), O = Math.max(u.to, h.to);
        h = d < h.from ? V.range(d, O) : V.range(O, d);
      }
      return o ? s.replaceRange(s.main.extend(h.from, h.to)) : a && r == 1 && s.ranges.length > 1 && (c = pP(s, l.pos)) ? c : a ? s.addRange(h) : V.create([h]);
    }
  };
}
function pP(i, e) {
  for (let t = 0; t < i.ranges.length; t++) {
    let { from: r, to: s } = i.ranges[t];
    if (r <= e && s >= e)
      return V.create(i.ranges.slice(0, t).concat(i.ranges.slice(t + 1)), i.mainIndex == t ? 0 : i.mainIndex - (i.mainIndex > t ? 1 : 0));
  }
  return null;
}
Ft.dragstart = (i, e) => {
  let { selection: { main: t } } = i.state;
  if (e.target.draggable) {
    let s = i.docView.nearest(e.target);
    if (s && s.isWidget) {
      let n = s.posAtStart, o = n + s.length;
      (n >= t.to || o <= t.from) && (t = V.range(n, o));
    }
  }
  let { inputState: r } = i;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", Pl(i.state, _f, i.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ft.dragend = (i) => (i.inputState.draggedContent = null, !1);
function IO(i, e, t, r) {
  if (t = Pl(i.state, vf, t), !t)
    return;
  let s = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: n } = i.inputState, o = r && n && lP(i, e) ? { from: n.from, to: n.to } : null, a = { from: s, insert: t }, l = i.state.changes(o ? [o, a] : a);
  i.focus(), i.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(s, -1), head: l.mapPos(s, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), i.inputState.draggedContent = null;
}
Ft.drop = (i, e) => {
  if (!e.dataTransfer)
    return !1;
  if (i.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), s = 0, n = () => {
      ++s == t.length && IO(i, e, r.filter((o) => o != null).join(i.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let a = new FileReader();
      a.onerror = n, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), n();
      }, a.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return IO(i, e, r, !0), !0;
  }
  return !1;
};
Ft.paste = (i, e) => {
  if (i.state.readOnly)
    return !0;
  i.observer.flush();
  let t = GS ? null : e.clipboardData;
  return t ? (KS(i, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (uP(i), !1);
};
function gP(i, e) {
  let t = i.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), i.focus();
  }, 50);
}
function mP(i) {
  let e = [], t = [], r = !1;
  for (let s of i.selection.ranges)
    s.empty || (e.push(i.sliceDoc(s.from, s.to)), t.push(s));
  if (!e.length) {
    let s = -1;
    for (let { from: n } of i.selection.ranges) {
      let o = i.doc.lineAt(n);
      o.number > s && (e.push(o.text), t.push({ from: o.from, to: Math.min(i.doc.length, o.to + 1) })), s = o.number;
    }
    r = !0;
  }
  return { text: Pl(i, _f, e.join(i.lineBreak)), ranges: t, linewise: r };
}
let iu = null;
Ft.copy = Ft.cut = (i, e) => {
  let { text: t, ranges: r, linewise: s } = mP(i.state);
  if (!t && !s)
    return !1;
  iu = s ? t : null, e.type == "cut" && !i.state.readOnly && i.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let n = GS ? null : e.clipboardData;
  return n ? (n.clearData(), n.setData("text/plain", t), !0) : (gP(i, t), !1);
};
const ev = /* @__PURE__ */ Wi.define();
function tv(i, e) {
  let t = [];
  for (let r of i.facet(BS)) {
    let s = r(i, e);
    s && t.push(s);
  }
  return t.length ? i.update({ effects: t, annotations: ev.of(!0) }) : null;
}
function iv(i) {
  setTimeout(() => {
    let e = i.hasFocus;
    if (e != i.inputState.notifiedFocused) {
      let t = tv(i.state, e);
      t ? i.dispatch(t) : i.update([]);
    }
  }, 10);
}
Xt.focus = (i) => {
  i.inputState.lastFocusTime = Date.now(), !i.scrollDOM.scrollTop && (i.inputState.lastScrollTop || i.inputState.lastScrollLeft) && (i.scrollDOM.scrollTop = i.inputState.lastScrollTop, i.scrollDOM.scrollLeft = i.inputState.lastScrollLeft), iv(i);
};
Xt.blur = (i) => {
  i.observer.clearSelectionRange(), iv(i);
};
Xt.compositionstart = Xt.compositionupdate = (i) => {
  i.observer.editContext || (i.inputState.compositionFirstChange == null && (i.inputState.compositionFirstChange = !0), i.inputState.composing < 0 && (i.inputState.composing = 0));
};
Xt.compositionend = (i) => {
  i.observer.editContext || (i.inputState.composing = -1, i.inputState.compositionEndedAt = Date.now(), i.inputState.compositionPendingKey = !0, i.inputState.compositionPendingChange = i.observer.pendingRecords().length > 0, i.inputState.compositionFirstChange = null, ie.chrome && ie.android ? i.observer.flushSoon() : i.inputState.compositionPendingChange ? Promise.resolve().then(() => i.observer.flush()) : setTimeout(() => {
    i.inputState.composing < 0 && i.docView.hasComposition && i.update([]);
  }, 50));
};
Xt.contextmenu = (i) => {
  i.inputState.lastContextMenu = Date.now();
};
Ft.beforeinput = (i, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && i.observer.editContext) {
    let n = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (n && o.length) {
      let a = o[0], l = i.posAtDOM(a.startContainer, a.startOffset), c = i.posAtDOM(a.endContainer, a.endOffset);
      return xf(i, { from: l, to: c, insert: i.state.toText(n) }, null), !0;
    }
  }
  let s;
  if (ie.chrome && ie.android && (s = FS.find((n) => n.inputType == e.inputType)) && (i.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let n = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > n + 10 && i.hasFocus && (i.contentDOM.blur(), i.focus());
    }, 100);
  }
  return ie.ios && e.inputType == "deleteContentForward" && i.observer.flushSoon(), ie.safari && e.inputType == "insertText" && i.inputState.composing >= 0 && setTimeout(() => Xt.compositionend(i, e), 20), !1;
};
const ZO = /* @__PURE__ */ new Set();
function SP(i) {
  ZO.has(i) || (ZO.add(i), i.addEventListener("copy", () => {
  }), i.addEventListener("cut", () => {
  }));
}
const WO = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let ds = !1;
function zO() {
  ds = !1;
}
class vP {
  constructor(e) {
    this.lineWrapping = e, this.doc = _e.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return WO.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      s < 0 ? r++ : this.heightSamples[Math.floor(s * 10)] || (t = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, s, n, o) {
    let a = WO.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = r, this.textHeight = s, this.lineLength = n, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let h = o[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class _P {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class ui {
  /**
  @internal
  */
  constructor(e, t, r, s, n) {
    this.from = e, this.length = t, this.top = r, this.height = s, this._content = n;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? ht.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof or ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new ui(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Ee = /* @__PURE__ */ function(i) {
  return i[i.ByPos = 0] = "ByPos", i[i.ByHeight = 1] = "ByHeight", i[i.ByPosNoHeight = 2] = "ByPosNoHeight", i;
}(Ee || (Ee = {}));
const aa = 1e-3;
class ut {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > aa && (ds = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return ut.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, s) {
    let n = this, o = r.doc;
    for (let a = s.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: h, toB: u } = s[a], d = n.lineAt(l, Ee.ByPosNoHeight, r.setDoc(t), 0, 0), O = d.to >= c ? d : n.lineAt(c, Ee.ByPosNoHeight, r, 0, 0);
      for (u += O.to - c, c = O.to; a > 0 && d.from <= s[a - 1].toA; )
        l = s[a - 1].fromA, h = s[a - 1].fromB, a--, l < d.from && (d = n.lineAt(l, Ee.ByPosNoHeight, r, 0, 0));
      h += d.from - l, l = d.from;
      let v = kf.build(r.setDoc(o), e, h, u);
      n = Ia(n, n.replace(l, c, v));
    }
    return n.updateHeight(r, 0);
  }
  static empty() {
    return new Qt(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, s = 0, n = 0;
    for (; ; )
      if (t == r)
        if (s > n * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), r += 1 + a.break, s -= a.size;
        } else if (n > s * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, n -= a.size;
        } else
          break;
      else if (s < n) {
        let a = e[t++];
        a && (s += a.size);
      } else {
        let a = e[--r];
        a && (n += a.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new bP(ut.of(e.slice(0, t)), o, ut.of(e.slice(r)));
  }
}
function Ia(i, e) {
  return i == e ? i : (i.constructor != e.constructor && (ds = !0), e);
}
ut.prototype.size = 1;
class rv extends ut {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, s) {
    return new ui(s, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, s, n) {
    return this.blockAt(0, r, s, n);
  }
  forEachLine(e, t, r, s, n, o) {
    e <= n + this.length && t >= n && o(this.blockAt(0, r, s, n));
  }
  updateHeight(e, t = 0, r = !1, s) {
    return s && s.from <= t && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Qt extends rv {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, s) {
    return new ui(s, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let s = r[0];
    return r.length == 1 && (s instanceof Qt || s instanceof He && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof He ? s = new Qt(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : ut.of(r);
  }
  updateHeight(e, t = 0, r = !1, s) {
    return s && s.from <= t && s.more ? this.setHeight(s.heights[s.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class He extends ut {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, s = e.doc.lineAt(t + this.length).number, n = s - r + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * n);
      o = l / n, this.length > n + 1 && (a = (this.height - l) / (this.length - n - 1));
    } else
      o = this.height / n;
    return { firstLine: r, lastLine: s, perLine: o, perChar: a };
  }
  blockAt(e, t, r, s) {
    let { firstLine: n, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(t, s);
    if (t.lineWrapping) {
      let c = s + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), h = t.doc.lineAt(c), u = a + h.length * l, d = Math.max(r, e - u / 2);
      return new ui(h.from, h.length, d, u, 0);
    } else {
      let c = Math.max(0, Math.min(o - n, Math.floor((e - r) / a))), { from: h, length: u } = t.doc.line(n + c);
      return new ui(h, u, r + a * c, a, 0);
    }
  }
  lineAt(e, t, r, s, n) {
    if (t == Ee.ByHeight)
      return this.blockAt(e, r, s, n);
    if (t == Ee.ByPosNoHeight) {
      let { from: O, to: v } = r.doc.lineAt(e);
      return new ui(O, v - O, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, n), c = r.doc.lineAt(e), h = a + c.length * l, u = c.number - o, d = s + a * u + l * (c.from - n - u);
    return new ui(c.from, c.length, Math.max(s, Math.min(d, s + this.height - h)), h, 0);
  }
  forEachLine(e, t, r, s, n, o) {
    e = Math.max(e, n), t = Math.min(t, n + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, n);
    for (let h = e, u = s; h <= t; ) {
      let d = r.doc.lineAt(h);
      if (h == e) {
        let v = d.number - a;
        u += l * v + c * (e - n - v);
      }
      let O = l + c * d.length;
      o(new ui(d.from, d.length, u, O, 0)), u += O, h = d.to + 1;
    }
  }
  replace(e, t, r) {
    let s = this.length - t;
    if (s > 0) {
      let n = r[r.length - 1];
      n instanceof He ? r[r.length - 1] = new He(n.length + s) : r.push(null, new He(s - 1));
    }
    if (e > 0) {
      let n = r[0];
      n instanceof He ? r[0] = new He(e + n.length) : r.unshift(new He(e - 1), null);
    }
    return ut.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new He(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new He(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, s) {
    let n = t + this.length;
    if (s && s.from <= t + this.length && s.more) {
      let o = [], a = Math.max(t, s.from), l = -1;
      for (s.from > t && o.push(new He(s.from - t - 1).updateHeight(e, t)); a <= n && s.more; ) {
        let h = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let u = s.heights[s.index++];
        l == -1 ? l = u : Math.abs(u - l) >= aa && (l = -2);
        let d = new Qt(h, u);
        d.outdated = !1, o.push(d), a += h + 1;
      }
      a <= n && o.push(null, new He(n - a).updateHeight(e, a));
      let c = ut.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= aa || Math.abs(l - this.heightMetrics(e, t).perLine) >= aa) && (ds = !0), Ia(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class bP extends ut {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, s) {
    let n = r + this.left.height;
    return e < n ? this.left.blockAt(e, t, r, s) : this.right.blockAt(e, t, n, s + this.left.length + this.break);
  }
  lineAt(e, t, r, s, n) {
    let o = s + this.left.height, a = n + this.left.length + this.break, l = t == Ee.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, t, r, s, n) : this.right.lineAt(e, t, r, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let h = t == Ee.ByPosNoHeight ? Ee.ByPosNoHeight : Ee.ByPos;
    return l ? c.join(this.right.lineAt(a, h, r, o, a)) : this.left.lineAt(a, h, r, s, n).join(c);
  }
  forEachLine(e, t, r, s, n, o) {
    let a = s + this.left.height, l = n + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, r, s, n, o), t >= l && this.right.forEachLine(e, t, r, a, l, o);
    else {
      let c = this.lineAt(l, Ee.ByPos, r, s, n);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, s, n, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, a, l, o);
    }
  }
  replace(e, t, r) {
    let s = this.left.length + this.break;
    if (t < s)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - s, t - s, r));
    let n = [];
    e > 0 && this.decomposeLeft(e, n);
    let o = n.length;
    for (let a of r)
      n.push(a);
    if (e > 0 && VO(n, o - 1), t < this.length) {
      let a = n.length;
      this.decomposeRight(t, n), VO(n, a);
    }
    return ut.of(n);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, s = r + this.break;
    if (e >= s)
      return this.right.decomposeRight(e - s, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < s && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? ut.of(this.break ? [e, null, t] : [e, t]) : (this.left = Ia(this.left, e), this.right = Ia(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, s) {
    let { left: n, right: o } = this, a = t + n.length + this.break, l = null;
    return s && s.from <= t + n.length && s.more ? l = n = n.updateHeight(e, t, r, s) : n.updateHeight(e, t, r), s && s.from <= a + o.length && s.more ? l = o = o.updateHeight(e, a, r, s) : o.updateHeight(e, a, r), l ? this.balanced(n, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function VO(i, e) {
  let t, r;
  i[e] == null && (t = i[e - 1]) instanceof He && (r = i[e + 1]) instanceof He && i.splice(e - 1, 3, new He(t.length + 1 + r.length));
}
const yP = 5;
class kf {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof Qt ? s.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Qt(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let s = r.widget ? r.widget.estimatedHeight : 0, n = r.widget ? r.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new rv(o, s, r)) : (o || n || s >= yP) && this.addLineDeco(s, n, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Qt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new He(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Qt)
      return e;
    let t = new Qt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let s = this.ensureLine();
    s.length += r, s.collapsed += r, s.widgetHeight = Math.max(s.widgetHeight, e), s.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Qt) && !this.isCovered ? this.nodes.push(new Qt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let s of this.nodes)
      s instanceof Qt && s.updateHeight(this.oracle, r), r += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, s) {
    let n = new kf(r, e);
    return be.spans(t, r, s, n, 0), n.finish(r);
  }
}
function wP(i, e, t) {
  let r = new xP();
  return be.compare(i, e, t, r, 0), r.changes;
}
class xP {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, s) {
    (e < t || r && r.heightRelevant || s && s.heightRelevant) && na(e, t, this.changes, 5);
  }
}
function kP(i, e) {
  let t = i.getBoundingClientRect(), r = i.ownerDocument, s = r.defaultView || window, n = Math.max(0, t.left), o = Math.min(s.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(s.innerHeight, t.bottom);
  for (let c = i.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let h = c, u = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && u.overflow != "visible") {
        let d = h.getBoundingClientRect();
        n = Math.max(n, d.left), o = Math.min(o, d.right), a = Math.max(a, d.top), l = Math.min(c == i.parentNode ? s.innerHeight : l, d.bottom);
      }
      c = u.position == "absolute" || u.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: n - t.left,
    right: Math.max(n, o) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function CP(i) {
  let e = i.getBoundingClientRect(), t = i.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function QP(i, e) {
  let t = i.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class hc {
  constructor(e, t, r, s) {
    this.from = e, this.to = t, this.size = r, this.displaySize = s;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r], n = t[r];
      if (s.from != n.from || s.to != n.to || s.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return ae.replace({
      widget: new PP(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class PP extends zi {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class UO {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = jO, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Le.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(bf).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new vP(t), this.stateDeco = e.facet(Qn).filter((r) => typeof r != "function"), this.heightMap = ut.empty().applyChanges(this.stateDeco, _e.empty, this.heightOracle.setDoc(e.doc), [new qt(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ae.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let s = r ? t.head : t.anchor;
      if (!e.some(({ from: n, to: o }) => s >= n && s <= o)) {
        let { from: n, to: o } = this.lineBlockAt(s);
        e.push(new Po(n, o));
      }
    }
    return this.viewports = e.sort((r, s) => r.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? jO : new Cf(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(Hs(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(Qn).filter((h) => typeof h != "function");
    let s = e.changedRanges, n = qt.extendWithRanges(s, wP(r, this.stateDeco, e ? e.changes : Ue.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    zO(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), n), (this.heightMap.height != o || ds) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let l = n.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(XS) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), s = this.heightOracle, n = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? Le.RTL : Le.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(n), a = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (a.width && a.height) {
      let { scaleX: _, scaleY: b } = fS(t, a);
      (_ > 5e-3 && Math.abs(this.scaleX - _) > 5e-3 || b > 5e-3 && Math.abs(this.scaleY - b) > 5e-3) && (this.scaleX = _, this.scaleY = b, c |= 16, o = l = !0);
    }
    let u = (parseInt(r.paddingTop) || 0) * this.scaleY, d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != u || this.paddingBottom != d) && (this.paddingTop = u, this.paddingBottom = d, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (s.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let O = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != O && (this.scrollAnchorHeight = -1, this.scrollTop = O), this.scrolledToBottom = pS(e.scrollDOM);
    let v = (this.printing ? QP : kP)(t, this.paddingTop), S = v.top - this.pixelViewport.top, f = v.bottom - this.pixelViewport.bottom;
    this.pixelViewport = v;
    let p = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (p != this.inView && (this.inView = p, p && (l = !0)), !this.inView && !this.scrollTarget && !CP(e.dom))
      return 0;
    let g = a.width;
    if ((this.contentDOMWidth != g || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
      let _ = e.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(_) && (o = !0), o || s.lineWrapping && Math.abs(g - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: b, charWidth: w, textHeight: x } = e.docView.measureTextSize();
        o = b > 0 && s.refresh(n, b, w, x, g / w, _), o && (e.docView.minWidth = 0, c |= 16);
      }
      S > 0 && f > 0 ? h = Math.max(S, f) : S < 0 && f < 0 && (h = Math.min(S, f)), zO();
      for (let b of this.viewports) {
        let w = b.from == this.viewport.from ? _ : e.docView.measureVisibleLineHeights(b);
        this.heightMap = (o ? ut.empty().applyChanges(this.stateDeco, _e.empty, this.heightOracle, [new qt(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(s, 0, o, new _P(b.from, w));
      }
      ds && (c |= 2);
    }
    let m = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return m && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(h, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || m) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), s = this.heightMap, n = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Po(s.lineAt(o - r * 1e3, Ee.ByHeight, n, 0, 0).from, s.lineAt(a + (1 - r) * 1e3, Ee.ByHeight, n, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = s.lineAt(c, Ee.ByPos, n, 0, 0), d;
        t.y == "center" ? d = (u.top + u.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? d = u.top : d = u.bottom - h, l = new Po(s.lineAt(d - 1e3 / 2, Ee.ByHeight, n, 0, 0).from, s.lineAt(d + h + 1e3 / 2, Ee.ByHeight, n, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), s = t.mapPos(e.to, 1);
    return new Po(this.heightMap.lineAt(r, Ee.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Ee.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(e, Ee.ByPos, this.heightOracle, 0, 0), { bottom: n } = this.heightMap.lineAt(t, Ee.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || s <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || n >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && s > o - 2 * 1e3 && n < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let s of e)
      t.touchesRange(s.from, s.to) || r.push(new hc(t.mapPos(s.from), t.mapPos(s.to), s.size, s.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, s = r ? 1e4 : 2e3, n = s >> 1, o = s << 1;
    if (this.defaultTextDirection != Le.LTR && !r)
      return [];
    let a = [], l = (h, u, d, O) => {
      if (u - h < n)
        return;
      let v = this.state.selection.main, S = [v.from];
      v.empty || S.push(v.to);
      for (let p of S)
        if (p > h && p < u) {
          l(h, p - 10, d, O), l(p + 10, u, d, O);
          return;
        }
      let f = $P(e, (p) => p.from >= d.from && p.to <= d.to && Math.abs(p.from - h) < n && Math.abs(p.to - u) < n && !S.some((g) => p.from < g && p.to > g));
      if (!f) {
        if (u < d.to && t && r && t.visibleRanges.some((m) => m.from <= u && m.to >= u)) {
          let m = t.moveToLineBoundary(V.cursor(u), !1, !0).head;
          m > h && (u = m);
        }
        let p = this.gapSize(d, h, u, O), g = r || p < 2e6 ? p : 2e6;
        f = new hc(h, u, p, g);
      }
      a.push(f);
    }, c = (h) => {
      if (h.length < o || h.type != ht.Text)
        return;
      let u = TP(h.from, h.to, this.stateDeco);
      if (u.total < o)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, O, v;
      if (r) {
        let S = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, f, p;
        if (d != null) {
          let g = $o(u, d), m = ((this.visibleBottom - this.visibleTop) / 2 + S) / h.height;
          f = g - m, p = g + m;
        } else
          f = (this.visibleTop - h.top - S) / h.height, p = (this.visibleBottom - h.top + S) / h.height;
        O = To(u, f), v = To(u, p);
      } else {
        let S = u.total * this.heightOracle.charWidth, f = s * this.heightOracle.charWidth, p = 0;
        if (S > 2e6)
          for (let w of e)
            w.from >= h.from && w.from < h.to && w.size != w.displaySize && w.from * this.heightOracle.charWidth + p < this.pixelViewport.left && (p = w.size - w.displaySize);
        let g = this.pixelViewport.left + p, m = this.pixelViewport.right + p, _, b;
        if (d != null) {
          let w = $o(u, d), x = ((m - g) / 2 + f) / S;
          _ = w - x, b = w + x;
        } else
          _ = (g - f) / S, b = (m + f) / S;
        O = To(u, _), v = To(u, b);
      }
      O > h.from && l(h.from, O, h, u), v < h.to && l(v, h.to, h, u);
    };
    for (let h of this.viewportLines)
      Array.isArray(h.type) ? h.type.forEach(c) : c(h);
    return a;
  }
  gapSize(e, t, r, s) {
    let n = $o(s, r) - $o(s, t);
    return this.heightOracle.lineWrapping ? e.height * n : s.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(e) {
    hc.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ae.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    be.spans(t, this.viewport.from, this.viewport.to, {
      span(n, o) {
        r.push({ from: n, to: o });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (r.length != this.visibleRanges.length)
      s = 12;
    else
      for (let n = 0; n < r.length && !(s & 8); n++) {
        let o = this.visibleRanges[n], a = r[n];
        (o.from != a.from || o.to != a.to) && (s |= 4, e && e.mapPos(o.from, -1) == a.from && e.mapPos(o.to, 1) == a.to || (s |= 8));
      }
    return this.visibleRanges = r, s;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Hs(this.heightMap.lineAt(e, Ee.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || Hs(this.heightMap.lineAt(this.scaler.fromDOM(e), Ee.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Hs(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Po {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function TP(i, e, t) {
  let r = [], s = i, n = 0;
  return be.spans(t, i, e, {
    span() {
    },
    point(o, a) {
      o > s && (r.push({ from: s, to: o }), n += o - s), s = a;
    }
  }, 20), s < e && (r.push({ from: s, to: e }), n += e - s), { total: n, ranges: r };
}
function To({ total: i, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(i * t);
  for (let s = 0; ; s++) {
    let { from: n, to: o } = e[s], a = o - n;
    if (r <= a)
      return n + r;
    r -= a;
  }
}
function $o(i, e) {
  let t = 0;
  for (let { from: r, to: s } of i.ranges) {
    if (e <= s) {
      t += e - r;
      break;
    }
    t += s - r;
  }
  return t / i.total;
}
function $P(i, e) {
  for (let t of i)
    if (e(t))
      return t;
}
const jO = {
  toDOM(i) {
    return i;
  },
  fromDOM(i) {
    return i;
  },
  scale: 1,
  eq(i) {
    return i == this;
  }
};
class Cf {
  constructor(e, t, r) {
    let s = 0, n = 0, o = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, Ee.ByPos, e, 0, 0).top, h = t.lineAt(l, Ee.ByPos, e, 0, 0).bottom;
      return s += h - c, { from: a, to: l, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (t.height - s);
    for (let a of this.viewports)
      a.domTop = o + (a.top - n) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), n = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, s = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.top)
        return s + (e - r) * this.scale;
      if (e <= n.bottom)
        return n.domTop + (e - n.top);
      r = n.bottom, s = n.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, s = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.domTop)
        return r + (e - s) / this.scale;
      if (e <= n.domBottom)
        return n.top + (e - n.domTop);
      r = n.bottom, s = n.domBottom;
    }
  }
  eq(e) {
    return e instanceof Cf ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function Hs(i, e) {
  if (e.scale == 1)
    return i;
  let t = e.toDOM(i.top), r = e.toDOM(i.bottom);
  return new ui(i.from, i.length, t, r - t, Array.isArray(i._content) ? i._content.map((s) => Hs(s, e)) : i._content);
}
const Ro = /* @__PURE__ */ ee.define({ combine: (i) => i.join(" ") }), ru = /* @__PURE__ */ ee.define({ combine: (i) => i.indexOf(!0) > -1 }), su = /* @__PURE__ */ sr.newName(), sv = /* @__PURE__ */ sr.newName(), nv = /* @__PURE__ */ sr.newName(), ov = { "&light": "." + sv, "&dark": "." + nv };
function nu(i, e, t) {
  return new sr(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (s) => {
        if (s == "&")
          return i;
        if (!t || !t[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return t[s];
      }) : i + " " + r;
    }
  });
}
const RP = /* @__PURE__ */ nu("." + su, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, ov), EP = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, uc = ie.ie && ie.ie_version <= 11;
class AP {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new OQ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (ie.ie && ie.ie_version <= 11 || ie.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(ie.chrome && ie.chrome_version < 126) && (this.editContext = new DP(e), e.state.facet(Ri) && (e.contentDOM.editContext = this.editContext.editContext)), uc && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, s = this.selectionRange;
    if (r.state.facet(Ri) ? r.root.activeElement != this.dom : !sa(this.dom, s))
      return;
    let n = s.anchorNode && r.docView.nearest(s.anchorNode);
    if (n && n.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (ie.ie && ie.ie_version <= 11 || ie.android && ie.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && nn(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = kn(e.root);
    if (!t)
      return !1;
    let r = ie.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && LP(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let s = sa(this.dom, r);
    return s && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && gQ(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, EP), uc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), uc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let s = () => {
        let n = this.delayedAndroidKey;
        n && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = n.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && n.force && ts(this.dom, n.key, n.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, s = !1;
    for (let n of e) {
      let o = this.readMutation(n);
      o && (o.typeOver && (s = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: s };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), s = this.selectionChanged && sa(this.dom, this.selectionRange);
    if (e < 0 && !s)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let n = new GQ(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: n.newSel ? n.newSel.main : null }, n;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, s = YS(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = NO(t, e.previousSibling || e.target.previousSibling, -1), s = NO(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: s ? t.posBefore(s) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Ri) != e.state.facet(Ri) && (e.view.contentDOM.editContext = e.state.facet(Ri) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function NO(i, e, t) {
  for (; e; ) {
    let r = Te.get(e);
    if (r && r.parent == i)
      return r;
    let s = e.parentNode;
    e = s != i.dom ? s : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function YO(i, e) {
  let t = e.startContainer, r = e.startOffset, s = e.endContainer, n = e.endOffset, o = i.docView.domAtPos(i.state.selection.main.anchor);
  return nn(o.node, o.offset, s, n) && ([t, r, s, n] = [s, n, t, r]), { anchorNode: t, anchorOffset: r, focusNode: s, focusOffset: n };
}
function LP(i, e) {
  if (e.getComposedRanges) {
    let s = e.getComposedRanges(i.root)[0];
    if (s)
      return YO(i, s);
  }
  let t = null;
  function r(s) {
    s.preventDefault(), s.stopImmediatePropagation(), t = s.getTargetRanges()[0];
  }
  return i.contentDOM.addEventListener("beforeinput", r, !0), i.dom.ownerDocument.execCommand("indent"), i.contentDOM.removeEventListener("beforeinput", r, !0), t ? YO(i, t) : null;
}
class DP {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let s = e.state.selection.main, { anchor: n, head: o } = s, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: a, drifted: !1 });
      let c = { from: a, to: l, insert: _e.of(r.text.split(`
`)) };
      if (c.from == this.from && n < this.from ? c.from = n : c.to == this.to && n > this.to && (c.to = n), c.from == c.to && !c.insert.length) {
        let h = V.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        h.main.eq(s) || e.dispatch({ selection: h, userEvent: "select" });
        return;
      }
      if ((ie.mac || ie.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: a, to: l, insert: _e.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let h = this.to - this.from + (c.to - c.from + c.insert.length);
        xf(e, c, V.single(this.toEditorPos(r.selectionStart, h), this.toEditorPos(r.selectionEnd, h)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let s = [], n = null;
      for (let o = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); o < a; o++) {
        let l = e.coordsForChar(o);
        n = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || n || new DOMRect(), s.push(n);
      }
      t.updateCharacterBounds(r.rangeStart, s);
    }, this.handlers.textformatupdate = (r) => {
      let s = [];
      for (let n of r.getTextFormats()) {
        let o = n.underlineStyle, a = n.underlineThickness;
        if (o != "None" && a != "None") {
          let l = this.toEditorPos(n.rangeStart), c = this.toEditorPos(n.rangeEnd);
          if (l < c) {
            let h = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
            s.push(ae.mark({ attributes: { style: h } }).range(l, c));
          }
        }
      }
      e.dispatch({ effects: ZS.of(ae.set(s)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let s = kn(r.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, s = this.pendingContextChange;
    return e.changes.iterChanges((n, o, a, l, c) => {
      if (r)
        return;
      let h = c.length - (o - n);
      if (s && o >= s.to)
        if (s.from == n && s.to == o && s.insert.eq(c)) {
          s = this.pendingContextChange = null, t += h, this.to += h;
          return;
        } else
          s = null, this.revertPending(e.state);
      if (n += t, o += t, o <= this.from)
        this.from += h, this.to += h;
      else if (n < this.to) {
        if (n < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(n), this.toContextPos(o), c.toString()), this.to += h;
      }
      t += h;
    }), s && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), s = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != s) && this.editContext.updateSelection(r, s);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class K {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((s) => s.forEach((n) => r(n, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = e.root || pQ(e.parent) || document, this.viewState = new UO(e.state || ve.create(e)), e.scrollTo && e.scrollTo.is(ko) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Fr).map((s) => new ac(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new AP(this), this.inputState = new iP(this), this.inputState.ensureHandlers(this.plugins), this.docView = new CO(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof We ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, s, n = this.state;
    for (let d of e) {
      if (d.startState != n)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = n;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(ev)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = tv(n, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(n.doc) || !this.state.selection.eq(n.selection)) && (h = null)) : this.observer.clear(), n.facet(ve.phrases) != this.state.facet(ve.phrases))
      return this.setState(n);
    s = Xa.create(this, n, e), s.flags |= a;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (u && (u = u.map(d.changes)), d.scrollIntoView) {
          let { main: O } = d.state.selection;
          u = new is(O.empty ? O : V.cursor(O.head, O.head > O.anchor ? -1 : 1));
        }
        for (let O of d.effects)
          O.is(ko) && (u = O.value.clip(this.state));
      }
      this.viewState.update(s, u), this.bidiCache = Za.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), t = this.docView.update(s), this.state.facet(Ys) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(Ro) != s.state.facet(Ro) && (this.viewState.mustMeasureContent = !0), (t || r || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !s.empty)
      for (let d of this.state.facet(Jh))
        try {
          d(s);
        } catch (O) {
          St(this.state, O, "update listener");
        }
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !YS(this, h) && c.force && ts(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new UO(e), this.plugins = e.facet(Fr).map((r) => new ac(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new CO(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Fr), r = e.state.facet(Fr);
    if (t != r) {
      let s = [];
      for (let n of r) {
        let o = t.indexOf(n);
        if (o < 0)
          s.push(new ac(n));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, s.push(a);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != e && n.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = e;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          St(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, s = r.scrollTop * this.scaleY, { scrollAnchorPos: n, scrollAnchorHeight: o } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (pS(r))
            n = -1, o = this.viewState.heightMap.height;
          else {
            let O = this.viewState.scrollAnchorAt(s);
            n = O.from, o = O.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((O) => {
          try {
            return O.read(this);
          } catch (v) {
            return St(this.state, v), FO;
          }
        }), u = Xa.create(this, this.state, []), d = !1;
        u.flags |= l, t ? t.flags |= l : t = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), d = this.docView.update(u), d && this.docViewUpdate());
        for (let O = 0; O < c.length; O++)
          if (h[O] != FO)
            try {
              let v = c[O];
              v.write && v.write(h[O], this);
            } catch (v) {
              St(this.state, v);
            }
        if (d && this.docView.updateSelection(!0), !u.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let v = (n < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n).top) - o;
              if (v > 1 || v < -1) {
                s = s + v, r.scrollTop = s / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(Jh))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return su + " " + (this.state.facet(ru) ? nv : sv) + " " + this.state.facet(Ro);
  }
  updateAttrs() {
    let e = HO(this, WS, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Ri) ? "true" : "false",
      class: "cm-content",
      style: `${ie.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), HO(this, bf, t);
    let r = this.observer.ignore(() => {
      let s = Yh(this.contentDOM, this.contentAttrs, t), n = Yh(this.dom, this.editorAttrs, e);
      return s || n;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let s of r.effects)
        if (s.is(K.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Ys);
    let e = this.state.facet(K.cspNonce);
    sr.mount(this.root, this.styleModules.concat(RP).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return cc(this, e, RO(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return cc(this, e, RO(this, e, t, (r) => NQ(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), s = this.textDirectionAt(e.from), n = r[t ? r.length - 1 : 0];
    return V.cursor(n.side(t, s) + e.from, n.forward(!t, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return jQ(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return cc(this, e, YQ(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), NS(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let s = this.state.doc.lineAt(e), n = this.bidiSpans(s), o = n[Ki.find(n, e - s.from, -1, t)];
    return Cl(r, o.dir == Le.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(qS) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > MP)
      return $S(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == t && (n.fresh || TS(n.isolates, r = kO(this, e))))
        return n.order;
    r || (r = kO(this, e));
    let s = $Q(e.text, t, r);
    return this.bidiCache.push(new Za(e.from, e.to, t, r, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ie.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      dS(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return ko.of(new is(typeof e == "number" ? V.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return ko.of(new is(V.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ve.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Ve.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = sr.newName(), s = [Ro.of(r), Ys.of(nu(`.${r}`, e))];
    return t && t.dark && s.push(ru.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Zi.lowest(Ys.of(nu("." + su, e, ov)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), s = r && Te.get(r) || Te.get(e);
    return ((t = s?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
K.styleModule = Ys;
K.inputHandler = MS;
K.clipboardInputFilter = vf;
K.clipboardOutputFilter = _f;
K.scrollHandler = IS;
K.focusChangeEffect = BS;
K.perLineTextDirection = qS;
K.exceptionSink = DS;
K.updateListener = Jh;
K.editable = Ri;
K.mouseSelectionStyle = LS;
K.dragMovesSelection = AS;
K.clickAddsSelectionRange = ES;
K.decorations = Qn;
K.outerDecorations = zS;
K.atomicRanges = yf;
K.bidiIsolatedRanges = VS;
K.scrollMargins = US;
K.darkTheme = ru;
K.cspNonce = /* @__PURE__ */ ee.define({ combine: (i) => i.length ? i[0] : "" });
K.contentAttributes = bf;
K.editorAttributes = WS;
K.lineWrapping = /* @__PURE__ */ K.contentAttributes.of({ class: "cm-lineWrapping" });
K.announce = /* @__PURE__ */ he.define();
const MP = 4096, FO = {};
class Za {
  constructor(e, t, r, s, n, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = s, this.fresh = n, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((n) => n.fresh))
      return e;
    let r = [], s = e.length ? e[e.length - 1].dir : Le.LTR;
    for (let n = Math.max(0, e.length - 10); n < e.length; n++) {
      let o = e[n];
      o.dir == s && !t.touchesRange(o.from, o.to) && r.push(new Za(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function HO(i, e, t) {
  for (let r = i.state.facet(e), s = r.length - 1; s >= 0; s--) {
    let n = r[s], o = typeof n == "function" ? n(i) : n;
    o && Nh(o, t);
  }
  return t;
}
const BP = ie.mac ? "mac" : ie.windows ? "win" : ie.linux ? "linux" : "key";
function qP(i, e) {
  const t = i.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let s, n, o, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      n = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return s && (r = "Alt-" + r), n && (r = "Ctrl-" + r), a && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function Eo(i, e, t) {
  return e.altKey && (i = "Alt-" + i), e.ctrlKey && (i = "Ctrl-" + i), e.metaKey && (i = "Meta-" + i), t !== !1 && e.shiftKey && (i = "Shift-" + i), i;
}
const XP = /* @__PURE__ */ Zi.default(/* @__PURE__ */ K.domEventHandlers({
  keydown(i, e) {
    return lv(av(e.state), i, e, "editor");
  }
})), oo = /* @__PURE__ */ ee.define({ enables: XP }), GO = /* @__PURE__ */ new WeakMap();
function av(i) {
  let e = i.facet(oo), t = GO.get(e);
  return t || GO.set(e, t = WP(e.reduce((r, s) => r.concat(s), []))), t;
}
function IP(i, e, t) {
  return lv(av(i.state), e, i, t);
}
let Fi = null;
const ZP = 4e3;
function WP(i, e = BP) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), s = (o, a) => {
    let l = r[o];
    if (l == null)
      r[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, n = (o, a, l, c, h) => {
    var u, d;
    let O = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), v = a.split(/ (?!$)/).map((p) => qP(p, e));
    for (let p = 1; p < v.length; p++) {
      let g = v.slice(0, p).join(" ");
      s(g, !0), O[g] || (O[g] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(m) => {
          let _ = Fi = { view: m, prefix: g, scope: o };
          return setTimeout(() => {
            Fi == _ && (Fi = null);
          }, ZP), !0;
        }]
      });
    }
    let S = v.join(" ");
    s(S, !1);
    let f = O[S] || (O[S] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (u = O._any) === null || u === void 0 ? void 0 : u.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && f.run.push(l), c && (f.preventDefault = !0), h && (f.stopPropagation = !0);
  };
  for (let o of i) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let h = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: u } = o;
        for (let d in h)
          h[d].run.push((O) => u(O, ou));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        n(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && n(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let ou = null;
function lv(i, e, t, r) {
  ou = e;
  let s = hQ(e), n = pt(s, 0), o = hi(n) == s.length && s != " ", a = "", l = !1, c = !1, h = !1;
  Fi && Fi.view == t && Fi.scope == r && (a = Fi.prefix + " ", HS.indexOf(e.keyCode) < 0 && (c = !0, Fi = null));
  let u = /* @__PURE__ */ new Set(), d = (f) => {
    if (f) {
      for (let p of f.run)
        if (!u.has(p) && (u.add(p), p(t)))
          return f.stopPropagation && (h = !0), !0;
      f.preventDefault && (f.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, O = i[r], v, S;
  return O && (d(O[a + Eo(s, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ie.windows && e.ctrlKey && e.altKey) && (v = nr[e.keyCode]) && v != s ? (d(O[a + Eo(v, e, !0)]) || e.shiftKey && (S = xn[e.keyCode]) != s && S != v && d(O[a + Eo(S, e, !1)])) && (l = !0) : o && e.shiftKey && d(O[a + Eo(s, e, !0)]) && (l = !0), !l && d(O._any) && (l = !0)), c && (l = !0), l && h && e.stopPropagation(), ou = null, l;
}
class ao {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, s, n) {
    this.className = e, this.left = t, this.top = r, this.width = s, this.height = n;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let s = e.coordsAtPos(r.head, r.assoc || 1);
      if (!s)
        return [];
      let n = cv(e);
      return [new ao(t, s.left - n.left, s.top - n.top, null, s.bottom - s.top)];
    } else
      return zP(e, t, r);
  }
}
function cv(i) {
  let e = i.scrollDOM.getBoundingClientRect();
  return { left: (i.textDirection == Le.LTR ? e.left : e.right - i.scrollDOM.clientWidth * i.scaleX) - i.scrollDOM.scrollLeft * i.scaleX, top: e.top - i.scrollDOM.scrollTop * i.scaleY };
}
function KO(i, e, t, r) {
  let s = i.coordsAtPos(e, t * 2);
  if (!s)
    return r;
  let n = i.dom.getBoundingClientRect(), o = (s.top + s.bottom) / 2, a = i.posAtCoords({ x: n.left + 1, y: o }), l = i.posAtCoords({ x: n.right - 1, y: o });
  return a == null || l == null ? r : { from: Math.max(r.from, Math.min(a, l)), to: Math.min(r.to, Math.max(a, l)) };
}
function zP(i, e, t) {
  if (t.to <= i.viewport.from || t.from >= i.viewport.to)
    return [];
  let r = Math.max(t.from, i.viewport.from), s = Math.min(t.to, i.viewport.to), n = i.textDirection == Le.LTR, o = i.contentDOM, a = o.getBoundingClientRect(), l = cv(i), c = o.querySelector(".cm-line"), h = c && window.getComputedStyle(c), u = a.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), d = a.right - (h ? parseInt(h.paddingRight) : 0), O = tu(i, r, 1), v = tu(i, s, -1), S = O.type == ht.Text ? O : null, f = v.type == ht.Text ? v : null;
  if (S && (i.lineWrapping || O.widgetLineBreaks) && (S = KO(i, r, 1, S)), f && (i.lineWrapping || v.widgetLineBreaks) && (f = KO(i, s, -1, f)), S && f && S.from == f.from && S.to == f.to)
    return g(m(t.from, t.to, S));
  {
    let b = S ? m(t.from, null, S) : _(O, !1), w = f ? m(null, t.to, f) : _(v, !0), x = [];
    return (S || O).to < (f || v).from - (S && f ? 1 : 0) || O.widgetLineBreaks > 1 && b.bottom + i.defaultLineHeight / 2 < w.top ? x.push(p(u, b.bottom, d, w.top)) : b.bottom < w.top && i.elementAtHeight((b.bottom + w.top) / 2).type == ht.Text && (b.bottom = w.top = (b.bottom + w.top) / 2), g(b).concat(x).concat(g(w));
  }
  function p(b, w, x, y) {
    return new ao(e, b - l.left, w - l.top, x - b, y - w);
  }
  function g({ top: b, bottom: w, horizontal: x }) {
    let y = [];
    for (let k = 0; k < x.length; k += 2)
      y.push(p(x[k], b, x[k + 1], w));
    return y;
  }
  function m(b, w, x) {
    let y = 1e9, k = -1e9, $ = [];
    function R(M, B, W, z, Q) {
      let E = i.coordsAtPos(M, M == x.to ? -2 : 2), L = i.coordsAtPos(W, W == x.from ? 2 : -2);
      !E || !L || (y = Math.min(E.top, L.top, y), k = Math.max(E.bottom, L.bottom, k), Q == Le.LTR ? $.push(n && B ? u : E.left, n && z ? d : L.right) : $.push(!n && z ? u : L.left, !n && B ? d : E.right));
    }
    let T = b ?? x.from, A = w ?? x.to;
    for (let M of i.visibleRanges)
      if (M.to > T && M.from < A)
        for (let B = Math.max(M.from, T), W = Math.min(M.to, A); ; ) {
          let z = i.state.doc.lineAt(B);
          for (let Q of i.bidiSpans(z)) {
            let E = Q.from + z.from, L = Q.to + z.from;
            if (E >= W)
              break;
            L > B && R(Math.max(E, B), b == null && E <= T, Math.min(L, W), w == null && L >= A, Q.dir);
          }
          if (B = z.to + 1, B >= W)
            break;
        }
    return $.length == 0 && R(T, b == null, A, w == null, i.textDirection), { top: y, bottom: k, horizontal: $ };
  }
  function _(b, w) {
    let x = a.top + (w ? b.top : b.bottom);
    return { top: x, bottom: x, horizontal: [] };
  }
}
function VP(i, e) {
  return i.constructor == e.constructor && i.eq(e);
}
class UP {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(la) != e.state.facet(la) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(la);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !VP(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let s of e)
        s.update && t && s.constructor && this.drawn[r].constructor && s.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(s.draw(), t);
      for (; t; ) {
        let s = t.nextSibling;
        t.remove(), t = s;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const la = /* @__PURE__ */ ee.define();
function hv(i) {
  return [
    Ve.define((e) => new UP(e, i)),
    la.of(i)
  ];
}
const Pn = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function jP(i = {}) {
  return [
    Pn.of(i),
    NP,
    YP,
    FP,
    XS.of(!0)
  ];
}
function uv(i) {
  return i.startState.facet(Pn) != i.state.facet(Pn);
}
const NP = /* @__PURE__ */ hv({
  above: !0,
  markers(i) {
    let { state: e } = i, t = e.facet(Pn), r = [];
    for (let s of e.selection.ranges) {
      let n = s == e.selection.main;
      if (s.empty || t.drawRangeCursor) {
        let o = n ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = s.empty ? s : V.cursor(s.head, s.head > s.anchor ? -1 : 1);
        for (let l of ao.forRange(i, o, a))
          r.push(l);
      }
    }
    return r;
  },
  update(i, e) {
    i.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = uv(i);
    return t && JO(i.state, e), i.docChanged || i.selectionSet || t;
  },
  mount(i, e) {
    JO(e.state, i);
  },
  class: "cm-cursorLayer"
});
function JO(i, e) {
  e.style.animationDuration = i.facet(Pn).cursorBlinkRate + "ms";
}
const YP = /* @__PURE__ */ hv({
  above: !1,
  markers(i) {
    return i.state.selection.ranges.map((e) => e.empty ? [] : ao.forRange(i, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(i, e) {
    return i.docChanged || i.selectionSet || i.viewportChanged || uv(i);
  },
  class: "cm-selectionLayer"
}), FP = /* @__PURE__ */ Zi.highest(/* @__PURE__ */ K.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), fv = /* @__PURE__ */ he.define({
  map(i, e) {
    return i == null ? null : e.mapPos(i);
  }
}), Gs = /* @__PURE__ */ Ye.define({
  create() {
    return null;
  },
  update(i, e) {
    return i != null && (i = e.changes.mapPos(i)), e.effects.reduce((t, r) => r.is(fv) ? r.value : t, i);
  }
}), HP = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.view = i, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(i) {
    var e;
    let t = i.state.field(Gs);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (i.startState.field(Gs) != t || i.docChanged || i.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: i } = this, e = i.state.field(Gs), t = e != null && i.coordsAtPos(e);
    if (!t)
      return null;
    let r = i.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + i.scrollDOM.scrollLeft * i.scaleX,
      top: t.top - r.top + i.scrollDOM.scrollTop * i.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(i) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      i ? (this.cursor.style.left = i.left / e + "px", this.cursor.style.top = i.top / t + "px", this.cursor.style.height = i.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(i) {
    this.view.state.field(Gs) != i && this.view.dispatch({ effects: fv.of(i) });
  }
}, {
  eventObservers: {
    dragover(i) {
      this.setDropPos(this.view.posAtCoords({ x: i.clientX, y: i.clientY }));
    },
    dragleave(i) {
      (i.target == this.view.contentDOM || !this.view.contentDOM.contains(i.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function GP() {
  return [Gs, HP];
}
function ep(i, e, t, r, s) {
  e.lastIndex = 0;
  for (let n = i.iterRange(t, r), o = t, a; !n.next().done; o += n.value.length)
    if (!n.lineBreak)
      for (; a = e.exec(n.value); )
        s(o + a.index, a);
}
function KP(i, e) {
  let t = i.visibleRanges;
  if (t.length == 1 && t[0].from == i.viewport.from && t[0].to == i.viewport.to)
    return t;
  let r = [];
  for (let { from: s, to: n } of t)
    s = Math.max(i.state.doc.lineAt(s).from, s - e), n = Math.min(i.state.doc.lineAt(n).to, n + e), r.length && r[r.length - 1].to >= s ? r[r.length - 1].to = n : r.push({ from: s, to: n });
  return r;
}
class JP {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: s, boundary: n, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, s)
      this.addMatch = (a, l, c, h) => s(h, c, c + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, c, h) => {
        let u = r(a, l, c);
        u && h(c, c + a[0].length, u);
      };
    else if (r)
      this.addMatch = (a, l, c, h) => h(c, c + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Bi(), r = t.add.bind(t);
    for (let { from: s, to: n } of KP(e, this.maxLength))
      ep(e.state.doc, this.regexp, s, n, (o, a) => this.addMatch(a, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, s = -1;
    return e.docChanged && e.changes.iterChanges((n, o, a, l) => {
      l >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), s = Math.max(l, s));
    }), e.viewportMoved || s - r > 1e3 ? this.createDeco(e.view) : s > -1 ? this.updateRange(e.view, t.map(e.changes), r, s) : t;
  }
  updateRange(e, t, r, s) {
    for (let n of e.visibleRanges) {
      let o = Math.max(n.from, r), a = Math.min(n.to, s);
      if (a >= o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, h = Math.max(n.from, l.from), u = Math.min(n.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              h = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              u = a;
              break;
            }
        }
        let d = [], O, v = (S, f, p) => d.push(p.range(S, f));
        if (l == c)
          for (this.regexp.lastIndex = h - l.from; (O = this.regexp.exec(l.text)) && O.index < u - l.from; )
            this.addMatch(O, e, O.index + l.from, v);
        else
          ep(e.state.doc, this.regexp, h, u, (S, f) => this.addMatch(f, e, S, v));
        t = t.update({ filterFrom: h, filterTo: u, filter: (S, f) => S < h || f > u, add: d });
      }
    }
    return t;
  }
}
const au = /x/.unicode != null ? "gu" : "g", eT = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, au), tT = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let fc = null;
function iT() {
  var i;
  if (fc == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    fc = ((i = e.tabSize) !== null && i !== void 0 ? i : e.MozTabSize) != null;
  }
  return fc || !1;
}
const ca = /* @__PURE__ */ ee.define({
  combine(i) {
    let e = _i(i, {
      render: null,
      specialChars: eT,
      addSpecialChars: null
    });
    return (e.replaceTabs = !iT()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, au)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, au)), e;
  }
});
function rT(i = {}) {
  return [ca.of(i), sT()];
}
let tp = null;
function sT() {
  return tp || (tp = Ve.fromClass(class {
    constructor(i) {
      this.view = i, this.decorations = ae.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(i.state.facet(ca)), this.decorations = this.decorator.createDeco(i);
    }
    makeDecorator(i) {
      return new JP({
        regexp: i.specialChars,
        decoration: (e, t, r) => {
          let { doc: s } = t.state, n = pt(e[0], 0);
          if (n == 9) {
            let o = s.lineAt(r), a = t.state.tabSize, l = Nt(o.text, a, r - o.from);
            return ae.replace({
              widget: new lT((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[n] || (this.decorationCache[n] = ae.replace({ widget: new aT(i, n) }));
        },
        boundary: i.replaceTabs ? void 0 : /[^]/
      });
    }
    update(i) {
      let e = i.state.facet(ca);
      i.startState.facet(ca) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(i.view)) : this.decorations = this.decorator.updateDeco(i, this.decorations);
    }
  }, {
    decorations: (i) => i.decorations
  }));
}
const nT = "";
function oT(i) {
  return i >= 32 ? nT : i == 10 ? "" : String.fromCharCode(9216 + i);
}
class aT extends zi {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = oT(this.code), r = e.state.phrase("Control character") + " " + (tT[this.code] || "0x" + this.code.toString(16)), s = this.options.render && this.options.render(this.code, r, t);
    if (s)
      return s;
    let n = document.createElement("span");
    return n.textContent = t, n.title = r, n.setAttribute("aria-label", r), n.className = "cm-specialChar", n;
  }
  ignoreEvent() {
    return !1;
  }
}
class lT extends zi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function cT() {
  return uT;
}
const hT = /* @__PURE__ */ ae.line({ class: "cm-activeLine" }), uT = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.docChanged || i.selectionSet) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = -1, t = [];
    for (let r of i.state.selection.ranges) {
      let s = i.lineBlockAt(r.head);
      s.from > e && (t.push(hT.range(s.from)), e = s.from);
    }
    return ae.set(t);
  }
}, {
  decorations: (i) => i.decorations
}), lu = 2e3;
function fT(i, e, t) {
  let r = Math.min(e.line, t.line), s = Math.max(e.line, t.line), n = [];
  if (e.off > lu || t.off > lu || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = r; l <= s; l++) {
      let c = i.doc.line(l);
      c.length <= a && n.push(V.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = r; l <= s; l++) {
      let c = i.doc.line(l), h = Ih(c.text, o, i.tabSize, !0);
      if (h < 0)
        n.push(V.cursor(c.to));
      else {
        let u = Ih(c.text, a, i.tabSize);
        n.push(V.range(c.from + h, c.from + u));
      }
    }
  }
  return n;
}
function dT(i, e) {
  let t = i.coordsAtPos(i.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / i.defaultCharacterWidth)) : -1;
}
function ip(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = i.state.doc.lineAt(t), s = t - r.from, n = s > lu ? -1 : s == r.length ? dT(i, e.clientX) : Nt(r.text, i.state.tabSize, t - r.from);
  return { line: r.number, col: n, off: s };
}
function OT(i, e) {
  let t = ip(i, e), r = i.state.selection;
  return t ? {
    update(s) {
      if (s.docChanged) {
        let n = s.changes.mapPos(s.startState.doc.line(t.line).from), o = s.state.doc.lineAt(n);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(s.changes);
      }
    },
    get(s, n, o) {
      let a = ip(i, s);
      if (!a)
        return r;
      let l = fT(i.state, t, a);
      return l.length ? o ? V.create(l.concat(r.ranges)) : V.create(l) : r;
    }
  } : null;
}
function pT(i) {
  let e = (t) => t.altKey && t.button == 0;
  return K.mouseSelectionStyle.of((t, r) => e(r) ? OT(t, r) : null);
}
const gT = {
  Alt: [18, (i) => !!i.altKey],
  Control: [17, (i) => !!i.ctrlKey],
  Shift: [16, (i) => !!i.shiftKey],
  Meta: [91, (i) => !!i.metaKey]
}, mT = { style: "cursor: crosshair" };
function ST(i = {}) {
  let [e, t] = gT[i.key || "Alt"], r = Ve.fromClass(class {
    constructor(s) {
      this.view = s, this.isDown = !1;
    }
    set(s) {
      this.isDown != s && (this.isDown = s, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(s) {
        this.set(s.keyCode == e || t(s));
      },
      keyup(s) {
        (s.keyCode == e || !t(s)) && this.set(!1);
      },
      mousemove(s) {
        this.set(t(s));
      }
    }
  });
  return [
    r,
    K.contentAttributes.of((s) => {
      var n;
      return !((n = s.plugin(r)) === null || n === void 0) && n.isDown ? mT : null;
    })
  ];
}
const Xs = "-10000px";
class dv {
  constructor(e, t, r, s) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = s, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let n = null;
    this.tooltipViews = this.tooltips.map((o) => n = r(o, n));
  }
  update(e, t) {
    var r;
    let s = e.state.facet(this.facet), n = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = t ? [] : null;
    for (let l = 0; l < n.length; l++) {
      let c = n[l], h = -1;
      if (c) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let d = this.tooltips[u];
          d && d.create == c.create && (h = u);
        }
        if (h < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let u = o[l] = this.tooltipViews[h];
          a && (a[l] = t[h]), u.update && u.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return t && (a.forEach((l, c) => t[c] = l), t.length = a.length), this.input = s, this.tooltips = n, this.tooltipViews = o, !0;
  }
}
function vT(i) {
  let e = i.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const dc = /* @__PURE__ */ ee.define({
  combine: (i) => {
    var e, t, r;
    return {
      position: ie.ios ? "absolute" : ((e = i.find((s) => s.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = i.find((s) => s.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = i.find((s) => s.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || vT
    };
  }
}), rp = /* @__PURE__ */ new WeakMap(), Qf = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.view = i, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = i.state.facet(dc);
    this.position = e.position, this.parent = e.parent, this.classes = i.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new dv(i, Pf, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), i.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let i of this.manager.tooltipViews)
        this.intersectionObserver.observe(i.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(i) {
    i.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(i, this.above);
    e && this.observeIntersection();
    let t = e || i.geometryChanged, r = i.state.facet(dc);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(i, e) {
    let t = i.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), i.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", t.dom.appendChild(s);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Xs, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var i, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (i = r.destroy) === null || i === void 0 || i.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let i = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (ie.gecko)
        t = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == Xs && n.style.left == "0px") {
        let o = n.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (i = n.width / this.parent.offsetWidth, e = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: i, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), s = wf(this.view);
    return {
      visible: {
        left: r.left + s.left,
        top: r.top + s.top,
        right: r.right - s.right,
        bottom: r.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((n, o) => {
        let a = this.manager.tooltipViews[o];
        return a.getCoords ? a.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(dc).tooltipSpace(this.view),
      scaleX: i,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(i) {
    var e;
    if (i.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: s, scaleY: n } = i, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: h } = c, u = i.pos[a], d = i.size[a];
      if (!u || l.clip !== !1 && (u.bottom <= Math.max(t.top, r.top) || u.top >= Math.min(t.bottom, r.bottom) || u.right < Math.max(t.left, r.left) - 0.1 || u.left > Math.min(t.right, r.right) + 0.1)) {
        h.style.top = Xs;
        continue;
      }
      let O = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, v = O ? 7 : 0, S = d.right - d.left, f = (e = rp.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top, p = c.offset || bT, g = this.view.textDirection == Le.LTR, m = d.width > r.right - r.left ? g ? r.left : r.right - d.width : g ? Math.max(r.left, Math.min(u.left - (O ? 14 : 0) + p.x, r.right - S)) : Math.min(Math.max(r.left, u.left - S + (O ? 14 : 0) - p.x), r.right - S), _ = this.above[a];
      !l.strictSide && (_ ? u.top - f - v - p.y < r.top : u.bottom + f + v + p.y > r.bottom) && _ == r.bottom - u.bottom > u.top - r.top && (_ = this.above[a] = !_);
      let b = (_ ? u.top - r.top : r.bottom - u.bottom) - v;
      if (b < f && c.resize !== !1) {
        if (b < this.view.defaultLineHeight) {
          h.style.top = Xs;
          continue;
        }
        rp.set(c, f), h.style.height = (f = b) / n + "px";
      } else h.style.height && (h.style.height = "");
      let w = _ ? u.top - f - v - p.y : u.bottom + v + p.y, x = m + S;
      if (c.overlap !== !0)
        for (let y of o)
          y.left < x && y.right > m && y.top < w + f && y.bottom > w && (w = _ ? y.top - f - 2 - v : y.bottom + v + 2);
      if (this.position == "absolute" ? (h.style.top = (w - i.parent.top) / n + "px", sp(h, (m - i.parent.left) / s)) : (h.style.top = w / n + "px", sp(h, m / s)), O) {
        let y = u.left + (g ? p.x : -p.x) - (m + 14 - 7);
        O.style.left = y / s + "px";
      }
      c.overlap !== !0 && o.push({ left: m, top: w, right: x, bottom: w + f }), h.classList.toggle("cm-tooltip-above", _), h.classList.toggle("cm-tooltip-below", !_), c.positioned && c.positioned(i.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let i of this.manager.tooltipViews)
        i.dom.style.top = Xs;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function sp(i, e) {
  let t = parseInt(i.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (i.style.left = e + "px");
}
const _T = /* @__PURE__ */ K.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), bT = { x: 0, y: 0 }, Pf = /* @__PURE__ */ ee.define({
  enables: [Qf, _T]
}), Wa = /* @__PURE__ */ ee.define({
  combine: (i) => i.reduce((e, t) => e.concat(t), [])
});
class Tl {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Tl(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new dv(e, Wa, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let s = r[e];
      if (s !== void 0) {
        if (t === void 0)
          t = s;
        else if (t !== s)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const yT = /* @__PURE__ */ Pf.compute([Wa], (i) => {
  let e = i.facet(Wa);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: Tl.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class wT {
  constructor(e, t, r, s, n) {
    this.view = e, this.source = t, this.field = r, this.setHover = s, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let s, n = 1;
    if (r instanceof Gi)
      s = r.posAtStart;
    else {
      if (s = e.posAtCoords(t), s == null)
        return;
      let a = e.coordsAtPos(s);
      if (!a || t.y < a.top || t.y > a.bottom || t.x < a.left - e.defaultCharacterWidth || t.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(s)).find((h) => h.from <= s && h.to >= s), c = l && l.dir == Le.RTL ? -1 : 1;
      n = t.x < a.left ? -c : c;
    }
    let o = this.source(e, s, n);
    if (o?.then) {
      let a = this.pending = { pos: s };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => St(e.state, l, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(Qf), t = e ? e.manager.tooltips.findIndex((r) => r.create == Tl.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: s, tooltip: n } = this;
    if (s.length && n && !xT(n.dom, e) || this.pending) {
      let { pos: o } = s[0] || this.pending, a = (r = (t = s[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !kT(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Ao = 4;
function xT(i, e) {
  let { left: t, right: r, top: s, bottom: n } = i.getBoundingClientRect(), o;
  if (o = i.querySelector(".cm-tooltip-arrow")) {
    let a = o.getBoundingClientRect();
    s = Math.min(a.top, s), n = Math.max(a.bottom, n);
  }
  return e.clientX >= t - Ao && e.clientX <= r + Ao && e.clientY >= s - Ao && e.clientY <= n + Ao;
}
function kT(i, e, t, r, s, n) {
  let o = i.scrollDOM.getBoundingClientRect(), a = i.documentTop + i.documentPadding.top + i.contentHeight;
  if (o.left > r || o.right < r || o.top > s || Math.min(o.bottom, a) < s)
    return !1;
  let l = i.posAtCoords({ x: r, y: s }, !1);
  return l >= e && l <= t;
}
function CT(i, e = {}) {
  let t = he.define(), r = Ye.define({
    create() {
      return [];
    },
    update(s, n) {
      if (s.length && (e.hideOnChange && (n.docChanged || n.selection) ? s = [] : e.hideOn && (s = s.filter((o) => !e.hideOn(n, o))), n.docChanged)) {
        let o = [];
        for (let a of s) {
          let l = n.changes.mapPos(a.pos, -1, Ke.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = n.changes.mapPos(c.end)), o.push(c);
          }
        }
        s = o;
      }
      for (let o of n.effects)
        o.is(t) && (s = o.value), o.is(QT) && (s = []);
      return s;
    },
    provide: (s) => Wa.from(s)
  });
  return {
    active: r,
    extension: [
      r,
      Ve.define((s) => new wT(
        s,
        i,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      yT
    ]
  };
}
function Ov(i, e) {
  let t = i.plugin(Qf);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const QT = /* @__PURE__ */ he.define(), np = /* @__PURE__ */ ee.define({
  combine(i) {
    let e, t;
    for (let r of i)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Tn(i, e) {
  let t = i.plugin(pv), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const pv = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.input = i.state.facet($n), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(i));
    let e = i.state.facet(np);
    this.top = new Lo(i, !0, e.topContainer), this.bottom = new Lo(i, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(i) {
    let e = i.state.facet(np);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Lo(i.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Lo(i.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = i.state.facet($n);
    if (t != this.input) {
      let r = t.filter((l) => l), s = [], n = [], o = [], a = [];
      for (let l of r) {
        let c = this.specs.indexOf(l), h;
        c < 0 ? (h = l(i.view), a.push(h)) : (h = this.panels[c], h.update && h.update(i)), s.push(h), (h.top ? n : o).push(h);
      }
      this.specs = r, this.panels = s, this.top.sync(n), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(i);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (i) => K.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Lo {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = op(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = op(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function op(i) {
  let e = i.nextSibling;
  return i.remove(), e;
}
const $n = /* @__PURE__ */ ee.define({
  enables: pv
});
class Xi extends Rr {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Xi.prototype.elementClass = "";
Xi.prototype.toDOM = void 0;
Xi.prototype.mapMode = Ke.TrackBefore;
Xi.prototype.startSide = Xi.prototype.endSide = -1;
Xi.prototype.point = !0;
const ha = /* @__PURE__ */ ee.define(), PT = /* @__PURE__ */ ee.define(), TT = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => be.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, an = /* @__PURE__ */ ee.define();
function $T(i) {
  return [gv(), an.of({ ...TT, ...i })];
}
const ap = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e)
});
function gv(i) {
  return [
    RT
  ];
}
const RT = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.view = i, this.prevViewport = i.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = i.state.facet(an).map((e) => new cp(i, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !i.state.facet(ap), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), i.scrollDOM.insertBefore(this.dom, i.contentDOM);
  }
  update(i) {
    if (this.updateGutters(i)) {
      let e = this.prevViewport, t = i.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    i.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(ap) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = i.view.viewport;
  }
  syncGutters(i) {
    let e = this.dom.nextSibling;
    i && this.dom.remove();
    let t = be.iter(this.view.state.facet(ha), this.view.viewport.from), r = [], s = this.gutters.map((n) => new ET(n, this.view.viewport, -this.view.documentPadding.top));
    for (let n of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(n.type)) {
        let o = !0;
        for (let a of n.type)
          if (a.type == ht.Text && o) {
            cu(t, r, a.from);
            for (let l of s)
              l.line(this.view, a, r);
            o = !1;
          } else if (a.widget)
            for (let l of s)
              l.widget(this.view, a);
      } else if (n.type == ht.Text) {
        cu(t, r, n.from);
        for (let o of s)
          o.line(this.view, n, r);
      } else if (n.widget)
        for (let o of s)
          o.widget(this.view, n);
    for (let n of s)
      n.finish();
    i && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(i) {
    let e = i.startState.facet(an), t = i.state.facet(an), r = i.docChanged || i.heightChanged || i.viewportChanged || !be.eq(i.startState.facet(ha), i.state.facet(ha), i.view.viewport.from, i.view.viewport.to);
    if (e == t)
      for (let s of this.gutters)
        s.update(i) && (r = !0);
    else {
      r = !0;
      let s = [];
      for (let n of t) {
        let o = e.indexOf(n);
        o < 0 ? s.push(new cp(this.view, n)) : (this.gutters[o].update(i), s.push(this.gutters[o]));
      }
      for (let n of this.gutters)
        n.dom.remove(), s.indexOf(n) < 0 && n.destroy();
      for (let n of s)
        this.dom.appendChild(n.dom);
      this.gutters = s;
    }
    return r;
  }
  destroy() {
    for (let i of this.gutters)
      i.destroy();
    this.dom.remove();
  }
}, {
  provide: (i) => K.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Le.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function lp(i) {
  return Array.isArray(i) ? i : [i];
}
function cu(i, e, t) {
  for (; i.value && i.from <= t; )
    i.from == t && e.push(i.value), i.next();
}
class ET {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = be.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: s } = this, n = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == s.elements.length) {
      let a = new mv(e, o, n, r);
      s.elements.push(a), s.dom.appendChild(a.dom);
    } else
      s.elements[this.i].update(e, o, n, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let s = [];
    cu(this.cursor, s, t.from), r.length && (s = s.concat(r));
    let n = this.gutter.config.lineMarker(e, t, s);
    n && s.unshift(n);
    let o = this.gutter;
    s.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, s);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), s = r ? [r] : null;
    for (let n of e.state.facet(PT)) {
      let o = n(e, t.widget, t);
      o && (s || (s = [])).push(o);
    }
    s && this.addElement(e, t, s);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class cp {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (s) => {
        let n = s.target, o;
        if (n != this.dom && this.dom.contains(n)) {
          for (; n.parentNode != this.dom; )
            n = n.parentNode;
          let l = n.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = s.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, a, s) && s.preventDefault();
      });
    this.markers = lp(t.markers(e)), t.initialSpacer && (this.spacer = new mv(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = lp(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], e);
      s != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [s]);
    }
    let r = e.view.viewport;
    return !be.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class mv {
  constructor(e, t, r, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, s);
  }
  update(e, t, r, s) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), AT(this.markers, s) || this.setMarkers(e, s);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", s = this.dom.firstChild;
    for (let n = 0, o = 0; ; ) {
      let a = o, l = n < t.length ? t[n++] : null, c = !1;
      if (l) {
        let h = l.elementClass;
        h && (r += " " + h);
        for (let u = o; u < this.markers.length; u++)
          if (this.markers[u].compare(l)) {
            a = u, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(s);
          let u = s.nextSibling;
          s.remove(), s = u;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? s = s.nextSibling : this.dom.insertBefore(l.toDOM(e), s)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function AT(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (!i[t].compare(e[t]))
      return !1;
  return !0;
}
const LT = /* @__PURE__ */ ee.define(), DT = /* @__PURE__ */ ee.define(), Hr = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let s in t) {
          let n = r[s], o = t[s];
          r[s] = n ? (a, l, c) => n(a, l, c) || o(a, l, c) : o;
        }
        return r;
      }
    });
  }
});
class Oc extends Xi {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function pc(i, e) {
  return i.state.facet(Hr).formatNumber(e, i.state);
}
const MT = /* @__PURE__ */ an.compute([Hr], (i) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(LT);
  },
  lineMarker(e, t, r) {
    return r.some((s) => s.toDOM) ? null : new Oc(pc(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let s of e.state.facet(DT)) {
      let n = s(e, t, r);
      if (n)
        return n;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Hr) != e.state.facet(Hr),
  initialSpacer(e) {
    return new Oc(pc(e, hp(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = pc(t.view, hp(t.view.state.doc.lines));
    return r == e.number ? e : new Oc(r);
  },
  domEventHandlers: i.facet(Hr).domEventHandlers
}));
function BT(i = {}) {
  return [
    Hr.of(i),
    gv(),
    MT
  ];
}
function hp(i) {
  let e = 9;
  for (; e < i; )
    e = e * 10 + 9;
  return e;
}
const qT = /* @__PURE__ */ new class extends Xi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), XT = /* @__PURE__ */ ha.compute(["selection"], (i) => {
  let e = [], t = -1;
  for (let r of i.selection.ranges) {
    let s = i.doc.lineAt(r.head).from;
    s > t && (t = s, e.push(qT.range(s)));
  }
  return be.of(e);
});
function IT() {
  return XT;
}
const Sv = 1024;
let ZT = 0;
class Lt {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class le {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = ZT++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = je.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
le.closedBy = new le({ deserialize: (i) => i.split(" ") });
le.openedBy = new le({ deserialize: (i) => i.split(" ") });
le.group = new le({ deserialize: (i) => i.split(" ") });
le.isolate = new le({ deserialize: (i) => {
  if (i && i != "rtl" && i != "ltr" && i != "auto")
    throw new RangeError("Invalid value for isolate: " + i);
  return i || "auto";
} });
le.contextHash = new le({ perNode: !0 });
le.lookAhead = new le({ perNode: !0 });
le.mounted = new le({ perNode: !0 });
class Rn {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[le.mounted.id];
  }
}
const WT = /* @__PURE__ */ Object.create(null);
class je {
  /**
  @internal
  */
  constructor(e, t, r, s = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : WT, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), s = new je(e.name || "", t, e.id, r);
    if (e.props) {
      for (let n of e.props)
        if (Array.isArray(n) || (n = n(s)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[n[0].id] = n[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(le.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let s of r.split(" "))
        t[s] = e[r];
    return (r) => {
      for (let s = r.prop(le.group), n = -1; n < (s ? s.length : 0); n++) {
        let o = t[n < 0 ? r.name : s[n]];
        if (o)
          return o;
      }
    };
  }
}
je.none = new je(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class lo {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let s = null;
      for (let n of e) {
        let o = n(r);
        o && (s || (s = Object.assign({}, r.props)), s[o[0].id] = o[1]);
      }
      t.push(s ? new je(r.name, s, r.id, r.flags) : r);
    }
    return new lo(t);
  }
}
const Do = /* @__PURE__ */ new WeakMap(), up = /* @__PURE__ */ new WeakMap();
var Pe;
(function(i) {
  i[i.ExcludeBuffers = 1] = "ExcludeBuffers", i[i.IncludeAnonymous = 2] = "IncludeAnonymous", i[i.IgnoreMounts = 4] = "IgnoreMounts", i[i.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Pe || (Pe = {}));
class we {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, s, n) {
    if (this.type = e, this.children = t, this.positions = r, this.length = s, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of n)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Rn.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let s = r.toString();
      s && (t && (t += ","), t += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new za(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let s = Do.get(this) || this.topNode, n = new za(s);
    return n.moveTo(e, t), Do.set(this, n._tree), n;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new nt(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = En(Do.get(this) || this.topNode, e, t, !1);
    return Do.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = En(up.get(this) || this.topNode, e, t, !0);
    return up.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return UT(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: s = 0, to: n = this.length } = e, o = e.mode || 0, a = (o & Pe.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Pe.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= n && l.to >= s && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Rf(je.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, s) => new we(this.type, t, r, s, this.propValues), e.makeTree || ((t, r, s) => new we(je.none, t, r, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return jT(e);
  }
}
we.empty = new we(je.none, [], [], 0);
class Tf {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Tf(this.buffer, this.index);
  }
}
class ar {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return je.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], s = this.set.types[t], n = s.name;
    if (/\W/.test(n) && !s.isError && (n = JSON.stringify(n)), e += 4, r == e)
      return n;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return n + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, s, n) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != t && !(vv(n, s, o[l + 1], o[l + 2]) && (a = l, r > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let s = this.buffer, n = new Uint16Array(t - e), o = 0;
    for (let a = e, l = 0; a < t; ) {
      n[l++] = s[a++], n[l++] = s[a++] - r;
      let c = n[l++] = s[a++] - r;
      n[l++] = s[a++] - e, o = Math.max(o, c);
    }
    return new ar(n, o, this.set);
  }
}
function vv(i, e, t, r) {
  switch (i) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function En(i, e, t, r) {
  for (var s; i.from == i.to || (t < 1 ? i.from >= e : i.from > e) || (t > -1 ? i.to <= e : i.to < e); ) {
    let o = !r && i instanceof nt && i.index < 0 ? null : i.parent;
    if (!o)
      return i;
    i = o;
  }
  let n = r ? 0 : Pe.IgnoreOverlays;
  if (r)
    for (let o = i, a = o.parent; a; o = a, a = o.parent)
      o instanceof nt && o.index < 0 && ((s = a.enter(e, t, n)) === null || s === void 0 ? void 0 : s.from) != o.from && (i = a);
  for (; ; ) {
    let o = i.enter(e, t, n);
    if (!o)
      return i;
    i = o;
  }
}
class _v {
  cursor(e = 0) {
    return new za(this, e);
  }
  getChild(e, t = null, r = null) {
    let s = fp(this, e, t, r);
    return s.length ? s[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return fp(this, e, t, r);
  }
  resolve(e, t = 0) {
    return En(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return En(this, e, t, !0);
  }
  matchContext(e) {
    return hu(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let s = t.lastChild;
      if (!s || s.to != t.to)
        break;
      s.type.isError && s.from == s.to ? (r = t, t = s.prevSibling) : t = s;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class nt extends _v {
  constructor(e, t, r, s) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, s, n = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = t > 0 ? a.length : -1; e != c; e += t) {
        let h = a[e], u = l[e] + o.from;
        if (vv(s, r, u, u + h.length)) {
          if (h instanceof ar) {
            if (n & Pe.ExcludeBuffers)
              continue;
            let d = h.findChild(0, h.buffer.length, t, r - u, s);
            if (d > -1)
              return new fi(new zT(o, h, e, u), null, d);
          } else if (n & Pe.IncludeAnonymous || !h.type.isAnonymous || $f(h)) {
            let d;
            if (!(n & Pe.IgnoreMounts) && (d = Rn.get(h)) && !d.overlay)
              return new nt(d.tree, u, e, o);
            let O = new nt(h, u, e, o);
            return n & Pe.IncludeAnonymous || !O.type.isAnonymous ? O : O.nextChild(t < 0 ? h.children.length - 1 : 0, t, r, s);
          }
        }
      }
      if (n & Pe.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let s;
    if (!(r & Pe.IgnoreOverlays) && (s = Rn.get(this._tree)) && s.overlay) {
      let n = e - this.from;
      for (let { from: o, to: a } of s.overlay)
        if ((t > 0 ? o <= n : o < n) && (t < 0 ? a >= n : a > n))
          return new nt(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function fp(i, e, t, r) {
  let s = i.cursor(), n = [];
  if (!s.firstChild())
    return n;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = s.type.is(t), !s.nextSibling())
        return n;
  }
  for (; ; ) {
    if (r != null && s.type.is(r))
      return n;
    if (s.type.is(e) && n.push(s.node), !s.nextSibling())
      return r == null ? n : [];
  }
}
function hu(i, e, t = e.length - 1) {
  for (let r = i; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class zT {
  constructor(e, t, r, s) {
    this.parent = e, this.buffer = t, this.index = r, this.start = s;
  }
}
class fi extends _v {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: s } = this.context, n = s.findChild(this.index + 4, s.buffer[this.index + 3], e, t - this.context.start, r);
    return n < 0 ? null : new fi(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Pe.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, n = s.findChild(this.index + 4, s.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return n < 0 ? null : new fi(this.context, this, n);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new fi(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new fi(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, s = this.index + 4, n = r.buffer[this.index + 3];
    if (n > s) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(s, n, o)), t.push(0);
    }
    return new we(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function bv(i) {
  if (!i.length)
    return null;
  let e = 0, t = i[0];
  for (let n = 1; n < i.length; n++) {
    let o = i[n];
    (o.from > t.from || o.to < t.to) && (t = o, e = n);
  }
  let r = t instanceof nt && t.index < 0 ? null : t.parent, s = i.slice();
  return r ? s[e] = r : s.splice(e, 1), new VT(s, t);
}
class VT {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return bv(this.heads);
  }
}
function UT(i, e, t) {
  let r = i.resolveInner(e, t), s = null;
  for (let n = r instanceof nt ? r : r.context.parent; n; n = n.parent)
    if (n.index < 0) {
      let o = n.parent;
      (s || (s = [r])).push(o.resolve(e, t)), n = o;
    } else {
      let o = Rn.get(n.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new nt(o.tree, o.overlay[0].from + n.from, -1, n);
        (s || (s = [r])).push(En(a, e, t, !1));
      }
    }
  return s ? bv(s) : r;
}
class za {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof nt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: s } = this.buffer;
    return this.type = t || s.set.types[s.buffer[e]], this.from = r + s.buffer[e + 1], this.to = r + s.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof nt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: s } = this.buffer, n = s.findChild(this.index + 4, s.buffer[this.index + 3], e, t - this.buffer.start, r);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Pe.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Pe.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Pe.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let s = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != s)
        return this.yieldBuf(t.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = t.buffer[this.index + 3];
      if (s < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(s);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: s } = this;
    if (s) {
      if (e > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (s.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = s);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let n = t + e, o = e < 0 ? -1 : r._tree.children.length; n != o; n += e) {
          let a = r._tree.children[n];
          if (this.mode & Pe.IncludeAnonymous || a instanceof ar || !a.type.isAnonymous || $f(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let s = this.index, n = this.stack.length; n >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == s) {
            if (s == this.index)
              return o;
            t = o, r = n + 1;
            break e;
          }
        s = this.stack[--n];
      }
    for (let s = r; s < this.stack.length; s++)
      t = new fi(this.buffer, t, this.stack[s]);
    return this.bufferNode = new fi(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && t && t(this), s = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return hu(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let s = e.length - 1, n = this.stack.length - 1; s >= 0; n--) {
      if (n < 0)
        return hu(this._tree, e, s);
      let o = r[t.buffer[this.stack[n]]];
      if (!o.isAnonymous) {
        if (e[s] && e[s] != o.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}
function $f(i) {
  return i.children.some((e) => e instanceof ar || !e.type.isAnonymous || $f(e));
}
function jT(i) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: s = Sv, reused: n = [], minRepeatType: o = r.types.length } = i, a = Array.isArray(t) ? new Tf(t, t.length) : t, l = r.types, c = 0, h = 0;
  function u(b, w, x, y, k, $) {
    let { id: R, start: T, end: A, size: M } = a, B = h, W = c;
    for (; M < 0; )
      if (a.next(), M == -1) {
        let D = n[R];
        x.push(D), y.push(T - b);
        return;
      } else if (M == -3) {
        c = R;
        return;
      } else if (M == -4) {
        h = R;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${M}`);
    let z = l[R], Q, E, L = T - b;
    if (A - T <= s && (E = f(a.pos - w, k))) {
      let D = new Uint16Array(E.size - E.skip), U = a.pos - E.size, Y = D.length;
      for (; a.pos > U; )
        Y = p(E.start, D, Y);
      Q = new ar(D, A - E.start, r), L = E.start - b;
    } else {
      let D = a.pos - M;
      a.next();
      let U = [], Y = [], ne = R >= o ? R : -1, te = 0, de = A;
      for (; a.pos > D; )
        ne >= 0 && a.id == ne && a.size >= 0 ? (a.end <= de - s && (v(U, Y, T, te, a.end, de, ne, B, W), te = U.length, de = a.end), a.next()) : $ > 2500 ? d(T, D, U, Y) : u(T, D, U, Y, ne, $ + 1);
      if (ne >= 0 && te > 0 && te < U.length && v(U, Y, T, te, T, de, ne, B, W), U.reverse(), Y.reverse(), ne > -1 && te > 0) {
        let P = O(z, W);
        Q = Rf(z, U, Y, 0, U.length, 0, A - T, P, P);
      } else
        Q = S(z, U, Y, A - T, B - A, W);
    }
    x.push(Q), y.push(L);
  }
  function d(b, w, x, y) {
    let k = [], $ = 0, R = -1;
    for (; a.pos > w; ) {
      let { id: T, start: A, end: M, size: B } = a;
      if (B > 4)
        a.next();
      else {
        if (R > -1 && A < R)
          break;
        R < 0 && (R = M - s), k.push(T, A, M), $++, a.next();
      }
    }
    if ($) {
      let T = new Uint16Array($ * 4), A = k[k.length - 2];
      for (let M = k.length - 3, B = 0; M >= 0; M -= 3)
        T[B++] = k[M], T[B++] = k[M + 1] - A, T[B++] = k[M + 2] - A, T[B++] = B;
      x.push(new ar(T, k[2] - A, r)), y.push(A - b);
    }
  }
  function O(b, w) {
    return (x, y, k) => {
      let $ = 0, R = x.length - 1, T, A;
      if (R >= 0 && (T = x[R]) instanceof we) {
        if (!R && T.type == b && T.length == k)
          return T;
        (A = T.prop(le.lookAhead)) && ($ = y[R] + T.length + A);
      }
      return S(b, x, y, k, $, w);
    };
  }
  function v(b, w, x, y, k, $, R, T, A) {
    let M = [], B = [];
    for (; b.length > y; )
      M.push(b.pop()), B.push(w.pop() + x - k);
    b.push(S(r.types[R], M, B, $ - k, T - $, A)), w.push(k - x);
  }
  function S(b, w, x, y, k, $, R) {
    if ($) {
      let T = [le.contextHash, $];
      R = R ? [T].concat(R) : [T];
    }
    if (k > 25) {
      let T = [le.lookAhead, k];
      R = R ? [T].concat(R) : [T];
    }
    return new we(b, w, x, y, R);
  }
  function f(b, w) {
    let x = a.fork(), y = 0, k = 0, $ = 0, R = x.end - s, T = { size: 0, start: 0, skip: 0 };
    e: for (let A = x.pos - b; x.pos > A; ) {
      let M = x.size;
      if (x.id == w && M >= 0) {
        T.size = y, T.start = k, T.skip = $, $ += 4, y += 4, x.next();
        continue;
      }
      let B = x.pos - M;
      if (M < 0 || B < A || x.start < R)
        break;
      let W = x.id >= o ? 4 : 0, z = x.start;
      for (x.next(); x.pos > B; ) {
        if (x.size < 0)
          if (x.size == -3)
            W += 4;
          else
            break e;
        else x.id >= o && (W += 4);
        x.next();
      }
      k = z, y += M, $ += W;
    }
    return (w < 0 || y == b) && (T.size = y, T.start = k, T.skip = $), T.size > 4 ? T : void 0;
  }
  function p(b, w, x) {
    let { id: y, start: k, end: $, size: R } = a;
    if (a.next(), R >= 0 && y < o) {
      let T = x;
      if (R > 4) {
        let A = a.pos - (R - 4);
        for (; a.pos > A; )
          x = p(b, w, x);
      }
      w[--x] = T, w[--x] = $ - b, w[--x] = k - b, w[--x] = y;
    } else R == -3 ? c = y : R == -4 && (h = y);
    return x;
  }
  let g = [], m = [];
  for (; a.pos > 0; )
    u(i.start || 0, i.bufferStart || 0, g, m, -1, 0);
  let _ = (e = i.length) !== null && e !== void 0 ? e : g.length ? m[0] + g[0].length : 0;
  return new we(l[i.topID], g.reverse(), m.reverse(), _);
}
const dp = /* @__PURE__ */ new WeakMap();
function ua(i, e) {
  if (!i.isAnonymous || e instanceof ar || e.type != i)
    return 1;
  let t = dp.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != i || !(r instanceof we)) {
        t = 1;
        break;
      }
      t += ua(i, r);
    }
    dp.set(e, t);
  }
  return t;
}
function Rf(i, e, t, r, s, n, o, a, l) {
  let c = 0;
  for (let v = r; v < s; v++)
    c += ua(i, e[v]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), u = [], d = [];
  function O(v, S, f, p, g) {
    for (let m = f; m < p; ) {
      let _ = m, b = S[m], w = ua(i, v[m]);
      for (m++; m < p; m++) {
        let x = ua(i, v[m]);
        if (w + x >= h)
          break;
        w += x;
      }
      if (m == _ + 1) {
        if (w > h) {
          let x = v[_];
          O(x.children, x.positions, 0, x.children.length, S[_] + g);
          continue;
        }
        u.push(v[_]);
      } else {
        let x = S[m - 1] + v[m - 1].length - b;
        u.push(Rf(i, v, S, _, m, b, x, null, l));
      }
      d.push(b + g - n);
    }
  }
  return O(e, t, r, s, 0), (a || l)(u, d, o);
}
class Ef {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let s = this.map.get(e);
    s || this.map.set(e, s = /* @__PURE__ */ new Map()), s.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof fi ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof nt && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof fi ? this.getBuffer(e.context.buffer, e.index) : e instanceof nt ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Li {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, s, n = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = s, this.open = (n ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let s = [new Li(0, e.length, e, 0, !1, r)];
    for (let n of t)
      n.to > e.length && s.push(n);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let s = [], n = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let h = a < t.length ? t[a] : null, u = h ? h.fromA : 1e9;
      if (u - l >= r)
        for (; o && o.from < u; ) {
          let d = o;
          if (l >= d.from || u <= d.to || c) {
            let O = Math.max(d.from, l) - c, v = Math.min(d.to, u) - c;
            d = O >= v ? null : new Li(O, v, d.tree, d.offset + c, a > 0, !!h);
          }
          if (d && s.push(d), o.to > u)
            break;
          o = n < e.length ? e[n++] : null;
        }
      if (!h)
        break;
      l = h.toA, c = h.toA - h.toB;
    }
    return s;
  }
}
class Af {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new NT(e)), r = r ? r.length ? r.map((s) => new Lt(s.from, s.to)) : [new Lt(0, 0)] : [new Lt(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let s = this.startParse(e, t, r);
    for (; ; ) {
      let n = s.advance();
      if (n)
        return n;
    }
  }
}
class NT {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function yv(i) {
  return (e, t, r, s) => new FT(e, i, t, r, s);
}
class Op {
  constructor(e, t, r, s, n) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = s, this.from = n;
  }
}
function pp(i) {
  if (!i.length || i.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(i));
}
class YT {
  constructor(e, t, r, s, n, o, a) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = s, this.start = n, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const uu = new le({ perNode: !0 });
class FT {
  constructor(e, t, r, s, n) {
    this.nest = t, this.input = r, this.fragments = s, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new we(r.type, r.children, r.positions, r.length, r.propValues.concat([[uu, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[le.mounted.id] = new Rn(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new KT(this.fragments), t = null, r = null, s = new za(new nt(this.baseTree, this.ranges[0].from, 0, null), Pe.IncludeAnonymous | Pe.IgnoreMounts);
    e: for (let n, o; ; ) {
      let a = !0, l;
      if (this.stoppedAt != null && s.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(s)) {
        if (t) {
          let c = t.mounts.find((h) => h.frag.from <= s.from && h.frag.to >= s.to && h.mount.overlay);
          if (c)
            for (let h of c.mount.overlay) {
              let u = h.from + c.pos, d = h.to + c.pos;
              u >= s.from && d <= s.to && !t.ranges.some((O) => O.from < d && O.to > u) && t.ranges.push({ from: u, to: d });
            }
        }
        a = !1;
      } else if (r && (o = HT(r.ranges, s.from, s.to)))
        a = o != 2;
      else if (!s.type.isAnonymous && (n = this.nest(s, this.input)) && (s.from < s.to || !n.overlay)) {
        s.tree || GT(s);
        let c = e.findMounts(s.from, n.parser);
        if (typeof n.overlay == "function")
          t = new YT(n.parser, n.overlay, c, this.inner.length, s.from, s.tree, t);
        else {
          let h = Sp(this.ranges, n.overlay || (s.from < s.to ? [new Lt(s.from, s.to)] : []));
          h.length && pp(h), (h.length || !n.overlay) && this.inner.push(new Op(n.parser, h.length ? n.parser.startParse(this.input, vp(c, h), h) : n.parser.startParse(""), n.overlay ? n.overlay.map((u) => new Lt(u.from - s.from, u.to - s.from)) : null, s.tree, h.length ? h[0].from : s.from)), n.overlay ? h.length && (r = { ranges: h, depth: 0, prev: r }) : a = !1;
        }
      } else if (t && (l = t.predicate(s)) && (l === !0 && (l = new Lt(s.from, s.to)), l.from < l.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == l.from ? t.ranges[c] = { from: t.ranges[c].from, to: l.to } : t.ranges.push(l);
      }
      if (a && s.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !s.nextSibling(); ) {
          if (!s.parent())
            break e;
          if (t && !--t.depth) {
            let c = Sp(this.ranges, t.ranges);
            c.length && (pp(c), this.inner.splice(t.index, 0, new Op(t.parser, t.parser.startParse(this.input, vp(t.mounts, c), c), t.ranges.map((h) => new Lt(h.from - t.start, h.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function HT(i, e, t) {
  for (let r of i) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function gp(i, e, t, r, s, n) {
  if (e < t) {
    let o = i.buffer[e + 1];
    r.push(i.slice(e, t, o)), s.push(o - n);
  }
}
function GT(i) {
  let { node: e } = i, t = [], r = e.context.buffer;
  do
    t.push(i.index), i.parent();
  while (!i.tree);
  let s = i.tree, n = s.children.indexOf(r), o = s.children[n], a = o.buffer, l = [n];
  function c(h, u, d, O, v, S) {
    let f = t[S], p = [], g = [];
    gp(o, h, f, p, g, O);
    let m = a[f + 1], _ = a[f + 2];
    l.push(p.length);
    let b = S ? c(f + 4, a[f + 3], o.set.types[a[f]], m, _ - m, S - 1) : e.toTree();
    return p.push(b), g.push(m - O), gp(o, a[f + 3], u, p, g, O), new we(d, p, g, v);
  }
  s.children[n] = c(0, a.length, je.none, 0, o.length, t.length - 1);
  for (let h of l) {
    let u = i.tree.children[h], d = i.tree.positions[h];
    i.yield(new nt(u, d + i.from, h, i._tree));
  }
}
class mp {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Pe.IncludeAnonymous | Pe.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Pe.IgnoreOverlays | Pe.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof we)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let KT = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(uu)) !== null && t !== void 0 ? t : r.to, this.inner = new mp(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(uu)) !== null && e !== void 0 ? e : t.to, this.inner = new mp(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let n = this.inner.cursor.node; n; n = n.parent) {
        let o = (r = n.tree) === null || r === void 0 ? void 0 : r.prop(le.mounted);
        if (o && o.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= n.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: n.from - l.offset,
              mount: o
            });
          }
      }
    }
    return s;
  }
};
function Sp(i, e) {
  let t = null, r = e;
  for (let s = 1, n = 0; s < i.length; s++) {
    let o = i[s - 1].to, a = i[s].from;
    for (; n < r.length; n++) {
      let l = r[n];
      if (l.from >= a)
        break;
      l.to <= o || (t || (r = t = e.slice()), l.from < o ? (t[n] = new Lt(l.from, o), l.to > a && t.splice(n + 1, 0, new Lt(a, l.to))) : l.to > a ? t[n--] = new Lt(a, l.to) : t.splice(n--, 1));
    }
  }
  return r;
}
function JT(i, e, t, r) {
  let s = 0, n = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let h = s == i.length ? 1e9 : o ? i[s].to : i[s].from, u = n == e.length ? 1e9 : a ? e[n].to : e[n].from;
    if (o != a) {
      let d = Math.max(l, t), O = Math.min(h, u, r);
      d < O && c.push(new Lt(d, O));
    }
    if (l = Math.min(h, u), l == 1e9)
      break;
    h == l && (o ? (o = !1, s++) : o = !0), u == l && (a ? (a = !1, n++) : a = !0);
  }
  return c;
}
function vp(i, e) {
  let t = [];
  for (let { pos: r, mount: s, frag: n } of i) {
    let o = r + (s.overlay ? s.overlay[0].from : 0), a = o + s.tree.length, l = Math.max(n.from, o), c = Math.min(n.to, a);
    if (s.overlay) {
      let h = s.overlay.map((d) => new Lt(d.from + r, d.to + r)), u = JT(e, h, l, c);
      for (let d = 0, O = l; ; d++) {
        let v = d == u.length, S = v ? c : u[d].from;
        if (S > O && t.push(new Li(O, S, s.tree, -o, n.from >= O || n.openStart, n.to <= S || n.openEnd)), v)
          break;
        O = u[d].to;
      }
    } else
      t.push(new Li(l, c, s.tree, -o, n.from >= o || n.openStart, n.to <= a || n.openEnd));
  }
  return t;
}
let e$ = 0, li = class fu {
  /**
  @internal
  */
  constructor(e, t, r, s) {
    this.name = e, this.set = t, this.base = r, this.modified = s, this.id = e$++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof fu && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let s = new fu(r, [], null, []);
    if (s.set.push(s), t)
      for (let n of t.set)
        s.set.push(n);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new Va(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : Va.get(r.base || r, r.modified.concat(t).sort((s, n) => s.id - n.id));
  }
}, t$ = 0;
class Va {
  constructor(e) {
    this.name = e, this.instances = [], this.id = t$++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((a) => a.base == e && i$(t, a.modified));
    if (r)
      return r;
    let s = [], n = new li(e.name, s, e, t);
    for (let a of t)
      a.instances.push(n);
    let o = r$(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          s.push(Va.get(a, l));
    return n;
  }
}
function i$(i, e) {
  return i.length == e.length && i.every((t, r) => t == e[r]);
}
function r$(i) {
  let e = [[]];
  for (let t = 0; t < i.length; t++)
    for (let r = 0, s = e.length; r < s; r++)
      e.push(e[r].concat(i[t]));
  return e.sort((t, r) => r.length - t.length);
}
function Jt(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in i) {
    let r = i[t];
    Array.isArray(r) || (r = [r]);
    for (let s of t.split(" "))
      if (s) {
        let n = [], o = 2, a = s;
        for (let u = 0; ; ) {
          if (a == "..." && u > 0 && u + 3 == s.length) {
            o = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + s);
          if (n.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), u += d[0].length, u == s.length)
            break;
          let O = s[u++];
          if (u == s.length && O == "!") {
            o = 0;
            break;
          }
          if (O != "/")
            throw new RangeError("Invalid path: " + s);
          a = s.slice(u);
        }
        let l = n.length - 1, c = n[l];
        if (!c)
          throw new RangeError("Invalid path: " + s);
        let h = new Ua(r, o, l > 0 ? n.slice(0, l) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return wv.add(e);
}
const wv = new le();
class Ua {
  constructor(e, t, r, s) {
    this.tags = e, this.mode = t, this.context = r, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Ua.empty = new Ua([], 2, null);
function xv(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n of i)
    if (!Array.isArray(n.tag))
      t[n.tag.id] = n.class;
    else
      for (let o of n.tag)
        t[o.id] = n.class;
  let { scope: r, all: s = null } = e || {};
  return {
    style: (n) => {
      let o = s;
      for (let a of n)
        for (let l of a.set) {
          let c = t[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function s$(i, e) {
  let t = null;
  for (let r of i) {
    let s = r.style(e);
    s && (t = t ? t + " " + s : s);
  }
  return t;
}
function n$(i, e, t, r = 0, s = i.length) {
  let n = new o$(r, Array.isArray(e) ? e : [e], t);
  n.highlightRange(i.cursor(), r, s, "", n.highlighters), n.flush(s);
}
class o$ {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, s, n) {
    let { type: o, from: a, to: l } = e;
    if (a >= r || l <= t)
      return;
    o.isTop && (n = this.highlighters.filter((O) => !O.scope || O.scope(o)));
    let c = s, h = a$(e) || Ua.empty, u = s$(n, h.tags);
    if (u && (c && (c += " "), c += u, h.mode == 1 && (s += (s ? " " : "") + u)), this.startSpan(Math.max(t, a), c), h.opaque)
      return;
    let d = e.tree && e.tree.prop(le.mounted);
    if (d && d.overlay) {
      let O = e.node.enter(d.overlay[0].from + a, 1), v = this.highlighters.filter((f) => !f.scope || f.scope(d.tree.type)), S = e.firstChild();
      for (let f = 0, p = a; ; f++) {
        let g = f < d.overlay.length ? d.overlay[f] : null, m = g ? g.from + a : l, _ = Math.max(t, p), b = Math.min(r, m);
        if (_ < b && S)
          for (; e.from < b && (this.highlightRange(e, _, b, s, n), this.startSpan(Math.min(b, e.to), c), !(e.to >= m || !e.nextSibling())); )
            ;
        if (!g || m > r)
          break;
        p = g.to + a, p > t && (this.highlightRange(O.cursor(), Math.max(t, g.from + a), Math.min(r, p), "", v), this.startSpan(Math.min(r, p), c));
      }
      S && e.parent();
    } else if (e.firstChild()) {
      d && (s = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, s, n), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function a$(i) {
  let e = i.type.prop(wv);
  for (; e && e.context && !i.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const G = li.define, Mo = G(), Ni = G(), _p = G(Ni), bp = G(Ni), Yi = G(), Bo = G(Yi), gc = G(Yi), ai = G(), hr = G(ai), ni = G(), oi = G(), du = G(), Is = G(du), qo = G(), C = {
  /**
  A comment.
  */
  comment: Mo,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: G(Mo),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: G(Mo),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: G(Mo),
  /**
  Any kind of identifier.
  */
  name: Ni,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: G(Ni),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: _p,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: G(_p),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: bp,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: G(bp),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: G(Ni),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: G(Ni),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: G(Ni),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: G(Ni),
  /**
  A literal value.
  */
  literal: Yi,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Bo,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: G(Bo),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: G(Bo),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: G(Bo),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: gc,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: G(gc),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: G(gc),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: G(Yi),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: G(Yi),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: G(Yi),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: G(Yi),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: G(Yi),
  /**
  A language keyword.
  */
  keyword: ni,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: G(ni),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: G(ni),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: G(ni),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: G(ni),
  /**
  An operator.
  */
  operator: oi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: G(oi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: G(oi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: G(oi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: G(oi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: G(oi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: G(oi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: G(oi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: G(oi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: G(oi),
  /**
  Program or markup punctuation.
  */
  punctuation: du,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: G(du),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Is,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: G(Is),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: G(Is),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: G(Is),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: G(Is),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: ai,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: hr,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: G(hr),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: G(hr),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: G(hr),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: G(hr),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: G(hr),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: G(hr),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: G(ai),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: G(ai),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: G(ai),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: G(ai),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: G(ai),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: G(ai),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: G(ai),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: G(ai),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: G(),
  /**
  Deleted text.
  */
  deleted: G(),
  /**
  Changed text.
  */
  changed: G(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: G(),
  /**
  Metadata or meta-instruction.
  */
  meta: qo,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: G(qo),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: G(qo),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: G(qo),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: li.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: li.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: li.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: li.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: li.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: li.defineModifier("special")
};
for (let i in C) {
  let e = C[i];
  e instanceof li && (e.name = i);
}
xv([
  { tag: C.link, class: "tok-link" },
  { tag: C.heading, class: "tok-heading" },
  { tag: C.emphasis, class: "tok-emphasis" },
  { tag: C.strong, class: "tok-strong" },
  { tag: C.keyword, class: "tok-keyword" },
  { tag: C.atom, class: "tok-atom" },
  { tag: C.bool, class: "tok-bool" },
  { tag: C.url, class: "tok-url" },
  { tag: C.labelName, class: "tok-labelName" },
  { tag: C.inserted, class: "tok-inserted" },
  { tag: C.deleted, class: "tok-deleted" },
  { tag: C.literal, class: "tok-literal" },
  { tag: C.string, class: "tok-string" },
  { tag: C.number, class: "tok-number" },
  { tag: [C.regexp, C.escape, C.special(C.string)], class: "tok-string2" },
  { tag: C.variableName, class: "tok-variableName" },
  { tag: C.local(C.variableName), class: "tok-variableName tok-local" },
  { tag: C.definition(C.variableName), class: "tok-variableName tok-definition" },
  { tag: C.special(C.variableName), class: "tok-variableName2" },
  { tag: C.definition(C.propertyName), class: "tok-propertyName tok-definition" },
  { tag: C.typeName, class: "tok-typeName" },
  { tag: C.namespace, class: "tok-namespace" },
  { tag: C.className, class: "tok-className" },
  { tag: C.macroName, class: "tok-macroName" },
  { tag: C.propertyName, class: "tok-propertyName" },
  { tag: C.operator, class: "tok-operator" },
  { tag: C.comment, class: "tok-comment" },
  { tag: C.meta, class: "tok-meta" },
  { tag: C.invalid, class: "tok-invalid" },
  { tag: C.punctuation, class: "tok-punctuation" }
]);
var mc;
const br = /* @__PURE__ */ new le();
function Lf(i) {
  return ee.define({
    combine: i ? (e) => e.concat(i) : void 0
  });
}
const Df = /* @__PURE__ */ new le();
class Dt {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], s = "") {
    this.data = e, this.name = s, ve.prototype.hasOwnProperty("tree") || Object.defineProperty(ve.prototype, "tree", { get() {
      return xe(this);
    } }), this.parser = t, this.extension = [
      lr.of(this),
      ve.languageData.of((n, o, a) => {
        let l = yp(n, o, a), c = l.type.prop(br);
        if (!c)
          return [];
        let h = n.facet(c), u = l.type.prop(Df);
        if (u) {
          let d = l.resolve(o - l.from, a);
          for (let O of u)
            if (O.test(d, n)) {
              let v = n.facet(O.facet);
              return O.type == "replace" ? v : v.concat(h);
            }
        }
        return h;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return yp(e, t, r).type.prop(br) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(lr);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], s = (n, o) => {
      if (n.prop(br) == this.data) {
        r.push({ from: o, to: o + n.length });
        return;
      }
      let a = n.prop(le.mounted);
      if (a) {
        if (a.tree.prop(br) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + o, to: l.to + o });
          else
            r.push({ from: o, to: o + n.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (s(a.tree, a.overlay[0].from + o), r.length > l)
            return;
        }
      }
      for (let l = 0; l < n.children.length; l++) {
        let c = n.children[l];
        c instanceof we && s(c, n.positions[l] + o);
      }
    };
    return s(xe(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Dt.setState = /* @__PURE__ */ he.define();
function yp(i, e, t) {
  let r = i.facet(lr), s = xe(i).topNode;
  if (!r || r.allowsNesting)
    for (let n = s; n; n = n.enter(e, t, Pe.ExcludeBuffers))
      n.type.isTop && (s = n);
  return s;
}
class Ht extends Dt {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = Lf(e.languageData);
    return new Ht(t, e.parser.configure({
      props: [br.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Ht(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function xe(i) {
  let e = i.field(Dt.state, !1);
  return e ? e.tree : we.empty;
}
class l$ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let Zs = null;
class An {
  constructor(e, t, r = [], s, n, o, a, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = s, this.treeLen = n, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new An(e, t, [], we.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new l$(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != we.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let s = Date.now() + e;
        e = () => Date.now() > s;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(Li.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(Li.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Zs;
    Zs = this;
    try {
      return e();
    } finally {
      Zs = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = wp(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: s, treeLen: n, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, h, u, d) => l.push({ fromA: c, toA: h, fromB: u, toB: d })), r = Li.applyChanges(r, l), s = we.empty, n = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), u = e.mapPos(c.to, -1);
          h < u && a.push({ from: h, to: u });
        }
      }
    }
    return new An(this.parser, t, r, s, n, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: s, to: n } = this.skipped[r];
      s < e.to && n > e.from && (this.fragments = wp(this.fragments, s, n), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Af {
      createParse(t, r, s) {
        let n = s[0].from, o = s[s.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let l = Zs;
            if (l) {
              for (let c of s)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new we(je.none, [], [], o - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Zs;
  }
}
function wp(i, e, t) {
  return Li.applyChanges(i, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Os {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new Os(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = An.create(e.facet(lr).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new Os(r);
  }
}
Dt.state = /* @__PURE__ */ Ye.define({
  create: Os.init,
  update(i, e) {
    for (let t of e.effects)
      if (t.is(Dt.setState))
        return t.value;
    return e.startState.facet(lr) != e.state.facet(lr) ? Os.init(e.state) : i.apply(e);
  }
});
let kv = (i) => {
  let e = setTimeout(
    () => i(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (kv = (i) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(i, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Sc = typeof navigator < "u" && (!((mc = navigator.scheduling) === null || mc === void 0) && mc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, c$ = /* @__PURE__ */ Ve.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Dt.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Dt.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = kv(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: s } } = this.view, n = r.field(Dt.state);
    if (n.tree == n.context.tree && n.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Sc ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = n.context.treeLen < s && r.doc.length > s + 1e3, l = n.context.work(() => Sc && Sc() || Date.now() > o, s + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: Dt.setState.of(new Os(n.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(n.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => St(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), lr = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.length ? i[0] : null;
  },
  enables: (i) => [
    Dt.state,
    c$,
    K.contentAttributes.compute([i], (e) => {
      let t = e.facet(i);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class Si {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class ja {
  constructor(e, t, r, s, n, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = s, this.loadFunc = n, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new ja(e.name, (e.alias || []).concat(e.name).map((s) => s.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let s of e)
      if (s.filename && s.filename.test(t))
        return s;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let s of e)
        if (s.extensions.indexOf(r[1]) > -1)
          return s;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let s of e)
      if (s.alias.some((n) => n == t))
        return s;
    if (r)
      for (let s of e)
        for (let n of s.alias) {
          let o = t.indexOf(n);
          if (o > -1 && (n.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + n.length])))
            return s;
        }
    return null;
  }
}
const h$ = /* @__PURE__ */ ee.define(), co = /* @__PURE__ */ ee.define({
  combine: (i) => {
    if (!i.length)
      return "  ";
    let e = i[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(i[0]));
    return e;
  }
});
function Na(i) {
  let e = i.facet(co);
  return e.charCodeAt(0) == 9 ? i.tabSize * e.length : e.length;
}
function Ln(i, e) {
  let t = "", r = i.tabSize, s = i.facet(co)[0];
  if (s == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    s = " ";
  }
  for (let n = 0; n < e; n++)
    t += s;
  return t;
}
function Mf(i, e) {
  i instanceof ve && (i = new $l(i));
  for (let r of i.state.facet(h$)) {
    let s = r(i, e);
    if (s !== void 0)
      return s;
  }
  let t = xe(i.state);
  return t.length >= e ? u$(i, t, e) : null;
}
class $l {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Na(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: s, simulateDoubleBreak: n } = this.options;
    return s != null && s >= r.from && s <= r.to ? n && s == e ? { text: "", from: e } : (t < 0 ? s < e : s <= e) ? { text: r.text.slice(s - r.from), from: s } : { text: r.text.slice(0, s - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: s } = this.lineAt(e, t);
    return r.slice(e - s, Math.min(r.length, e + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: s } = this.lineAt(e, t), n = this.countColumn(r, e - s), o = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return o > -1 && (n += o - this.countColumn(r, r.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Nt(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: s } = this.lineAt(e, t), n = this.options.overrideIndentation;
    if (n) {
      let o = n(s);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const bi = /* @__PURE__ */ new le();
function u$(i, e, t) {
  let r = e.resolveStack(t), s = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (s != r.node) {
    let n = [];
    for (let o = s; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      n.push(o);
    for (let o = n.length - 1; o >= 0; o--)
      r = { node: n[o], next: r };
  }
  return Cv(r, i, t);
}
function Cv(i, e, t) {
  for (let r = i; r; r = r.next) {
    let s = d$(r.node);
    if (s)
      return s(Bf.create(e, t, r));
  }
  return 0;
}
function f$(i) {
  return i.pos == i.options.simulateBreak && i.options.simulateDoubleBreak;
}
function d$(i) {
  let e = i.type.prop(bi);
  if (e)
    return e;
  let t = i.firstChild, r;
  if (t && (r = t.type.prop(le.closedBy))) {
    let s = i.lastChild, n = s && r.indexOf(s.name) > -1;
    return (o) => Qv(o, !0, 1, void 0, n && !f$(o) ? s.from : void 0);
  }
  return i.parent == null ? O$ : null;
}
function O$() {
  return 0;
}
class Bf extends $l {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Bf(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (p$(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return Cv(this.context.next, this.base, this.pos);
  }
}
function p$(i, e) {
  for (let t = e; t; t = t.parent)
    if (i == t)
      return !0;
  return !1;
}
function g$(i) {
  let e = i.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let s = i.options.simulateBreak, n = i.state.doc.lineAt(t.from), o = s == null || s <= n.from ? n.to : Math.min(n.to, s);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= o)
        return null;
      let c = /^ */.exec(n.text.slice(t.to - n.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    a = l.to;
  }
}
function rs({ closing: i, align: e = !0, units: t = 1 }) {
  return (r) => Qv(r, e, t, i);
}
function Qv(i, e, t, r, s) {
  let n = i.textAfter, o = n.match(/^\s*/)[0].length, a = r && n.slice(o, o + r.length) == r || s == i.pos + o, l = e ? g$(i) : null;
  return l ? a ? i.column(l.from) : i.column(l.to) : i.baseIndent + (a ? 0 : i.unit * t);
}
const m$ = (i) => i.baseIndent;
function Cr({ except: i, units: e = 1 } = {}) {
  return (t) => {
    let r = i && i.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const S$ = 200;
function v$() {
  return ve.transactionFilter.of((i) => {
    if (!i.docChanged || !i.isUserEvent("input.type") && !i.isUserEvent("input.complete"))
      return i;
    let e = i.startState.languageDataAt("indentOnInput", i.startState.selection.main.head);
    if (!e.length)
      return i;
    let t = i.newDoc, { head: r } = i.newSelection.main, s = t.lineAt(r);
    if (r > s.from + S$)
      return i;
    let n = t.sliceString(s.from, r);
    if (!e.some((c) => c.test(n)))
      return i;
    let { state: o } = i, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let h = o.doc.lineAt(c);
      if (h.from == a)
        continue;
      a = h.from;
      let u = Mf(o, h.from);
      if (u == null)
        continue;
      let d = /^\s*/.exec(h.text)[0], O = Ln(o, u);
      d != O && l.push({ from: h.from, to: h.from + d.length, insert: O });
    }
    return l.length ? [i, { changes: l, sequential: !0 }] : i;
  });
}
const Pv = /* @__PURE__ */ ee.define(), ei = /* @__PURE__ */ new le();
function ho(i) {
  let e = i.firstChild, t = i.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? i.to : t.from } : null;
}
function _$(i, e, t) {
  let r = xe(i);
  if (r.length < t)
    return null;
  let s = r.resolveStack(t, 1), n = null;
  for (let o = s; o; o = o.next) {
    let a = o.node;
    if (a.to <= t || a.from > t)
      continue;
    if (n && a.from < e)
      break;
    let l = a.type.prop(ei);
    if (l && (a.to < r.length - 50 || r.length == i.doc.length || !b$(a))) {
      let c = l(a, i);
      c && c.from <= t && c.from >= e && c.to > t && (n = c);
    }
  }
  return n;
}
function b$(i) {
  let e = i.lastChild;
  return e && e.to == i.to && e.type.isError;
}
function Ya(i, e, t) {
  for (let r of i.facet(Pv)) {
    let s = r(i, e, t);
    if (s)
      return s;
  }
  return _$(i, e, t);
}
function Tv(i, e) {
  let t = e.mapPos(i.from, 1), r = e.mapPos(i.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const Rl = /* @__PURE__ */ he.define({ map: Tv }), uo = /* @__PURE__ */ he.define({ map: Tv });
function $v(i) {
  let e = [];
  for (let { head: t } of i.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(i.lineBlockAt(t));
  return e;
}
const Dr = /* @__PURE__ */ Ye.define({
  create() {
    return ae.none;
  },
  update(i, e) {
    i = i.map(e.changes);
    for (let t of e.effects)
      if (t.is(Rl) && !y$(i, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(Av), s = r ? ae.replace({ widget: new T$(r(e.state, t.value)) }) : xp;
        i = i.update({ add: [s.range(t.value.from, t.value.to)] });
      } else t.is(uo) && (i = i.update({
        filter: (r, s) => t.value.from != r || t.value.to != s,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: r } = e.selection.main;
      i.between(r, r, (s, n) => {
        s < r && n > r && (t = !0);
      }), t && (i = i.update({
        filterFrom: r,
        filterTo: r,
        filter: (s, n) => n <= r || s >= r
      }));
    }
    return i;
  },
  provide: (i) => K.decorations.from(i),
  toJSON(i, e) {
    let t = [];
    return i.between(0, e.doc.length, (r, s) => {
      t.push(r, s);
    }), t;
  },
  fromJSON(i) {
    if (!Array.isArray(i) || i.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < i.length; ) {
      let r = i[t++], s = i[t++];
      if (typeof r != "number" || typeof s != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(xp.range(r, s));
    }
    return ae.set(e, !0);
  }
});
function Fa(i, e, t) {
  var r;
  let s = null;
  return (r = i.field(Dr, !1)) === null || r === void 0 || r.between(e, t, (n, o) => {
    (!s || s.from > n) && (s = { from: n, to: o });
  }), s;
}
function y$(i, e, t) {
  let r = !1;
  return i.between(e, e, (s, n) => {
    s == e && n == t && (r = !0);
  }), r;
}
function Rv(i, e) {
  return i.field(Dr, !1) ? e : e.concat(he.appendConfig.of(Lv()));
}
const w$ = (i) => {
  for (let e of $v(i)) {
    let t = Ya(i.state, e.from, e.to);
    if (t)
      return i.dispatch({ effects: Rv(i.state, [Rl.of(t), Ev(i, t)]) }), !0;
  }
  return !1;
}, x$ = (i) => {
  if (!i.state.field(Dr, !1))
    return !1;
  let e = [];
  for (let t of $v(i)) {
    let r = Fa(i.state, t.from, t.to);
    r && e.push(uo.of(r), Ev(i, r, !1));
  }
  return e.length && i.dispatch({ effects: e }), e.length > 0;
};
function Ev(i, e, t = !0) {
  let r = i.state.doc.lineAt(e.from).number, s = i.state.doc.lineAt(e.to).number;
  return K.announce.of(`${i.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${i.state.phrase("to")} ${s}.`);
}
const k$ = (i) => {
  let { state: e } = i, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let s = i.lineBlockAt(r), n = Ya(e, s.from, s.to);
    n && t.push(Rl.of(n)), r = (n ? i.lineBlockAt(n.to) : s).to + 1;
  }
  return t.length && i.dispatch({ effects: Rv(i.state, t) }), !!t.length;
}, C$ = (i) => {
  let e = i.state.field(Dr, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, i.state.doc.length, (r, s) => {
    t.push(uo.of({ from: r, to: s }));
  }), i.dispatch({ effects: t }), !0;
}, Q$ = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: w$ },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: x$ },
  { key: "Ctrl-Alt-[", run: k$ },
  { key: "Ctrl-Alt-]", run: C$ }
], P$ = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, Av = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, P$);
  }
});
function Lv(i) {
  return [Dr, E$];
}
function Dv(i, e) {
  let { state: t } = i, r = t.facet(Av), s = (o) => {
    let a = i.lineBlockAt(i.posAtDOM(o.target)), l = Fa(i.state, a.from, a.to);
    l && i.dispatch({ effects: uo.of(l) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(i, s, e);
  let n = document.createElement("span");
  return n.textContent = r.placeholderText, n.setAttribute("aria-label", t.phrase("folded code")), n.title = t.phrase("unfold"), n.className = "cm-foldPlaceholder", n.onclick = s, n;
}
const xp = /* @__PURE__ */ ae.replace({ widget: /* @__PURE__ */ new class extends zi {
  toDOM(i) {
    return Dv(i, null);
  }
}() });
class T$ extends zi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return Dv(e, this.value);
  }
}
const $$ = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class vc extends Xi {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function R$(i = {}) {
  let e = { ...$$, ...i }, t = new vc(e, !0), r = new vc(e, !1), s = Ve.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(lr) != o.state.facet(lr) || o.startState.field(Dr, !1) != o.state.field(Dr, !1) || xe(o.startState) != xe(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new Bi();
      for (let l of o.viewportLineBlocks) {
        let c = Fa(o.state, l.from, l.to) ? r : Ya(o.state, l.from, l.to) ? t : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: n } = e;
  return [
    s,
    $T({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(s)) === null || a === void 0 ? void 0 : a.markers) || be.empty;
      },
      initialSpacer() {
        return new vc(e, !1);
      },
      domEventHandlers: {
        ...n,
        click: (o, a, l) => {
          if (n.click && n.click(o, a, l))
            return !0;
          let c = Fa(o.state, a.from, a.to);
          if (c)
            return o.dispatch({ effects: uo.of(c) }), !0;
          let h = Ya(o.state, a.from, a.to);
          return h ? (o.dispatch({ effects: Rl.of(h) }), !0) : !1;
        }
      }
    }),
    Lv()
  ];
}
const E$ = /* @__PURE__ */ K.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class xs {
  constructor(e, t) {
    this.specs = e;
    let r;
    function s(a) {
      let l = sr.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const n = typeof t.all == "string" ? t.all : t.all ? s(t.all) : void 0, o = t.scope;
    this.scope = o instanceof Dt ? (a) => a.prop(br) == o.data : o ? (a) => a == o : void 0, this.style = xv(e.map((a) => ({
      tag: a.tag,
      class: a.class || s(Object.assign({}, a, { tag: null }))
    })), {
      all: n
    }).style, this.module = r ? new sr(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new xs(e, t || {});
  }
}
const Ou = /* @__PURE__ */ ee.define(), Mv = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.length ? [i[0]] : null;
  }
});
function _c(i) {
  let e = i.facet(Ou);
  return e.length ? e : i.facet(Mv);
}
function Bv(i, e) {
  let t = [L$], r;
  return i instanceof xs && (i.module && t.push(K.styleModule.of(i.module)), r = i.themeType), e?.fallback ? t.push(Mv.of(i)) : r ? t.push(Ou.computeN([K.darkTheme], (s) => s.facet(K.darkTheme) == (r == "dark") ? [i] : [])) : t.push(Ou.of(i)), t;
}
class A$ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = xe(e.state), this.decorations = this.buildDeco(e, _c(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = xe(e.state), r = _c(e.state), s = r != _c(e.startState), { viewport: n } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < n.to && !s && t.type == this.tree.type && o >= n.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || s) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = n.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return ae.none;
    let r = new Bi();
    for (let { from: s, to: n } of e.visibleRanges)
      n$(this.tree, t, (o, a, l) => {
        r.add(o, a, this.markCache[l] || (this.markCache[l] = ae.mark({ class: l })));
      }, s, n);
    return r.finish();
  }
}
const L$ = /* @__PURE__ */ Zi.high(/* @__PURE__ */ Ve.fromClass(A$, {
  decorations: (i) => i.decorations
})), D$ = /* @__PURE__ */ xs.define([
  {
    tag: C.meta,
    color: "#404740"
  },
  {
    tag: C.link,
    textDecoration: "underline"
  },
  {
    tag: C.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: C.emphasis,
    fontStyle: "italic"
  },
  {
    tag: C.strong,
    fontWeight: "bold"
  },
  {
    tag: C.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: C.keyword,
    color: "#708"
  },
  {
    tag: [C.atom, C.bool, C.url, C.contentSeparator, C.labelName],
    color: "#219"
  },
  {
    tag: [C.literal, C.inserted],
    color: "#164"
  },
  {
    tag: [C.string, C.deleted],
    color: "#a11"
  },
  {
    tag: [C.regexp, C.escape, /* @__PURE__ */ C.special(C.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ C.definition(C.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ C.local(C.variableName),
    color: "#30a"
  },
  {
    tag: [C.typeName, C.namespace],
    color: "#085"
  },
  {
    tag: C.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ C.special(C.variableName), C.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ C.definition(C.propertyName),
    color: "#00c"
  },
  {
    tag: C.comment,
    color: "#940"
  },
  {
    tag: C.invalid,
    color: "#f00"
  }
]), M$ = /* @__PURE__ */ K.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), qv = 1e4, Xv = "()[]{}", Iv = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, {
      afterCursor: !0,
      brackets: Xv,
      maxScanDistance: qv,
      renderMatch: X$
    });
  }
}), B$ = /* @__PURE__ */ ae.mark({ class: "cm-matchingBracket" }), q$ = /* @__PURE__ */ ae.mark({ class: "cm-nonmatchingBracket" });
function X$(i) {
  let e = [], t = i.matched ? B$ : q$;
  return e.push(t.range(i.start.from, i.start.to)), i.end && e.push(t.range(i.end.from, i.end.to)), e;
}
const I$ = /* @__PURE__ */ Ye.define({
  create() {
    return ae.none;
  },
  update(i, e) {
    if (!e.docChanged && !e.selection)
      return i;
    let t = [], r = e.state.facet(Iv);
    for (let s of e.state.selection.ranges) {
      if (!s.empty)
        continue;
      let n = di(e.state, s.head, -1, r) || s.head > 0 && di(e.state, s.head - 1, 1, r) || r.afterCursor && (di(e.state, s.head, 1, r) || s.head < e.state.doc.length && di(e.state, s.head + 1, -1, r));
      n && (t = t.concat(r.renderMatch(n, e.state)));
    }
    return ae.set(t, !0);
  },
  provide: (i) => K.decorations.from(i)
}), Z$ = [
  I$,
  M$
];
function W$(i = {}) {
  return [Iv.of(i), Z$];
}
const qf = /* @__PURE__ */ new le();
function pu(i, e, t) {
  let r = i.prop(e < 0 ? le.openedBy : le.closedBy);
  if (r)
    return r;
  if (i.name.length == 1) {
    let s = t.indexOf(i.name);
    if (s > -1 && s % 2 == (e < 0 ? 1 : 0))
      return [t[s + e]];
  }
  return null;
}
function gu(i) {
  let e = i.type.prop(qf);
  return e ? e(i.node) : i;
}
function di(i, e, t, r = {}) {
  let s = r.maxScanDistance || qv, n = r.brackets || Xv, o = xe(i), a = o.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let c = pu(l.type, t, n);
    if (c && l.from < l.to) {
      let h = gu(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return z$(i, e, t, l, h, c, n);
    }
  }
  return V$(i, e, t, o, a.type, s, n);
}
function z$(i, e, t, r, s, n, o) {
  let a = r.parent, l = { from: s.from, to: s.to }, c = 0, h = a?.cursor();
  if (h && (t < 0 ? h.childBefore(r.from) : h.childAfter(r.to)))
    do
      if (t < 0 ? h.to <= r.from : h.from >= r.to) {
        if (c == 0 && n.indexOf(h.type.name) > -1 && h.from < h.to) {
          let u = gu(h);
          return { start: l, end: u ? { from: u.from, to: u.to } : void 0, matched: !0 };
        } else if (pu(h.type, t, o))
          c++;
        else if (pu(h.type, -t, o)) {
          if (c == 0) {
            let u = gu(h);
            return {
              start: l,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function V$(i, e, t, r, s, n, o) {
  let a = t < 0 ? i.sliceDoc(e - 1, e) : i.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = i.doc.iterRange(e, t > 0 ? i.doc.length : 0), u = 0;
  for (let d = 0; !h.next().done && d <= n; ) {
    let O = h.value;
    t < 0 && (d += O.length);
    let v = e + d * t;
    for (let S = t > 0 ? 0 : O.length - 1, f = t > 0 ? O.length : -1; S != f; S += t) {
      let p = o.indexOf(O[S]);
      if (!(p < 0 || r.resolveInner(v + S, 1).type != s))
        if (p % 2 == 0 == t > 0)
          u++;
        else {
          if (u == 1)
            return { start: c, end: { from: v + S, to: v + S + 1 }, matched: p >> 1 == l >> 1 };
          u--;
        }
    }
    t > 0 && (d += O.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const U$ = /* @__PURE__ */ Object.create(null), kp = [je.none], Cp = [], Qp = /* @__PURE__ */ Object.create(null), j$ = /* @__PURE__ */ Object.create(null);
for (let [i, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  j$[i] = /* @__PURE__ */ N$(U$, e);
function bc(i, e) {
  Cp.indexOf(i) > -1 || (Cp.push(i), console.warn(e));
}
function N$(i, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let h = i[c] || C[c];
      h ? typeof h == "function" ? l.length ? l = l.map(h) : bc(c, `Modifier ${c} used at start of tag`) : l.length ? bc(c, `Tag ${c} used as modifier`) : l = Array.isArray(h) ? h : [h] : bc(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), s = r + " " + t.map((a) => a.id), n = Qp[s];
  if (n)
    return n.id;
  let o = Qp[s] = je.define({
    id: kp.length,
    name: r,
    props: [Jt({ [r]: t })]
  });
  return kp.push(o), o.id;
}
Le.RTL, Le.LTR;
const Y$ = (i) => {
  let { state: e } = i, t = e.doc.lineAt(e.selection.main.from), r = If(i.state, t.from);
  return r.line ? F$(i) : r.block ? G$(i) : !1;
};
function Xf(i, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let s = i(e, t);
    return s ? (r(t.update(s)), !0) : !1;
  };
}
const F$ = /* @__PURE__ */ Xf(
  eR,
  0
  /* CommentOption.Toggle */
), H$ = /* @__PURE__ */ Xf(
  Zv,
  0
  /* CommentOption.Toggle */
), G$ = /* @__PURE__ */ Xf(
  (i, e) => Zv(i, e, J$(e)),
  0
  /* CommentOption.Toggle */
);
function If(i, e) {
  let t = i.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const Ws = 50;
function K$(i, { open: e, close: t }, r, s) {
  let n = i.sliceDoc(r - Ws, r), o = i.sliceDoc(s, s + Ws), a = /\s*$/.exec(n)[0].length, l = /^\s*/.exec(o)[0].length, c = n.length - a;
  if (n.slice(c - e.length, c) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: s + l, margin: l && 1 }
    };
  let h, u;
  s - r <= 2 * Ws ? h = u = i.sliceDoc(r, s) : (h = i.sliceDoc(r, r + Ws), u = i.sliceDoc(s - Ws, s));
  let d = /^\s*/.exec(h)[0].length, O = /\s*$/.exec(u)[0].length, v = u.length - O - t.length;
  return h.slice(d, d + e.length) == e && u.slice(v, v + t.length) == t ? {
    open: {
      pos: r + d + e.length,
      margin: /\s/.test(h.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: s - O - t.length,
      margin: /\s/.test(u.charAt(v - 1)) ? 1 : 0
    }
  } : null;
}
function J$(i) {
  let e = [];
  for (let t of i.selection.ranges) {
    let r = i.doc.lineAt(t.from), s = t.to <= r.to ? r : i.doc.lineAt(t.to);
    s.from > r.from && s.from == t.to && (s = t.to == r.to + 1 ? r : i.doc.lineAt(t.to - 1));
    let n = e.length - 1;
    n >= 0 && e[n].to > r.from ? e[n].to = s.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: s.to });
  }
  return e;
}
function Zv(i, e, t = e.selection.ranges) {
  let r = t.map((n) => If(e, n.from).block);
  if (!r.every((n) => n))
    return null;
  let s = t.map((n, o) => K$(e, r[o], n.from, n.to));
  if (i != 2 && !s.every((n) => n))
    return { changes: e.changes(t.map((n, o) => s[o] ? [] : [{ from: n.from, insert: r[o].open + " " }, { from: n.to, insert: " " + r[o].close }])) };
  if (i != 1 && s.some((n) => n)) {
    let n = [];
    for (let o = 0, a; o < s.length; o++)
      if (a = s[o]) {
        let l = r[o], { open: c, close: h } = a;
        n.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: n };
  }
  return null;
}
function eR(i, e, t = e.selection.ranges) {
  let r = [], s = -1;
  for (let { from: n, to: o } of t) {
    let a = r.length, l = 1e9, c = If(e, n).line;
    if (c) {
      for (let h = n; h <= o; ) {
        let u = e.doc.lineAt(h);
        if (u.from > s && (n == o || o > u.from)) {
          s = u.from;
          let d = /^\s*/.exec(u.text)[0].length, O = d == u.length, v = u.text.slice(d, d + c.length) == c ? d : -1;
          d < u.text.length && d < l && (l = d), r.push({ line: u, comment: v, token: c, indent: d, empty: O, single: !1 });
        }
        h = u.to + 1;
      }
      if (l < 1e9)
        for (let h = a; h < r.length; h++)
          r[h].indent < r[h].line.text.length && (r[h].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (i != 2 && r.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: a, token: l, indent: c, empty: h, single: u } of r)
      (u || !h) && n.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(n);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (i != 1 && r.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let c = o.from + a, h = c + l.length;
        o.text[h - o.from] == " " && h++, n.push({ from: c, to: h });
      }
    return { changes: n };
  }
  return null;
}
const mu = /* @__PURE__ */ Wi.define(), tR = /* @__PURE__ */ Wi.define(), iR = /* @__PURE__ */ ee.define(), Wv = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, s) => e(r, s) || t(r, s)
    });
  }
}), zv = /* @__PURE__ */ Ye.define({
  create() {
    return Oi.empty;
  },
  update(i, e) {
    let t = e.state.facet(Wv), r = e.annotation(mu);
    if (r) {
      let l = vt.fromTransaction(e, r.selection), c = r.side, h = c == 0 ? i.undone : i.done;
      return l ? h = Ha(h, h.length, t.minDepth, l) : h = jv(h, e.startState.selection), new Oi(c == 0 ? r.rest : h, c == 0 ? h : r.rest);
    }
    let s = e.annotation(tR);
    if ((s == "full" || s == "before") && (i = i.isolate()), e.annotation(We.addToHistory) === !1)
      return e.changes.empty ? i : i.addMapping(e.changes.desc);
    let n = vt.fromTransaction(e), o = e.annotation(We.time), a = e.annotation(We.userEvent);
    return n ? i = i.addChanges(n, o, a, t, e) : e.selection && (i = i.addSelection(e.startState.selection, o, a, t.newGroupDelay)), (s == "full" || s == "after") && (i = i.isolate()), i;
  },
  toJSON(i) {
    return { done: i.done.map((e) => e.toJSON()), undone: i.undone.map((e) => e.toJSON()) };
  },
  fromJSON(i) {
    return new Oi(i.done.map(vt.fromJSON), i.undone.map(vt.fromJSON));
  }
});
function rR(i = {}) {
  return [
    zv,
    Wv.of(i),
    K.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? Vv : e.inputType == "historyRedo" ? Su : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function El(i, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let s = t.field(zv, !1);
    if (!s)
      return !1;
    let n = s.pop(i, t, e);
    return n ? (r(n), !0) : !1;
  };
}
const Vv = /* @__PURE__ */ El(0, !1), Su = /* @__PURE__ */ El(1, !1), sR = /* @__PURE__ */ El(0, !0), nR = /* @__PURE__ */ El(1, !0);
class vt {
  constructor(e, t, r, s, n) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = s, this.selectionsAfter = n;
  }
  setSelAfter(e) {
    return new vt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(e) {
    return new vt(e.changes && Ue.fromJSON(e.changes), [], e.mapped && pi.fromJSON(e.mapped), e.startSelection && V.fromJSON(e.startSelection), e.selectionsAfter.map(V.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = Mt;
    for (let s of e.startState.facet(iR)) {
      let n = s(e);
      n.length && (r = r.concat(n));
    }
    return !r.length && e.changes.empty ? null : new vt(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, Mt);
  }
  static selection(e) {
    return new vt(void 0, Mt, void 0, void 0, e);
  }
}
function Ha(i, e, t, r) {
  let s = e + 1 > t + 20 ? e - t - 1 : 0, n = i.slice(s, e);
  return n.push(r), n;
}
function oR(i, e) {
  let t = [], r = !1;
  return i.iterChangedRanges((s, n) => t.push(s, n)), e.iterChangedRanges((s, n, o, a) => {
    for (let l = 0; l < t.length; ) {
      let c = t[l++], h = t[l++];
      a >= c && o <= h && (r = !0);
    }
  }), r;
}
function aR(i, e) {
  return i.ranges.length == e.ranges.length && i.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function Uv(i, e) {
  return i.length ? e.length ? i.concat(e) : i : e;
}
const Mt = [], lR = 200;
function jv(i, e) {
  if (i.length) {
    let t = i[i.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - lR));
    return r.length && r[r.length - 1].eq(e) ? i : (r.push(e), Ha(i, i.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [vt.selection([e])];
}
function cR(i) {
  let e = i[i.length - 1], t = i.slice();
  return t[i.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function yc(i, e) {
  if (!i.length)
    return i;
  let t = i.length, r = Mt;
  for (; t; ) {
    let s = hR(i[t - 1], e, r);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let n = i.slice(0, t);
      return n[t - 1] = s, n;
    } else
      e = s.mapped, t--, r = s.selectionsAfter;
  }
  return r.length ? [vt.selection(r)] : Mt;
}
function hR(i, e, t) {
  let r = Uv(i.selectionsAfter.length ? i.selectionsAfter.map((a) => a.map(e)) : Mt, t);
  if (!i.changes)
    return vt.selection(r);
  let s = i.changes.map(e), n = e.mapDesc(i.changes, !0), o = i.mapped ? i.mapped.composeDesc(n) : n;
  return new vt(s, he.mapEffects(i.effects, e), o, i.startSelection.map(n), r);
}
const uR = /^(input\.type|delete)($|\.)/;
class Oi {
  constructor(e, t, r = 0, s = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new Oi(this.done, this.undone) : this;
  }
  addChanges(e, t, r, s, n) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || uR.test(r)) && (!a.selectionsAfter.length && t - this.prevTime < s.newGroupDelay && s.joinToEvent(n, oR(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = Ha(o, o.length - 1, s.minDepth, new vt(e.changes.compose(a.changes), Uv(he.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, Mt)) : o = Ha(o, o.length, s.minDepth, e), new Oi(o, Mt, t, r);
  }
  addSelection(e, t, r, s) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Mt;
    return n.length > 0 && t - this.prevTime < s && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && aR(n[n.length - 1], e) ? this : new Oi(jv(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new Oi(yc(this.done, e), yc(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let s = e == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let n = s[s.length - 1], o = n.selectionsAfter[0] || t.selection;
    if (r && n.selectionsAfter.length)
      return t.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: mu.of({ side: e, rest: cR(s), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let a = s.length == 1 ? Mt : s.slice(0, s.length - 1);
      return n.mapped && (a = yc(a, n.mapped)), t.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: mu.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Oi.empty = /* @__PURE__ */ new Oi(Mt, Mt);
const fR = [
  { key: "Mod-z", run: Vv, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Su, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Su, preventDefault: !0 },
  { key: "Mod-u", run: sR, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: nR, preventDefault: !0 }
];
function ks(i, e) {
  return V.create(i.ranges.map(e), i.mainIndex);
}
function yi(i, e) {
  return i.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ti({ state: i, dispatch: e }, t) {
  let r = ks(i.selection, t);
  return r.eq(i.selection, !0) ? !1 : (e(yi(i, r)), !0);
}
function Al(i, e) {
  return V.cursor(e ? i.to : i.from);
}
function Nv(i, e) {
  return ti(i, (t) => t.empty ? i.moveByChar(t, e) : Al(t, e));
}
function at(i) {
  return i.textDirectionAt(i.state.selection.main.head) == Le.LTR;
}
const Yv = (i) => Nv(i, !at(i)), Fv = (i) => Nv(i, at(i));
function Hv(i, e) {
  return ti(i, (t) => t.empty ? i.moveByGroup(t, e) : Al(t, e));
}
const dR = (i) => Hv(i, !at(i)), OR = (i) => Hv(i, at(i));
function pR(i, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(i.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Ll(i, e, t) {
  let r = xe(i).resolveInner(e.head), s = t ? le.closedBy : le.openedBy;
  for (let l = e.head; ; ) {
    let c = t ? r.childAfter(l) : r.childBefore(l);
    if (!c)
      break;
    pR(i, c, s) ? r = c : l = t ? c.to : c.from;
  }
  let n = r.type.prop(s), o, a;
  return n && (o = t ? di(i, r.from, 1) : di(i, r.to, -1)) && o.matched ? a = t ? o.end.to : o.end.from : a = t ? r.to : r.from, V.cursor(a, t ? -1 : 1);
}
const gR = (i) => ti(i, (e) => Ll(i.state, e, !at(i))), mR = (i) => ti(i, (e) => Ll(i.state, e, at(i)));
function Gv(i, e) {
  return ti(i, (t) => {
    if (!t.empty)
      return Al(t, e);
    let r = i.moveVertically(t, e);
    return r.head != t.head ? r : i.moveToLineBoundary(t, e);
  });
}
const Kv = (i) => Gv(i, !1), Jv = (i) => Gv(i, !0);
function e_(i) {
  let e = i.scrollDOM.clientHeight < i.scrollDOM.scrollHeight - 2, t = 0, r = 0, s;
  if (e) {
    for (let n of i.state.facet(K.scrollMargins)) {
      let o = n(i);
      o?.top && (t = Math.max(o?.top, t)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    s = i.scrollDOM.clientHeight - t - r;
  } else
    s = (i.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(i.defaultLineHeight, s - 5)
  };
}
function t_(i, e) {
  let t = e_(i), { state: r } = i, s = ks(r.selection, (o) => o.empty ? i.moveVertically(o, e, t.height) : Al(o, e));
  if (s.eq(r.selection))
    return !1;
  let n;
  if (t.selfScroll) {
    let o = i.coordsAtPos(r.selection.main.head), a = i.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, c = a.bottom - t.marginBottom;
    o && o.top > l && o.bottom < c && (n = K.scrollIntoView(s.main.head, { y: "start", yMargin: o.top - l }));
  }
  return i.dispatch(yi(r, s), { effects: n }), !0;
}
const Pp = (i) => t_(i, !1), vu = (i) => t_(i, !0);
function cr(i, e, t) {
  let r = i.lineBlockAt(e.head), s = i.moveToLineBoundary(e, t);
  if (s.head == e.head && s.head != (t ? r.to : r.from) && (s = i.moveToLineBoundary(e, t, !1)), !t && s.head == r.from && r.length) {
    let n = /^\s*/.exec(i.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    n && e.head != r.from + n && (s = V.cursor(r.from + n));
  }
  return s;
}
const SR = (i) => ti(i, (e) => cr(i, e, !0)), vR = (i) => ti(i, (e) => cr(i, e, !1)), _R = (i) => ti(i, (e) => cr(i, e, !at(i))), bR = (i) => ti(i, (e) => cr(i, e, at(i))), yR = (i) => ti(i, (e) => V.cursor(i.lineBlockAt(e.head).from, 1)), wR = (i) => ti(i, (e) => V.cursor(i.lineBlockAt(e.head).to, -1));
function xR(i, e, t) {
  let r = !1, s = ks(i.selection, (n) => {
    let o = di(i, n.head, -1) || di(i, n.head, 1) || n.head > 0 && di(i, n.head - 1, 1) || n.head < i.doc.length && di(i, n.head + 1, -1);
    if (!o || !o.end)
      return n;
    r = !0;
    let a = o.start.from == n.head ? o.end.to : o.end.from;
    return V.cursor(a);
  });
  return r ? (e(yi(i, s)), !0) : !1;
}
const kR = ({ state: i, dispatch: e }) => xR(i, e);
function It(i, e) {
  let t = ks(i.state.selection, (r) => {
    let s = e(r);
    return V.range(r.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return t.eq(i.state.selection) ? !1 : (i.dispatch(yi(i.state, t)), !0);
}
function i_(i, e) {
  return It(i, (t) => i.moveByChar(t, e));
}
const r_ = (i) => i_(i, !at(i)), s_ = (i) => i_(i, at(i));
function n_(i, e) {
  return It(i, (t) => i.moveByGroup(t, e));
}
const CR = (i) => n_(i, !at(i)), QR = (i) => n_(i, at(i)), PR = (i) => It(i, (e) => Ll(i.state, e, !at(i))), TR = (i) => It(i, (e) => Ll(i.state, e, at(i)));
function o_(i, e) {
  return It(i, (t) => i.moveVertically(t, e));
}
const a_ = (i) => o_(i, !1), l_ = (i) => o_(i, !0);
function c_(i, e) {
  return It(i, (t) => i.moveVertically(t, e, e_(i).height));
}
const Tp = (i) => c_(i, !1), $p = (i) => c_(i, !0), $R = (i) => It(i, (e) => cr(i, e, !0)), RR = (i) => It(i, (e) => cr(i, e, !1)), ER = (i) => It(i, (e) => cr(i, e, !at(i))), AR = (i) => It(i, (e) => cr(i, e, at(i))), LR = (i) => It(i, (e) => V.cursor(i.lineBlockAt(e.head).from)), DR = (i) => It(i, (e) => V.cursor(i.lineBlockAt(e.head).to)), Rp = ({ state: i, dispatch: e }) => (e(yi(i, { anchor: 0 })), !0), Ep = ({ state: i, dispatch: e }) => (e(yi(i, { anchor: i.doc.length })), !0), Ap = ({ state: i, dispatch: e }) => (e(yi(i, { anchor: i.selection.main.anchor, head: 0 })), !0), Lp = ({ state: i, dispatch: e }) => (e(yi(i, { anchor: i.selection.main.anchor, head: i.doc.length })), !0), MR = ({ state: i, dispatch: e }) => (e(i.update({ selection: { anchor: 0, head: i.doc.length }, userEvent: "select" })), !0), BR = ({ state: i, dispatch: e }) => {
  let t = Dl(i).map(({ from: r, to: s }) => V.range(r, Math.min(s + 1, i.doc.length)));
  return e(i.update({ selection: V.create(t), userEvent: "select" })), !0;
}, qR = ({ state: i, dispatch: e }) => {
  let t = ks(i.selection, (r) => {
    let s = xe(i), n = s.resolveStack(r.from, 1);
    if (r.empty) {
      let o = s.resolveStack(r.from, -1);
      o.node.from >= n.node.from && o.node.to <= n.node.to && (n = o);
    }
    for (let o = n; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && o.next)
        return V.range(a.to, a.from);
    }
    return r;
  });
  return t.eq(i.selection) ? !1 : (e(yi(i, t)), !0);
}, XR = ({ state: i, dispatch: e }) => {
  let t = i.selection, r = null;
  return t.ranges.length > 1 ? r = V.create([t.main]) : t.main.empty || (r = V.create([V.cursor(t.main.head)])), r ? (e(yi(i, r)), !0) : !1;
};
function fo(i, e) {
  if (i.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = i, s = r.changeByRange((n) => {
    let { from: o, to: a } = n;
    if (o == a) {
      let l = e(n);
      l < o ? (t = "delete.backward", l = Xo(i, l, !1)) : l > o && (t = "delete.forward", l = Xo(i, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = Xo(i, o, !1), a = Xo(i, a, !0);
    return o == a ? { range: n } : { changes: { from: o, to: a }, range: V.cursor(o, o < n.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (i.dispatch(r.update(s, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? K.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function Xo(i, e, t) {
  if (i instanceof K)
    for (let r of i.state.facet(K.atomicRanges).map((s) => s(i)))
      r.between(e, e, (s, n) => {
        s < e && n > e && (e = t ? n : s);
      });
  return e;
}
const h_ = (i, e, t) => fo(i, (r) => {
  let s = r.from, { state: n } = i, o = n.doc.lineAt(s), a, l;
  if (t && !e && s > o.from && s < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, s - o.from))) {
    if (a[a.length - 1] == "	")
      return s - 1;
    let c = Nt(a, n.tabSize), h = c % Na(n) || Na(n);
    for (let u = 0; u < h && a[a.length - 1 - u] == " "; u++)
      s--;
    l = s;
  } else
    l = Je(o.text, s - o.from, e, e) + o.from, l == s && o.number != (e ? n.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, s - o.from)) && (l = Je(o.text, l - o.from, !1, !1) + o.from);
  return l;
}), _u = (i) => h_(i, !1, !0), u_ = (i) => h_(i, !0, !1), f_ = (i, e) => fo(i, (t) => {
  let r = t.head, { state: s } = i, n = s.doc.lineAt(r), o = s.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? n.to : n.from)) {
      r == t.head && n.number != (e ? s.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = Je(n.text, r - n.from, e) + n.from, c = n.text.slice(Math.min(r, l) - n.from, Math.max(r, l) - n.from), h = o(c);
    if (a != null && h != a)
      break;
    (c != " " || r != t.head) && (a = h), r = l;
  }
  return r;
}), d_ = (i) => f_(i, !1), IR = (i) => f_(i, !0), ZR = (i) => fo(i, (e) => {
  let t = i.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(i.state.doc.length, e.head + 1);
}), WR = (i) => fo(i, (e) => {
  let t = i.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), zR = (i) => fo(i, (e) => {
  let t = i.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(i.state.doc.length, e.head + 1);
}), VR = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: _e.of(["", ""]) },
    range: V.cursor(r.from)
  }));
  return e(i.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, UR = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == i.doc.length)
      return { range: r };
    let s = r.from, n = i.doc.lineAt(s), o = s == n.from ? s - 1 : Je(n.text, s - n.from, !1) + n.from, a = s == n.to ? s + 1 : Je(n.text, s - n.from, !0) + n.from;
    return {
      changes: { from: o, to: a, insert: i.doc.slice(s, a).append(i.doc.slice(o, s)) },
      range: V.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(i.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Dl(i) {
  let e = [], t = -1;
  for (let r of i.selection.ranges) {
    let s = i.doc.lineAt(r.from), n = i.doc.lineAt(r.to);
    if (!r.empty && r.to == n.from && (n = i.doc.lineAt(r.to - 1)), t >= s.number) {
      let o = e[e.length - 1];
      o.to = n.to, o.ranges.push(r);
    } else
      e.push({ from: s.from, to: n.to, ranges: [r] });
    t = n.number + 1;
  }
  return e;
}
function O_(i, e, t) {
  if (i.readOnly)
    return !1;
  let r = [], s = [];
  for (let n of Dl(i)) {
    if (t ? n.to == i.doc.length : n.from == 0)
      continue;
    let o = i.doc.lineAt(t ? n.to + 1 : n.from - 1), a = o.length + 1;
    if (t) {
      r.push({ from: n.to, to: o.to }, { from: n.from, insert: o.text + i.lineBreak });
      for (let l of n.ranges)
        s.push(V.range(Math.min(i.doc.length, l.anchor + a), Math.min(i.doc.length, l.head + a)));
    } else {
      r.push({ from: o.from, to: n.from }, { from: n.to, insert: i.lineBreak + o.text });
      for (let l of n.ranges)
        s.push(V.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (e(i.update({
    changes: r,
    scrollIntoView: !0,
    selection: V.create(s, i.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const jR = ({ state: i, dispatch: e }) => O_(i, e, !1), NR = ({ state: i, dispatch: e }) => O_(i, e, !0);
function p_(i, e, t) {
  if (i.readOnly)
    return !1;
  let r = [];
  for (let s of Dl(i))
    t ? r.push({ from: s.from, insert: i.doc.slice(s.from, s.to) + i.lineBreak }) : r.push({ from: s.to, insert: i.lineBreak + i.doc.slice(s.from, s.to) });
  return e(i.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const YR = ({ state: i, dispatch: e }) => p_(i, e, !1), FR = ({ state: i, dispatch: e }) => p_(i, e, !0), HR = (i) => {
  if (i.state.readOnly)
    return !1;
  let { state: e } = i, t = e.changes(Dl(e).map(({ from: s, to: n }) => (s > 0 ? s-- : n < e.doc.length && n++, { from: s, to: n }))), r = ks(e.selection, (s) => {
    let n;
    if (i.lineWrapping) {
      let o = i.lineBlockAt(s.head), a = i.coordsAtPos(s.head, s.assoc || 1);
      a && (n = o.bottom + i.documentTop - a.bottom + i.defaultLineHeight / 2);
    }
    return i.moveVertically(s, !0, n);
  }).map(t);
  return i.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function GR(i, e) {
  if (/\(\)|\[\]|\{\}/.test(i.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = xe(i).resolveInner(e), r = t.childBefore(e), s = t.childAfter(e), n;
  return r && s && r.to <= e && s.from >= e && (n = r.type.prop(le.closedBy)) && n.indexOf(s.name) > -1 && i.doc.lineAt(r.to).from == i.doc.lineAt(s.from).from && !/\S/.test(i.sliceDoc(r.to, s.from)) ? { from: r.to, to: s.from } : null;
}
const Dp = /* @__PURE__ */ g_(!1), KR = /* @__PURE__ */ g_(!0);
function g_(i) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((s) => {
      let { from: n, to: o } = s, a = e.doc.lineAt(n), l = !i && n == o && GR(e, n);
      i && (n = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new $l(e, { simulateBreak: n, simulateDoubleBreak: !!l }), h = Mf(c, n);
      for (h == null && (h = Nt(/^\s*/.exec(e.doc.lineAt(n).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: n, to: o } = l : n > a.from && n < a.from + 100 && !/\S/.test(a.text.slice(0, n)) && (n = a.from);
      let u = ["", Ln(e, h)];
      return l && u.push(Ln(e, c.lineIndent(a.from, -1))), {
        changes: { from: n, to: o, insert: _e.of(u) },
        range: V.cursor(n + 1 + u[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Zf(i, e) {
  let t = -1;
  return i.changeByRange((r) => {
    let s = [];
    for (let o = r.from; o <= r.to; ) {
      let a = i.doc.lineAt(o);
      a.number > t && (r.empty || r.to > a.from) && (e(a, s, r), t = a.number), o = a.to + 1;
    }
    let n = i.changes(s);
    return {
      changes: s,
      range: V.range(n.mapPos(r.anchor, 1), n.mapPos(r.head, 1))
    };
  });
}
const JR = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new $l(i, { overrideIndentation: (n) => {
    let o = t[n];
    return o ?? -1;
  } }), s = Zf(i, (n, o, a) => {
    let l = Mf(r, n.from);
    if (l == null)
      return;
    /\S/.test(n.text) || (l = 0);
    let c = /^\s*/.exec(n.text)[0], h = Ln(i, l);
    (c != h || a.from < n.from + c.length) && (t[n.from] = l, o.push({ from: n.from, to: n.from + c.length, insert: h }));
  });
  return s.changes.empty || e(i.update(s, { userEvent: "indent" })), !0;
}, eE = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(Zf(i, (t, r) => {
  r.push({ from: t.from, insert: i.facet(co) });
}), { userEvent: "input.indent" })), !0), tE = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(Zf(i, (t, r) => {
  let s = /^\s*/.exec(t.text)[0];
  if (!s)
    return;
  let n = Nt(s, i.tabSize), o = 0, a = Ln(i, Math.max(0, n - Na(i)));
  for (; o < s.length && o < a.length && s.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + s.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), iE = (i) => (i.setTabFocusMode(), !0), rE = [
  { key: "Ctrl-b", run: Yv, shift: r_, preventDefault: !0 },
  { key: "Ctrl-f", run: Fv, shift: s_ },
  { key: "Ctrl-p", run: Kv, shift: a_ },
  { key: "Ctrl-n", run: Jv, shift: l_ },
  { key: "Ctrl-a", run: yR, shift: LR },
  { key: "Ctrl-e", run: wR, shift: DR },
  { key: "Ctrl-d", run: u_ },
  { key: "Ctrl-h", run: _u },
  { key: "Ctrl-k", run: ZR },
  { key: "Ctrl-Alt-h", run: d_ },
  { key: "Ctrl-o", run: VR },
  { key: "Ctrl-t", run: UR },
  { key: "Ctrl-v", run: vu }
], sE = /* @__PURE__ */ [
  { key: "ArrowLeft", run: Yv, shift: r_, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: dR, shift: CR, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: _R, shift: ER, preventDefault: !0 },
  { key: "ArrowRight", run: Fv, shift: s_, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: OR, shift: QR, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: bR, shift: AR, preventDefault: !0 },
  { key: "ArrowUp", run: Kv, shift: a_, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Rp, shift: Ap },
  { mac: "Ctrl-ArrowUp", run: Pp, shift: Tp },
  { key: "ArrowDown", run: Jv, shift: l_, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Ep, shift: Lp },
  { mac: "Ctrl-ArrowDown", run: vu, shift: $p },
  { key: "PageUp", run: Pp, shift: Tp },
  { key: "PageDown", run: vu, shift: $p },
  { key: "Home", run: vR, shift: RR, preventDefault: !0 },
  { key: "Mod-Home", run: Rp, shift: Ap },
  { key: "End", run: SR, shift: $R, preventDefault: !0 },
  { key: "Mod-End", run: Ep, shift: Lp },
  { key: "Enter", run: Dp, shift: Dp },
  { key: "Mod-a", run: MR },
  { key: "Backspace", run: _u, shift: _u },
  { key: "Delete", run: u_ },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: d_ },
  { key: "Mod-Delete", mac: "Alt-Delete", run: IR },
  { mac: "Mod-Backspace", run: WR },
  { mac: "Mod-Delete", run: zR }
].concat(/* @__PURE__ */ rE.map((i) => ({ mac: i.key, run: i.run, shift: i.shift }))), nE = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: gR, shift: PR },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: mR, shift: TR },
  { key: "Alt-ArrowUp", run: jR },
  { key: "Shift-Alt-ArrowUp", run: YR },
  { key: "Alt-ArrowDown", run: NR },
  { key: "Shift-Alt-ArrowDown", run: FR },
  { key: "Escape", run: XR },
  { key: "Mod-Enter", run: KR },
  { key: "Alt-l", mac: "Ctrl-l", run: BR },
  { key: "Mod-i", run: qR, preventDefault: !0 },
  { key: "Mod-[", run: tE },
  { key: "Mod-]", run: eE },
  { key: "Mod-Alt-\\", run: JR },
  { key: "Shift-Mod-k", run: HR },
  { key: "Shift-Mod-\\", run: kR },
  { key: "Mod-/", run: Y$ },
  { key: "Alt-A", run: H$ },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: iE }
].concat(sE), Mp = typeof String.prototype.normalize == "function" ? (i) => i.normalize("NFKD") : (i) => i;
class ps {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, s = e.length, n, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, s), this.bufferStart = r, this.normalize = n ? (a) => n(Mp(a)) : Mp, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return pt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = df(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += hi(e);
      let s = this.normalize(t);
      if (s.length)
        for (let n = 0, o = r; ; n++) {
          let a = s.charCodeAt(n), l = this.match(a, o, this.bufferPos + this.bufferStart);
          if (n == s.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          o == r && n < t.length && t.charCodeAt(n) == a && o++;
        }
    }
  }
  match(e, t, r) {
    let s = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let o = this.matches[n], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? s = { from: this.matches[n + 1], to: r } : (this.matches[n]++, a = !0)), a || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? s = { from: t, to: r } : this.matches.push(1, t)), s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) && (s = null), s;
  }
}
typeof Symbol < "u" && (ps.prototype[Symbol.iterator] = function() {
  return this;
});
const m_ = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Wf = "gm" + (/x/.unicode == null ? "" : "u");
class S_ {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, s = 0, n = e.length) {
    if (this.text = e, this.to = n, this.curLine = "", this.done = !1, this.value = m_, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new v_(e, t, r, s, n);
    this.re = new RegExp(t, Wf + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(s);
    this.curLineStart = o.from, this.matchPos = Ga(e, s), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, s = r + t[0].length;
        if (this.matchPos = Ga(this.text, s + (r == s ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < s || r > this.value.to) && (!this.test || this.test(r, s, t)))
          return this.value = { from: r, to: s, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const wc = /* @__PURE__ */ new WeakMap();
class ss {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let s = wc.get(e);
    if (!s || s.from >= r || s.to <= t) {
      let a = new ss(t, e.sliceString(t, r));
      return wc.set(e, a), a;
    }
    if (s.from == t && s.to == r)
      return s;
    let { text: n, from: o } = s;
    return o > t && (n = e.sliceString(t, o) + n, o = t), s.to < r && (n += e.sliceString(s.to, r)), wc.set(e, new ss(o, n)), new ss(t, n.slice(t - o, r - o));
  }
}
class v_ {
  constructor(e, t, r, s, n) {
    this.text = e, this.to = n, this.done = !1, this.value = m_, this.matchPos = Ga(e, s), this.re = new RegExp(t, Wf + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = ss.get(e, s, this.chunkEnd(
      s + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, s = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, s, t)))
          return this.value = { from: r, to: s, match: t }, this.matchPos = Ga(this.text, s + (r == s ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = ss.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (S_.prototype[Symbol.iterator] = v_.prototype[Symbol.iterator] = function() {
  return this;
});
function oE(i) {
  try {
    return new RegExp(i, Wf), !0;
  } catch {
    return !1;
  }
}
function Ga(i, e) {
  if (e >= i.length)
    return e;
  let t = i.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function bu(i) {
  let e = String(i.state.doc.lineAt(i.state.selection.main.head).number), t = Ce("input", { class: "cm-textfield", name: "line", value: e }), r = Ce("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), i.dispatch({ effects: ln.of(!1) }), i.focus()) : n.keyCode == 13 && (n.preventDefault(), s());
    },
    onsubmit: (n) => {
      n.preventDefault(), s();
    }
  }, Ce("label", i.state.phrase("Go to line"), ": ", t), " ", Ce("button", { class: "cm-button", type: "submit" }, i.state.phrase("go")), Ce("button", {
    name: "close",
    onclick: () => {
      i.dispatch({ effects: ln.of(!1) }), i.focus();
    },
    "aria-label": i.state.phrase("close"),
    type: "button"
  }, [""]));
  function s() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!n)
      return;
    let { state: o } = i, a = o.doc.lineAt(o.selection.main.head), [, l, c, h, u] = n, d = h ? +h.slice(1) : 0, O = c ? +c : a.number;
    if (c && u) {
      let f = O / 100;
      l && (f = f * (l == "-" ? -1 : 1) + a.number / o.doc.lines), O = Math.round(o.doc.lines * f);
    } else c && l && (O = O * (l == "-" ? -1 : 1) + a.number);
    let v = o.doc.line(Math.max(1, Math.min(o.doc.lines, O))), S = V.cursor(v.from + Math.max(0, Math.min(d, v.length)));
    i.dispatch({
      effects: [ln.of(!1), K.scrollIntoView(S.from, { y: "center" })],
      selection: S
    }), i.focus();
  }
  return { dom: r };
}
const ln = /* @__PURE__ */ he.define(), Bp = /* @__PURE__ */ Ye.define({
  create() {
    return !0;
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(ln) && (i = t.value);
    return i;
  },
  provide: (i) => $n.from(i, (e) => e ? bu : null)
}), aE = (i) => {
  let e = Tn(i, bu);
  if (!e) {
    let t = [ln.of(!0)];
    i.state.field(Bp, !1) == null && t.push(he.appendConfig.of([Bp, lE])), i.dispatch({ effects: t }), e = Tn(i, bu);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, lE = /* @__PURE__ */ K.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), cE = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, hE = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, cE, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function uE(i) {
  return [gE, pE];
}
const fE = /* @__PURE__ */ ae.mark({ class: "cm-selectionMatch" }), dE = /* @__PURE__ */ ae.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function qp(i, e, t, r) {
  return (t == 0 || i(e.sliceDoc(t - 1, t)) != De.Word) && (r == e.doc.length || i(e.sliceDoc(r, r + 1)) != De.Word);
}
function OE(i, e, t, r) {
  return i(e.sliceDoc(t, t + 1)) == De.Word && i(e.sliceDoc(r - 1, r)) == De.Word;
}
const pE = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.selectionSet || i.docChanged || i.viewportChanged) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = i.state.facet(hE), { state: t } = i, r = t.selection;
    if (r.ranges.length > 1)
      return ae.none;
    let s = r.main, n, o = null;
    if (s.empty) {
      if (!e.highlightWordAroundCursor)
        return ae.none;
      let l = t.wordAt(s.head);
      if (!l)
        return ae.none;
      o = t.charCategorizer(s.head), n = t.sliceDoc(l.from, l.to);
    } else {
      let l = s.to - s.from;
      if (l < e.minSelectionLength || l > 200)
        return ae.none;
      if (e.wholeWords) {
        if (n = t.sliceDoc(s.from, s.to), o = t.charCategorizer(s.head), !(qp(o, t, s.from, s.to) && OE(o, t, s.from, s.to)))
          return ae.none;
      } else if (n = t.sliceDoc(s.from, s.to), !n)
        return ae.none;
    }
    let a = [];
    for (let l of i.visibleRanges) {
      let c = new ps(t.doc, n, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: h, to: u } = c.value;
        if ((!o || qp(o, t, h, u)) && (s.empty && h <= s.from && u >= s.to ? a.push(dE.range(h, u)) : (h >= s.to || u <= s.from) && a.push(fE.range(h, u)), a.length > e.maxMatches))
          return ae.none;
      }
    }
    return ae.set(a);
  }
}, {
  decorations: (i) => i.decorations
}), gE = /* @__PURE__ */ K.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), mE = ({ state: i, dispatch: e }) => {
  let { selection: t } = i, r = V.create(t.ranges.map((s) => i.wordAt(s.head) || V.cursor(s.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(i.update({ selection: r })), !0);
};
function SE(i, e) {
  let { main: t, ranges: r } = i.selection, s = i.wordAt(t.head), n = s && s.from == t.from && s.to == t.to;
  for (let o = !1, a = new ps(i.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new ps(i.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((l) => l.from == a.value.from))
        continue;
      if (n) {
        let l = i.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const vE = ({ state: i, dispatch: e }) => {
  let { ranges: t } = i.selection;
  if (t.some((n) => n.from === n.to))
    return mE({ state: i, dispatch: e });
  let r = i.sliceDoc(t[0].from, t[0].to);
  if (i.selection.ranges.some((n) => i.sliceDoc(n.from, n.to) != r))
    return !1;
  let s = SE(i, r);
  return s ? (e(i.update({
    selection: i.selection.addRange(V.range(s.from, s.to), !1),
    effects: K.scrollIntoView(s.to)
  })), !0) : !1;
}, Cs = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new RE(e),
      scrollToMatch: (e) => K.scrollIntoView(e)
    });
  }
});
class __ {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || oE(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new wE(this) : new bE(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let s = e.doc ? e : ve.create({ doc: e });
    return r == null && (r = s.doc.length), this.regexp ? jr(this, s, t, r) : Ur(this, s, t, r);
  }
}
class b_ {
  constructor(e) {
    this.spec = e;
  }
}
function Ur(i, e, t, r) {
  return new ps(e.doc, i.unquoted, t, r, i.caseSensitive ? void 0 : (s) => s.toLowerCase(), i.wholeWord ? _E(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function _E(i, e) {
  return (t, r, s, n) => ((n > t || n + s.length < r) && (n = Math.max(0, t - 2), s = i.sliceString(n, Math.min(i.length, r + 2))), (e(Ka(s, t - n)) != De.Word || e(Ja(s, t - n)) != De.Word) && (e(Ja(s, r - n)) != De.Word || e(Ka(s, r - n)) != De.Word));
}
class bE extends b_ {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let s = Ur(this.spec, e, r, e.doc.length).nextOverlapping();
    if (s.done) {
      let n = Math.min(e.doc.length, t + this.spec.unquoted.length);
      s = Ur(this.spec, e, 0, n).nextOverlapping();
    }
    return s.done || s.value.from == t && s.value.to == r ? null : s.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let s = r; ; ) {
      let n = Math.max(t, s - 1e4 - this.spec.unquoted.length), o = Ur(this.spec, e, n, s), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (n == t)
        return null;
      s -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let s = this.prevMatchInRange(e, 0, t);
    return s || (s = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), s && (s.from != t || s.to != r) ? s : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = Ur(this.spec, e, 0, e.doc.length), s = [];
    for (; !r.next().done; ) {
      if (s.length >= t)
        return null;
      s.push(r.value);
    }
    return s;
  }
  highlight(e, t, r, s) {
    let n = Ur(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !n.next().done; )
      s(n.value.from, n.value.to);
  }
}
function jr(i, e, t, r) {
  return new S_(e.doc, i.search, {
    ignoreCase: !i.caseSensitive,
    test: i.wholeWord ? yE(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function Ka(i, e) {
  return i.slice(Je(i, e, !1), e);
}
function Ja(i, e) {
  return i.slice(e, Je(i, e));
}
function yE(i) {
  return (e, t, r) => !r[0].length || (i(Ka(r.input, r.index)) != De.Word || i(Ja(r.input, r.index)) != De.Word) && (i(Ja(r.input, r.index + r[0].length)) != De.Word || i(Ka(r.input, r.index + r[0].length)) != De.Word);
}
class wE extends b_ {
  nextMatch(e, t, r) {
    let s = jr(this.spec, e, r, e.doc.length).next();
    return s.done && (s = jr(this.spec, e, 0, t).next()), s.done ? null : s.value;
  }
  prevMatchInRange(e, t, r) {
    for (let s = 1; ; s++) {
      let n = Math.max(
        t,
        r - s * 1e4
        /* FindPrev.ChunkSize */
      ), o = jr(this.spec, e, n, r), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (n == t || a.from > n + 10))
        return a;
      if (n == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let s = r.length; s > 0; s--) {
        let n = +r.slice(0, s);
        if (n > 0 && n < e.match.length)
          return e.match[n] + r.slice(s);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = jr(this.spec, e, 0, e.doc.length), s = [];
    for (; !r.next().done; ) {
      if (s.length >= t)
        return null;
      s.push(r.value);
    }
    return s;
  }
  highlight(e, t, r, s) {
    let n = jr(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !n.next().done; )
      s(n.value.from, n.value.to);
  }
}
const Dn = /* @__PURE__ */ he.define(), zf = /* @__PURE__ */ he.define(), Ji = /* @__PURE__ */ Ye.define({
  create(i) {
    return new xc(yu(i).create(), null);
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(Dn) ? i = new xc(t.value.create(), i.panel) : t.is(zf) && (i = new xc(i.query, t.value ? Vf : null));
    return i;
  },
  provide: (i) => $n.from(i, (e) => e.panel)
});
class xc {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const xE = /* @__PURE__ */ ae.mark({ class: "cm-searchMatch" }), kE = /* @__PURE__ */ ae.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), CE = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.view = i, this.decorations = this.highlight(i.state.field(Ji));
  }
  update(i) {
    let e = i.state.field(Ji);
    (e != i.startState.field(Ji) || i.docChanged || i.selectionSet || i.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: i, panel: e }) {
    if (!e || !i.spec.valid)
      return ae.none;
    let { view: t } = this, r = new Bi();
    for (let s = 0, n = t.visibleRanges, o = n.length; s < o; s++) {
      let { from: a, to: l } = n[s];
      for (; s < o - 1 && l > n[s + 1].from - 2 * 250; )
        l = n[++s].to;
      i.highlight(t.state, a, l, (c, h) => {
        let u = t.state.selection.ranges.some((d) => d.from == c && d.to == h);
        r.add(c, h, u ? kE : xE);
      });
    }
    return r.finish();
  }
}, {
  decorations: (i) => i.decorations
});
function Oo(i) {
  return (e) => {
    let t = e.state.field(Ji, !1);
    return t && t.query.spec.valid ? i(e, t) : x_(e);
  };
}
const el = /* @__PURE__ */ Oo((i, { query: e }) => {
  let { to: t } = i.state.selection.main, r = e.nextMatch(i.state, t, t);
  if (!r)
    return !1;
  let s = V.single(r.from, r.to), n = i.state.facet(Cs);
  return i.dispatch({
    selection: s,
    effects: [Uf(i, r), n.scrollToMatch(s.main, i)],
    userEvent: "select.search"
  }), w_(i), !0;
}), tl = /* @__PURE__ */ Oo((i, { query: e }) => {
  let { state: t } = i, { from: r } = t.selection.main, s = e.prevMatch(t, r, r);
  if (!s)
    return !1;
  let n = V.single(s.from, s.to), o = i.state.facet(Cs);
  return i.dispatch({
    selection: n,
    effects: [Uf(i, s), o.scrollToMatch(n.main, i)],
    userEvent: "select.search"
  }), w_(i), !0;
}), QE = /* @__PURE__ */ Oo((i, { query: e }) => {
  let t = e.matchAll(i.state, 1e3);
  return !t || !t.length ? !1 : (i.dispatch({
    selection: V.create(t.map((r) => V.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), PE = ({ state: i, dispatch: e }) => {
  let t = i.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: s } = t.main, n = [], o = 0;
  for (let a = new ps(i.doc, i.sliceDoc(r, s)); !a.next().done; ) {
    if (n.length > 1e3)
      return !1;
    a.value.from == r && (o = n.length), n.push(V.range(a.value.from, a.value.to));
  }
  return e(i.update({
    selection: V.create(n, o),
    userEvent: "select.search.matches"
  })), !0;
}, Xp = /* @__PURE__ */ Oo((i, { query: e }) => {
  let { state: t } = i, { from: r, to: s } = t.selection.main;
  if (t.readOnly)
    return !1;
  let n = e.nextMatch(t, r, r);
  if (!n)
    return !1;
  let o = n, a = [], l, c, h = [];
  o.from == r && o.to == s && (c = t.toText(e.getReplacement(o)), a.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), h.push(K.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let u = i.state.changes(a);
  return o && (l = V.single(o.from, o.to).map(u), h.push(Uf(i, o)), h.push(t.facet(Cs).scrollToMatch(l.main, i))), i.dispatch({
    changes: u,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), TE = /* @__PURE__ */ Oo((i, { query: e }) => {
  if (i.state.readOnly)
    return !1;
  let t = e.matchAll(i.state, 1e9).map((s) => {
    let { from: n, to: o } = s;
    return { from: n, to: o, insert: e.getReplacement(s) };
  });
  if (!t.length)
    return !1;
  let r = i.state.phrase("replaced $ matches", t.length) + ".";
  return i.dispatch({
    changes: t,
    effects: K.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Vf(i) {
  return i.state.facet(Cs).createPanel(i);
}
function yu(i, e) {
  var t, r, s, n, o;
  let a = i.selection.main, l = a.empty || a.to > a.from + 100 ? "" : i.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = i.facet(Cs);
  return new __({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (s = e?.literal) !== null && s !== void 0 ? s : c.literal,
    regexp: (n = e?.regexp) !== null && n !== void 0 ? n : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function y_(i) {
  let e = Tn(i, Vf);
  return e && e.dom.querySelector("[main-field]");
}
function w_(i) {
  let e = y_(i);
  e && e == i.root.activeElement && e.select();
}
const x_ = (i) => {
  let e = i.state.field(Ji, !1);
  if (e && e.panel) {
    let t = y_(i);
    if (t && t != i.root.activeElement) {
      let r = yu(i.state, e.query.spec);
      r.valid && i.dispatch({ effects: Dn.of(r) }), t.focus(), t.select();
    }
  } else
    i.dispatch({ effects: [
      zf.of(!0),
      e ? Dn.of(yu(i.state, e.query.spec)) : he.appendConfig.of(AE)
    ] });
  return !0;
}, k_ = (i) => {
  let e = i.state.field(Ji, !1);
  if (!e || !e.panel)
    return !1;
  let t = Tn(i, Vf);
  return t && t.dom.contains(i.root.activeElement) && i.focus(), i.dispatch({ effects: zf.of(!1) }), !0;
}, $E = [
  { key: "Mod-f", run: x_, scope: "editor search-panel" },
  { key: "F3", run: el, shift: tl, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: el, shift: tl, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: k_, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: PE },
  { key: "Mod-Alt-g", run: aE },
  { key: "Mod-d", run: vE, preventDefault: !0 }
];
class RE {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Ji).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ce("input", {
      value: t.search,
      placeholder: xt(e, "Find"),
      "aria-label": xt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ce("input", {
      value: t.replace,
      placeholder: xt(e, "Replace"),
      "aria-label": xt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ce("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Ce("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Ce("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(s, n, o) {
      return Ce("button", { class: "cm-button", name: s, onclick: n, type: "button" }, o);
    }
    this.dom = Ce("div", { onkeydown: (s) => this.keydown(s), class: "cm-search" }, [
      this.searchField,
      r("next", () => el(e), [xt(e, "next")]),
      r("prev", () => tl(e), [xt(e, "previous")]),
      r("select", () => QE(e), [xt(e, "all")]),
      Ce("label", null, [this.caseField, xt(e, "match case")]),
      Ce("label", null, [this.reField, xt(e, "regexp")]),
      Ce("label", null, [this.wordField, xt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ce("br"),
        this.replaceField,
        r("replace", () => Xp(e), [xt(e, "replace")]),
        r("replaceAll", () => TE(e), [xt(e, "replace all")])
      ],
      Ce("button", {
        name: "close",
        onclick: () => k_(e),
        "aria-label": xt(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new __({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Dn.of(e) }));
  }
  keydown(e) {
    IP(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? tl : el)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Xp(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Dn) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Cs).top;
  }
}
function xt(i, e) {
  return i.state.phrase(e);
}
const Io = 30, Zo = /[\s\.,:;?!]/;
function Uf(i, { from: e, to: t }) {
  let r = i.state.doc.lineAt(e), s = i.state.doc.lineAt(t).to, n = Math.max(r.from, e - Io), o = Math.min(s, t + Io), a = i.state.sliceDoc(n, o);
  if (n != r.from) {
    for (let l = 0; l < Io; l++)
      if (!Zo.test(a[l + 1]) && Zo.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != s) {
    for (let l = a.length - 1; l > a.length - Io; l--)
      if (!Zo.test(a[l - 1]) && Zo.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return K.announce.of(`${i.state.phrase("current match")}. ${a} ${i.state.phrase("on line")} ${r.number}.`);
}
const EE = /* @__PURE__ */ K.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), AE = [
  Ji,
  /* @__PURE__ */ Zi.low(CE),
  EE
];
class jf {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, s) {
    this.state = e, this.pos = t, this.explicit = r, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = xe(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), s = t.text.slice(r - t.from, this.pos - t.from), n = s.search(C_(e, !1));
    return n < 0 ? null : { from: r + n, to: this.pos, text: s.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Ip(i) {
  let e = Object.keys(i).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function LE(i) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of i) {
    e[s[0]] = !0;
    for (let n = 1; n < s.length; n++)
      t[s[n]] = !0;
  }
  let r = Ip(e) + Ip(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function Ml(i) {
  let e = i.map((s) => typeof s == "string" ? { label: s } : s), [t, r] = e.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : LE(e);
  return (s) => {
    let n = s.matchBefore(r);
    return n || s.explicit ? { from: n ? n.from : s.pos, options: e, validFor: t } : null;
  };
}
function Nf(i, e) {
  return (t) => {
    for (let r = xe(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (i.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Zp {
  constructor(e, t, r, s) {
    this.completion = e, this.source = t, this.match = r, this.score = s;
  }
}
function Qr(i) {
  return i.selection.main.from;
}
function C_(i, e) {
  var t;
  let { source: r } = i, s = e && r[0] != "^", n = r[r.length - 1] != "$";
  return !s && !n ? i : new RegExp(`${s ? "^" : ""}(?:${r})${n ? "$" : ""}`, (t = i.flags) !== null && t !== void 0 ? t : i.ignoreCase ? "i" : "");
}
const Yf = /* @__PURE__ */ Wi.define();
function DE(i, e, t, r) {
  let { main: s } = i.selection, n = t - s.from, o = r - s.from;
  return Object.assign(Object.assign({}, i.changeByRange((a) => {
    if (a != s && t != r && i.sliceDoc(a.from + n, a.from + o) != i.sliceDoc(t, r))
      return { range: a };
    let l = i.toText(e);
    return {
      changes: { from: a.from + n, to: r == s.from ? a.to : a.from + o, insert: l },
      range: V.cursor(a.from + n + l.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Wp = /* @__PURE__ */ new WeakMap();
function ME(i) {
  if (!Array.isArray(i))
    return i;
  let e = Wp.get(i);
  return e || Wp.set(i, e = Ml(i)), e;
}
const il = /* @__PURE__ */ he.define(), Mn = /* @__PURE__ */ he.define();
class BE {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = pt(e, t), s = hi(r);
      this.chars.push(r);
      let n = e.slice(t, t + s), o = n.toUpperCase();
      this.folded.push(pt(o == n ? n.toLowerCase() : o, 0)), t += s;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: s, precise: n, byWord: o } = this;
    if (t.length == 1) {
      let g = pt(e, 0), m = hi(g), _ = m == e.length ? 0 : -100;
      if (g != t[0]) if (g == r[0])
        _ += -200;
      else
        return null;
      return this.ret(_, [0, m]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, c = 0;
    if (a < 0) {
      for (let g = 0, m = Math.min(e.length, 200); g < m && c < l; ) {
        let _ = pt(e, g);
        (_ == t[c] || _ == r[c]) && (s[c++] = g), g += hi(_);
      }
      if (c < l)
        return null;
    }
    let h = 0, u = 0, d = !1, O = 0, v = -1, S = -1, f = /[a-z]/.test(e), p = !0;
    for (let g = 0, m = Math.min(e.length, 200), _ = 0; g < m && u < l; ) {
      let b = pt(e, g);
      a < 0 && (h < l && b == t[h] && (n[h++] = g), O < l && (b == t[O] || b == r[O] ? (O == 0 && (v = g), S = g + 1, O++) : O = 0));
      let w, x = b < 255 ? b >= 48 && b <= 57 || b >= 97 && b <= 122 ? 2 : b >= 65 && b <= 90 ? 1 : 0 : (w = df(b)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!g || x == 1 && f || _ == 0 && x != 0) && (t[u] == b || r[u] == b && (d = !0) ? o[u++] = g : o.length && (p = !1)), _ = x, g += hi(b);
    }
    return u == l && o[0] == 0 && p ? this.result(-100 + (d ? -200 : 0), o, e) : O == l && v == 0 ? this.ret(-200 - e.length + (S == e.length ? 0 : -100), [0, S]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : O == l ? this.ret(-900 - e.length, [v, S]) : u == l ? this.result(-100 + (d ? -200 : 0) + -700 + (p ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, e);
  }
  result(e, t, r) {
    let s = [], n = 0;
    for (let o of t) {
      let a = o + (this.astral ? hi(pt(r, o)) : 1);
      n && s[n - 1] == o ? s[n - 1] = a : (s[n++] = o, s[n++] = a);
    }
    return this.ret(e - r.length, s);
  }
}
class qE {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Ne = /* @__PURE__ */ ee.define({
  combine(i) {
    return _i(i, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: XE,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => zp(e(r), t(r)),
      optionClass: (e, t) => (r) => zp(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function zp(i, e) {
  return i ? e ? i + " " + e : i : e;
}
function XE(i, e, t, r, s, n) {
  let o = i.textDirection == Le.RTL, a = o, l = !1, c = "top", h, u, d = e.left - s.left, O = s.right - e.right, v = r.right - r.left, S = r.bottom - r.top;
  if (a && d < Math.min(v, O) ? a = !1 : !a && O < Math.min(v, d) && (a = !0), v <= (a ? d : O))
    h = Math.max(s.top, Math.min(t.top, s.bottom - S)) - e.top, u = Math.min(400, a ? d : O);
  else {
    l = !0, u = Math.min(
      400,
      (o ? e.right : s.right - e.left) - 30
      /* Info.Margin */
    );
    let g = s.bottom - e.bottom;
    g >= S || g > e.top ? h = t.bottom - e.top : (c = "bottom", h = e.bottom - t.top);
  }
  let f = (e.bottom - e.top) / n.offsetHeight, p = (e.right - e.left) / n.offsetWidth;
  return {
    style: `${c}: ${h / f}px; max-width: ${u / p}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function IE(i) {
  let e = i.addToOptions.slice();
  return i.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, s, n) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = t.displayLabel || t.label, l = 0;
      for (let c = 0; c < n.length; ) {
        let h = n[c++], u = n[c++];
        h > l && o.appendChild(document.createTextNode(a.slice(l, h)));
        let d = o.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(h, u))), d.className = "cm-completionMatchedText", l = u;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function kc(i, e, t) {
  if (i <= t)
    return { from: 0, to: i };
  if (e < 0 && (e = 0), e <= i >> 1) {
    let s = Math.floor(e / t);
    return { from: s * t, to: (s + 1) * t };
  }
  let r = Math.floor((i - e) / t);
  return { from: i - (r + 1) * t, to: i - r * t };
}
class ZE {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = e.state.field(t), { options: n, selected: o } = s.open, a = e.state.facet(Ne);
    this.optionContent = IE(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = kc(n.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(t).open;
      for (let h = l.target, u; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (u = /-(\d+)$/.exec(h.id)) && +u[1] < c.length) {
          this.applyCompletion(e, c[+u[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Ne).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Mn.of(null) });
    }), this.showOptions(n, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), s = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != s) {
      let { options: n, selected: o, disabled: a } = r.open;
      (!s.open || s.open.options != n) && (this.range = kc(n.length, o, e.state.facet(Ne).maxRenderedOptions), this.showOptions(n, r.id)), this.updateSel(), a != ((t = s.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = kc(t.options.length, t.selected, this.view.state.facet(Ne).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: s } = r;
      if (!s)
        return;
      let n = typeof s == "string" ? document.createTextNode(s) : s(r);
      if (!n)
        return;
      "then" in n ? n.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => St(this.view.state, o, "completion info")) : this.addInfoPane(n, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: s, destroy: n } = e;
      r.appendChild(s), this.infoDestroy = n || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, s = this.range.from; r; r = r.nextSibling, s++)
      r.nodeName != "LI" || !r.id ? s-- : s == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && zE(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), s = e.getBoundingClientRect(), n = this.space;
    if (!n) {
      let o = this.dom.ownerDocument.documentElement;
      n = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return s.top > Math.min(n.bottom, t.bottom) - 10 || s.bottom < Math.max(n.top, t.top) + 10 ? null : this.view.state.facet(Ne).positionInfo(this.view, t, s, r, n, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const s = document.createElement("ul");
    s.id = t, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (o) => {
      o.target == s && o.preventDefault();
    });
    let n = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let d = typeof c == "string" ? c : c.name;
        if (d != n && (o > r.from || r.from == 0))
          if (n = d, typeof c != "string" && c.header)
            s.appendChild(c.header(c));
          else {
            let O = s.appendChild(document.createElement("completion-section"));
            O.textContent = d;
          }
      }
      const h = s.appendChild(document.createElement("li"));
      h.id = t + "-" + o, h.setAttribute("role", "option");
      let u = this.optionClass(a);
      u && (h.className = u);
      for (let d of this.optionContent) {
        let O = d(a, this.view.state, this.view, l);
        O && h.appendChild(O);
      }
    }
    return r.from && s.classList.add("cm-completionListIncompleteTop"), r.to < e.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function WE(i, e) {
  return (t) => new ZE(t, i, e);
}
function zE(i, e) {
  let t = i.getBoundingClientRect(), r = e.getBoundingClientRect(), s = t.height / i.offsetHeight;
  r.top < t.top ? i.scrollTop -= (t.top - r.top) / s : r.bottom > t.bottom && (i.scrollTop += (r.bottom - t.bottom) / s);
}
function Vp(i) {
  return (i.boost || 0) * 100 + (i.apply ? 10 : 0) + (i.info ? 5 : 0) + (i.type ? 1 : 0);
}
function VE(i, e) {
  let t = [], r = null, s = (c) => {
    t.push(c);
    let { section: h } = c.completion;
    if (h) {
      r || (r = []);
      let u = typeof h == "string" ? h : h.name;
      r.some((d) => d.name == u) || r.push(typeof h == "string" ? { name: u } : h);
    }
  }, n = e.facet(Ne);
  for (let c of i)
    if (c.hasResult()) {
      let h = c.result.getMatch;
      if (c.result.filter === !1)
        for (let u of c.result.options)
          s(new Zp(u, c.source, h ? h(u) : [], 1e9 - t.length));
      else {
        let u = e.sliceDoc(c.from, c.to), d, O = n.filterStrict ? new qE(u) : new BE(u);
        for (let v of c.result.options)
          if (d = O.match(v.label)) {
            let S = v.displayLabel ? h ? h(v, d.matched) : [] : d.matched;
            s(new Zp(v, c.source, S, d.score + (v.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), h = 0, u = (d, O) => {
      var v, S;
      return ((v = d.rank) !== null && v !== void 0 ? v : 1e9) - ((S = O.rank) !== null && S !== void 0 ? S : 1e9) || (d.name < O.name ? -1 : 1);
    };
    for (let d of r.sort(u))
      h -= 1e5, c[d.name] = h;
    for (let d of t) {
      let { section: O } = d.completion;
      O && (d.score += c[typeof O == "string" ? O : O.name]);
    }
  }
  let o = [], a = null, l = n.compareCompletions;
  for (let c of t.sort((h, u) => u.score - h.score || l(h.completion, u.completion))) {
    let h = c.completion;
    !a || a.label != h.label || a.detail != h.detail || a.type != null && h.type != null && a.type != h.type || a.apply != h.apply || a.boost != h.boost ? o.push(c) : Vp(c.completion) > Vp(a) && (o[o.length - 1] = c), a = c.completion;
  }
  return o;
}
class Gr {
  constructor(e, t, r, s, n, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = s, this.selected = n, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Gr(this.options, Up(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, s, n, o) {
    if (s && !o && e.some((c) => c.isPending))
      return s.setDisabled();
    let a = VE(e, t);
    if (!a.length)
      return s && e.some((c) => c.isPending) ? s.setDisabled() : null;
    let l = t.facet(Ne).selectOnOpen ? 0 : -1;
    if (s && s.selected != l && s.selected != -1) {
      let c = s.options[s.selected].completion;
      for (let h = 0; h < a.length; h++)
        if (a[h].completion == c) {
          l = h;
          break;
        }
    }
    return new Gr(a, Up(r, l), {
      pos: e.reduce((c, h) => h.hasResult() ? Math.min(c, h.from) : c, 1e8),
      create: HE,
      above: n.aboveCursor
    }, s ? s.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Gr(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Gr(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class rl {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new rl(YE, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(Ne), n = (r.override || t.languageDataAt("autocomplete", Qr(t)).map(ME)).map((l) => (this.active.find((h) => h.source == l) || new Bt(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    n.length == this.active.length && n.every((l, c) => l == this.active[c]) && (n = this.active);
    let o = this.open, a = e.effects.some((l) => l.is(Ff));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || n.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !UE(n, this.active) || a ? o = Gr.build(n, t, this.id, o, r, a) : o && o.disabled && !n.some((l) => l.isPending) && (o = null), !o && n.every((l) => !l.isPending) && n.some((l) => l.hasResult()) && (n = n.map((l) => l.hasResult() ? new Bt(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(P_) && (o = o && o.setSelected(l.value, this.id));
    return n == this.active && o == this.open ? this : new rl(n, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? jE : NE;
  }
}
function UE(i, e) {
  if (i == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < i.length && !i[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let s = t == i.length, n = r == e.length;
    if (s || n)
      return s == n;
    if (i[t++].result != e[r++].result)
      return !1;
  }
}
const jE = {
  "aria-autocomplete": "list"
}, NE = {};
function Up(i, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": i
  };
  return e > -1 && (t["aria-activedescendant"] = i + "-" + e), t;
}
const YE = [];
function Q_(i, e) {
  if (i.isUserEvent("input.complete")) {
    let r = i.annotation(Yf);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = i.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : i.isUserEvent("delete.backward") ? 2 : i.selection ? 8 : i.docChanged ? 16 : 0;
}
class Bt {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = Q_(e, t), s = this;
    (r & 8 || r & 16 && this.touches(e)) && (s = new Bt(
      s.source,
      0
      /* State.Inactive */
    )), r & 4 && s.state == 0 && (s = new Bt(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(e, r);
    for (let n of e.effects)
      if (n.is(il))
        s = new Bt(s.source, 1, n.value);
      else if (n.is(Mn))
        s = new Bt(
          s.source,
          0
          /* State.Inactive */
        );
      else if (n.is(Ff))
        for (let o of n.value)
          o.source == s.source && (s = o);
    return s;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(Qr(e.state));
  }
}
class ns extends Bt {
  constructor(e, t, r, s, n, o) {
    super(e, 3, t), this.limit = r, this.result = s, this.from = n, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let s = this.result;
    s.map && !e.changes.empty && (s = s.map(s, e.changes));
    let n = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = Qr(e.state);
    if (a > o || !s || t & 2 && (Qr(e.startState) == this.from || a < this.limit))
      return new Bt(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return FE(s.validFor, e.state, n, o) ? new ns(this.source, this.explicit, l, s, n, o) : s.update && (s = s.update(s, n, o, new jf(e.state, a, !1))) ? new ns(this.source, this.explicit, l, s, s.from, (r = s.to) !== null && r !== void 0 ? r : Qr(e.state)) : new Bt(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new ns(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Bt(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function FE(i, e, t, r) {
  if (!i)
    return !1;
  let s = e.sliceDoc(t, r);
  return typeof i == "function" ? i(s, t, r, e) : C_(i, !0).test(s);
}
const Ff = /* @__PURE__ */ he.define({
  map(i, e) {
    return i.map((t) => t.map(e));
  }
}), P_ = /* @__PURE__ */ he.define(), mt = /* @__PURE__ */ Ye.define({
  create() {
    return rl.start();
  },
  update(i, e) {
    return i.update(e);
  },
  provide: (i) => [
    Pf.from(i, (e) => e.tooltip),
    K.contentAttributes.from(i, (e) => e.attrs)
  ]
});
function Hf(i, e) {
  const t = e.completion.apply || e.completion.label;
  let r = i.state.field(mt).active.find((s) => s.source == e.source);
  return r instanceof ns ? (typeof t == "string" ? i.dispatch(Object.assign(Object.assign({}, DE(i.state, t, r.from, r.to)), { annotations: Yf.of(e.completion) })) : t(i, e.completion, r.from, r.to), !0) : !1;
}
const HE = /* @__PURE__ */ WE(mt, Hf);
function Wo(i, e = "option") {
  return (t) => {
    let r = t.state.field(mt, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(Ne).interactionDelay)
      return !1;
    let s = 1, n;
    e == "page" && (n = Ov(t, r.open.tooltip)) && (s = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, a = r.open.selected > -1 ? r.open.selected + s * (i ? 1 : -1) : i ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), t.dispatch({ effects: P_.of(a) }), !0;
  };
}
const GE = (i) => {
  let e = i.state.field(mt, !1);
  return i.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < i.state.facet(Ne).interactionDelay ? !1 : Hf(i, e.open.options[e.open.selected]);
}, jp = (i) => i.state.field(mt, !1) ? (i.dispatch({ effects: il.of(!0) }), !0) : !1, KE = (i) => {
  let e = i.state.field(mt, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (i.dispatch({ effects: Mn.of(null) }), !0);
};
class JE {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const e2 = 50, t2 = 1e3, i2 = /* @__PURE__ */ Ve.fromClass(class {
  constructor(i) {
    this.view = i, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of i.state.field(mt).active)
      e.isPending && this.startQuery(e);
  }
  update(i) {
    let e = i.state.field(mt), t = i.state.facet(Ne);
    if (!i.selectionSet && !i.docChanged && i.startState.field(mt) == e)
      return;
    let r = i.transactions.some((n) => {
      let o = Q_(n, t);
      return o & 8 || (n.selection || n.docChanged) && !(o & 3);
    });
    for (let n = 0; n < this.running.length; n++) {
      let o = this.running[n];
      if (r || o.context.abortOnDocChange && i.docChanged || o.updates.length + i.transactions.length > e2 && Date.now() - o.time > t2) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (l) {
            St(this.view.state, l);
          }
        o.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        o.updates.push(...i.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), i.transactions.some((n) => n.effects.some((o) => o.is(il))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.isPending && !this.running.some((o) => o.active.source == n.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let n of i.transactions)
        n.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: i } = this.view, e = i.field(mt);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ne).updateSyncTime));
  }
  startQuery(i) {
    let { state: e } = this.view, t = Qr(e), r = new jf(e, t, i.explicit, this.view), s = new JE(i, r);
    this.running.push(s), Promise.resolve(i.source(r)).then((n) => {
      s.context.aborted || (s.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: Mn.of(null) }), St(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((i) => i.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ne).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var i;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Ne), r = this.view.state.field(mt);
    for (let s = 0; s < this.running.length; s++) {
      let n = this.running[s];
      if (n.done === void 0)
        continue;
      if (this.running.splice(s--, 1), n.done) {
        let a = Qr(n.updates.length ? n.updates[0].startState : this.view.state), l = Math.min(a, n.done.from + (n.active.explicit ? 0 : 1)), c = new ns(n.active.source, n.active.explicit, l, n.done, n.done.from, (i = n.done.to) !== null && i !== void 0 ? i : a);
        for (let h of n.updates)
          c = c.update(h, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((a) => a.source == n.active.source);
      if (o && o.isPending)
        if (n.done == null) {
          let a = new Bt(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let l of n.updates)
            a = a.update(l, t);
          a.isPending || e.push(a);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: Ff.of(e) });
  }
}, {
  eventHandlers: {
    blur(i) {
      let e = this.view.state.field(mt, !1);
      if (e && e.tooltip && this.view.state.facet(Ne).closeOnBlur) {
        let t = e.open && Ov(this.view, e.open.tooltip);
        (!t || !t.dom.contains(i.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Mn.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: il.of(!1) }), 20), this.composing = 0;
    }
  }
}), r2 = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), s2 = /* @__PURE__ */ Zi.highest(/* @__PURE__ */ K.domEventHandlers({
  keydown(i, e) {
    let t = e.state.field(mt, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || i.key.length > 1 || i.ctrlKey && !(r2 && i.altKey) || i.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], s = t.active.find((o) => o.source == r.source), n = r.completion.commitCharacters || s.result.commitCharacters;
    return n && n.indexOf(i.key) > -1 && Hf(e, r), !1;
  }
})), T_ = /* @__PURE__ */ K.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class n2 {
  constructor(e, t, r, s) {
    this.field = e, this.line = t, this.from = r, this.to = s;
  }
}
class Gf {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Ke.TrackDel), r = e.mapPos(this.to, 1, Ke.TrackDel);
    return t == null || r == null ? null : new Gf(this.field, t, r);
  }
}
class Kf {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], s = [t], n = e.doc.lineAt(t), o = /^\s*/.exec(n.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let c = o, h = /^\t*/.exec(l)[0].length;
        for (let u = 0; u < h; u++)
          c += e.facet(co);
        s.push(t + c.length - h), l = c + l.slice(h);
      }
      r.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new Gf(l.field, s[l.line] + l.from, s[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let t = [], r = [], s = [], n;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o); ) {
        let a = n[1] ? +n[1] : null, l = n[2] || n[3] || "", c = -1, h = l.replace(/\\[{}]/g, (u) => u[1]);
        for (let u = 0; u < t.length; u++)
          (a != null ? t[u].seq == a : h && t[u].name == h) && (c = u);
        if (c < 0) {
          let u = 0;
          for (; u < t.length && (a == null || t[u].seq != null && t[u].seq < a); )
            u++;
          t.splice(u, 0, { seq: a, name: h }), c = u;
          for (let d of s)
            d.field >= c && d.field++;
        }
        s.push(new n2(c, r.length, n.index, n.index + h.length)), o = o.slice(0, n.index) + l + o.slice(n.index + n[0].length);
      }
      o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let h of s)
          h.line == r.length && h.from > c && (h.from--, h.to--);
        return l;
      }), r.push(o);
    }
    return new Kf(r, s);
  }
}
let o2 = /* @__PURE__ */ ae.widget({ widget: /* @__PURE__ */ new class extends zi {
  toDOM() {
    let i = document.createElement("span");
    return i.className = "cm-snippetFieldPosition", i;
  }
  ignoreEvent() {
    return !1;
  }
}() }), a2 = /* @__PURE__ */ ae.mark({ class: "cm-snippetField" });
class Qs {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = ae.set(e.map((r) => (r.from == r.to ? o2 : a2).range(r.from, r.to)));
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let s = r.map(e);
      if (!s)
        return null;
      t.push(s);
    }
    return new Qs(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const po = /* @__PURE__ */ he.define({
  map(i, e) {
    return i && i.map(e);
  }
}), l2 = /* @__PURE__ */ he.define(), Bn = /* @__PURE__ */ Ye.define({
  create() {
    return null;
  },
  update(i, e) {
    for (let t of e.effects) {
      if (t.is(po))
        return t.value;
      if (t.is(l2) && i)
        return new Qs(i.ranges, t.value);
    }
    return i && e.docChanged && (i = i.map(e.changes)), i && e.selection && !i.selectionInsideField(e.selection) && (i = null), i;
  },
  provide: (i) => K.decorations.from(i, (e) => e ? e.deco : ae.none)
});
function Jf(i, e) {
  return V.create(i.filter((t) => t.field == e).map((t) => V.range(t.from, t.to)));
}
function c2(i) {
  let e = Kf.parse(i);
  return (t, r, s, n) => {
    let { text: o, ranges: a } = e.instantiate(t.state, s), { main: l } = t.state.selection, c = {
      changes: { from: s, to: n == l.from ? l.to : n, insert: _e.of(o) },
      scrollIntoView: !0,
      annotations: r ? [Yf.of(r), We.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (c.selection = Jf(a, 0)), a.some((h) => h.field > 0)) {
      let h = new Qs(a, 0), u = c.effects = [po.of(h)];
      t.state.field(Bn, !1) === void 0 && u.push(he.appendConfig.of([Bn, O2, p2, T_]));
    }
    t.dispatch(t.state.update(c));
  };
}
function $_(i) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(Bn, !1);
    if (!r || i < 0 && r.active == 0)
      return !1;
    let s = r.active + i, n = i > 0 && !r.ranges.some((o) => o.field == s + i);
    return t(e.update({
      selection: Jf(r.ranges, s),
      effects: po.of(n ? null : new Qs(r.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
const h2 = ({ state: i, dispatch: e }) => i.field(Bn, !1) ? (e(i.update({ effects: po.of(null) })), !0) : !1, u2 = /* @__PURE__ */ $_(1), f2 = /* @__PURE__ */ $_(-1), d2 = [
  { key: "Tab", run: u2, shift: f2 },
  { key: "Escape", run: h2 }
], Np = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.length ? i[0] : d2;
  }
}), O2 = /* @__PURE__ */ Zi.highest(/* @__PURE__ */ oo.compute([Np], (i) => i.facet(Np)));
function Be(i, e) {
  return Object.assign(Object.assign({}, e), { apply: c2(i) });
}
const p2 = /* @__PURE__ */ K.domEventHandlers({
  mousedown(i, e) {
    let t = e.state.field(Bn, !1), r;
    if (!t || (r = e.posAtCoords({ x: i.clientX, y: i.clientY })) == null)
      return !1;
    let s = t.ranges.find((n) => n.from <= r && n.to >= r);
    return !s || s.field == t.active ? !1 : (e.dispatch({
      selection: Jf(t.ranges, s.field),
      effects: po.of(t.ranges.some((n) => n.field > s.field) ? new Qs(t.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), qn = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, yr = /* @__PURE__ */ he.define({
  map(i, e) {
    let t = e.mapPos(i, -1, Ke.TrackAfter);
    return t ?? void 0;
  }
}), ed = /* @__PURE__ */ new class extends Rr {
}();
ed.startSide = 1;
ed.endSide = -1;
const R_ = /* @__PURE__ */ Ye.define({
  create() {
    return be.empty;
  },
  update(i, e) {
    if (i = i.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      i = i.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(yr) && (i = i.update({ add: [ed.range(t.value, t.value + 1)] }));
    return i;
  }
});
function g2() {
  return [S2, R_];
}
const Cc = "()[]{}<>";
function E_(i) {
  for (let e = 0; e < Cc.length; e += 2)
    if (Cc.charCodeAt(e) == i)
      return Cc.charAt(e + 1);
  return df(i < 128 ? i : i + 1);
}
function A_(i, e) {
  return i.languageDataAt("closeBrackets", e)[0] || qn;
}
const m2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), S2 = /* @__PURE__ */ K.inputHandler.of((i, e, t, r) => {
  if ((m2 ? i.composing : i.compositionStarted) || i.state.readOnly)
    return !1;
  let s = i.state.selection.main;
  if (r.length > 2 || r.length == 2 && hi(pt(r, 0)) == 1 || e != s.from || t != s.to)
    return !1;
  let n = b2(i.state, r);
  return n ? (i.dispatch(n), !0) : !1;
}), v2 = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let r = A_(i, i.selection.main.head).brackets || qn.brackets, s = null, n = i.changeByRange((o) => {
    if (o.empty) {
      let a = y2(i.doc, o.head);
      for (let l of r)
        if (l == a && Bl(i.doc, o.head) == E_(pt(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: V.cursor(o.head - l.length)
          };
    }
    return { range: s = o };
  });
  return s || e(i.update(n, { scrollIntoView: !0, userEvent: "delete.backward" })), !s;
}, _2 = [
  { key: "Backspace", run: v2 }
];
function b2(i, e) {
  let t = A_(i, i.selection.main.head), r = t.brackets || qn.brackets;
  for (let s of r) {
    let n = E_(pt(s, 0));
    if (e == s)
      return n == s ? k2(i, s, r.indexOf(s + s + s) > -1, t) : w2(i, s, n, t.before || qn.before);
    if (e == n && L_(i, i.selection.main.from))
      return x2(i, s, n);
  }
  return null;
}
function L_(i, e) {
  let t = !1;
  return i.field(R_).between(0, i.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function Bl(i, e) {
  let t = i.sliceString(e, e + 2);
  return t.slice(0, hi(pt(t, 0)));
}
function y2(i, e) {
  let t = i.sliceString(e - 2, e);
  return hi(pt(t, 0)) == t.length ? t : t.slice(1);
}
function w2(i, e, t, r) {
  let s = null, n = i.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: yr.of(o.to + e.length),
        range: V.range(o.anchor + e.length, o.head + e.length)
      };
    let a = Bl(i.doc, o.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: yr.of(o.head + e.length),
      range: V.cursor(o.head + e.length)
    } : { range: s = o };
  });
  return s ? null : i.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function x2(i, e, t) {
  let r = null, s = i.changeByRange((n) => n.empty && Bl(i.doc, n.head) == t ? {
    changes: { from: n.head, to: n.head + t.length, insert: t },
    range: V.cursor(n.head + t.length)
  } : r = { range: n });
  return r ? null : i.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function k2(i, e, t, r) {
  let s = r.stringPrefixes || qn.stringPrefixes, n = null, o = i.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: yr.of(a.to + e.length),
        range: V.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = Bl(i.doc, l), h;
    if (c == e) {
      if (Yp(i, l))
        return {
          changes: { insert: e + e, from: l },
          effects: yr.of(l + e.length),
          range: V.cursor(l + e.length)
        };
      if (L_(i, l)) {
        let d = t && i.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: V.cursor(l + d.length)
        };
      }
    } else {
      if (t && i.sliceDoc(l - 2 * e.length, l) == e + e && (h = Fp(i, l - 2 * e.length, s)) > -1 && Yp(i, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: yr.of(l + e.length),
          range: V.cursor(l + e.length)
        };
      if (i.charCategorizer(l)(c) != De.Word && Fp(i, l, s) > -1 && !C2(i, l, e, s))
        return {
          changes: { insert: e + e, from: l },
          effects: yr.of(l + e.length),
          range: V.cursor(l + e.length)
        };
    }
    return { range: n = a };
  });
  return n ? null : i.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Yp(i, e) {
  let t = xe(i).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function C2(i, e, t, r) {
  let s = xe(i).resolveInner(e, -1), n = r.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = i.sliceDoc(s.from, Math.min(s.to, s.from + t.length + n)), l = a.indexOf(t);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let h = s.firstChild;
      for (; h && h.from == s.from && h.to - h.from > t.length + l; ) {
        if (i.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = s.to == e && s.parent;
    if (!c)
      break;
    s = c;
  }
  return !1;
}
function Fp(i, e, t) {
  let r = i.charCategorizer(e);
  if (r(i.sliceDoc(e - 1, e)) != De.Word)
    return e;
  for (let s of t) {
    let n = e - s.length;
    if (i.sliceDoc(n, e) == s && r(i.sliceDoc(n - 1, n)) != De.Word)
      return n;
  }
  return -1;
}
function Q2(i = {}) {
  return [
    s2,
    mt,
    Ne.of(i),
    i2,
    P2,
    T_
  ];
}
const D_ = [
  { key: "Ctrl-Space", run: jp },
  { mac: "Alt-`", run: jp },
  { key: "Escape", run: KE },
  { key: "ArrowDown", run: /* @__PURE__ */ Wo(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Wo(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Wo(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Wo(!1, "page") },
  { key: "Enter", run: GE }
], P2 = /* @__PURE__ */ Zi.highest(/* @__PURE__ */ oo.computeN([Ne], (i) => i.facet(Ne).defaultKeymap ? [D_] : []));
class Hp {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class mr {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let s = r.facet(Xn).markerFilter;
    s && (e = s(e, r));
    let n = e.slice().sort((h, u) => h.from - u.from || h.to - u.to), o = new Bi(), a = [], l = 0;
    for (let h = 0; ; ) {
      let u = h == n.length ? null : n[h];
      if (!u && !a.length)
        break;
      let d, O;
      for (a.length ? (d = l, O = a.reduce((S, f) => Math.min(S, f.to), u && u.from > d ? u.from : 1e8)) : (d = u.from, O = u.to, a.push(u), h++); h < n.length; ) {
        let S = n[h];
        if (S.from == d && (S.to > S.from || S.to == d))
          a.push(S), h++, O = Math.min(S.to, O);
        else {
          O = Math.min(S.from, O);
          break;
        }
      }
      let v = Z2(a);
      if (a.some((S) => S.from == S.to || S.from == S.to - 1 && r.doc.lineAt(S.from).to == S.from))
        o.add(d, d, ae.widget({
          widget: new B2(v),
          diagnostics: a.slice()
        }));
      else {
        let S = a.reduce((f, p) => p.markClass ? f + " " + p.markClass : f, "");
        o.add(d, O, ae.mark({
          class: "cm-lintRange cm-lintRange-" + v + S,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((f) => f.to > O)
        }));
      }
      l = O;
      for (let S = 0; S < a.length; S++)
        a[S].to <= l && a.splice(S--, 1);
    }
    let c = o.finish();
    return new mr(c, t, gs(c));
  }
}
function gs(i, e = null, t = 0) {
  let r = null;
  return i.between(t, 1e9, (s, n, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new Hp(s, n, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new Hp(r.from, n, r.diagnostic);
      }
  }), r;
}
function T2(i, e) {
  let t = e.pos, r = e.end || t, s = i.state.facet(Xn).hideOn(i, t, r);
  if (s != null)
    return s;
  let n = i.startState.doc.lineAt(e.pos);
  return !!(i.effects.some((o) => o.is(M_)) || i.changes.touchesRange(n.from, Math.max(n.to, r)));
}
function $2(i, e) {
  return i.field(Pt, !1) ? e : e.concat(he.appendConfig.of(W2));
}
const M_ = /* @__PURE__ */ he.define(), td = /* @__PURE__ */ he.define(), B_ = /* @__PURE__ */ he.define(), Pt = /* @__PURE__ */ Ye.define({
  create() {
    return new mr(ae.none, null, null);
  },
  update(i, e) {
    if (e.docChanged && i.diagnostics.size) {
      let t = i.diagnostics.map(e.changes), r = null, s = i.panel;
      if (i.selected) {
        let n = e.changes.mapPos(i.selected.from, 1);
        r = gs(t, i.selected.diagnostic, n) || gs(t, null, n);
      }
      !t.size && s && e.state.facet(Xn).autoPanel && (s = null), i = new mr(t, s, r);
    }
    for (let t of e.effects)
      if (t.is(M_)) {
        let r = e.state.facet(Xn).autoPanel ? t.value.length ? In.open : null : i.panel;
        i = mr.init(t.value, r, e.state);
      } else t.is(td) ? i = new mr(i.diagnostics, t.value ? In.open : null, i.selected) : t.is(B_) && (i = new mr(i.diagnostics, i.panel, t.value));
    return i;
  },
  provide: (i) => [
    $n.from(i, (e) => e.panel),
    K.decorations.from(i, (e) => e.diagnostics)
  ]
}), R2 = /* @__PURE__ */ ae.mark({ class: "cm-lintRange cm-lintRange-active" });
function E2(i, e, t) {
  let { diagnostics: r } = i.state.field(Pt), s, n = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: h }) => {
    if (e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)))
      return s = h.diagnostics, n = l, o = c, !1;
  });
  let a = i.state.facet(Xn).tooltipFilter;
  return s && a && (s = a(s, i.state)), s ? {
    pos: n,
    end: o,
    above: i.state.doc.lineAt(n).to < o,
    create() {
      return { dom: A2(i, s) };
    }
  } : null;
}
function A2(i, e) {
  return Ce("ul", { class: "cm-tooltip-lint" }, e.map((t) => X_(i, t, !1)));
}
const L2 = (i) => {
  let e = i.state.field(Pt, !1);
  (!e || !e.panel) && i.dispatch({ effects: $2(i.state, [td.of(!0)]) });
  let t = Tn(i, In.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Gp = (i) => {
  let e = i.state.field(Pt, !1);
  return !e || !e.panel ? !1 : (i.dispatch({ effects: td.of(!1) }), !0);
}, D2 = (i) => {
  let e = i.state.field(Pt, !1);
  if (!e)
    return !1;
  let t = i.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (i.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, M2 = [
  { key: "Mod-Shift-m", run: L2, preventDefault: !0 },
  { key: "F8", run: D2 }
], Xn = /* @__PURE__ */ ee.define({
  combine(i) {
    return Object.assign({ sources: i.map((e) => e.source).filter((e) => e != null) }, _i(i.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function q_(i) {
  let e = [];
  if (i)
    e: for (let { name: t } of i) {
      for (let r = 0; r < t.length; r++) {
        let s = t[r];
        if (/[a-zA-Z]/.test(s) && !e.some((n) => n.toLowerCase() == s.toLowerCase())) {
          e.push(s);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function X_(i, e, t) {
  var r;
  let s = t ? q_(e.actions) : [];
  return Ce("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ce("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(i) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((n, o) => {
    let a = !1, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = !0;
      let O = gs(i.state.field(Pt).diagnostics, e);
      O && n.apply(i, O.from, O.to);
    }, { name: c } = n, h = s[o] ? c.indexOf(s[o]) : -1, u = h < 0 ? c : [
      c.slice(0, h),
      Ce("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return Ce("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${s[o]})"`}.`
    }, u);
  }), e.source && Ce("div", { class: "cm-diagnosticSource" }, e.source));
}
class B2 extends zi {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Ce("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class Kp {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = X_(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class In {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (s) => {
      if (s.keyCode == 27)
        Gp(this.view), this.view.focus();
      else if (s.keyCode == 38 || s.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (s.keyCode == 40 || s.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (s.keyCode == 36)
        this.moveSelection(0);
      else if (s.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (s.keyCode == 13)
        this.view.focus();
      else if (s.keyCode >= 65 && s.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], o = q_(n.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == s.keyCode) {
            let l = gs(this.view.state.field(Pt).diagnostics, n);
            l && n.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      s.preventDefault();
    }, r = (s) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(s.target) && this.moveSelection(n);
    };
    this.list = Ce("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = Ce("div", { class: "cm-panel-lint" }, this.list, Ce("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Gp(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Pt).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Pt), r = 0, s = !1, n = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
      for (let h of c.diagnostics) {
        if (o.has(h))
          continue;
        o.add(h);
        let u = -1, d;
        for (let O = r; O < this.items.length; O++)
          if (this.items[O].diagnostic == h) {
            u = O;
            break;
          }
        u < 0 ? (d = new Kp(this.view, h), this.items.splice(r, 0, d), s = !0) : (d = this.items[u], u > r && (this.items.splice(r, u - r), s = !0)), t && d.diagnostic == t.diagnostic ? d.dom.hasAttribute("aria-selected") || (d.dom.setAttribute("aria-selected", "true"), n = d) : d.dom.hasAttribute("aria-selected") && d.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      s = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Kp(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), s = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let c = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), s && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Pt), r = gs(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: B_.of(r)
    });
  }
  static open(e) {
    return new In(e);
  }
}
function q2(i, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(i)}</svg>')`;
}
function zo(i) {
  return q2(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${i}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const X2 = /* @__PURE__ */ K.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ zo("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ zo("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ zo("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ zo("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function I2(i) {
  return i == "error" ? 4 : i == "warning" ? 3 : i == "info" ? 2 : 1;
}
function Z2(i) {
  let e = "hint", t = 1;
  for (let r of i) {
    let s = I2(r.severity);
    s > t && (t = s, e = r.severity);
  }
  return e;
}
const W2 = [
  Pt,
  /* @__PURE__ */ K.decorations.compute([Pt], (i) => {
    let { selected: e, panel: t } = i.field(Pt);
    return !e || !t || e.from == e.to ? ae.none : ae.set([
      R2.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ CT(E2, { hideOn: T2 }),
  X2
], z2 = [
  BT(),
  IT(),
  rT(),
  rR(),
  R$(),
  jP(),
  GP(),
  ve.allowMultipleSelections.of(!0),
  v$(),
  Bv(D$, { fallback: !0 }),
  W$(),
  g2(),
  Q2(),
  pT(),
  ST(),
  cT(),
  uE(),
  oo.of([
    ..._2,
    ...nE,
    ...$E,
    ...fR,
    ...Q$,
    ...D_,
    ...M2
  ])
];
class sl {
  /**
  @internal
  */
  constructor(e, t, r, s, n, o, a, l, c, h = 0, u) {
    this.p = e, this.stack = t, this.state = r, this.reducePos = s, this.pos = n, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = h, this.parent = u;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, r = 0) {
    let s = e.parser.context;
    return new sl(e, [], t, r, r, 0, [], 0, s ? new Jp(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let r = e >> 19, s = e & 65535, { parser: n } = this.p, o = this.reducePos < this.pos - 25;
    o && this.setLookAhead(this.pos);
    let a = n.dynamicPrecedence(s);
    if (a && (this.score += a), r == 0) {
      this.pushState(n.getGoto(this.state, s, !0), this.reducePos), s < n.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, o ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let l = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), c = l ? this.stack[l - 2] : this.p.ranges[0].from, h = this.reducePos - c;
    h >= 2e3 && !(!((t = this.p.parser.nodeSet.types[s]) === null || t === void 0) && t.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = h));
    let u = l ? this.stack[l - 1] : 0, d = this.bufferBase + this.buffer.length - u;
    if (s < n.minRepeatTerm || e & 131072) {
      let O = n.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, c, O, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let O = this.stack[l - 3];
      this.state = n.getGoto(O, s, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(s, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, r, s = 4, n = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (t == r)
          return;
        if (o.buffer[a - 2] >= t) {
          o.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!n || this.pos == r)
      this.buffer.push(e, t, r, s);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0) {
        let a = !1;
        for (let l = o; l > 0 && this.buffer[l - 2] > r; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; o > 0 && this.buffer[o - 2] > r; )
            this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, s > 4 && (s -= 4);
      }
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = r, this.buffer[o + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, r, s) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let n = e, { parser: o } = this.p;
      (s > this.pos || t <= o.maxNode) && (this.pos = s, o.stateFlag(
        n,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(n, r), this.shiftContext(t, r), t <= o.maxNode && this.buffer.push(t, r, s, 4);
    } else
      this.pos = s, this.shiftContext(t, r), t <= this.p.parser.maxNode && this.buffer.push(t, r, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, r, s) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, r, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let s = this.pos;
    this.reducePos = this.pos = s + e.length, this.pushState(t, s), this.buffer.push(
      r,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let r = e.buffer.slice(t), s = e.bufferBase + t;
    for (; e && s == e.bufferBase; )
      e = e.parent;
    return new sl(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, s, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, r ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new V2(this); ; ) {
      let r = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (r == 0)
        return !1;
      if ((r & 65536) == 0)
        return !0;
      t.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let n = 0, o; n < t.length; n += 2)
        (o = t[n + 1]) != this.state && this.p.parser.hasAction(o, e) && s.push(t[n], o);
      if (this.stack.length < 120)
        for (let n = 0; s.length < 8 && n < t.length; n += 2) {
          let o = t[n + 1];
          s.some((a, l) => l & 1 && a == o) || s.push(t[n], o);
        }
      t = s;
    }
    let r = [];
    for (let s = 0; s < t.length && r.length < 4; s += 2) {
      let n = t[s + 1];
      if (n == this.state)
        continue;
      let o = this.split();
      o.pushState(n, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[s], this.pos), o.reducePos = this.pos, o.score -= 200, r.push(o);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((t & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, t)) {
      let r = t >> 19, s = t & 65535, n = this.stack.length - r * 3;
      if (n < 0 || e.getGoto(this.stack[n], s, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], r = (s, n) => {
      if (!t.includes(s))
        return t.push(s), e.allActions(s, (o) => {
          if (!(o & 393216)) if (o & 65536) {
            let a = (o >> 19) - n;
            if (a > 1) {
              let l = o & 65535, c = this.stack.length - a * 3;
              if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                return a << 19 | 65536 | l;
            }
          } else {
            let a = r(o, n + 1);
            if (a != null)
              return a;
          }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new Jp(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class Jp {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class V2 {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = s;
  }
}
class nl {
  constructor(e, t, r) {
    this.stack = e, this.pos = t, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new nl(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new nl(this.stack, this.pos, this.index);
  }
}
function Ks(i, e = Uint16Array) {
  if (typeof i != "string")
    return i;
  let t = null;
  for (let r = 0, s = 0; r < i.length; ) {
    let n = 0;
    for (; ; ) {
      let o = i.charCodeAt(r++), a = !1;
      if (o == 126) {
        n = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), n += l, a)
        break;
      n *= 46;
    }
    t ? t[s++] = n : t = new e(n);
  }
  return t;
}
class fa {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const eg = new fa();
class U2 {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = eg, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let r = this.range, s = this.rangeIndex, n = this.pos + e;
    for (; n < r.from; ) {
      if (!s)
        return null;
      let o = this.ranges[--s];
      n -= r.from - o.to, r = o;
    }
    for (; t < 0 ? n > r.to : n >= r.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let o = this.ranges[++s];
      n += o.from - r.to, r = o;
    }
    return n;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, r, s;
    if (t >= 0 && t < this.chunk.length)
      r = this.pos + e, s = this.chunk.charCodeAt(t);
    else {
      let n = this.resolveOffset(e, 1);
      if (n == null)
        return -1;
      if (r = n, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), s = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let r = t ? this.resolveOffset(t, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = eg, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let r = "";
    for (let s of this.ranges) {
      if (s.from >= t)
        break;
      s.to > e && (r += this.input.read(Math.max(s.from, e), Math.min(s.to, t)));
    }
    return r;
  }
}
class os {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: r } = t.p;
    I_(this.data, e, t, this.id, r.data, r.tokenPrecTable);
  }
}
os.prototype.contextual = os.prototype.fallback = os.prototype.extend = !1;
class ol {
  constructor(e, t, r) {
    this.precTable = t, this.elseToken = r, this.data = typeof e == "string" ? Ks(e) : e;
  }
  token(e, t) {
    let r = e.pos, s = 0;
    for (; ; ) {
      let n = e.next < 0, o = e.resolveOffset(1, 1);
      if (I_(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (n || s++, o == null)
        break;
      e.reset(o, e.token);
    }
    s && (e.reset(r, e.token), e.acceptToken(this.elseToken, s));
  }
}
ol.prototype.contextual = os.prototype.fallback = os.prototype.extend = !1;
class qe {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function I_(i, e, t, r, s, n) {
  let o = 0, a = 1 << r, { dialect: l } = t.p.parser;
  e: for (; (a & i[o]) != 0; ) {
    let c = i[o + 1];
    for (let O = o + 3; O < c; O += 2)
      if ((i[O + 1] & a) > 0) {
        let v = i[O];
        if (l.allows(v) && (e.token.value == -1 || e.token.value == v || j2(v, e.token.value, s, n))) {
          e.acceptToken(v);
          break;
        }
      }
    let h = e.next, u = 0, d = i[o + 2];
    if (e.next < 0 && d > u && i[c + d * 3 - 3] == 65535) {
      o = i[c + d * 3 - 1];
      continue e;
    }
    for (; u < d; ) {
      let O = u + d >> 1, v = c + O + (O << 1), S = i[v], f = i[v + 1] || 65536;
      if (h < S)
        d = O;
      else if (h >= f)
        u = O + 1;
      else {
        o = i[v + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function tg(i, e, t) {
  for (let r = e, s; (s = i[r]) != 65535; r++)
    if (s == t)
      return r - e;
  return -1;
}
function j2(i, e, t, r) {
  let s = tg(t, r, e);
  return s < 0 || tg(t, r, i) < s;
}
const kt = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Qc = null;
function ig(i, e, t) {
  let r = i.cursor(Pe.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(t < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(i.length, Math.max(
            r.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (t < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return t < 0 ? 0 : i.length;
      }
}
let N2 = class {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? ig(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? ig(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let r = this.trees[t], s = this.index[t];
      if (s == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = r.children[s], o = this.start[t] + r.positions[s];
      if (o > e)
        return this.nextStart = o, null;
      if (n instanceof we) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let a = o + n.length;
          if (a <= this.safeTo) {
            let l = n.prop(le.lookAhead);
            if (!l || a + l < this.fragment.to)
              return n;
          }
        }
        this.index[t]++, o + n.length >= Math.max(this.safeFrom, e) && (this.trees.push(n), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + n.length;
    }
  }
};
class Y2 {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new fa());
  }
  getActions(e) {
    let t = 0, r = null, { parser: s } = e.p, { tokenizers: n } = s, o = s.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < n.length; c++) {
      if ((1 << c & o) == 0)
        continue;
      let h = n[c], u = this.tokens[c];
      if (!(r && !h.fallback) && ((h.contextual || u.start != e.pos || u.mask != o || u.context != a) && (this.updateCachedToken(u, h, e), u.mask = o, u.context = a), u.lookAhead > u.end + 25 && (l = Math.max(u.lookAhead, l)), u.value != 0)) {
        let d = t;
        if (u.extended > -1 && (t = this.addActions(e, u.extended, u.end, t)), t = this.addActions(e, u.value, u.end, t), !h.extend && (r = u, t > d))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !r && e.pos == this.stream.end && (r = new fa(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, t = this.addActions(e, r.value, r.end, t)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new fa(), { pos: r, p: s } = e;
    return t.start = r, t.end = Math.min(r + 1, s.stream.end), t.value = r == s.stream.end ? s.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, r) {
    let s = this.stream.clipPos(r.pos);
    if (t.token(this.stream.reset(s, e), r), e.value > -1) {
      let { parser: n } = r.p;
      for (let o = 0; o < n.specialized.length; o++)
        if (n.specialized[o] == e.value) {
          let a = n.specializers[o](this.stream.read(e.start, e.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            (a & 1) == 0 ? e.value = a >> 1 : e.extended = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(s + 1);
  }
  putAction(e, t, r, s) {
    for (let n = 0; n < s; n += 3)
      if (this.actions[n] == e)
        return s;
    return this.actions[s++] = e, this.actions[s++] = t, this.actions[s++] = r, s;
  }
  addActions(e, t, r, s) {
    let { state: n } = e, { parser: o } = e.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(
        n,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = $i(a, c + 2);
          else {
            s == 0 && a[c + 1] == 2 && (s = this.putAction($i(a, c + 2), t, r, s));
            break;
          }
        a[c] == t && (s = this.putAction($i(a, c + 1), t, r, s));
      }
    return s;
  }
}
class F2 {
  constructor(e, t, r, s) {
    this.parser = e, this.input = t, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new U2(t, s), this.tokens = new Y2(e, this.stream), this.topTerm = e.top[1];
    let { from: n } = s[0];
    this.stacks = [sl.start(this, e.top[0], n)], this.fragments = r.length && this.stream.end - n > e.bufferLength * 4 ? new N2(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, r = this.stacks = [], s, n;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > t)
          r.push(a);
        else {
          if (this.advanceStack(a, r, e))
            continue;
          {
            s || (s = [], n = []), s.push(a);
            let l = this.tokens.getMainToken(a);
            n.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let o = s && G2(s);
      if (o)
        return kt && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw kt && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let o = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, n, r);
      if (o)
        return kt && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > o)
        for (r.sort((a, l) => l.score - a.score); r.length > o; )
          r.pop();
      r.some((a) => a.reducePos > t) && this.recovering--;
    } else if (r.length > 1) {
      e: for (let o = 0; o < r.length - 1; o++) {
        let a = r[o];
        for (let l = o + 1; l < r.length; l++) {
          let c = r[l];
          if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
              r.splice(l--, 1);
            else {
              r.splice(o--, 1);
              continue e;
            }
        }
      }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let o = 1; o < r.length; o++)
      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, r) {
    let s = e.pos, { parser: n } = this, o = kt ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let u = this.fragments.nodeAt(s); u; ) {
        let d = this.parser.nodeSet.types[u.type.id] == u.type ? n.getGoto(e.state, u.type.id) : -1;
        if (d > -1 && u.length && (!c || (u.prop(le.contextHash) || 0) == h))
          return e.useNode(u, d), kt && console.log(o + this.stackID(e) + ` (via reuse of ${n.getName(u.type.id)})`), !0;
        if (!(u instanceof we) || u.children.length == 0 || u.positions[0] > 0)
          break;
        let O = u.children[0];
        if (O instanceof we && u.positions[0] == 0)
          u = O;
        else
          break;
      }
    }
    let a = n.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), kt && console.log(o + this.stackID(e) + ` (via always-reduce ${n.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let h = l[c++], u = l[c++], d = l[c++], O = c == l.length || !r, v = O ? e : e.split(), S = this.tokens.mainToken;
      if (v.apply(h, u, S ? S.start : v.pos, d), kt && console.log(o + this.stackID(v) + ` (via ${(h & 65536) == 0 ? "shift" : `reduce of ${n.getName(
        h & 65535
        /* Action.ValueMask */
      )}`} for ${n.getName(u)} @ ${s}${v == e ? "" : ", split"})`), O)
        return !0;
      v.pos > s ? t.push(v) : r.push(v);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return rg(e, t), !0;
    }
  }
  runRecovery(e, t, r) {
    let s = null, n = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = t[o << 1], c = t[(o << 1) + 1], h = kt ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (n || (n = !0, a.restart(), kt && console.log(h + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let u = a.split(), d = h;
      for (let O = 0; u.forceReduce() && O < 10 && (kt && console.log(d + this.stackID(u) + " (via force-reduce)"), !this.advanceFully(u, r)); O++)
        kt && (d = this.stackID(u) + " -> ");
      for (let O of a.recoverByInsert(l))
        kt && console.log(h + this.stackID(O) + " (via recover-insert)"), this.advanceFully(O, r);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), kt && console.log(h + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), rg(a, r)) : (!s || s.score < a.score) && (s = a);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), we.build({
      buffer: nl.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Qc || (Qc = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Qc.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function rg(i, e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (r.pos == i.pos && r.sameState(i)) {
      e[t].score < i.score && (e[t] = i);
      return;
    }
  }
  e.push(i);
}
class H2 {
  constructor(e, t, r) {
    this.source = e, this.flags = t, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Pc = (i) => i;
class go {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Pc, this.reduce = e.reduce || Pc, this.reuse = e.reuse || Pc, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Gt extends Af {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      t.push("");
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]), s = [];
    for (let a = 0; a < t.length; a++)
      s.push([]);
    function n(a, l, c) {
      s[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = le[l]);
        for (let c = 1; c < a.length; ) {
          let h = a[c++];
          if (h >= 0)
            n(h, l, a[c++]);
          else {
            let u = a[c + -h];
            for (let d = -h; d > 0; d--)
              n(a[c++], l, u);
            c++;
          }
        }
      }
    this.nodeSet = new lo(t.map((a, l) => je.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: s[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Sv;
    let o = Ks(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(sg), this.states = Ks(e.states, Uint32Array), this.data = Ks(e.stateData), this.goto = Ks(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new os(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, r) {
    let s = new F2(this, e, t, r);
    for (let n of this.wrappers)
      s = n(s, e, t, r);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, r = !1) {
    let s = this.goto;
    if (t >= s[0])
      return -1;
    for (let n = s[t + 1]; ; ) {
      let o = s[n++], a = o & 1, l = s[n++];
      if (a && r)
        return l;
      for (let c = n + (o >> 1); n < c; n++)
        if (s[n] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let r = this.data;
    for (let s = 0; s < 2; s++)
      for (let n = this.stateSlot(
        e,
        s ? 2 : 1
        /* ParseState.Actions */
      ), o; ; n += 3) {
        if ((o = r[n]) == 65535)
          if (r[n + 1] == 1)
            o = r[n = $i(r, n + 2)];
          else {
            if (r[n + 1] == 2)
              return $i(r, n + 2);
            break;
          }
        if (o == t || o == 0)
          return $i(r, n + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (r) => r == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), s = r ? t(r) : void 0;
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); s == null; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = $i(this.data, n + 2);
        else
          break;
      s = t($i(this.data, n + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = $i(this.data, r + 2);
        else
          break;
      if ((this.data[r + 2] & 1) == 0) {
        let s = this.data[r + 1];
        t.some((n, o) => o & 1 && n == s) || t.push(this.data[r], s);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(Gt.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = r;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((r) => {
      let s = e.tokenizers.find((n) => n.from == r);
      return s ? s.to : r;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((r, s) => {
      let n = e.specializers.find((a) => a.from == r.external);
      if (!n)
        return r;
      let o = Object.assign(Object.assign({}, r), { external: n.to });
      return t.specializers[s] = sg(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), r = t.map(() => !1);
    if (e)
      for (let n of e.split(" ")) {
        let o = t.indexOf(n);
        o >= 0 && (r[o] = !0);
      }
    let s = null;
    for (let n = 0; n < t.length; n++)
      if (!r[n])
        for (let o = this.dialects[t[n]], a; (a = this.data[o++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new H2(e, r, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Gt(e);
  }
}
function $i(i, e) {
  return i[e] | i[e + 1] << 16;
}
function G2(i) {
  let e = null;
  for (let t of i) {
    let r = t.p.stoppedAt;
    (t.pos == t.p.stream.end || r != null && t.pos > r) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function sg(i) {
  if (i.external) {
    let e = i.extend ? 1 : 0;
    return (t, r) => i.external(t, r) << 1 | e;
  }
  return i.get;
}
const K2 = 315, J2 = 316, ng = 1, eA = 2, tA = 3, iA = 4, rA = 317, sA = 319, nA = 320, oA = 5, aA = 6, lA = 0, wu = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Z_ = 125, cA = 59, xu = 47, hA = 42, uA = 43, fA = 45, dA = 60, OA = 44, pA = 63, gA = 46, mA = 91, SA = new go({
  start: !1,
  shift(i, e) {
    return e == oA || e == aA || e == sA ? i : e == nA;
  },
  strict: !1
}), vA = new qe((i, e) => {
  let { next: t } = i;
  (t == Z_ || t == -1 || e.context) && i.acceptToken(rA);
}, { contextual: !0, fallback: !0 }), _A = new qe((i, e) => {
  let { next: t } = i, r;
  wu.indexOf(t) > -1 || t == xu && ((r = i.peek(1)) == xu || r == hA) || t != Z_ && t != cA && t != -1 && !e.context && i.acceptToken(K2);
}, { contextual: !0 }), bA = new qe((i, e) => {
  i.next == mA && !e.context && i.acceptToken(J2);
}, { contextual: !0 }), yA = new qe((i, e) => {
  let { next: t } = i;
  if (t == uA || t == fA) {
    if (i.advance(), t == i.next) {
      i.advance();
      let r = !e.context && e.canShift(ng);
      i.acceptToken(r ? ng : eA);
    }
  } else t == pA && i.peek(1) == gA && (i.advance(), i.advance(), (i.next < 48 || i.next > 57) && i.acceptToken(tA));
}, { contextual: !0 });
function Tc(i, e) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i == 95 || i >= 192 || !e && i >= 48 && i <= 57;
}
const wA = new qe((i, e) => {
  if (i.next != dA || !e.dialectEnabled(lA) || (i.advance(), i.next == xu)) return;
  let t = 0;
  for (; wu.indexOf(i.next) > -1; )
    i.advance(), t++;
  if (Tc(i.next, !0)) {
    for (i.advance(), t++; Tc(i.next, !1); )
      i.advance(), t++;
    for (; wu.indexOf(i.next) > -1; )
      i.advance(), t++;
    if (i.next == OA) return;
    for (let r = 0; ; r++) {
      if (r == 7) {
        if (!Tc(i.next, !0)) return;
        break;
      }
      if (i.next != "extends".charCodeAt(r)) break;
      i.advance(), t++;
    }
  }
  i.acceptToken(iA, -t);
}), xA = Jt({
  "get set async static": C.modifier,
  "for while do if else switch try catch finally return throw break continue default case": C.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": C.operatorKeyword,
  "let var const using function class extends": C.definitionKeyword,
  "import export from": C.moduleKeyword,
  "with debugger new": C.keyword,
  TemplateString: C.special(C.string),
  super: C.atom,
  BooleanLiteral: C.bool,
  this: C.self,
  null: C.null,
  Star: C.modifier,
  VariableName: C.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": C.function(C.variableName),
  VariableDefinition: C.definition(C.variableName),
  Label: C.labelName,
  PropertyName: C.propertyName,
  PrivatePropertyName: C.special(C.propertyName),
  "CallExpression/MemberExpression/PropertyName": C.function(C.propertyName),
  "FunctionDeclaration/VariableDefinition": C.function(C.definition(C.variableName)),
  "ClassDeclaration/VariableDefinition": C.definition(C.className),
  "NewExpression/VariableName": C.className,
  PropertyDefinition: C.definition(C.propertyName),
  PrivatePropertyDefinition: C.definition(C.special(C.propertyName)),
  UpdateOp: C.updateOperator,
  "LineComment Hashbang": C.lineComment,
  BlockComment: C.blockComment,
  Number: C.number,
  String: C.string,
  Escape: C.escape,
  ArithOp: C.arithmeticOperator,
  LogicOp: C.logicOperator,
  BitOp: C.bitwiseOperator,
  CompareOp: C.compareOperator,
  RegExp: C.regexp,
  Equals: C.definitionOperator,
  Arrow: C.function(C.punctuation),
  ": Spread": C.punctuation,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace,
  "InterpolationStart InterpolationEnd": C.special(C.brace),
  ".": C.derefOperator,
  ", ;": C.separator,
  "@": C.meta,
  TypeName: C.typeName,
  TypeDefinition: C.definition(C.typeName),
  "type enum interface implements namespace module declare": C.definitionKeyword,
  "abstract global Privacy readonly override": C.modifier,
  "is keyof unique infer asserts": C.operatorKeyword,
  JSXAttributeValue: C.attributeValue,
  JSXText: C.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": C.angleBracket,
  "JSXIdentifier JSXNameSpacedName": C.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": C.attributeName,
  "JSXBuiltin/JSXIdentifier": C.standard(C.tagName)
}), kA = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, for: 474, of: 483, while: 486, with: 490, do: 494, if: 498, else: 500, switch: 504, case: 510, try: 516, catch: 520, finally: 524, return: 528, throw: 532, break: 536, continue: 540, debugger: 544 }, CA = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, QA = { __proto__: null, "<": 193 }, PA = Gt.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]",
  stateData: "((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~",
  goto: "$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: " ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 379,
  context: SA,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 236, 242, 244, 246, 248, 251, 257, 263, 265, 267, 269, 271, 273, 274, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [xA],
  skippedNodes: [0, 5, 6, 277],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [_A, bA, yA, wA, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, vA, new ol("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~", 141, 339), new ol("j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~", 25, 322)],
  topRules: { Script: [0, 7], SingleExpression: [1, 275], SingleClassItem: [2, 276] },
  dialects: { jsx: 0, ts: 15098 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 326, get: (i) => kA[i] || -1 }, { term: 342, get: (i) => CA[i] || -1 }, { term: 95, get: (i) => QA[i] || -1 }],
  tokenPrec: 15124
}), W_ = [
  /* @__PURE__ */ Be("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Be('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], TA = /* @__PURE__ */ W_.concat([
  /* @__PURE__ */ Be("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), og = /* @__PURE__ */ new Ef(), z_ = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function zs(i) {
  return (e, t) => {
    let r = e.node.getChild("VariableDefinition");
    return r && t(r, i), !0;
  };
}
const $A = ["FunctionDeclaration"], RA = {
  FunctionDeclaration: /* @__PURE__ */ zs("function"),
  ClassDeclaration: /* @__PURE__ */ zs("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ zs("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ zs("type"),
  NamespaceDeclaration: /* @__PURE__ */ zs("namespace"),
  VariableDefinition(i, e) {
    i.matchContext($A) || e(i, "variable");
  },
  TypeDefinition(i, e) {
    e(i, "type");
  },
  __proto__: null
};
function V_(i, e) {
  let t = og.get(e);
  if (t)
    return t;
  let r = [], s = !0;
  function n(o, a) {
    let l = i.sliceString(o.from, o.to);
    r.push({ label: l, type: a });
  }
  return e.cursor(Pe.IncludeAnonymous).iterate((o) => {
    if (s)
      s = !1;
    else if (o.name) {
      let a = RA[o.name];
      if (a && a(o, n) || z_.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of V_(i, o.node))
        r.push(a);
      return !1;
    }
  }), og.set(e, r), r;
}
const ag = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, U_ = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function EA(i) {
  let e = xe(i.state).resolveInner(i.pos, -1);
  if (U_.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && ag.test(i.state.sliceDoc(e.from, e.to));
  if (!t && !i.explicit)
    return null;
  let r = [];
  for (let s = e; s; s = s.parent)
    z_.has(s.name) && (r = r.concat(V_(i.state.doc, s)));
  return {
    options: r,
    from: t ? e.from : i.pos,
    validFor: ag
  };
}
const gi = /* @__PURE__ */ Ht.define({
  name: "javascript",
  parser: /* @__PURE__ */ PA.configure({
    props: [
      /* @__PURE__ */ bi.add({
        IfStatement: /* @__PURE__ */ Cr({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Cr({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: m$,
        SwitchBody: (i) => {
          let e = i.textAfter, t = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return i.baseIndent + (t ? 0 : r ? 1 : 2) * i.unit;
        },
        Block: /* @__PURE__ */ rs({ closing: "}" }),
        ArrowFunction: (i) => i.baseIndent + i.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Cr({ except: /^\s*{/ }),
        JSXElement(i) {
          let e = /^\s*<\//.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        JSXEscape(i) {
          let e = /\s*\}/.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        }
      }),
      /* @__PURE__ */ ei.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": ho,
        BlockComment(i) {
          return { from: i.from + 2, to: i.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), j_ = {
  test: (i) => /^JSX/.test(i.name),
  facet: /* @__PURE__ */ Lf({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, N_ = /* @__PURE__ */ gi.configure({ dialect: "ts" }, "typescript"), Y_ = /* @__PURE__ */ gi.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Df.add((i) => i.isTop ? [j_] : void 0)]
}), F_ = /* @__PURE__ */ gi.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Df.add((i) => i.isTop ? [j_] : void 0)]
}, "typescript");
let H_ = (i) => ({ label: i, type: "keyword" });
const G_ = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(H_), AA = /* @__PURE__ */ G_.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(H_));
function K_(i = {}) {
  let e = i.jsx ? i.typescript ? F_ : Y_ : i.typescript ? N_ : gi, t = i.typescript ? TA.concat(AA) : W_.concat(G_);
  return new Si(e, [
    gi.data.of({
      autocomplete: Nf(U_, Ml(t))
    }),
    gi.data.of({
      autocomplete: EA
    }),
    i.jsx ? MA : []
  ]);
}
function LA(i) {
  for (; ; ) {
    if (i.name == "JSXOpenTag" || i.name == "JSXSelfClosingTag" || i.name == "JSXFragmentTag")
      return i;
    if (i.name == "JSXEscape" || !i.parent)
      return null;
    i = i.parent;
  }
}
function lg(i, e, t = i.length) {
  for (let r = e?.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return i.sliceString(r.from, Math.min(r.to, t));
  return "";
}
const DA = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), MA = /* @__PURE__ */ K.inputHandler.of((i, e, t, r, s) => {
  if ((DA ? i.composing : i.compositionStarted) || i.state.readOnly || e != t || r != ">" && r != "/" || !gi.isActiveAt(i.state, e, -1))
    return !1;
  let n = s(), { state: o } = n, a = o.changeByRange((l) => {
    var c;
    let { head: h } = l, u = xe(o).resolveInner(h - 1, -1), d;
    if (u.name == "JSXStartTag" && (u = u.parent), !(o.doc.sliceString(h - 1, h) != r || u.name == "JSXAttributeValue" && u.to > h)) {
      if (r == ">" && u.name == "JSXFragmentTag")
        return { range: l, changes: { from: h, insert: "</>" } };
      if (r == "/" && u.name == "JSXStartCloseTag") {
        let O = u.parent, v = O.parent;
        if (v && O.from == h - 2 && ((d = lg(o.doc, v.firstChild, h)) || ((c = v.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let S = `${d}>`;
          return { range: V.cursor(h + S.length, -1), changes: { from: h, insert: S } };
        }
      } else if (r == ">") {
        let O = LA(u);
        if (O && O.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(h, h + 2)) && (d = lg(o.doc, O, h)))
          return { range: l, changes: { from: h, insert: `</${d}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    n,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
class al {
  static create(e, t, r, s, n) {
    let o = s + (s << 8) + e + (t << 4) | 0;
    return new al(e, t, r, o, n, [], []);
  }
  constructor(e, t, r, s, n, o, a) {
    this.type = e, this.value = t, this.from = r, this.hash = s, this.end = n, this.children = o, this.positions = a, this.hashProp = [[le.contextHash, s]];
  }
  addChild(e, t) {
    e.prop(le.contextHash) != this.hash && (e = new we(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(t);
  }
  toTree(e, t = this.end) {
    let r = this.children.length - 1;
    return r >= 0 && (t = Math.max(t, this.positions[r] + this.children[r].length + this.from)), new we(e.types[this.type], this.children, this.positions, t - this.from).balance({
      makeTree: (s, n, o) => new we(je.none, s, n, o, this.hashProp)
    });
  }
}
var F;
(function(i) {
  i[i.Document = 1] = "Document", i[i.CodeBlock = 2] = "CodeBlock", i[i.FencedCode = 3] = "FencedCode", i[i.Blockquote = 4] = "Blockquote", i[i.HorizontalRule = 5] = "HorizontalRule", i[i.BulletList = 6] = "BulletList", i[i.OrderedList = 7] = "OrderedList", i[i.ListItem = 8] = "ListItem", i[i.ATXHeading1 = 9] = "ATXHeading1", i[i.ATXHeading2 = 10] = "ATXHeading2", i[i.ATXHeading3 = 11] = "ATXHeading3", i[i.ATXHeading4 = 12] = "ATXHeading4", i[i.ATXHeading5 = 13] = "ATXHeading5", i[i.ATXHeading6 = 14] = "ATXHeading6", i[i.SetextHeading1 = 15] = "SetextHeading1", i[i.SetextHeading2 = 16] = "SetextHeading2", i[i.HTMLBlock = 17] = "HTMLBlock", i[i.LinkReference = 18] = "LinkReference", i[i.Paragraph = 19] = "Paragraph", i[i.CommentBlock = 20] = "CommentBlock", i[i.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", i[i.Escape = 22] = "Escape", i[i.Entity = 23] = "Entity", i[i.HardBreak = 24] = "HardBreak", i[i.Emphasis = 25] = "Emphasis", i[i.StrongEmphasis = 26] = "StrongEmphasis", i[i.Link = 27] = "Link", i[i.Image = 28] = "Image", i[i.InlineCode = 29] = "InlineCode", i[i.HTMLTag = 30] = "HTMLTag", i[i.Comment = 31] = "Comment", i[i.ProcessingInstruction = 32] = "ProcessingInstruction", i[i.Autolink = 33] = "Autolink", i[i.HeaderMark = 34] = "HeaderMark", i[i.QuoteMark = 35] = "QuoteMark", i[i.ListMark = 36] = "ListMark", i[i.LinkMark = 37] = "LinkMark", i[i.EmphasisMark = 38] = "EmphasisMark", i[i.CodeMark = 39] = "CodeMark", i[i.CodeText = 40] = "CodeText", i[i.CodeInfo = 41] = "CodeInfo", i[i.LinkTitle = 42] = "LinkTitle", i[i.LinkLabel = 43] = "LinkLabel", i[i.URL = 44] = "URL";
})(F || (F = {}));
class BA {
  /**
  @internal
  */
  constructor(e, t) {
    this.start = e, this.content = t, this.marks = [], this.parsers = [];
  }
}
class qA {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(e) {
    return cn(this.text, e);
  }
  /**
  @internal
  */
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(e) {
    this.markers.push(e);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(e, t = 0, r = 0) {
    for (let s = t; s < e; s++)
      r += this.text.charCodeAt(s) == 9 ? 4 - r % 4 : 1;
    return r;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(e) {
    let t = 0;
    for (let r = 0; t < this.text.length && r < e; t++)
      r += this.text.charCodeAt(t) == 9 ? 4 - r % 4 : 1;
    return t;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let t = 0; t < this.basePos; t++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function cg(i, e, t) {
  if (t.pos == t.text.length || i != e.block && t.indent >= e.stack[t.depth + 1].value + t.baseIndent)
    return !0;
  if (t.indent >= t.baseIndent + 4)
    return !1;
  let r = (i.type == F.OrderedList ? sd : rd)(t, e, !1);
  return r > 0 && (i.type != F.BulletList || id(t, e, !1) < 0) && t.text.charCodeAt(t.pos + r - 1) == i.value;
}
const J_ = {
  [F.Blockquote](i, e, t) {
    return t.next != 62 ? !1 : (t.markers.push(Se(F.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1)), t.moveBase(t.pos + (Zt(t.text.charCodeAt(t.pos + 1)) ? 2 : 1)), i.end = e.lineStart + t.text.length, !0);
  },
  [F.ListItem](i, e, t) {
    return t.indent < t.baseIndent + i.value && t.next > -1 ? !1 : (t.moveBaseColumn(t.baseIndent + i.value), !0);
  },
  [F.OrderedList]: cg,
  [F.BulletList]: cg,
  [F.Document]() {
    return !0;
  }
};
function Zt(i) {
  return i == 32 || i == 9 || i == 10 || i == 13;
}
function cn(i, e = 0) {
  for (; e < i.length && Zt(i.charCodeAt(e)); )
    e++;
  return e;
}
function hg(i, e, t) {
  for (; e > t && Zt(i.charCodeAt(e - 1)); )
    e--;
  return e;
}
function eb(i) {
  if (i.next != 96 && i.next != 126)
    return -1;
  let e = i.pos + 1;
  for (; e < i.text.length && i.text.charCodeAt(e) == i.next; )
    e++;
  if (e < i.pos + 3)
    return -1;
  if (i.next == 96) {
    for (let t = e; t < i.text.length; t++)
      if (i.text.charCodeAt(t) == 96)
        return -1;
  }
  return e;
}
function tb(i) {
  return i.next != 62 ? -1 : i.text.charCodeAt(i.pos + 1) == 32 ? 2 : 1;
}
function id(i, e, t) {
  if (i.next != 42 && i.next != 45 && i.next != 95)
    return -1;
  let r = 1;
  for (let s = i.pos + 1; s < i.text.length; s++) {
    let n = i.text.charCodeAt(s);
    if (n == i.next)
      r++;
    else if (!Zt(n))
      return -1;
  }
  return t && i.next == 45 && sb(i) > -1 && i.depth == e.stack.length && e.parser.leafBlockParsers.indexOf(lb.SetextHeading) > -1 || r < 3 ? -1 : 1;
}
function ib(i, e) {
  for (let t = i.stack.length - 1; t >= 0; t--)
    if (i.stack[t].type == e)
      return !0;
  return !1;
}
function rd(i, e, t) {
  return (i.next == 45 || i.next == 43 || i.next == 42) && (i.pos == i.text.length - 1 || Zt(i.text.charCodeAt(i.pos + 1))) && (!t || ib(e, F.BulletList) || i.skipSpace(i.pos + 2) < i.text.length) ? 1 : -1;
}
function sd(i, e, t) {
  let r = i.pos, s = i.next;
  for (; s >= 48 && s <= 57; ) {
    r++;
    if (r == i.text.length)
      return -1;
    s = i.text.charCodeAt(r);
  }
  return r == i.pos || r > i.pos + 9 || s != 46 && s != 41 || r < i.text.length - 1 && !Zt(i.text.charCodeAt(r + 1)) || t && !ib(e, F.OrderedList) && (i.skipSpace(r + 1) == i.text.length || r > i.pos + 1 || i.next != 49) ? -1 : r + 1 - i.pos;
}
function rb(i) {
  if (i.next != 35)
    return -1;
  let e = i.pos + 1;
  for (; e < i.text.length && i.text.charCodeAt(e) == 35; )
    e++;
  if (e < i.text.length && i.text.charCodeAt(e) != 32)
    return -1;
  let t = e - i.pos;
  return t > 6 ? -1 : t;
}
function sb(i) {
  if (i.next != 45 && i.next != 61 || i.indent >= i.baseIndent + 4)
    return -1;
  let e = i.pos + 1;
  for (; e < i.text.length && i.text.charCodeAt(e) == i.next; )
    e++;
  let t = e;
  for (; e < i.text.length && Zt(i.text.charCodeAt(e)); )
    e++;
  return e == i.text.length ? t : -1;
}
const ku = /^[ \t]*$/, nb = /-->/, ob = /\?>/, Cu = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, nb],
  [/^\s*<\?/, ob],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, ku],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, ku]
];
function ab(i, e, t) {
  if (i.next != 60)
    return -1;
  let r = i.text.slice(i.pos);
  for (let s = 0, n = Cu.length - (t ? 1 : 0); s < n; s++)
    if (Cu[s][0].test(r))
      return s;
  return -1;
}
function ug(i, e) {
  let t = i.countIndent(e, i.pos, i.indent), r = i.countIndent(i.skipSpace(e), e, t);
  return r >= t + 5 ? t + 1 : r;
}
function ur(i, e, t) {
  let r = i.length - 1;
  r >= 0 && i[r].to == e && i[r].type == F.CodeText ? i[r].to = t : i.push(Se(F.CodeText, e, t));
}
const Vo = {
  LinkReference: void 0,
  IndentedCode(i, e) {
    let t = e.baseIndent + 4;
    if (e.indent < t)
      return !1;
    let r = e.findColumn(t), s = i.lineStart + r, n = i.lineStart + e.text.length, o = [], a = [];
    for (ur(o, s, n); i.nextLine() && e.depth >= i.stack.length; )
      if (e.pos == e.text.length) {
        ur(a, i.lineStart - 1, i.lineStart);
        for (let l of e.markers)
          a.push(l);
      } else {
        if (e.indent < t)
          break;
        {
          if (a.length) {
            for (let c of a)
              c.type == F.CodeText ? ur(o, c.from, c.to) : o.push(c);
            a = [];
          }
          ur(o, i.lineStart - 1, i.lineStart);
          for (let c of e.markers)
            o.push(c);
          n = i.lineStart + e.text.length;
          let l = i.lineStart + e.findColumn(e.baseIndent + 4);
          l < n && ur(o, l, n);
        }
      }
    return a.length && (a = a.filter((l) => l.type != F.CodeText), a.length && (e.markers = a.concat(e.markers))), i.addNode(i.buffer.writeElements(o, -s).finish(F.CodeBlock, n - s), s), !0;
  },
  FencedCode(i, e) {
    let t = eb(e);
    if (t < 0)
      return !1;
    let r = i.lineStart + e.pos, s = e.next, n = t - e.pos, o = e.skipSpace(t), a = hg(e.text, e.text.length, o), l = [Se(F.CodeMark, r, r + n)];
    o < a && l.push(Se(F.CodeInfo, i.lineStart + o, i.lineStart + a));
    for (let c = !0; i.nextLine() && e.depth >= i.stack.length; c = !1) {
      let h = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; h < e.text.length && e.text.charCodeAt(h) == s; )
          h++;
      if (h - e.pos >= n && e.skipSpace(h) == e.text.length) {
        for (let u of e.markers)
          l.push(u);
        l.push(Se(F.CodeMark, i.lineStart + e.pos, i.lineStart + h)), i.nextLine();
        break;
      } else {
        c || ur(l, i.lineStart - 1, i.lineStart);
        for (let O of e.markers)
          l.push(O);
        let u = i.lineStart + e.basePos, d = i.lineStart + e.text.length;
        u < d && ur(l, u, d);
      }
    }
    return i.addNode(i.buffer.writeElements(l, -r).finish(F.FencedCode, i.prevLineEnd() - r), r), !0;
  },
  Blockquote(i, e) {
    let t = tb(e);
    return t < 0 ? !1 : (i.startContext(F.Blockquote, e.pos), i.addNode(F.QuoteMark, i.lineStart + e.pos, i.lineStart + e.pos + 1), e.moveBase(e.pos + t), null);
  },
  HorizontalRule(i, e) {
    if (id(e, i, !1) < 0)
      return !1;
    let t = i.lineStart + e.pos;
    return i.nextLine(), i.addNode(F.HorizontalRule, t), !0;
  },
  BulletList(i, e) {
    let t = rd(e, i, !1);
    if (t < 0)
      return !1;
    i.block.type != F.BulletList && i.startContext(F.BulletList, e.basePos, e.next);
    let r = ug(e, e.pos + 1);
    return i.startContext(F.ListItem, e.basePos, r - e.baseIndent), i.addNode(F.ListMark, i.lineStart + e.pos, i.lineStart + e.pos + t), e.moveBaseColumn(r), null;
  },
  OrderedList(i, e) {
    let t = sd(e, i, !1);
    if (t < 0)
      return !1;
    i.block.type != F.OrderedList && i.startContext(F.OrderedList, e.basePos, e.text.charCodeAt(e.pos + t - 1));
    let r = ug(e, e.pos + t);
    return i.startContext(F.ListItem, e.basePos, r - e.baseIndent), i.addNode(F.ListMark, i.lineStart + e.pos, i.lineStart + e.pos + t), e.moveBaseColumn(r), null;
  },
  ATXHeading(i, e) {
    let t = rb(e);
    if (t < 0)
      return !1;
    let r = e.pos, s = i.lineStart + r, n = hg(e.text, e.text.length, r), o = n;
    for (; o > r && e.text.charCodeAt(o - 1) == e.next; )
      o--;
    (o == n || o == r || !Zt(e.text.charCodeAt(o - 1))) && (o = e.text.length);
    let a = i.buffer.write(F.HeaderMark, 0, t).writeElements(i.parser.parseInline(e.text.slice(r + t + 1, o), s + t + 1), -s);
    o < e.text.length && a.write(F.HeaderMark, o - r, n - r);
    let l = a.finish(F.ATXHeading1 - 1 + t, e.text.length - r);
    return i.nextLine(), i.addNode(l, s), !0;
  },
  HTMLBlock(i, e) {
    let t = ab(e, i, !1);
    if (t < 0)
      return !1;
    let r = i.lineStart + e.pos, s = Cu[t][1], n = [], o = s != ku;
    for (; !s.test(e.text) && i.nextLine(); ) {
      if (e.depth < i.stack.length) {
        o = !1;
        break;
      }
      for (let c of e.markers)
        n.push(c);
    }
    o && i.nextLine();
    let a = s == nb ? F.CommentBlock : s == ob ? F.ProcessingInstructionBlock : F.HTMLBlock, l = i.prevLineEnd();
    return i.addNode(i.buffer.writeElements(n, -r).finish(a, l - r), r), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
class XA {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, t, r) {
    if (this.stage == -1)
      return !1;
    let s = r.content + `
` + t.scrub(), n = this.advance(s);
    return n > -1 && n < s.length ? this.complete(e, r, n) : !1;
  }
  finish(e, t) {
    return (this.stage == 2 || this.stage == 3) && cn(t.content, this.pos) == t.content.length ? this.complete(e, t, t.content.length) : !1;
  }
  complete(e, t, r) {
    return e.addLeafElement(t, Se(F.LinkReference, this.start, this.start + r, this.elts)), !0;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(mb(e, this.pos, this.start, !0)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Se(F.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(pb(e, cn(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let t = cn(e, this.pos), r = 0;
        if (t > this.pos) {
          let s = gb(e, t, this.start);
          if (s) {
            let n = $c(e, s.to - this.start);
            n > 0 && (this.nextStage(s), r = n);
          }
        }
        return r || (r = $c(e, this.pos)), r > 0 && r < e.length ? r : -1;
      } else
        return $c(e, this.pos);
    }
  }
}
function $c(i, e) {
  for (; e < i.length; e++) {
    let t = i.charCodeAt(e);
    if (t == 10)
      break;
    if (!Zt(t))
      return -1;
  }
  return e;
}
class IA {
  nextLine(e, t, r) {
    let s = t.depth < e.stack.length ? -1 : sb(t), n = t.next;
    if (s < 0)
      return !1;
    let o = Se(F.HeaderMark, e.lineStart + t.pos, e.lineStart + s);
    return e.nextLine(), e.addLeafElement(r, Se(n == 61 ? F.SetextHeading1 : F.SetextHeading2, r.start, e.prevLineEnd(), [
      ...e.parser.parseInline(r.content, r.start),
      o
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const lb = {
  LinkReference(i, e) {
    return e.content.charCodeAt(0) == 91 ? new XA(e) : null;
  },
  SetextHeading() {
    return new IA();
  }
}, ZA = [
  (i, e) => rb(e) >= 0,
  (i, e) => eb(e) >= 0,
  (i, e) => tb(e) >= 0,
  (i, e) => rd(e, i, !0) >= 0,
  (i, e) => sd(e, i, !0) >= 0,
  (i, e) => id(e, i, !0) >= 0,
  (i, e) => ab(e, i, !0) >= 0
], WA = { text: "", end: 0 };
class zA {
  /**
  @internal
  */
  constructor(e, t, r, s) {
    this.parser = e, this.input = t, this.ranges = s, this.line = new qA(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = s[s.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = s[0].from, this.block = al.create(F.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = r.length ? new NA(r, t) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (let r = 0; ; ) {
        let s = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; r < e.markers.length && (!s || e.markers[r].from < s.end); ) {
          let n = e.markers[r++];
          this.addNode(n.type, n.from, n.to);
        }
        if (!s)
          break;
        this.finishContext();
      }
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e: for (; ; ) {
      for (let r of this.parser.blockParsers)
        if (r) {
          let s = r(this, e);
          if (s != !1) {
            if (s == !0)
              return null;
            e.forward();
            continue e;
          }
        }
      break;
    }
    let t = new BA(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let r of this.parser.leafBlockParsers)
      if (r) {
        let s = r(this, t);
        s && t.parsers.push(s);
      }
    e: for (; this.nextLine() && e.pos != e.text.length; ) {
      if (e.indent < e.baseIndent + 4) {
        for (let r of this.parser.endLeafBlock)
          if (r(this, e, t))
            break e;
      }
      for (let r of t.parsers)
        if (r.nextLine(this, e, t))
          return null;
      t.content += `
` + e.scrub();
      for (let r of e.markers)
        t.marks.push(r);
    }
    return this.finishLeaf(t), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let t = this.fragments.takeNodes(this);
    return t ? (this.absoluteLineStart += t, this.lineStart = Sb(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(e) {
    let t = WA;
    if (t.end = e, e >= this.to)
      t.text = "";
    else if (t.text = this.lineChunkAt(e), t.end += t.text.length, this.ranges.length > 1) {
      let r = this.absoluteLineStart, s = this.rangeI;
      for (; this.ranges[s].to < t.end; ) {
        s++;
        let n = this.ranges[s].from, o = this.lineChunkAt(n);
        t.end = n + o.length, t.text = t.text.slice(0, this.ranges[s - 1].to - r) + o, r = t.end - t.text.length;
      }
    }
    return t;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: e } = this, { text: t, end: r } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = r, e.reset(t); e.depth < this.stack.length; e.depth++) {
      let s = this.stack[e.depth], n = this.parser.skipContextMarkup[s.type];
      if (!n)
        throw new Error("Unhandled block context " + F[s.type]);
      if (!n(s, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let t = this.input.chunk(e), r;
    if (this.input.lineChunks)
      r = t == `
` ? "" : t;
    else {
      let s = t.indexOf(`
`);
      r = s < 0 ? t : t.slice(0, s);
    }
    return e + r.length > this.to ? r.slice(0, this.to - e) : r;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(e, t, r = 0) {
    this.block = al.create(e, r, this.lineStart + t, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(e, t, r = 0) {
    this.startContext(this.parser.getNodeType(e), t, r);
  }
  /**
  @internal
  */
  addNode(e, t, r) {
    typeof e == "number" && (e = new we(this.parser.nodeSet.types[e], ms, ms, (r ?? this.prevLineEnd()) - t)), this.block.addChild(e, t - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(e, t) {
    this.addNode(this.buffer.writeElements(Tu(t.children, e.marks), -t.from).finish(t.type, t.to - t.from), t.from);
  }
  /**
  @internal
  */
  finishContext() {
    let e = this.stack.pop(), t = this.stack[this.stack.length - 1];
    t.addChild(e.toTree(this.parser.nodeSet), e.from - t.from), this.block = t;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? cb(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  /**
  @internal
  */
  finishLeaf(e) {
    for (let r of e.parsers)
      if (r.finish(this, e))
        return;
    let t = Tu(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(t, -e.start).finish(F.Paragraph, e.content.length), e.start);
  }
  elt(e, t, r, s) {
    return typeof e == "string" ? Se(this.parser.getNodeType(e), t, r, s) : new fb(e, t);
  }
  /**
  @internal
  */
  get buffer() {
    return new ub(this.parser.nodeSet);
  }
}
function cb(i, e, t, r, s) {
  let n = i[e].to, o = [], a = [], l = t.from + r;
  function c(h, u) {
    for (; u ? h >= n : h > n; ) {
      let d = i[e + 1].from - n;
      r += d, h += d, e++, n = i[e].to;
    }
  }
  for (let h = t.firstChild; h; h = h.nextSibling) {
    c(h.from + r, !0);
    let u = h.from + r, d, O = s.get(h.tree);
    O ? d = O : h.to + r > n ? (d = cb(i, e, h, r, s), c(h.to + r, !1)) : d = h.toTree(), o.push(d), a.push(u - l);
  }
  return c(t.to + r, !1), new we(t.type, o, a, t.to + r - l, t.tree ? t.tree.propValues : void 0);
}
class ql extends Af {
  /**
  @internal
  */
  constructor(e, t, r, s, n, o, a, l, c) {
    super(), this.nodeSet = e, this.blockParsers = t, this.leafBlockParsers = r, this.blockNames = s, this.endLeafBlock = n, this.skipContextMarkup = o, this.inlineParsers = a, this.inlineNames = l, this.wrappers = c, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let h of e.types)
      this.nodeTypes[h.name] = h.id;
  }
  createParse(e, t, r) {
    let s = new zA(this, e, t, r);
    for (let n of this.wrappers)
      s = n(s, e, t, r);
    return s;
  }
  /**
  Reconfigure the parser.
  */
  configure(e) {
    let t = Qu(e);
    if (!t)
      return this;
    let { nodeSet: r, skipContextMarkup: s } = this, n = this.blockParsers.slice(), o = this.leafBlockParsers.slice(), a = this.blockNames.slice(), l = this.inlineParsers.slice(), c = this.inlineNames.slice(), h = this.endLeafBlock.slice(), u = this.wrappers;
    if (Vs(t.defineNodes)) {
      s = Object.assign({}, s);
      let d = r.types.slice(), O;
      for (let v of t.defineNodes) {
        let { name: S, block: f, composite: p, style: g } = typeof v == "string" ? { name: v } : v;
        if (d.some((b) => b.name == S))
          continue;
        p && (s[d.length] = (b, w, x) => p(w, x, b.value));
        let m = d.length, _ = p ? ["Block", "BlockContext"] : f ? m >= F.ATXHeading1 && m <= F.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        d.push(je.define({
          id: m,
          name: S,
          props: _ && [[le.group, _]]
        })), g && (O || (O = {}), Array.isArray(g) || g instanceof li ? O[S] = g : Object.assign(O, g));
      }
      r = new lo(d), O && (r = r.extend(Jt(O)));
    }
    if (Vs(t.props) && (r = r.extend(...t.props)), Vs(t.remove))
      for (let d of t.remove) {
        let O = this.blockNames.indexOf(d), v = this.inlineNames.indexOf(d);
        O > -1 && (n[O] = o[O] = void 0), v > -1 && (l[v] = void 0);
      }
    if (Vs(t.parseBlock))
      for (let d of t.parseBlock) {
        let O = a.indexOf(d.name);
        if (O > -1)
          n[O] = d.parse, o[O] = d.leaf;
        else {
          let v = d.before ? Uo(a, d.before) : d.after ? Uo(a, d.after) + 1 : a.length - 1;
          n.splice(v, 0, d.parse), o.splice(v, 0, d.leaf), a.splice(v, 0, d.name);
        }
        d.endLeaf && h.push(d.endLeaf);
      }
    if (Vs(t.parseInline))
      for (let d of t.parseInline) {
        let O = c.indexOf(d.name);
        if (O > -1)
          l[O] = d.parse;
        else {
          let v = d.before ? Uo(c, d.before) : d.after ? Uo(c, d.after) + 1 : c.length - 1;
          l.splice(v, 0, d.parse), c.splice(v, 0, d.name);
        }
      }
    return t.wrap && (u = u.concat(t.wrap)), new ql(r, n, o, a, h, s, l, c, u);
  }
  /**
  @internal
  */
  getNodeType(e) {
    let t = this.nodeTypes[e];
    if (t == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return t;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(e, t) {
    let r = new UA(this, e, t);
    e: for (let s = t; s < r.end; ) {
      let n = r.char(s);
      for (let o of this.inlineParsers)
        if (o) {
          let a = o(r, n, s);
          if (a >= 0) {
            s = a;
            continue e;
          }
        }
      s++;
    }
    return r.resolveMarkers(0);
  }
}
function Vs(i) {
  return i != null && i.length > 0;
}
function Qu(i) {
  if (!Array.isArray(i))
    return i;
  if (i.length == 0)
    return null;
  let e = Qu(i[0]);
  if (i.length == 1)
    return e;
  let t = Qu(i.slice(1));
  if (!t || !e)
    return e || t;
  let r = (o, a) => (o || ms).concat(a || ms), s = e.wrap, n = t.wrap;
  return {
    props: r(e.props, t.props),
    defineNodes: r(e.defineNodes, t.defineNodes),
    parseBlock: r(e.parseBlock, t.parseBlock),
    parseInline: r(e.parseInline, t.parseInline),
    remove: r(e.remove, t.remove),
    wrap: s ? n ? (o, a, l, c) => s(n(o, a, l, c), a, l, c) : s : n
  };
}
function Uo(i, e) {
  let t = i.indexOf(e);
  if (t < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return t;
}
let hb = [je.none];
for (let i = 1, e; e = F[i]; i++)
  hb[i] = je.define({
    id: i,
    name: e,
    props: i >= F.Escape ? [] : [[le.group, i in J_ ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document"
  });
const ms = [];
let ub = class {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, t, r, s = 0) {
    return this.content.push(e, t, r, 4 + s * 4), this;
  }
  writeElements(e, t = 0) {
    for (let r of e)
      r.writeTo(this, t);
    return this;
  }
  finish(e, t) {
    return we.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: t
    });
  }
}, Zn = class {
  /**
  @internal
  */
  constructor(e, t, r, s = ms) {
    this.type = e, this.from = t, this.to = r, this.children = s;
  }
  /**
  @internal
  */
  writeTo(e, t) {
    let r = e.content.length;
    e.writeElements(this.children, t), e.content.push(this.type, this.from + t, this.to + t, e.content.length + 4 - r);
  }
  /**
  @internal
  */
  toTree(e) {
    return new ub(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class fb {
  constructor(e, t) {
    this.tree = e, this.from = t;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return ms;
  }
  writeTo(e, t) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + t, this.to + t, -1);
  }
  toTree() {
    return this.tree;
  }
}
function Se(i, e, t, r) {
  return new Zn(i, e, t, r);
}
const db = { resolve: "Emphasis", mark: "EmphasisMark" }, Ob = { resolve: "Emphasis", mark: "EmphasisMark" }, Nr = {}, Pu = {};
class Et {
  constructor(e, t, r, s) {
    this.type = e, this.from = t, this.to = r, this.side = s;
  }
}
const fg = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Wn = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Wn = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const Rc = {
  Escape(i, e, t) {
    if (e != 92 || t == i.end - 1)
      return -1;
    let r = i.char(t + 1);
    for (let s = 0; s < fg.length; s++)
      if (fg.charCodeAt(s) == r)
        return i.append(Se(F.Escape, t, t + 2));
    return -1;
  },
  Entity(i, e, t) {
    if (e != 38)
      return -1;
    let r = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(i.slice(t + 1, t + 31));
    return r ? i.append(Se(F.Entity, t, t + 1 + r[0].length)) : -1;
  },
  InlineCode(i, e, t) {
    if (e != 96 || t && i.char(t - 1) == 96)
      return -1;
    let r = t + 1;
    for (; r < i.end && i.char(r) == 96; )
      r++;
    let s = r - t, n = 0;
    for (; r < i.end; r++)
      if (i.char(r) == 96) {
        if (n++, n == s && i.char(r + 1) != 96)
          return i.append(Se(F.InlineCode, t, r + 1, [
            Se(F.CodeMark, t, t + s),
            Se(F.CodeMark, r + 1 - s, r + 1)
          ]));
      } else
        n = 0;
    return -1;
  },
  HTMLTag(i, e, t) {
    if (e != 60 || t == i.end - 1)
      return -1;
    let r = i.slice(t + 1, i.end), s = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(r);
    if (s)
      return i.append(Se(F.Autolink, t, t + 1 + s[0].length, [
        Se(F.LinkMark, t, t + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        Se(F.URL, t + 1, t + s[0].length),
        Se(F.LinkMark, t + s[0].length, t + 1 + s[0].length)
      ]));
    let n = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r);
    if (n)
      return i.append(Se(F.Comment, t, t + 1 + n[0].length));
    let o = /^\?[^]*?\?>/.exec(r);
    if (o)
      return i.append(Se(F.ProcessingInstruction, t, t + 1 + o[0].length));
    let a = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(r);
    return a ? i.append(Se(F.HTMLTag, t, t + 1 + a[0].length)) : -1;
  },
  Emphasis(i, e, t) {
    if (e != 95 && e != 42)
      return -1;
    let r = t + 1;
    for (; i.char(r) == e; )
      r++;
    let s = i.slice(t - 1, t), n = i.slice(r, r + 1), o = Wn.test(s), a = Wn.test(n), l = /\s|^$/.test(s), c = /\s|^$/.test(n), h = !c && (!a || l || o), u = !l && (!o || c || a), d = h && (e == 42 || !u || o), O = u && (e == 42 || !h || a);
    return i.append(new Et(e == 95 ? db : Ob, t, r, (d ? 1 : 0) | (O ? 2 : 0)));
  },
  HardBreak(i, e, t) {
    if (e == 92 && i.char(t + 1) == 10)
      return i.append(Se(F.HardBreak, t, t + 2));
    if (e == 32) {
      let r = t + 1;
      for (; i.char(r) == 32; )
        r++;
      if (i.char(r) == 10 && r >= t + 2)
        return i.append(Se(F.HardBreak, t, r + 1));
    }
    return -1;
  },
  Link(i, e, t) {
    return e == 91 ? i.append(new Et(
      Nr,
      t,
      t + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(i, e, t) {
    return e == 33 && i.char(t + 1) == 91 ? i.append(new Et(
      Pu,
      t,
      t + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(i, e, t) {
    if (e != 93)
      return -1;
    for (let r = i.parts.length - 1; r >= 0; r--) {
      let s = i.parts[r];
      if (s instanceof Et && (s.type == Nr || s.type == Pu)) {
        if (!s.side || i.skipSpace(s.to) == t && !/[(\[]/.test(i.slice(t + 1, t + 2)))
          return i.parts[r] = null, -1;
        let n = i.takeContent(r), o = i.parts[r] = VA(i, n, s.type == Nr ? F.Link : F.Image, s.from, t + 1);
        if (s.type == Nr)
          for (let a = 0; a < r; a++) {
            let l = i.parts[a];
            l instanceof Et && l.type == Nr && (l.side = 0);
          }
        return o.to;
      }
    }
    return -1;
  }
};
function VA(i, e, t, r, s) {
  let { text: n } = i, o = i.char(s), a = s;
  if (e.unshift(Se(F.LinkMark, r, r + (t == F.Image ? 2 : 1))), e.push(Se(F.LinkMark, s - 1, s)), o == 40) {
    let l = i.skipSpace(s + 1), c = pb(n, l - i.offset, i.offset), h;
    c && (l = i.skipSpace(c.to), l != c.to && (h = gb(n, l - i.offset, i.offset), h && (l = i.skipSpace(h.to)))), i.char(l) == 41 && (e.push(Se(F.LinkMark, s, s + 1)), a = l + 1, c && e.push(c), h && e.push(h), e.push(Se(F.LinkMark, l, a)));
  } else if (o == 91) {
    let l = mb(n, s - i.offset, i.offset, !1);
    l && (e.push(l), a = l.to);
  }
  return Se(t, r, a, e);
}
function pb(i, e, t) {
  if (i.charCodeAt(e) == 60) {
    for (let s = e + 1; s < i.length; s++) {
      let n = i.charCodeAt(s);
      if (n == 62)
        return Se(F.URL, e + t, s + 1 + t);
      if (n == 60 || n == 10)
        return !1;
    }
    return null;
  } else {
    let s = 0, n = e;
    for (let o = !1; n < i.length; n++) {
      let a = i.charCodeAt(n);
      if (Zt(a))
        break;
      if (o)
        o = !1;
      else if (a == 40)
        s++;
      else if (a == 41) {
        if (!s)
          break;
        s--;
      } else a == 92 && (o = !0);
    }
    return n > e ? Se(F.URL, e + t, n + t) : n == i.length ? null : !1;
  }
}
function gb(i, e, t) {
  let r = i.charCodeAt(e);
  if (r != 39 && r != 34 && r != 40)
    return !1;
  let s = r == 40 ? 41 : r;
  for (let n = e + 1, o = !1; n < i.length; n++) {
    let a = i.charCodeAt(n);
    if (o)
      o = !1;
    else {
      if (a == s)
        return Se(F.LinkTitle, e + t, n + 1 + t);
      a == 92 && (o = !0);
    }
  }
  return null;
}
function mb(i, e, t, r) {
  for (let s = !1, n = e + 1, o = Math.min(i.length, n + 999); n < o; n++) {
    let a = i.charCodeAt(n);
    if (s)
      s = !1;
    else {
      if (a == 93)
        return r ? !1 : Se(F.LinkLabel, e + t, n + 1 + t);
      if (r && !Zt(a) && (r = !1), a == 91)
        return !1;
      a == 92 && (s = !0);
    }
  }
  return null;
}
class UA {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.parser = e, this.text = t, this.offset = r, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(e, t) {
    return this.text.slice(e - this.offset, t - this.offset);
  }
  /**
  @internal
  */
  append(e) {
    return this.parts.push(e), e.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(e, t, r, s, n) {
    return this.append(new Et(e, t, r, (s ? 1 : 0) | (n ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let t = this.parts[e];
      if (t instanceof Et && (t.type == Nr || t.type == Pu))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(e) {
    return this.append(e);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(e) {
    for (let r = e; r < this.parts.length; r++) {
      let s = this.parts[r];
      if (!(s instanceof Et && s.type.resolve && s.side & 2))
        continue;
      let n = s.type == db || s.type == Ob, o = s.to - s.from, a, l = r - 1;
      for (; l >= e; l--) {
        let S = this.parts[l];
        if (S instanceof Et && S.side & 1 && S.type == s.type && // Ignore emphasis delimiters where the character count doesn't match
        !(n && (s.side & 1 || S.side & 2) && (S.to - S.from + o) % 3 == 0 && ((S.to - S.from) % 3 || o % 3))) {
          a = S;
          break;
        }
      }
      if (!a)
        continue;
      let c = s.type.resolve, h = [], u = a.from, d = s.to;
      if (n) {
        let S = Math.min(2, a.to - a.from, o);
        u = a.to - S, d = s.from + S, c = S == 1 ? "Emphasis" : "StrongEmphasis";
      }
      a.type.mark && h.push(this.elt(a.type.mark, u, a.to));
      for (let S = l + 1; S < r; S++)
        this.parts[S] instanceof Zn && h.push(this.parts[S]), this.parts[S] = null;
      s.type.mark && h.push(this.elt(s.type.mark, s.from, d));
      let O = this.elt(c, u, d, h);
      this.parts[l] = n && a.from != u ? new Et(a.type, a.from, u, a.side) : null, (this.parts[r] = n && s.to != d ? new Et(s.type, d, s.to, s.side) : null) ? this.parts.splice(r, 0, O) : this.parts[r] = O;
    }
    let t = [];
    for (let r = e; r < this.parts.length; r++) {
      let s = this.parts[r];
      s instanceof Zn && t.push(s);
    }
    return t;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(e) {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let r = this.parts[t];
      if (r instanceof Et && r.type == e)
        return t;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(e) {
    let t = this.resolveMarkers(e);
    return this.parts.length = e, t;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(e) {
    return cn(this.text, e - this.offset) + this.offset;
  }
  elt(e, t, r, s) {
    return typeof e == "string" ? Se(this.parser.getNodeType(e), t, r, s) : new fb(e, t);
  }
}
function Tu(i, e) {
  if (!e.length)
    return i;
  if (!i.length)
    return e;
  let t = i.slice(), r = 0;
  for (let s of e) {
    for (; r < t.length && t[r].to < s.to; )
      r++;
    if (r < t.length && t[r].from < s.from) {
      let n = t[r];
      n instanceof Zn && (t[r] = new Zn(n.type, n.from, n.to, Tu(n.children, [s])));
    } else
      t.splice(r++, 0, s);
  }
  return t;
}
const jA = [F.CodeBlock, F.ListItem, F.OrderedList, F.BulletList];
class NA {
  constructor(e, t) {
    this.fragments = e, this.input = t, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, t) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let n = this.fragment.to;
      for (; n > 0 && this.input.read(n - 1, n) != `
`; )
        n--;
      this.fragmentEnd = n ? n - 1 : 0;
    }
    let r = this.cursor;
    r || (r = this.cursor = this.fragment.tree.cursor(), r.firstChild());
    let s = e + this.fragment.offset;
    for (; r.to <= s; )
      if (!r.parent())
        return !1;
    for (; ; ) {
      if (r.from >= s)
        return this.fragment.from <= t;
      if (!r.childAfter(s))
        return !1;
    }
  }
  matches(e) {
    let t = this.cursor.tree;
    return t && t.prop(le.contextHash) == e;
  }
  takeNodes(e) {
    let t = this.cursor, r = this.fragment.offset, s = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), n = e.absoluteLineStart, o = n, a = e.block.children.length, l = o, c = a;
    for (; ; ) {
      if (t.to - r > s) {
        if (t.type.isAnonymous && t.firstChild())
          continue;
        break;
      }
      let h = Sb(t.from - r, e.ranges);
      if (t.to - r <= e.ranges[e.rangeI].to)
        e.addNode(t.tree, h);
      else {
        let u = new we(e.parser.nodeSet.types[F.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(u, t.tree), e.addNode(u, h);
      }
      if (t.type.is("Block") && (jA.indexOf(t.type.id) < 0 ? (o = t.to - r, a = e.block.children.length) : (o = l, a = c, l = t.to - r, c = e.block.children.length)), !t.nextSibling())
        break;
    }
    for (; e.block.children.length > a; )
      e.block.children.pop(), e.block.positions.pop();
    return o - n;
  }
}
function Sb(i, e) {
  let t = i;
  for (let r = 1; r < e.length; r++) {
    let s = e[r - 1].to, n = e[r].from;
    s < i && (t -= n - s);
  }
  return t;
}
const YA = Jt({
  "Blockquote/...": C.quote,
  HorizontalRule: C.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": C.heading1,
  "ATXHeading2/... SetextHeading2/...": C.heading2,
  "ATXHeading3/...": C.heading3,
  "ATXHeading4/...": C.heading4,
  "ATXHeading5/...": C.heading5,
  "ATXHeading6/...": C.heading6,
  "Comment CommentBlock": C.comment,
  Escape: C.escape,
  Entity: C.character,
  "Emphasis/...": C.emphasis,
  "StrongEmphasis/...": C.strong,
  "Link/... Image/...": C.link,
  "OrderedList/... BulletList/...": C.list,
  "BlockQuote/...": C.quote,
  "InlineCode CodeText": C.monospace,
  "URL Autolink": C.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": C.processingInstruction,
  "CodeInfo LinkLabel": C.labelName,
  LinkTitle: C.string,
  Paragraph: C.content
}), FA = new ql(new lo(hb).extend(YA), Object.keys(Vo).map((i) => Vo[i]), Object.keys(Vo).map((i) => lb[i]), Object.keys(Vo), ZA, J_, Object.keys(Rc).map((i) => Rc[i]), Object.keys(Rc), []);
function HA(i, e, t) {
  let r = [];
  for (let s = i.firstChild, n = e; ; s = s.nextSibling) {
    let o = s ? s.from : t;
    if (o > n && r.push({ from: n, to: o }), !s)
      break;
    n = s.to;
  }
  return r;
}
function GA(i) {
  let { codeParser: e, htmlParser: t } = i;
  return { wrap: yv((s, n) => {
    let o = s.type.id;
    if (e && (o == F.CodeBlock || o == F.FencedCode)) {
      let a = "";
      if (o == F.FencedCode) {
        let c = s.node.getChild(F.CodeInfo);
        c && (a = n.read(c.from, c.to));
      }
      let l = e(a);
      if (l)
        return { parser: l, overlay: (c) => c.type.id == F.CodeText };
    } else if (t && (o == F.HTMLBlock || o == F.HTMLTag || o == F.CommentBlock))
      return { parser: t, overlay: HA(s.node, s.from, s.to) };
    return null;
  }) };
}
const KA = { resolve: "Strikethrough", mark: "StrikethroughMark" }, JA = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": C.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: C.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(i, e, t) {
      if (e != 126 || i.char(t + 1) != 126 || i.char(t + 2) == 126)
        return -1;
      let r = i.slice(t - 1, t), s = i.slice(t + 2, t + 3), n = /\s|^$/.test(r), o = /\s|^$/.test(s), a = Wn.test(r), l = Wn.test(s);
      return i.addDelimiter(KA, t, t + 2, !o && (!l || n || a), !n && (!a || o || l));
    },
    after: "Emphasis"
  }]
};
function hn(i, e, t = 0, r, s = 0) {
  let n = 0, o = !0, a = -1, l = -1, c = !1, h = () => {
    r.push(i.elt("TableCell", s + a, s + l, i.parser.parseInline(e.slice(a, l), s + a)));
  };
  for (let u = t; u < e.length; u++) {
    let d = e.charCodeAt(u);
    d == 124 && !c ? ((!o || a > -1) && n++, o = !1, r && (a > -1 && h(), r.push(i.elt("TableDelimiter", u + s, u + s + 1))), a = l = -1) : (c || d != 32 && d != 9) && (a < 0 && (a = u), l = u + 1), c = !c && d == 92;
  }
  return a > -1 && (n++, r && h()), n;
}
function dg(i, e) {
  for (let t = e; t < i.length; t++) {
    let r = i.charCodeAt(t);
    if (r == 124)
      return !0;
    r == 92 && t++;
  }
  return !1;
}
const vb = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class Og {
  constructor() {
    this.rows = null;
  }
  nextLine(e, t, r) {
    if (this.rows == null) {
      this.rows = !1;
      let s;
      if ((t.next == 45 || t.next == 58 || t.next == 124) && vb.test(s = t.text.slice(t.pos))) {
        let n = [];
        hn(e, r.content, 0, n, r.start) == hn(e, s, t.pos) && (this.rows = [
          e.elt("TableHeader", r.start, r.start + r.content.length, n),
          e.elt("TableDelimiter", e.lineStart + t.pos, e.lineStart + t.text.length)
        ]);
      }
    } else if (this.rows) {
      let s = [];
      hn(e, t.text, t.pos, s, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + t.pos, e.lineStart + t.text.length, s));
    }
    return !1;
  }
  finish(e, t) {
    return this.rows ? (e.addLeafElement(t, e.elt("Table", t.start, t.start + t.content.length, this.rows)), !0) : !1;
  }
}
const e5 = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": C.heading } },
    "TableRow",
    { name: "TableCell", style: C.content },
    { name: "TableDelimiter", style: C.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(i, e) {
      return dg(e.content, 0) ? new Og() : null;
    },
    endLeaf(i, e, t) {
      if (t.parsers.some((s) => s instanceof Og) || !dg(e.text, e.basePos))
        return !1;
      let r = i.peekLine();
      return vb.test(r) && hn(i, e.text, e.basePos) == hn(i, r, e.basePos);
    },
    before: "SetextHeading"
  }]
};
class t5 {
  nextLine() {
    return !1;
  }
  finish(e, t) {
    return e.addLeafElement(t, e.elt("Task", t.start, t.start + t.content.length, [
      e.elt("TaskMarker", t.start, t.start + 3),
      ...e.parser.parseInline(t.content.slice(3), t.start + 3)
    ])), !0;
  }
}
const i5 = {
  defineNodes: [
    { name: "Task", block: !0, style: C.list },
    { name: "TaskMarker", style: C.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(i, e) {
      return /^\[[ xX]\][ \t]/.test(e.content) && i.parentType().name == "ListItem" ? new t5() : null;
    },
    after: "SetextHeading"
  }]
}, pg = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, gg = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, r5 = /[\w-]+\.[\w-]+($|\/)/, mg = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, Sg = /\/[a-zA-Z\d@.]+/gy;
function vg(i, e, t, r) {
  let s = 0;
  for (let n = e; n < t; n++)
    i[n] == r && s++;
  return s;
}
function s5(i, e) {
  gg.lastIndex = e;
  let t = gg.exec(i);
  if (!t || r5.exec(t[0])[0].indexOf("_") > -1)
    return -1;
  let r = e + t[0].length;
  for (; ; ) {
    let s = i[r - 1], n;
    if (/[?!.,:*_~]/.test(s) || s == ")" && vg(i, e, r, ")") > vg(i, e, r, "("))
      r--;
    else if (s == ";" && (n = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(i.slice(e, r))))
      r = e + n.index;
    else
      break;
  }
  return r;
}
function _g(i, e) {
  mg.lastIndex = e;
  let t = mg.exec(i);
  if (!t)
    return -1;
  let r = t[0][t[0].length - 1];
  return r == "_" || r == "-" ? -1 : e + t[0].length - (r == "." ? 1 : 0);
}
const n5 = {
  parseInline: [{
    name: "Autolink",
    parse(i, e, t) {
      let r = t - i.offset;
      if (r && /\w/.test(i.text[r - 1]))
        return -1;
      pg.lastIndex = r;
      let s = pg.exec(i.text), n = -1;
      if (!s)
        return -1;
      if (s[1] || s[2]) {
        if (n = s5(i.text, r + s[0].length), n > -1 && i.hasOpenLink) {
          let o = /([^\[\]]|\[[^\]]*\])*/.exec(i.text.slice(r, n));
          n = r + o[0].length;
        }
      } else s[3] ? n = _g(i.text, r) : (n = _g(i.text, r + s[0].length), n > -1 && s[0] == "xmpp:" && (Sg.lastIndex = n, s = Sg.exec(i.text), s && (n = s.index + s[0].length)));
      return n < 0 ? -1 : (i.addElement(i.elt("URL", t, n + i.offset)), n + i.offset);
    }
  }]
}, o5 = [e5, i5, JA, n5];
function _b(i, e, t) {
  return (r, s, n) => {
    if (s != i || r.char(n + 1) == i)
      return -1;
    let o = [r.elt(t, n, n + 1)];
    for (let a = n + 1; a < r.end; a++) {
      let l = r.char(a);
      if (l == i)
        return r.addElement(r.elt(e, n, a + 1, o.concat(r.elt(t, a, a + 1))));
      if (l == 92 && o.push(r.elt("Escape", a, a++ + 2)), Zt(l))
        break;
    }
    return -1;
  };
}
const a5 = {
  defineNodes: [
    { name: "Superscript", style: C.special(C.content) },
    { name: "SuperscriptMark", style: C.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: _b(94, "Superscript", "SuperscriptMark")
  }]
}, l5 = {
  defineNodes: [
    { name: "Subscript", style: C.special(C.content) },
    { name: "SubscriptMark", style: C.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: _b(126, "Subscript", "SubscriptMark")
  }]
}, c5 = {
  defineNodes: [{ name: "Emoji", style: C.character }],
  parseInline: [{
    name: "Emoji",
    parse(i, e, t) {
      let r;
      return e != 58 || !(r = /^[a-zA-Z_0-9]+:/.exec(i.slice(t + 1, i.end))) ? -1 : i.addElement(i.elt("Emoji", t, t + 1 + r[0].length));
    }
  }]
}, h5 = 54, u5 = 1, f5 = 55, d5 = 2, O5 = 56, p5 = 3, bg = 4, g5 = 5, ll = 6, bb = 7, yb = 8, wb = 9, xb = 10, m5 = 11, S5 = 12, v5 = 13, Ec = 57, _5 = 14, yg = 58, kb = 20, b5 = 22, Cb = 23, y5 = 24, $u = 26, Qb = 27, w5 = 28, x5 = 31, k5 = 34, C5 = 36, Q5 = 37, P5 = 0, T5 = 1, $5 = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, R5 = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, wg = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function E5(i) {
  return i == 45 || i == 46 || i == 58 || i >= 65 && i <= 90 || i == 95 || i >= 97 && i <= 122 || i >= 161;
}
function Pb(i) {
  return i == 9 || i == 10 || i == 13 || i == 32;
}
let xg = null, kg = null, Cg = 0;
function Ru(i, e) {
  let t = i.pos + e;
  if (Cg == t && kg == i) return xg;
  let r = i.peek(e);
  for (; Pb(r); ) r = i.peek(++e);
  let s = "";
  for (; E5(r); )
    s += String.fromCharCode(r), r = i.peek(++e);
  return kg = i, Cg = t, xg = s ? s.toLowerCase() : r == A5 || r == L5 ? void 0 : null;
}
const Tb = 60, cl = 62, nd = 47, A5 = 63, L5 = 33, D5 = 45;
function Qg(i, e) {
  this.name = i, this.parent = e;
}
const M5 = [ll, xb, bb, yb, wb], B5 = new go({
  start: null,
  shift(i, e, t, r) {
    return M5.indexOf(e) > -1 ? new Qg(Ru(r, 1) || "", i) : i;
  },
  reduce(i, e) {
    return e == kb && i ? i.parent : i;
  },
  reuse(i, e, t, r) {
    let s = e.type.id;
    return s == ll || s == C5 ? new Qg(Ru(r, 1) || "", i) : i;
  },
  strict: !1
}), q5 = new qe((i, e) => {
  if (i.next != Tb) {
    i.next < 0 && e.context && i.acceptToken(Ec);
    return;
  }
  i.advance();
  let t = i.next == nd;
  t && i.advance();
  let r = Ru(i, 0);
  if (r === void 0) return;
  if (!r) return i.acceptToken(t ? _5 : ll);
  let s = e.context ? e.context.name : null;
  if (t) {
    if (r == s) return i.acceptToken(m5);
    if (s && R5[s]) return i.acceptToken(Ec, -2);
    if (e.dialectEnabled(P5)) return i.acceptToken(S5);
    for (let n = e.context; n; n = n.parent) if (n.name == r) return;
    i.acceptToken(v5);
  } else {
    if (r == "script") return i.acceptToken(bb);
    if (r == "style") return i.acceptToken(yb);
    if (r == "textarea") return i.acceptToken(wb);
    if ($5.hasOwnProperty(r)) return i.acceptToken(xb);
    s && wg[s] && wg[s][r] ? i.acceptToken(Ec, -1) : i.acceptToken(ll);
  }
}, { contextual: !0 }), X5 = new qe((i) => {
  for (let e = 0, t = 0; ; t++) {
    if (i.next < 0) {
      t && i.acceptToken(yg);
      break;
    }
    if (i.next == D5)
      e++;
    else if (i.next == cl && e >= 2) {
      t >= 3 && i.acceptToken(yg, -2);
      break;
    } else
      e = 0;
    i.advance();
  }
});
function I5(i) {
  for (; i; i = i.parent)
    if (i.name == "svg" || i.name == "math") return !0;
  return !1;
}
const Z5 = new qe((i, e) => {
  if (i.next == nd && i.peek(1) == cl) {
    let t = e.dialectEnabled(T5) || I5(e.context);
    i.acceptToken(t ? g5 : bg, 2);
  } else i.next == cl && i.acceptToken(bg, 1);
});
function od(i, e, t) {
  let r = 2 + i.length;
  return new qe((s) => {
    for (let n = 0, o = 0, a = 0; ; a++) {
      if (s.next < 0) {
        a && s.acceptToken(e);
        break;
      }
      if (n == 0 && s.next == Tb || n == 1 && s.next == nd || n >= 2 && n < r && s.next == i.charCodeAt(n - 2))
        n++, o++;
      else if ((n == 2 || n == r) && Pb(s.next))
        o++;
      else if (n == r && s.next == cl) {
        a > o ? s.acceptToken(e, -o) : s.acceptToken(t, -(o - 2));
        break;
      } else if ((s.next == 10 || s.next == 13) && a) {
        s.acceptToken(e, 1);
        break;
      } else
        n = o = 0;
      s.advance();
    }
  });
}
const W5 = od("script", h5, u5), z5 = od("style", f5, d5), V5 = od("textarea", O5, p5), U5 = Jt({
  "Text RawText": C.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": C.angleBracket,
  TagName: C.tagName,
  "MismatchedCloseTag/TagName": [C.tagName, C.invalid],
  AttributeName: C.attributeName,
  "AttributeValue UnquotedAttributeValue": C.attributeValue,
  Is: C.definitionOperator,
  "EntityReference CharacterReference": C.character,
  Comment: C.blockComment,
  ProcessingInst: C.processingInstruction,
  DoctypeDecl: C.documentMeta
}), j5 = Gt.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: B5,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [U5],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [W5, z5, V5, Z5, q5, X5, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function $b(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r of i.getChildren(Cb)) {
    let s = r.getChild(y5), n = r.getChild($u) || r.getChild(Qb);
    s && (t[e.read(s.from, s.to)] = n ? n.type.id == $u ? e.read(n.from + 1, n.to - 1) : e.read(n.from, n.to) : "");
  }
  return t;
}
function Pg(i, e) {
  let t = i.getChild(b5);
  return t ? e.read(t.from, t.to) : " ";
}
function Ac(i, e, t) {
  let r;
  for (let s of t)
    if (!s.attrs || s.attrs(r || (r = $b(i.node.parent.firstChild, e))))
      return { parser: s.parser };
  return null;
}
function Rb(i = [], e = []) {
  let t = [], r = [], s = [], n = [];
  for (let a of i)
    (a.tag == "script" ? t : a.tag == "style" ? r : a.tag == "textarea" ? s : n).push(a);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e) (o[a.name] || (o[a.name] = [])).push(a);
  return yv((a, l) => {
    let c = a.type.id;
    if (c == w5) return Ac(a, l, t);
    if (c == x5) return Ac(a, l, r);
    if (c == k5) return Ac(a, l, s);
    if (c == kb && n.length) {
      let h = a.node, u = h.firstChild, d = u && Pg(u, l), O;
      if (d) {
        for (let v of n)
          if (v.tag == d && (!v.attrs || v.attrs(O || (O = $b(u, l))))) {
            let S = h.lastChild, f = S.type.id == Q5 ? S.from : h.to;
            if (f > u.to)
              return { parser: v.parser, overlay: [{ from: u.to, to: f }] };
          }
      }
    }
    if (o && c == Cb) {
      let h = a.node, u;
      if (u = h.firstChild) {
        let d = o[l.read(u.from, u.to)];
        if (d) for (let O of d) {
          if (O.tagName && O.tagName != Pg(h.parent, l)) continue;
          let v = h.lastChild;
          if (v.type.id == $u) {
            let S = v.from + 1, f = v.lastChild, p = v.to - (f && f.isError ? 0 : 1);
            if (p > S) return { parser: O.parser, overlay: [{ from: S, to: p }] };
          } else if (v.type.id == Qb)
            return { parser: O.parser, overlay: [{ from: v.from, to: v.to }] };
        }
      }
    }
    return null;
  });
}
const N5 = 107, Tg = 1, Y5 = 108, F5 = 109, $g = 2, Rg = 110, Eb = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], H5 = 58, G5 = 40, Ab = 95, K5 = 91, da = 45, J5 = 46, eL = 35, tL = 37, iL = 38, rL = 92, sL = 10, nL = 42;
function zn(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 161;
}
function Lb(i) {
  return i >= 48 && i <= 57;
}
const oL = new qe((i, e) => {
  for (let t = !1, r = 0, s = 0; ; s++) {
    let { next: n } = i;
    if (zn(n) || n == da || n == Ab || t && Lb(n))
      !t && (n != da || s > 0) && (t = !0), r === s && n == da && r++, i.advance();
    else if (n == rL && i.peek(1) != sL)
      i.advance(), i.next > -1 && i.advance(), t = !0;
    else {
      t && i.acceptToken(
        r == 2 && e.canShift($g) ? $g : e.canShift(Rg) ? Rg : n == G5 ? Y5 : F5
      );
      break;
    }
  }
}), aL = new qe((i) => {
  if (Eb.includes(i.peek(-1))) {
    let { next: e } = i;
    (zn(e) || e == Ab || e == eL || e == J5 || e == nL || e == K5 || e == H5 && zn(i.peek(1)) || e == da || e == iL) && i.acceptToken(N5);
  }
}), lL = new qe((i) => {
  if (!Eb.includes(i.peek(-1))) {
    let { next: e } = i;
    if (e == tL && (i.advance(), i.acceptToken(Tg)), zn(e)) {
      do
        i.advance();
      while (zn(i.next) || Lb(i.next));
      i.acceptToken(Tg);
    }
  }
}), cL = Jt({
  "AtKeyword import charset namespace keyframes media supports": C.definitionKeyword,
  "from to selector": C.keyword,
  NamespaceName: C.namespace,
  KeyframeName: C.labelName,
  KeyframeRangeName: C.operatorKeyword,
  TagName: C.tagName,
  ClassName: C.className,
  PseudoClassName: C.constant(C.className),
  IdName: C.labelName,
  "FeatureName PropertyName": C.propertyName,
  AttributeName: C.attributeName,
  NumberLiteral: C.number,
  KeywordQuery: C.keyword,
  UnaryQueryOp: C.operatorKeyword,
  "CallTag ValueName": C.atom,
  VariableName: C.variableName,
  Callee: C.operatorKeyword,
  Unit: C.unit,
  "UniversalSelector NestingSelector": C.definitionOperator,
  "MatchOp CompareOp": C.compareOperator,
  "ChildOp SiblingOp, LogicOp": C.logicOperator,
  BinOp: C.arithmeticOperator,
  Important: C.modifier,
  Comment: C.blockComment,
  ColorLiteral: C.color,
  "ParenthesizedContent StringLiteral": C.string,
  ":": C.punctuation,
  "PseudoOp #": C.derefOperator,
  "; ,": C.separator,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace
}), hL = { __proto__: null, lang: 34, "nth-child": 34, "nth-last-child": 34, "nth-of-type": 34, "nth-last-of-type": 34, dir: 34, "host-context": 34, url: 62, "url-prefix": 62, domain: 62, regexp: 62 }, uL = { __proto__: null, "@import": 120, "@media": 154, "@charset": 158, "@namespace": 162, "@keyframes": 168, "@supports": 180 }, fL = { __proto__: null, layer: 124, not: 144, only: 144, selector: 150 }, dL = Gt.deserialize({
  version: 14,
  states: ">`QYQ[OOO#kQ[OOP#rOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#wQ[O'#CfO$hQXO'#CaO$rQ[O'#CiO$}Q[O'#DUO%SQ[O'#DXO%XQ[O'#D[O%XQ[O'#D_OOQP'#Ev'#EvO%yQdO'#DhO&hQ[O'#DzO%yQdO'#D|O&yQ[O'#EOO'UQ[O'#ERO'^Q[O'#EXO'lQ[O'#EZOOQS'#Eu'#EuOOQS'#E^'#E^QYQ[OOO'sQXO'#CdO(hQWO'#DdO(mQWO'#E{O(xQ[O'#E{QOQWOOP)SO#tO'#C_POOO)C@e)C@eOOQP'#Ch'#ChOOQP,59Q,59QO#wQ[O,59QO)_Q[O,59TO$}Q[O,59pO%SQ[O,59sO%XQ[O,59vO%XQ[O,59xO%XQ[O,59yO%XQ[O'#EcO)jQWO,58{O)rQ[O'#DcOOQS,58{,58{OOQP'#Cl'#ClOOQO'#DS'#DSOOQP,59T,59TO)yQWO,59TO*OQWO,59TOOQP'#DW'#DWOOQP,59p,59pOOQO'#DY'#DYO*TQ`O,59sO*nQXO,59vO+UQXO,59yOOQS'#Cq'#CqO%yQdO'#CrO+lQvO'#CtO-hQtO,5:SOOQO'#Cy'#CyO*OQWO'#CxO-rQWO'#CzO-wQ[O'#DPOOQS'#Ex'#ExOOQO'#Dn'#DnO.eQdO'#DwO.uQWO'#E|O'^Q[O'#DuO/TQWO'#DxOOQO'#E}'#E}O)mQWO,5:fO/YQpO,5:hOOQS'#EQ'#EQO/bQWO,5:jO/gQ[O,5:jOOQO'#ET'#ETO/oQWO,5:mO/tQWO,5:sO/|QWO,5:uOOQS-E8[-E8[O0UQdO,5:OO0fQ[O'#EeO0sQWO,5;gO0sQWO,5;gPOOO'#E]'#E]P1OO#tO,58yPOOO,58y,58yOOQP1G.l1G.lOOQP1G.o1G.oO)yQWO1G.oO*OQWO1G.oOOQP1G/[1G/[O1ZQ`O1G/_O1cQXO1G/bO1yQXO1G/dO2aQXO1G/eO2wQXO,5:}OOQO-E8a-E8aOOQS1G.g1G.gO3RQWO,59}O3WQ[O'#DTO3_QdO'#CpOOQP1G/_1G/_O%yQdO1G/_O3fQpO,59^OOQS,59`,59`O%yQdO,59bO3nQ[O'#DkO4PQWO1G/nO-VQ[O1G/nOOQS,59d,59dO4UQ!bO,59fOOQS'#DQ'#DQOOQS'#E`'#E`O4aQ[O,59kOOQS,59k,59kO4iQpO'#DnO4wQpO,5:ZO5PQWO,5:cOOQO'#FO'#FOO4zQpO,5:_O'^Q[O,5:]O5XQ[O'#EgO5pQWO,5;hO5{QWO,5:aO%XQ[O,5:dOOQS1G0Q1G0QOOQS1G0S1G0SOOQS1G0U1G0UO6^QWO1G0UO6cQdO'#EUOOQS1G0X1G0XOOQS1G0_1G0_OOQS1G0a1G0aO6nQtO1G/jOOQO1G/j1G/jOOQO,5;P,5;PO7UQ[O,5;POOQO-E8c-E8cO7cQWO1G1RPOOO-E8Z-E8ZPOOO1G.e1G.eOOQP7+$Z7+$ZOOQP7+$y7+$yO%yQdO7+$yOOQS1G/i1G/iO7nQXO'#EzO7xQWO,59oO7}QtO'#E_O8uQdO'#EwO9PQWO,59[O9UQpO7+$yOOQS1G.x1G.xOOQS1G.|1G.|O9^Q[O,5:VOOQS7+%Y7+%YO9cQWO7+%YOOQS1G/Q1G/QO9hQWO1G/QOOQS-E8^-E8^OOQS1G/V1G/VO%yQdO1G/uO9mQdO1G/yOOQO1G/}1G/}OOQO1G/w1G/wO9tQWO,5;ROOQO-E8e-E8eO:SQXO1G0OOOQS7+%p7+%pO:ZQYO'#CtOOQO'#EW'#EWO:iQ`O'#EVOOQO'#EV'#EVO:tQWO'#EhO:|QdO,5:pOOQS,5:p,5:pO;XQtO'#EdO%yQdO'#EdO<YQdO7+%UOOQO7+%U7+%UOOQO1G0k1G0kO<mQpO<<HeO<uQ[O'#EbO=PQWO,5;fOOQP1G/Z1G/ZOOQS-E8]-E8]O=XQdO'#EaO=cQWO,5;cOOQT1G.v1G.vOOQP<<He<<HeOOQO'#Dm'#DmO=kQWO1G/qOOQS<<Ht<<HtOOQS7+$l7+$lO=sQdO7+%aOOQO'#Dp'#DpO=zQpO7+%eOOQO7+%j7+%jOOQO,5:q,5:qO6fQdO'#EiO:tQWO,5;SOOQS,5;S,5;SOOQS-E8f-E8fOOQS1G0[1G0[O>SQtO,5;OOOQS-E8b-E8bOOQO<<Hp<<HpOOQPAN>PAN>PO?TQXO,5:|OOQO-E8`-E8`O?_QdO,5:{OOQO-E8_-E8_O9^Q[O'#EfO?iQWO7+%]OOQS7+%]7+%]OOQO<<H{<<H{OOQO<<IP<<IPO?qQdO<<IPOOQO,5;T,5;TOOQO-E8g-E8gOOQS1G0n1G0nOOQO,5;Q,5;QOOQO-E8d-E8dOOQS<<Hw<<HwO@YQWOAN>kOOQOG24VG24V",
  stateData: "@g~O#dOS#eQQ~OU[OX[OZTO^VO_VOrXOyWO!PYO!SZO!]cO!^]O!o^O!q_O!s`O!vaO!|bO#aRO~OQhOU[OX[OZTO^VO_VOrXOyWO!PYO!SZO!]cO!^]O!o^O!q_O!s`O!vaO!|bO#agO~O#^#oP~P!aO#elO~O#anO~OZpO^qO_qOrsOyrO!PtO!SvO#_uO~OuwO!UyO~P#|Oa!PO#`|O#a{O~O#a!QO~O#a!SO~OU[OX[OZTO^VO_VOrXOyWO!PYO!SZO#aRO~OQ!`Oc!XOg!`Oi!`Oo!^Or!_O#`![O#a!WO#m!YO~Oc!bO!j!dO!m!eO#b!aO!U#pP~Oi!jOo!^O#a!iO~Oi!lO#a!lO~Oc!bO!j!dO!m!eO#b!aO~O!Z#pP~P&hOZWX^WX^!XX_WXrWXuWXyWX!PWX!SWX!UWX#_WX~O^!qO~O!Z!rO#^#oX!T#oX~O#^#oX!T#oX~P!aO#f!uO#g!uO#h!wO~Oa!{O#`|O#a{O~OuwO!UyO~O!T#oP~P!aOc#VO~Oc#WO~Oq#XO}#YO~OZpO^qO_qOrsOyrO~Ou!Oa!P!Oa!S!Oa!U!Oa#_!Oab!Oa~P*]Ou!Ra!P!Ra!S!Ra!U!Ra#_!Rab!Ra~P*]OP#[OchXkhX!ZhX!`hX!jhX!mhX#bhXbhX!hhXQhXghXihXohXrhXuhX!YhX#^hX#`hX#ahX#mhXqhX!ThX~Oc!bO!j!dO!m!eO#b!aO!Z#pP~Ok#]O!`#^O~P-VOc#bO~Oq#fO#a#cO~OQ#jOg#jOi#jOo!^O#`![O#m!YO~Oc!bO!j!dO!m!eO#b#gO~P.POu#mO!f#lO!U#pX!Z#pX~Oc#pO~Ok#]O!Z#rO~O!Z#sO~Oi#tOo!^O~O!U#uO~O!UyO!f#lO~O!UyO!Z#xO~O!Y#zO!Z!Wa#^!Wa!T!Wa~P%yO!Z#XX#^#XX!T#XX~P!aO!Z!rO#^#oa!T#oa~O#f!uO#g!uO#h$QO~Oq$SO}$TO~Ou!Oi!P!Oi!S!Oi!U!Oi#_!Oib!Oi~P*]Ou!Qi!P!Qi!S!Qi!U!Qi#_!Qib!Qi~P*]Ou!Ri!P!Ri!S!Ri!U!Ri#_!Rib!Ri~P*]Ou#Va!U#Va~P#|O!T$UO~Ob#nP~P%XOb#kP~P%yOb$]Ok#]O~Oc$_O!Z!_X!j!_X!m!_X#b!_X~O!Z$`O~Ob$bOi$cOp$cO~Oq$eO#a#cO~O^!dXb!bX!f!bX!h!dX~O^$fO!h$gO~Ob$hO!f#lO~Oc!bO!j!dO!m!eO#b!aOu#ZX!U#ZX!Z#ZX~Ou#mO!U#pa!Z#pa~O!f#lOu!ia!U!ia!Z!iab!ia~O!Z$mO~O!T$tO#a$oO#m$nO~Ok#]Ou$vO!Y$xO!Z!Wi#^!Wi!T!Wi~P%yO!Z#Xa#^#Xa!T#Xa~P!aO!Z!rO#^#oi!T#oi~Ou${Ob#nX~P#|Ob$}O~Ok#]OQ#RXb#RXc#RXg#RXi#RXo#RXr#RXu#RX#`#RX#a#RX#m#RX~Ou%POb#kX~P%yOb%RO~Ok#]Oq%SO~O#a%TO~O!Z%VO~Ob%WO~O#b%YO~P.PO!f#lOu#Za!U#Za!Z#Za~Ob%[O~P#|OP#[OuhX!UhXbhX~O#m$nOu!yX!U!yX~Ou%^O!UyO~O!T%bO#a$oO#m$nO~Ok#]OQ#WXc#WXg#WXi#WXo#WXr#WXu#WX!Y#WX!Z#WX#^#WX#`#WX#a#WX#m#WX!T#WX~Ou$vO!Y%eO!Z!Wq#^!Wq!T!Wq~P%yOk#]Oq%fO~Ob#UXu#UX~P%XOu${Ob#na~Ob#TXu#TX~P%yOu%POb#ka~OZ%kOb%mO~Ob%nO~P%yOb%oO!h%pO~Ok#]OQ#Wac#Wag#Wai#Wao#War#Wau#Wa!Y#Wa!Z#Wa#^#Wa#`#Wa#a#Wa#m#Wa!T#Wa~Ob#Uau#Ua~P#|Ob#Tau#Ta~P%yOZ%kOb%vO~OQ#jOg#jOi#jOo!^O#`![O#b%YO#m$nO~Ob%xO~O#dp#e#mk!S#m~",
  goto: "/l#sPPP#tP#wP$Q$dP$QP$v$QPP$|PPP%S%]%]P%oP%]P&`&w'^PPPP%]'{P(P(V$QP(]$Q(cP$QP$Q$QPPP(i)O)]PP#wPP)dP)g)m)m)x)mP)mP)mP)m)mP#wP#wP#wP*R#wP*U*X*[*c#wP#wP*h*n*}+]+c+i+o+u+{,V,],c,iPPPPPPPPPPP,o,x-n-qP.g.j.p.|/cRmQ_dOPfjy!r#|q[OPYZfjtuvwy!r#V#p#|${qSOPYZfjtuvwy!r#V#p#|${QoTR!xpQ}VR!yqQ!y!PQ#a!]R$R!{q!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%ip!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iU#j!b$g%pU$q#u$s%^R%]$pp!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iV#j!b$g%pw!]]_!X!b!q#W#Y#]#y$T$Y$f$g$v$w%P%X%i%pp!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iQ!j`U#j!b$g%pR#t!kT#d!_#eQ!OVR!zqQ!y!OR$R!zQ!RWR!|rQ!TXR!}sQzUQ#TxQ#q!gQ#w!nQ#x!oQ%`$rR%s%_SiPyQ!tjQ#{!rR$y#|ZhPjy!r#|R#`!ZQ%U$_R%t%kc!f^bc!Z!b!d#`#l#mQ#h!bQ%Z$gR%w%pR!k`R!maR#v!mS$r#u$sR%q%^V$p#u$s%^Q!vlR$P!vQfOSjPyU!pfj#|R#|!rQ$Y#WU%O$Y%X%iQ%X$fR%i%PQ#e!_R$d#eQ%Q$YR%j%QQ$|$VR%h$|QxUR#SxQ$w#yR%d$wQ!siS#}!s$OR$O!tQ%l%UR%u%lQ#n!cR$k#nQ$s#uR%a$sQ%_$rR%r%__eOPfjy!r#|^UOPfjy!r#|Q!UYQ!VZQ#OtQ#PuQ#QvQ#RwQ$V#VQ$l#pR%g${R$Z#WQ!Z]Q!h_Q#Z!XQ#y!q[$X#W$Y$f%P%X%iQ$[#YQ$^#]S$u#y$wQ$z$TR%c$vR$W#VQkPR#UyQ!g^Q!ocQ#_!ZR$a#`W!c^c!Z#`Q!nbQ#i!bQ#o!dQ$i#lR$j#mQ#k!bQ%Z$gR%w%p",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import Layer layer LayerName KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 126,
  nodeProps: [
    ["isolate", -2, 3, 25, ""],
    ["openedBy", 18, "(", 33, "[", 51, "{"],
    ["closedBy", 19, ")", 34, "]", 52, "}"]
  ],
  propSources: [cL],
  skippedNodes: [0, 3, 93],
  repeatNodeCount: 13,
  tokenData: "LU~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_Cj!_!`Df!`!aDy!a!b$}!b!cEz!c!}$}!}#OHX#O#P$}#P#QHj#Q#R6d#R#T$}#T#UH{#U#c$}#c#dJ^#d#o$}#o#pJs#p#q6d#q#rKU#r#sKg#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`LO<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSp`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#d~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#d~p`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUp`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Up`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUp`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Up`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUp`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Up`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUp`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Up`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!Y[p`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOi~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYyQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYp`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYp`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYg[p`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYg[p`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYp`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYg[p`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYp`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSg[p`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS}Sp`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSc^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOb~n9{UUQkWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWkW!SQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUp`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYp`#m[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYp`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUp`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUp`#m[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[p`#m[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSu^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWkWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VUZQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTkWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSp`#e~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#m[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^jBbU^YOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S_Qp`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Z^Oy%^z;'S%^;'S;=`%o<%lO%^hCoU!hWOy%^z!_%^!_!`DR!`;'S%^;'S;=`%o<%lO%^hDYS!hWp`Oy%^z;'S%^;'S;=`%o<%lO%^lDmS!hW}SOy%^z;'S%^;'S;=`%o<%lO%^jEQV!PQ!hWOy%^z!_%^!_!`DR!`!aEg!a;'S%^;'S;=`%o<%lO%^bEnS!PQp`Oy%^z;'S%^;'S;=`%o<%lO%^bE}YOy%^z}%^}!OFm!O!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^bFrWp`Oy%^z!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^bGc[!]Qp`Oy%^z}%^}!OG[!O!Q%^!Q![G[![!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^nH^Sr^Oy%^z;'S%^;'S;=`%o<%lO%^nHoSq^Oy%^z;'S%^;'S;=`%o<%lO%^jIOUOy%^z#b%^#b#cIb#c;'S%^;'S;=`%o<%lO%^jIgUp`Oy%^z#W%^#W#XIy#X;'S%^;'S;=`%o<%lO%^jJQS!fYp`Oy%^z;'S%^;'S;=`%o<%lO%^jJaUOy%^z#f%^#f#gIy#g;'S%^;'S;=`%o<%lO%^fJxS!UUOy%^z;'S%^;'S;=`%o<%lO%^nKZS!T^Oy%^z;'S%^;'S;=`%o<%lO%^fKlU!SQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`LRP;=`<%l$}",
  tokenizers: [aL, lL, oL, 1, 2, 3, 4, new ol("m~RRYZ[z{a~~g~aO#g~~dP!P!Qg~lO#h~~", 28, 114)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 92] },
  specialized: [{ term: 108, get: (i) => hL[i] || -1 }, { term: 59, get: (i) => uL[i] || -1 }, { term: 110, get: (i) => fL[i] || -1 }],
  tokenPrec: 1441
});
let Lc = null;
function Dc() {
  if (!Lc && typeof document == "object" && document.body) {
    let { style: i } = document.body, e = [], t = /* @__PURE__ */ new Set();
    for (let r in i)
      r != "cssText" && r != "cssFloat" && typeof i[r] == "string" && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase())), t.has(r) || (e.push(r), t.add(r)));
    Lc = e.sort().map((r) => ({ type: "property", label: r, apply: r + ": " }));
  }
  return Lc || [];
}
const Eg = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((i) => ({ type: "class", label: i })), Ag = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((i) => ({ type: "keyword", label: i })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((i) => ({ type: "constant", label: i }))), OL = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((i) => ({ type: "type", label: i })), pL = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((i) => ({ type: "keyword", label: i })), xi = /^(\w[\w-]*|-\w[\w-]*|)$/, gL = /^-(-[\w-]*)?$/;
function mL(i, e) {
  var t;
  if ((i.name == "(" || i.type.isError) && (i = i.parent || i), i.name != "ArgList")
    return !1;
  let r = (t = i.parent) === null || t === void 0 ? void 0 : t.firstChild;
  return r?.name != "Callee" ? !1 : e.sliceString(r.from, r.to) == "var";
}
const Lg = /* @__PURE__ */ new Ef(), SL = ["Declaration"];
function vL(i) {
  for (let e = i; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return i;
  }
}
function Db(i, e, t) {
  if (e.to - e.from > 4096) {
    let r = Lg.get(e);
    if (r)
      return r;
    let s = [], n = /* @__PURE__ */ new Set(), o = e.cursor(Pe.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let a of Db(i, o.node, t))
          n.has(a.label) || (n.add(a.label), s.push(a));
      while (o.nextSibling());
    return Lg.set(e, s), s;
  } else {
    let r = [], s = /* @__PURE__ */ new Set();
    return e.cursor().iterate((n) => {
      var o;
      if (t(n) && n.matchContext(SL) && ((o = n.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let a = i.sliceString(n.from, n.to);
        s.has(a) || (s.add(a), r.push({ label: a, type: "variable" }));
      }
    }), r;
  }
}
const _L = (i) => (e) => {
  let { state: t, pos: r } = e, s = xe(t).resolveInner(r, -1), n = s.type.isError && s.from == s.to - 1 && t.doc.sliceString(s.from, s.to) == "-";
  if (s.name == "PropertyName" || (n || s.name == "TagName") && /^(Block|Styles)$/.test(s.resolve(s.to).name))
    return { from: s.from, options: Dc(), validFor: xi };
  if (s.name == "ValueName")
    return { from: s.from, options: Ag, validFor: xi };
  if (s.name == "PseudoClassName")
    return { from: s.from, options: Eg, validFor: xi };
  if (i(s) || (e.explicit || n) && mL(s, t.doc))
    return {
      from: i(s) || n ? s.from : r,
      options: Db(t.doc, vL(s), i),
      validFor: gL
    };
  if (s.name == "TagName") {
    for (let { parent: l } = s; l; l = l.parent)
      if (l.name == "Block")
        return { from: s.from, options: Dc(), validFor: xi };
    return { from: s.from, options: OL, validFor: xi };
  }
  if (s.name == "AtKeyword")
    return { from: s.from, options: pL, validFor: xi };
  if (!e.explicit)
    return null;
  let o = s.resolve(r), a = o.childBefore(r);
  return a && a.name == ":" && o.name == "PseudoClassSelector" ? { from: r, options: Eg, validFor: xi } : a && a.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: r, options: Ag, validFor: xi } : o.name == "Block" || o.name == "Styles" ? { from: r, options: Dc(), validFor: xi } : null;
}, bL = /* @__PURE__ */ _L((i) => i.name == "VariableName"), hl = /* @__PURE__ */ Ht.define({
  name: "css",
  parser: /* @__PURE__ */ dL.configure({
    props: [
      /* @__PURE__ */ bi.add({
        Declaration: /* @__PURE__ */ Cr()
      }),
      /* @__PURE__ */ ei.add({
        "Block KeyframeList": ho
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Mb() {
  return new Si(hl, hl.data.of({ autocomplete: bL }));
}
const Us = ["_blank", "_self", "_top", "_parent"], Mc = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Bc = ["get", "post", "put", "delete"], qc = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ct = ["true", "false"], oe = {}, yL = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Us,
      hreflang: null
    }
  },
  abbr: oe,
  address: oe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: oe,
  aside: oe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: oe,
  base: { attrs: { href: null, target: Us } },
  bdi: oe,
  bdo: oe,
  blockquote: { attrs: { cite: null } },
  body: oe,
  br: oe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: qc,
      formmethod: Bc,
      formnovalidate: ["novalidate"],
      formtarget: Us,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: oe,
  center: oe,
  cite: oe,
  code: oe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: oe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: oe,
  div: oe,
  dl: oe,
  dt: oe,
  em: oe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: oe,
  figure: oe,
  footer: oe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Mc,
      autocomplete: ["on", "off"],
      enctype: qc,
      method: Bc,
      novalidate: ["novalidate"],
      target: Us
    }
  },
  h1: oe,
  h2: oe,
  h3: oe,
  h4: oe,
  h5: oe,
  h6: oe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: oe,
  hgroup: oe,
  hr: oe,
  html: {
    attrs: { manifest: null }
  },
  i: oe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: qc,
      formmethod: Bc,
      formnovalidate: ["novalidate"],
      formtarget: Us,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: oe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: oe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: oe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Mc,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: oe,
  noscript: oe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: oe,
  param: { attrs: { name: null, value: null } },
  pre: oe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: oe,
  rt: oe,
  ruby: oe,
  samp: oe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Mc
    }
  },
  section: oe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: oe,
  source: { attrs: { src: null, type: null, media: null } },
  span: oe,
  strong: oe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: oe,
  summary: oe,
  sup: oe,
  table: oe,
  tbody: oe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: oe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: oe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: oe,
  time: { attrs: { datetime: null } },
  title: oe,
  tr: oe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: oe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: oe
}, Bb = {
  accesskey: null,
  class: null,
  contenteditable: Ct,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ct,
  autocorrect: Ct,
  autocapitalize: Ct,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ct,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ct,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ct,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ct,
  "aria-hidden": Ct,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ct,
  "aria-multiselectable": Ct,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ct,
  "aria-relevant": null,
  "aria-required": Ct,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, qb = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((i) => "on" + i);
for (let i of qb)
  Bb[i] = null;
class Vn {
  constructor(e, t) {
    this.tags = Object.assign(Object.assign({}, yL), e), this.globalAttrs = Object.assign(Object.assign({}, Bb), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Vn.default = /* @__PURE__ */ new Vn();
function Ss(i, e, t = i.length) {
  if (!e)
    return "";
  let r = e.firstChild, s = r && r.getChild("TagName");
  return s ? i.sliceString(s.from, Math.min(s.to, t)) : "";
}
function vs(i, e = !1) {
  for (; i; i = i.parent)
    if (i.name == "Element")
      if (e)
        e = !1;
      else
        return i;
  return null;
}
function Xb(i, e, t) {
  let r = t.tags[Ss(i, vs(e))];
  return r?.children || t.allTags;
}
function ad(i, e) {
  let t = [];
  for (let r = vs(e); r && !r.type.isTop; r = vs(r.parent)) {
    let s = Ss(i, r);
    if (s && r.lastChild.name == "CloseTag")
      break;
    s && t.indexOf(s) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && t.push(s);
  }
  return t;
}
const Ib = /^[:\-\.\w\u00b7-\uffff]*$/;
function Dg(i, e, t, r, s) {
  let n = /\s*>/.test(i.sliceDoc(s, s + 5)) ? "" : ">", o = vs(t, !0);
  return {
    from: r,
    to: s,
    options: Xb(i.doc, o, e).map((a) => ({ label: a, type: "type" })).concat(ad(i.doc, t).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + n,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Mg(i, e, t, r) {
  let s = /\s*>/.test(i.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: t,
    to: r,
    options: ad(i.doc, e).map((n, o) => ({ label: n, apply: n + s, type: "type", boost: 99 - o })),
    validFor: Ib
  };
}
function wL(i, e, t, r) {
  let s = [], n = 0;
  for (let o of Xb(i.doc, t, e))
    s.push({ label: "<" + o, type: "type" });
  for (let o of ad(i.doc, t))
    s.push({ label: "</" + o + ">", type: "type", boost: 99 - n++ });
  return { from: r, to: r, options: s, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function xL(i, e, t, r, s) {
  let n = vs(t), o = n ? e.tags[Ss(i.doc, n)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: r,
    to: s,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: Ib
  };
}
function kL(i, e, t, r, s) {
  var n;
  let o = (n = t.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), a = [], l;
  if (o) {
    let c = i.sliceDoc(o.from, o.to), h = e.globalAttrs[c];
    if (!h) {
      let u = vs(t), d = u ? e.tags[Ss(i.doc, u)] : null;
      h = d?.attrs && d.attrs[c];
    }
    if (h) {
      let u = i.sliceDoc(r, s).toLowerCase(), d = '"', O = '"';
      /^['"]/.test(u) ? (l = u[0] == '"' ? /^[^"]*$/ : /^[^']*$/, d = "", O = i.sliceDoc(s, s + 1) == u[0] ? "" : u[0], u = u.slice(1), r++) : l = /^[^\s<>='"]*$/;
      for (let v of h)
        a.push({ label: v, apply: d + v + O, type: "constant" });
    }
  }
  return { from: r, to: s, options: a, validFor: l };
}
function Zb(i, e) {
  let { state: t, pos: r } = e, s = xe(t).resolveInner(r, -1), n = s.resolve(r);
  for (let o = r, a; n == s && (a = s.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    n = s = a, o = l.from;
  }
  return s.name == "TagName" ? s.parent && /CloseTag$/.test(s.parent.name) ? Mg(t, s, s.from, r) : Dg(t, i, s, s.from, r) : s.name == "StartTag" ? Dg(t, i, s, r, r) : s.name == "StartCloseTag" || s.name == "IncompleteCloseTag" ? Mg(t, s, r, r) : s.name == "OpenTag" || s.name == "SelfClosingTag" || s.name == "AttributeName" ? xL(t, i, s, s.name == "AttributeName" ? s.from : r, r) : s.name == "Is" || s.name == "AttributeValue" || s.name == "UnquotedAttributeValue" ? kL(t, i, s, s.name == "Is" ? r : s.from, r) : e.explicit && (n.name == "Element" || n.name == "Text" || n.name == "Document") ? wL(t, i, s, r) : null;
}
function CL(i) {
  return Zb(Vn.default, i);
}
function QL(i) {
  let { extraTags: e, extraGlobalAttributes: t } = i, r = t || e ? new Vn(e, t) : Vn.default;
  return (s) => Zb(r, s);
}
const PL = /* @__PURE__ */ gi.parser.configure({ top: "SingleExpression" }), Wb = [
  {
    tag: "script",
    attrs: (i) => i.type == "text/typescript" || i.lang == "ts",
    parser: N_.parser
  },
  {
    tag: "script",
    attrs: (i) => i.type == "text/babel" || i.type == "text/jsx",
    parser: Y_.parser
  },
  {
    tag: "script",
    attrs: (i) => i.type == "text/typescript-jsx",
    parser: F_.parser
  },
  {
    tag: "script",
    attrs(i) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(i.type);
    },
    parser: PL
  },
  {
    tag: "script",
    attrs(i) {
      return !i.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(i.type);
    },
    parser: gi.parser
  },
  {
    tag: "style",
    attrs(i) {
      return (!i.lang || i.lang == "css") && (!i.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(i.type));
    },
    parser: hl.parser
  }
], zb = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ hl.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ qb.map((i) => ({ name: i, parser: gi.parser }))), Vb = /* @__PURE__ */ Ht.define({
  name: "html",
  parser: /* @__PURE__ */ j5.configure({
    props: [
      /* @__PURE__ */ bi.add({
        Element(i) {
          let e = /^(\s*)(<\/)?/.exec(i.textAfter);
          return i.node.to <= i.pos + e[0].length ? i.continue() : i.lineIndent(i.node.from) + (e[2] ? 0 : i.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        },
        Document(i) {
          if (i.pos + /\s*/.exec(i.textAfter)[0].length < i.node.to)
            return i.continue();
          let e = null, t;
          for (let r = i.node; ; ) {
            let s = r.lastChild;
            if (!s || s.name != "Element" || s.to != r.to)
              break;
            e = r = s;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? i.lineIndent(e.from) + i.unit : null;
        }
      }),
      /* @__PURE__ */ ei.add({
        Element(i) {
          let e = i.firstChild, t = i.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : i.to };
        }
      }),
      /* @__PURE__ */ qf.add({
        "OpenTag CloseTag": (i) => i.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), Oa = /* @__PURE__ */ Vb.configure({
  wrap: /* @__PURE__ */ Rb(Wb, zb)
});
function Ub(i = {}) {
  let e = "", t;
  i.matchClosingTags === !1 && (e = "noMatch"), i.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (i.nestedLanguages && i.nestedLanguages.length || i.nestedAttributes && i.nestedAttributes.length) && (t = Rb((i.nestedLanguages || []).concat(Wb), (i.nestedAttributes || []).concat(zb)));
  let r = t ? Vb.configure({ wrap: t, dialect: e }) : e ? Oa.configure({ dialect: e }) : Oa;
  return new Si(r, [
    Oa.data.of({ autocomplete: QL(i) }),
    i.autoCloseTags !== !1 ? TL : [],
    K_().support,
    Mb().support
  ]);
}
const Bg = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), TL = /* @__PURE__ */ K.inputHandler.of((i, e, t, r, s) => {
  if (i.composing || i.state.readOnly || e != t || r != ">" && r != "/" || !Oa.isActiveAt(i.state, e, -1))
    return !1;
  let n = s(), { state: o } = n, a = o.changeByRange((l) => {
    var c, h, u;
    let d = o.doc.sliceString(l.from - 1, l.to) == r, { head: O } = l, v = xe(o).resolveInner(O, -1), S;
    if (d && r == ">" && v.name == "EndTag") {
      let f = v.parent;
      if (((h = (c = f.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (S = Ss(o.doc, f.parent, O)) && !Bg.has(S)) {
        let p = O + (o.doc.sliceString(O, O + 1) === ">" ? 1 : 0), g = `</${S}>`;
        return { range: l, changes: { from: O, to: p, insert: g } };
      }
    } else if (d && r == "/" && v.name == "IncompleteCloseTag") {
      let f = v.parent;
      if (v.from == O - 2 && ((u = f.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (S = Ss(o.doc, f, O)) && !Bg.has(S)) {
        let p = O + (o.doc.sliceString(O, O + 1) === ">" ? 1 : 0), g = `${S}>`;
        return {
          range: V.cursor(O + g.length, -1),
          changes: { from: O, to: p, insert: g }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    n,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), jb = /* @__PURE__ */ Lf({ commentTokens: { block: { open: "<!--", close: "-->" } } }), Nb = /* @__PURE__ */ new le(), Yb = /* @__PURE__ */ FA.configure({
  props: [
    /* @__PURE__ */ ei.add((i) => !i.is("Block") || i.is("Document") || Eu(i) != null || $L(i) ? void 0 : (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })),
    /* @__PURE__ */ Nb.add(Eu),
    /* @__PURE__ */ bi.add({
      Document: () => null
    }),
    /* @__PURE__ */ br.add({
      Document: jb
    })
  ]
});
function Eu(i) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(i.name);
  return e ? +e[1] : void 0;
}
function $L(i) {
  return i.name == "OrderedList" || i.name == "BulletList";
}
function RL(i, e) {
  let t = i;
  for (; ; ) {
    let r = t.nextSibling, s;
    if (!r || (s = Eu(r.type)) != null && s <= e)
      break;
    t = r;
  }
  return t.to;
}
const EL = /* @__PURE__ */ Pv.of((i, e, t) => {
  for (let r = xe(i).resolveInner(t, -1); r && !(r.from < e); r = r.parent) {
    let s = r.type.prop(Nb);
    if (s == null)
      continue;
    let n = RL(r, s);
    if (n > t)
      return { from: t, to: n };
  }
  return null;
});
function ld(i) {
  return new Dt(jb, i, [EL], "markdown");
}
const AL = /* @__PURE__ */ ld(Yb), LL = /* @__PURE__ */ Yb.configure([o5, l5, a5, c5, {
  props: [
    /* @__PURE__ */ ei.add({
      Table: (i, e) => ({ from: e.doc.lineAt(i.from).to, to: i.to })
    })
  ]
}]), Fb = /* @__PURE__ */ ld(LL);
function DL(i, e) {
  return (t) => {
    if (t && i) {
      let r = null;
      if (t = /\S*/.exec(t)[0], typeof i == "function" ? r = i(t) : r = ja.matchLanguageName(i, t, !0), r instanceof ja)
        return r.support ? r.support.language.parser : An.getSkippingParser(r.load());
      if (r)
        return r.parser;
    }
    return e ? e.parser : null;
  };
}
let Xc = class {
  constructor(e, t, r, s, n, o, a) {
    this.node = e, this.from = t, this.to = r, this.spaceBefore = s, this.spaceAfter = n, this.type = o, this.item = a;
  }
  blank(e, t = !0) {
    let r = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; r.length < e; )
        r += " ";
      return r;
    } else {
      for (let s = this.to - this.from - r.length - this.spaceAfter.length; s > 0; s--)
        r += " ";
      return r + (t ? this.spaceAfter : "");
    }
  }
  marker(e, t) {
    let r = this.node.name == "OrderedList" ? String(+Gb(this.item, e)[2] + t) : "";
    return this.spaceBefore + r + this.type + this.spaceAfter;
  }
};
function Hb(i, e) {
  let t = [], r = [];
  for (let s = i; s; s = s.parent) {
    if (s.name == "FencedCode")
      return r;
    (s.name == "ListItem" || s.name == "Blockquote") && t.push(s);
  }
  for (let s = t.length - 1; s >= 0; s--) {
    let n = t[s], o, a = e.lineAt(n.from), l = n.from - a.from;
    if (n.name == "Blockquote" && (o = /^ *>( ?)/.exec(a.text.slice(l))))
      r.push(new Xc(n, l, l + o[0].length, "", o[1], ">", null));
    else if (n.name == "ListItem" && n.parent.name == "OrderedList" && (o = /^( *)\d+([.)])( *)/.exec(a.text.slice(l)))) {
      let c = o[3], h = o[0].length;
      c.length >= 4 && (c = c.slice(0, c.length - 4), h -= 4), r.push(new Xc(n.parent, l, l + h, o[1], c, o[2], n));
    } else if (n.name == "ListItem" && n.parent.name == "BulletList" && (o = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(a.text.slice(l)))) {
      let c = o[4], h = o[0].length;
      c.length > 4 && (c = c.slice(0, c.length - 4), h -= 4);
      let u = o[2];
      o[3] && (u += o[3].replace(/[xX]/, " ")), r.push(new Xc(n.parent, l, l + h, o[1], c, u, n));
    }
  }
  return r;
}
function Gb(i, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(i.from, i.from + 10));
}
function Ic(i, e, t, r = 0) {
  for (let s = -1, n = i; ; ) {
    if (n.name == "ListItem") {
      let a = Gb(n, e), l = +a[2];
      if (s >= 0) {
        if (l != s + 1)
          return;
        t.push({ from: n.from + a[1].length, to: n.from + a[0].length, insert: String(s + 2 + r) });
      }
      s = l;
    }
    let o = n.nextSibling;
    if (!o)
      break;
    n = o;
  }
}
function cd(i, e) {
  let t = /^[ \t]*/.exec(i)[0].length;
  if (!t || e.facet(co) != "	")
    return i;
  let r = Nt(i, 4, t), s = "";
  for (let n = r; n > 0; )
    n >= 4 ? (s += "	", n -= 4) : (s += " ", n--);
  return s + i.slice(t);
}
const ML = ({ state: i, dispatch: e }) => {
  let t = xe(i), { doc: r } = i, s = null, n = i.changeByRange((o) => {
    if (!o.empty || !Fb.isActiveAt(i, o.from, 0))
      return s = { range: o };
    let a = o.from, l = r.lineAt(a), c = Hb(t.resolveInner(a, -1), r);
    for (; c.length && c[c.length - 1].from > a - l.from; )
      c.pop();
    if (!c.length)
      return s = { range: o };
    let h = c[c.length - 1];
    if (h.to - h.spaceAfter.length > a - l.from)
      return s = { range: o };
    let u = a >= h.to - h.spaceAfter.length && !/\S/.test(l.text.slice(h.to));
    if (h.item && u) {
      let f = h.node.firstChild, p = h.node.getChild("ListItem", "ListItem");
      if (f.to >= a || p && p.to < a || l.from > 0 && !/[^\s>]/.test(r.lineAt(l.from - 1).text)) {
        let g = c.length > 1 ? c[c.length - 2] : null, m, _ = "";
        g && g.item ? (m = l.from + g.from, _ = g.marker(r, 1)) : m = l.from + (g ? g.to : 0);
        let b = [{ from: m, to: a, insert: _ }];
        return h.node.name == "OrderedList" && Ic(h.item, r, b, -2), g && g.node.name == "OrderedList" && Ic(g.item, r, b), { range: V.cursor(m + _.length), changes: b };
      } else {
        let g = Xg(c, i, l);
        return {
          range: V.cursor(a + g.length + 1),
          changes: { from: l.from, insert: g + i.lineBreak }
        };
      }
    }
    if (h.node.name == "Blockquote" && u && l.from) {
      let f = r.lineAt(l.from - 1), p = />\s*$/.exec(f.text);
      if (p && p.index == h.from) {
        let g = i.changes([
          { from: f.from + p.index, to: f.to },
          { from: l.from + h.from, to: l.to }
        ]);
        return { range: o.map(g), changes: g };
      }
    }
    let d = [];
    h.node.name == "OrderedList" && Ic(h.item, r, d);
    let O = h.item && h.item.from < l.from, v = "";
    if (!O || /^[\s\d.)\-+*>]*/.exec(l.text)[0].length >= h.to)
      for (let f = 0, p = c.length - 1; f <= p; f++)
        v += f == p && !O ? c[f].marker(r, 1) : c[f].blank(f < p ? Nt(l.text, 4, c[f + 1].from) - v.length : null);
    let S = a;
    for (; S > l.from && /\s/.test(l.text.charAt(S - l.from - 1)); )
      S--;
    return v = cd(v, i), BL(h.node, i.doc) && (v = Xg(c, i, l) + i.lineBreak + v), d.push({ from: S, to: a, insert: i.lineBreak + v }), { range: V.cursor(S + v.length + 1), changes: d };
  });
  return s ? !1 : (e(i.update(n, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function qg(i) {
  return i.name == "QuoteMark" || i.name == "ListMark";
}
function BL(i, e) {
  if (i.name != "OrderedList" && i.name != "BulletList")
    return !1;
  let t = i.firstChild, r = i.getChild("ListItem", "ListItem");
  if (!r)
    return !1;
  let s = e.lineAt(t.to), n = e.lineAt(r.from), o = /^[\s>]*$/.test(s.text);
  return s.number + (o ? 0 : 1) < n.number;
}
function Xg(i, e, t) {
  let r = "";
  for (let s = 0, n = i.length - 2; s <= n; s++)
    r += i[s].blank(s < n ? Nt(t.text, 4, Math.min(t.text.length, i[s + 1].from)) - r.length : null, s < n);
  return cd(r, e);
}
function qL(i, e) {
  let t = i.resolveInner(e, -1), r = e;
  qg(t) && (r = t.from, t = t.parent);
  for (let s; s = t.childBefore(r); )
    if (qg(s))
      r = s.from;
    else if (s.name == "OrderedList" || s.name == "BulletList")
      t = s.lastChild, r = t.to;
    else
      break;
  return t;
}
const XL = ({ state: i, dispatch: e }) => {
  let t = xe(i), r = null, s = i.changeByRange((n) => {
    let o = n.from, { doc: a } = i;
    if (n.empty && Fb.isActiveAt(i, n.from)) {
      let l = a.lineAt(o), c = Hb(qL(t, o), a);
      if (c.length) {
        let h = c[c.length - 1], u = h.to - h.spaceAfter.length + (h.spaceAfter ? 1 : 0);
        if (o - l.from > u && !/\S/.test(l.text.slice(u, o - l.from)))
          return {
            range: V.cursor(l.from + u),
            changes: { from: l.from + u, to: o }
          };
        if (o - l.from == u && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!h.item || l.from <= h.item.from || !/\S/.test(l.text.slice(0, h.to)))) {
          let d = l.from + h.from;
          if (h.item && h.node.from < h.item.from && /\S/.test(l.text.slice(h.from, h.to))) {
            let O = h.blank(Nt(l.text, 4, h.to) - Nt(l.text, 4, h.from));
            return d == l.from && (O = cd(O, i)), {
              range: V.cursor(d + O.length),
              changes: { from: d, to: l.from + h.to, insert: O }
            };
          }
          if (d < o)
            return { range: V.cursor(d), changes: { from: d, to: o } };
        }
      }
    }
    return r = { range: n };
  });
  return r ? !1 : (e(i.update(s, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, IL = [
  { key: "Enter", run: ML },
  { key: "Backspace", run: XL }
], Kb = /* @__PURE__ */ Ub({ matchClosingTags: !1 });
function ZL(i = {}) {
  let { codeLanguages: e, defaultCodeLanguage: t, addKeymap: r = !0, base: { parser: s } = AL, completeHTMLTags: n = !0, htmlTagLanguage: o = Kb } = i;
  if (!(s instanceof ql))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let a = i.extensions ? [i.extensions] : [], l = [o.support], c;
  t instanceof Si ? (l.push(t.support), c = t.language) : t && (c = t);
  let h = e || c ? DL(e, c) : void 0;
  a.push(GA({ codeParser: h, htmlParser: o.language.parser })), r && l.push(Zi.high(oo.of(IL)));
  let u = ld(s.configure(a));
  return n && l.push(u.data.of({ autocomplete: WL })), new Si(u, l);
}
function WL(i) {
  let { state: e, pos: t } = i, r = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(t - 25, t));
  if (!r)
    return null;
  let s = xe(e).resolveInner(t, -1);
  for (; s && !s.type.isTop; ) {
    if (s.name == "CodeBlock" || s.name == "FencedCode" || s.name == "ProcessingInstructionBlock" || s.name == "CommentBlock" || s.name == "Link" || s.name == "Image")
      return null;
    s = s.parent;
  }
  return {
    from: t - r[0].length,
    to: t,
    options: zL(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let Zc = null;
function zL() {
  if (Zc)
    return Zc;
  let i = CL(new jf(ve.create({ extensions: Kb }), 0, !0));
  return Zc = i ? i.options : [];
}
const VL = 36, Ig = 1, UL = 2, Wr = 3, Wc = 4, jL = 5, NL = 6, YL = 7, FL = 8, HL = 9, GL = 10, KL = 11, JL = 12, eD = 13, tD = 14, iD = 15, rD = 16, sD = 17, Zg = 18, nD = 19, Jb = 20, ey = 21, Wg = 22, oD = 23, aD = 24;
function Au(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 48 && i <= 57;
}
function lD(i) {
  return i >= 48 && i <= 57 || i >= 97 && i <= 102 || i >= 65 && i <= 70;
}
function Or(i, e, t) {
  for (let r = !1; ; ) {
    if (i.next < 0)
      return;
    if (i.next == e && !r) {
      i.advance();
      return;
    }
    r = t && !r && i.next == 92, i.advance();
  }
}
function cD(i, e) {
  e: for (; ; ) {
    if (i.next < 0)
      return;
    if (i.next == 36) {
      i.advance();
      for (let t = 0; t < e.length; t++) {
        if (i.next != e.charCodeAt(t))
          continue e;
        i.advance();
      }
      if (i.next == 36) {
        i.advance();
        return;
      }
    } else
      i.advance();
  }
}
function hD(i, e) {
  let t = "[{<(".indexOf(String.fromCharCode(e)), r = t < 0 ? e : "]}>)".charCodeAt(t);
  for (; ; ) {
    if (i.next < 0)
      return;
    if (i.next == r && i.peek(1) == 39) {
      i.advance(2);
      return;
    }
    i.advance();
  }
}
function Lu(i, e) {
  for (; !(i.next != 95 && !Au(i.next)); )
    e != null && (e += String.fromCharCode(i.next)), i.advance();
  return e;
}
function uD(i) {
  if (i.next == 39 || i.next == 34 || i.next == 96) {
    let e = i.next;
    i.advance(), Or(i, e, !1);
  } else
    Lu(i);
}
function zg(i, e) {
  for (; i.next == 48 || i.next == 49; )
    i.advance();
  e && i.next == e && i.advance();
}
function Vg(i, e) {
  for (; ; ) {
    if (i.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (i.next < 48 || i.next > 57)
      break;
    i.advance();
  }
  if (i.next == 69 || i.next == 101)
    for (i.advance(), (i.next == 43 || i.next == 45) && i.advance(); i.next >= 48 && i.next <= 57; )
      i.advance();
}
function Ug(i) {
  for (; !(i.next < 0 || i.next == 10); )
    i.advance();
}
function fr(i, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == i)
      return !0;
  return !1;
}
const zc = ` 	\r
`;
function ty(i, e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  r.true = r.false = jL, r.null = r.unknown = NL;
  for (let s of i.split(" "))
    s && (r[s] = Jb);
  for (let s of e.split(" "))
    s && (r[s] = ey);
  for (let s of (t || "").split(" "))
    s && (r[s] = aD);
  return r;
}
const fD = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", dD = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", Du = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ ty(dD, fD)
};
function OD(i, e, t, r) {
  let s = {};
  for (let n in Du)
    s[n] = (i.hasOwnProperty(n) ? i : Du)[n];
  return e && (s.words = ty(e, t || "", r)), s;
}
function iy(i) {
  return new qe((e) => {
    var t;
    let { next: r } = e;
    if (e.advance(), fr(r, zc)) {
      for (; fr(e.next, zc); )
        e.advance();
      e.acceptToken(VL);
    } else if (r == 36 && i.doubleDollarQuotedStrings) {
      let s = Lu(e, "");
      e.next == 36 && (e.advance(), cD(e, s), e.acceptToken(Wr));
    } else if (r == 39 || r == 34 && i.doubleQuotedStrings)
      Or(e, r, i.backslashEscapes), e.acceptToken(Wr);
    else if (r == 35 && i.hashComments || r == 47 && e.next == 47 && i.slashComments)
      Ug(e), e.acceptToken(Ig);
    else if (r == 45 && e.next == 45 && (!i.spaceAfterDashes || e.peek(1) == 32))
      Ug(e), e.acceptToken(Ig);
    else if (r == 47 && e.next == 42) {
      e.advance();
      for (let s = 1; ; ) {
        let n = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), n == 42 && e.next == 47) {
          if (s--, e.advance(), !s)
            break;
        } else n == 47 && e.next == 42 && (s++, e.advance());
      }
      e.acceptToken(UL);
    } else if ((r == 101 || r == 69) && e.next == 39)
      e.advance(), Or(e, 39, !0), e.acceptToken(Wr);
    else if ((r == 110 || r == 78) && e.next == 39 && i.charSetCasts)
      e.advance(), Or(e, 39, i.backslashEscapes), e.acceptToken(Wr);
    else if (r == 95 && i.charSetCasts)
      for (let s = 0; ; s++) {
        if (e.next == 39 && s > 1) {
          e.advance(), Or(e, 39, i.backslashEscapes), e.acceptToken(Wr);
          break;
        }
        if (!Au(e.next))
          break;
        e.advance();
      }
    else if (i.plsqlQuotingMechanism && (r == 113 || r == 81) && e.next == 39 && e.peek(1) > 0 && !fr(e.peek(1), zc)) {
      let s = e.peek(1);
      e.advance(2), hD(e, s), e.acceptToken(Wr);
    } else if (r == 40)
      e.acceptToken(YL);
    else if (r == 41)
      e.acceptToken(FL);
    else if (r == 123)
      e.acceptToken(HL);
    else if (r == 125)
      e.acceptToken(GL);
    else if (r == 91)
      e.acceptToken(KL);
    else if (r == 93)
      e.acceptToken(JL);
    else if (r == 59)
      e.acceptToken(eD);
    else if (i.unquotedBitLiterals && r == 48 && e.next == 98)
      e.advance(), zg(e), e.acceptToken(Wg);
    else if ((r == 98 || r == 66) && (e.next == 39 || e.next == 34)) {
      const s = e.next;
      e.advance(), i.treatBitsAsBytes ? (Or(e, s, i.backslashEscapes), e.acceptToken(oD)) : (zg(e, s), e.acceptToken(Wg));
    } else if (r == 48 && (e.next == 120 || e.next == 88) || (r == 120 || r == 88) && e.next == 39) {
      let s = e.next == 39;
      for (e.advance(); lD(e.next); )
        e.advance();
      s && e.next == 39 && e.advance(), e.acceptToken(Wc);
    } else if (r == 46 && e.next >= 48 && e.next <= 57)
      Vg(e, !0), e.acceptToken(Wc);
    else if (r == 46)
      e.acceptToken(tD);
    else if (r >= 48 && r <= 57)
      Vg(e, !1), e.acceptToken(Wc);
    else if (fr(r, i.operatorChars)) {
      for (; fr(e.next, i.operatorChars); )
        e.advance();
      e.acceptToken(iD);
    } else if (fr(r, i.specialVar))
      e.next == r && e.advance(), uD(e), e.acceptToken(sD);
    else if (fr(r, i.identifierQuotes))
      Or(e, r, !1), e.acceptToken(nD);
    else if (r == 58 || r == 44)
      e.acceptToken(rD);
    else if (Au(r)) {
      let s = Lu(e, String.fromCharCode(r));
      e.acceptToken(e.next == 46 || e.peek(-s.length - 1) == 46 ? Zg : (t = i.words[s.toLowerCase()]) !== null && t !== void 0 ? t : Zg);
    }
  });
}
const ry = /* @__PURE__ */ iy(Du), pD = /* @__PURE__ */ Gt.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: " LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, ry],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function Mu(i) {
  let e = i.cursor().moveTo(i.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function Un(i, e) {
  let t = i.sliceString(e.from, e.to), r = /^([`'"])(.*)\1$/.exec(t);
  return r ? r[2] : t;
}
function ul(i) {
  return i && (i.name == "Identifier" || i.name == "QuotedIdentifier");
}
function gD(i, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let r = e.firstChild; r; r = r.nextSibling)
      ul(r) && t.push(Un(i, r));
    return t;
  }
  return [Un(i, e)];
}
function jg(i, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let r = Mu(e);
    if (!ul(r))
      return t;
    t.unshift(Un(i, r)), e = Mu(r);
  }
}
function mD(i, e) {
  let t = xe(i).resolveInner(e, -1), r = vD(i.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? i.doc.sliceString(t.from, t.from + 1) : null,
    parents: jg(i.doc, Mu(t)),
    aliases: r
  } : t.name == "." ? { from: e, quoted: null, parents: jg(i.doc, t), aliases: r } : { from: e, quoted: null, parents: [], empty: !0, aliases: r };
}
const SD = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function vD(i, e) {
  let t;
  for (let s = e; !t; s = s.parent) {
    if (!s)
      return null;
    s.name == "Statement" && (t = s);
  }
  let r = null;
  for (let s = t.firstChild, n = !1, o = null; s; s = s.nextSibling) {
    let a = s.name == "Keyword" ? i.sliceString(s.from, s.to).toLowerCase() : null, l = null;
    if (!n)
      n = a == "from";
    else if (a == "as" && o && ul(s.nextSibling))
      l = Un(i, s.nextSibling);
    else {
      if (a && SD.has(a))
        break;
      o && ul(s) && (l = Un(i, s));
    }
    l && (r || (r = /* @__PURE__ */ Object.create(null)), r[l] = gD(i, o)), o = /Identifier$/.test(s.name) ? s : null;
  }
  return r;
}
function _D(i, e) {
  return i ? e.map((t) => ({ ...t, label: t.label[0] == i ? t.label : i + t.label + i, apply: void 0 })) : e;
}
const bD = /^\w*$/, yD = /^[`'"]?\w*[`'"]?$/;
function Ng(i) {
  return i.self && typeof i.self.label == "string";
}
class hd {
  constructor(e, t) {
    this.idQuote = e, this.idCaseInsensitive = t, this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null)), r = t[e];
    return r || (e && !this.list.some((s) => s.label == e) && this.list.push(Yg(e, "type", this.idQuote, this.idCaseInsensitive)), t[e] = new hd(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let t = this.list.findIndex((r) => r.label == e.label);
    t > -1 ? this.list[t] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let t of e)
      this.addCompletion(typeof t == "string" ? Yg(t, "property", this.idQuote, this.idCaseInsensitive) : t);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : Ng(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let t of Object.keys(e)) {
      let r = e[t], s = null, n = t.replace(/\\?\./g, (a) => a == "." ? "\0" : a).split("\0"), o = this;
      Ng(r) && (s = r.self, r = r.children);
      for (let a = 0; a < n.length; a++)
        s && a == n.length - 1 && o.addCompletion(s), o = o.child(n[a].replace(/\\\./g, "."));
      o.addNamespace(r);
    }
  }
}
function Yg(i, e, t, r) {
  return new RegExp("^[a-z_][a-z_\\d]*$", r ? "i" : "").test(i) ? { label: i, type: e } : { label: i, type: e, apply: t + i + t };
}
function wD(i, e, t, r, s, n) {
  var o;
  let a = ((o = n?.spec.identifierQuotes) === null || o === void 0 ? void 0 : o[0]) || '"', l = new hd(a, !!n?.spec.caseInsensitiveIdentifiers), c = s ? l.child(s) : null;
  return l.addNamespace(i), e && (c || l).addCompletions(e), t && l.addCompletions(t), c && l.addCompletions(c.list), r && l.addCompletions((c || l).child(r).list), (h) => {
    let { parents: u, from: d, quoted: O, empty: v, aliases: S } = mD(h.state, h.pos);
    if (v && !h.explicit)
      return null;
    S && u.length == 1 && (u = S[u[0]] || u);
    let f = l;
    for (let m of u) {
      for (; !f.children || !f.children[m]; )
        if (f == l && c)
          f = c;
        else if (f == c && r)
          f = f.child(r);
        else
          return null;
      let _ = f.maybeChild(m);
      if (!_)
        return null;
      f = _;
    }
    let p = O && h.state.sliceDoc(h.pos, h.pos + 1) == O, g = f.list;
    return f == l && S && (g = g.concat(Object.keys(S).map((m) => ({ label: m, type: "constant" })))), {
      from: d,
      to: p ? h.pos + 1 : void 0,
      options: _D(O, g),
      validFor: O ? yD : bD
    };
  };
}
function xD(i) {
  return i == ey ? "type" : i == Jb ? "keyword" : "variable";
}
function kD(i, e, t) {
  let r = Object.keys(i).map((s) => t(e ? s.toUpperCase() : s, xD(i[s])));
  return Nf(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Ml(r));
}
let CD = /* @__PURE__ */ pD.configure({
  props: [
    /* @__PURE__ */ bi.add({
      Statement: /* @__PURE__ */ Cr()
    }),
    /* @__PURE__ */ ei.add({
      Statement(i, e) {
        return { from: Math.min(i.from + 100, e.doc.lineAt(i.from).to), to: i.to };
      },
      BlockComment(i) {
        return { from: i.from + 2, to: i.to - 2 };
      }
    }),
    /* @__PURE__ */ Jt({
      Keyword: C.keyword,
      Type: C.typeName,
      Builtin: /* @__PURE__ */ C.standard(C.name),
      Bits: C.number,
      Bytes: C.string,
      Bool: C.bool,
      Null: C.null,
      Number: C.number,
      String: C.string,
      Identifier: C.name,
      QuotedIdentifier: /* @__PURE__ */ C.special(C.string),
      SpecialVar: /* @__PURE__ */ C.special(C.name),
      LineComment: C.lineComment,
      BlockComment: C.blockComment,
      Operator: C.operator,
      "Semi Punctuation": C.punctuation,
      "( )": C.paren,
      "{ }": C.brace,
      "[ ]": C.squareBracket
    })
  ]
});
class fl {
  constructor(e, t, r) {
    this.dialect = e, this.language = t, this.spec = r;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Reconfigure the parser used by this dialect. Returns a new
  dialect object.
  */
  configureLanguage(e, t) {
    return new fl(this.dialect, this.language.configure(e, t), this.spec);
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = OD(e, e.keywords, e.types, e.builtin), r = Ht.define({
      name: "sql",
      parser: CD.configure({
        tokenizers: [{ from: ry, to: iy(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new fl(t, r, e);
  }
}
function QD(i, e) {
  return { label: i, type: e, boost: -1 };
}
function PD(i, e = !1, t) {
  return kD(i.dialect.words, e, t || QD);
}
function TD(i) {
  return i.schema ? wD(i.schema, i.tables, i.schemas, i.defaultTable, i.defaultSchema, i.dialect || ud) : () => null;
}
function $D(i) {
  return i.schema ? (i.dialect || ud).language.data.of({
    autocomplete: TD(i)
  }) : [];
}
function RD(i = {}) {
  let e = i.dialect || ud;
  return new Si(e.language, [
    $D(i),
    e.language.data.of({
      autocomplete: PD(e, i.upperCaseKeywords, i.keywordCompletion)
    })
  ]);
}
const ud = /* @__PURE__ */ fl.define({}), ED = 1, sy = 194, ny = 195, AD = 196, Fg = 197, LD = 198, DD = 199, MD = 200, BD = 2, oy = 3, Hg = 201, qD = 24, XD = 25, ID = 49, ZD = 50, WD = 55, zD = 56, VD = 57, UD = 59, jD = 60, ND = 61, YD = 62, FD = 63, HD = 65, GD = 238, KD = 71, JD = 241, eM = 242, tM = 243, iM = 244, rM = 245, sM = 246, nM = 247, oM = 248, ay = 72, aM = 249, lM = 250, cM = 251, hM = 252, uM = 253, fM = 254, dM = 255, OM = 256, pM = 73, gM = 77, mM = 263, SM = 112, vM = 130, _M = 151, bM = 152, yM = 155, Mr = 10, jn = 13, fd = 32, Xl = 9, dd = 35, wM = 40, xM = 46, Bu = 123, Gg = 125, ly = 39, cy = 34, Kg = 92, kM = 111, CM = 120, QM = 78, PM = 117, TM = 85, $M = /* @__PURE__ */ new Set([
  XD,
  ID,
  ZD,
  mM,
  HD,
  vM,
  zD,
  VD,
  GD,
  YD,
  FD,
  ay,
  pM,
  gM,
  jD,
  ND,
  _M,
  bM,
  yM,
  SM
]);
function Vc(i) {
  return i == Mr || i == jn;
}
function Uc(i) {
  return i >= 48 && i <= 57 || i >= 65 && i <= 70 || i >= 97 && i <= 102;
}
const RM = new qe((i, e) => {
  let t;
  if (i.next < 0)
    i.acceptToken(DD);
  else if (e.context.flags & pa)
    Vc(i.next) && i.acceptToken(LD, 1);
  else if (((t = i.peek(-1)) < 0 || Vc(t)) && e.canShift(Fg)) {
    let r = 0;
    for (; i.next == fd || i.next == Xl; )
      i.advance(), r++;
    (i.next == Mr || i.next == jn || i.next == dd) && i.acceptToken(Fg, -r);
  } else Vc(i.next) && i.acceptToken(AD, 1);
}, { contextual: !0 }), EM = new qe((i, e) => {
  let t = e.context;
  if (t.flags) return;
  let r = i.peek(-1);
  if (r == Mr || r == jn) {
    let s = 0, n = 0;
    for (; ; ) {
      if (i.next == fd) s++;
      else if (i.next == Xl) s += 8 - s % 8;
      else break;
      i.advance(), n++;
    }
    s != t.indent && i.next != Mr && i.next != jn && i.next != dd && (s < t.indent ? i.acceptToken(ny, -n) : i.acceptToken(sy));
  }
}), pa = 1, hy = 2, ki = 4, Ci = 8, Qi = 16, Pi = 32;
function ga(i, e, t) {
  this.parent = i, this.indent = e, this.flags = t, this.hash = (i ? i.hash + i.hash << 8 : 0) + e + (e << 4) + t + (t << 6);
}
const AM = new ga(null, 0, 0);
function LM(i) {
  let e = 0;
  for (let t = 0; t < i.length; t++)
    e += i.charCodeAt(t) == Xl ? 8 - e % 8 : 1;
  return e;
}
const Jg = new Map([
  [JD, 0],
  [eM, ki],
  [tM, Ci],
  [iM, Ci | ki],
  [rM, Qi],
  [sM, Qi | ki],
  [nM, Qi | Ci],
  [oM, Qi | Ci | ki],
  [aM, Pi],
  [lM, Pi | ki],
  [cM, Pi | Ci],
  [hM, Pi | Ci | ki],
  [uM, Pi | Qi],
  [fM, Pi | Qi | ki],
  [dM, Pi | Qi | Ci],
  [OM, Pi | Qi | Ci | ki]
].map(([i, e]) => [i, e | hy])), DM = new go({
  start: AM,
  reduce(i, e, t, r) {
    return i.flags & pa && $M.has(e) || (e == KD || e == ay) && i.flags & hy ? i.parent : i;
  },
  shift(i, e, t, r) {
    return e == sy ? new ga(i, LM(r.read(r.pos, t.pos)), 0) : e == ny ? i.parent : e == qD || e == WD || e == UD || e == oy ? new ga(i, 0, pa) : Jg.has(e) ? new ga(i, 0, Jg.get(e) | i.flags & pa) : i;
  },
  hash(i) {
    return i.hash;
  }
}), MM = new qe((i) => {
  for (let e = 0; e < 5; e++) {
    if (i.next != "print".charCodeAt(e)) return;
    i.advance();
  }
  if (!/\w/.test(String.fromCharCode(i.next)))
    for (let e = 0; ; e++) {
      let t = i.peek(e);
      if (!(t == fd || t == Xl)) {
        t != wM && t != xM && t != Mr && t != jn && t != dd && i.acceptToken(ED);
        return;
      }
    }
}), BM = new qe((i, e) => {
  let { flags: t } = e.context, r = t & ki ? cy : ly, s = (t & Ci) > 0, n = !(t & Qi), o = (t & Pi) > 0, a = i.pos;
  for (; !(i.next < 0); )
    if (o && i.next == Bu)
      if (i.peek(1) == Bu)
        i.advance(2);
      else {
        if (i.pos == a) {
          i.acceptToken(oy, 1);
          return;
        }
        break;
      }
    else if (n && i.next == Kg) {
      if (i.pos == a) {
        i.advance();
        let l = i.next;
        l >= 0 && (i.advance(), qM(i, l)), i.acceptToken(BD);
        return;
      }
      break;
    } else if (i.next == Kg && !n && i.peek(1) > -1)
      i.advance(2);
    else if (i.next == r && (!s || i.peek(1) == r && i.peek(2) == r)) {
      if (i.pos == a) {
        i.acceptToken(Hg, s ? 3 : 1);
        return;
      }
      break;
    } else if (i.next == Mr) {
      if (s)
        i.advance();
      else if (i.pos == a) {
        i.acceptToken(Hg);
        return;
      }
      break;
    } else
      i.advance();
  i.pos > a && i.acceptToken(MD);
});
function qM(i, e) {
  if (e == kM)
    for (let t = 0; t < 2 && i.next >= 48 && i.next <= 55; t++) i.advance();
  else if (e == CM)
    for (let t = 0; t < 2 && Uc(i.next); t++) i.advance();
  else if (e == PM)
    for (let t = 0; t < 4 && Uc(i.next); t++) i.advance();
  else if (e == TM)
    for (let t = 0; t < 8 && Uc(i.next); t++) i.advance();
  else if (e == QM && i.next == Bu) {
    for (i.advance(); i.next >= 0 && i.next != Gg && i.next != ly && i.next != cy && i.next != Mr; ) i.advance();
    i.next == Gg && i.advance();
  }
}
const XM = Jt({
  'async "*" "**" FormatConversion FormatSpec': C.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": C.controlKeyword,
  "in not and or is del": C.operatorKeyword,
  "from def class global nonlocal lambda": C.definitionKeyword,
  import: C.moduleKeyword,
  "with as print": C.keyword,
  Boolean: C.bool,
  None: C.null,
  VariableName: C.variableName,
  "CallExpression/VariableName": C.function(C.variableName),
  "FunctionDefinition/VariableName": C.function(C.definition(C.variableName)),
  "ClassDefinition/VariableName": C.definition(C.className),
  PropertyName: C.propertyName,
  "CallExpression/MemberExpression/PropertyName": C.function(C.propertyName),
  Comment: C.lineComment,
  Number: C.number,
  String: C.string,
  FormatString: C.special(C.string),
  Escape: C.escape,
  UpdateOp: C.updateOperator,
  "ArithOp!": C.arithmeticOperator,
  BitOp: C.bitwiseOperator,
  CompareOp: C.compareOperator,
  AssignOp: C.definitionOperator,
  Ellipsis: C.punctuation,
  At: C.meta,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace,
  ".": C.derefOperator,
  ", ;": C.separator
}), IM = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 }, ZM = Gt.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: " print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: DM,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [XM],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [MM, EM, RM, BM, 0, 1, 2, 3, 4],
  topRules: { Script: [0, 5] },
  specialized: [{ term: 221, get: (i) => IM[i] || -1 }],
  tokenPrec: 7668
}), em = /* @__PURE__ */ new Ef(), uy = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function jo(i) {
  return (e, t, r) => {
    if (r)
      return !1;
    let s = e.node.getChild("VariableName");
    return s && t(s, i), !0;
  };
}
const WM = {
  FunctionDefinition: /* @__PURE__ */ jo("function"),
  ClassDefinition: /* @__PURE__ */ jo("class"),
  ForStatement(i, e, t) {
    if (t) {
      for (let r = i.node.firstChild; r; r = r.nextSibling)
        if (r.name == "VariableName")
          e(r, "variable");
        else if (r.name == "in")
          break;
    }
  },
  ImportStatement(i, e) {
    var t, r;
    let { node: s } = i, n = ((t = s.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let o = s.getChild("import"); o; o = o.nextSibling)
      o.name == "VariableName" && ((r = o.nextSibling) === null || r === void 0 ? void 0 : r.name) != "as" && e(o, n ? "variable" : "namespace");
  },
  AssignStatement(i, e) {
    for (let t = i.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(i, e) {
    for (let t = null, r = i.node.firstChild; r; r = r.nextSibling)
      r.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(r, "variable"), t = r;
  },
  CapturePattern: /* @__PURE__ */ jo("variable"),
  AsPattern: /* @__PURE__ */ jo("variable"),
  __proto__: null
};
function fy(i, e) {
  let t = em.get(e);
  if (t)
    return t;
  let r = [], s = !0;
  function n(o, a) {
    let l = i.sliceString(o.from, o.to);
    r.push({ label: l, type: a });
  }
  return e.cursor(Pe.IncludeAnonymous).iterate((o) => {
    if (o.name) {
      let a = WM[o.name];
      if (a && a(o, n, s) || !s && uy.has(o.name))
        return !1;
      s = !1;
    } else if (o.to - o.from > 8192) {
      for (let a of fy(i, o.node))
        r.push(a);
      return !1;
    }
  }), em.set(e, r), r;
}
const tm = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, dy = ["String", "FormatString", "Comment", "PropertyName"];
function zM(i) {
  let e = xe(i.state).resolveInner(i.pos, -1);
  if (dy.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && tm.test(i.state.sliceDoc(e.from, e.to));
  if (!t && !i.explicit)
    return null;
  let r = [];
  for (let s = e; s; s = s.parent)
    uy.has(s.name) && (r = r.concat(fy(i.state.doc, s)));
  return {
    options: r,
    from: t ? e.from : i.pos,
    validFor: tm
  };
}
const VM = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((i) => ({ label: i, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((i) => ({ label: i, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((i) => ({ label: i, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((i) => ({ label: i, type: "function" }))), UM = [
  /* @__PURE__ */ Be("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], jM = /* @__PURE__ */ Nf(dy, /* @__PURE__ */ Ml(/* @__PURE__ */ VM.concat(UM)));
function jc(i) {
  let { node: e, pos: t } = i, r = i.lineIndent(t, -1), s = null;
  for (; ; ) {
    let n = e.childBefore(t);
    if (n)
      if (n.name == "Comment")
        t = n.from;
      else if (n.name == "Body" || n.name == "MatchBody")
        i.baseIndentFor(n) + i.unit <= r && (s = n), e = n;
      else if (n.name == "MatchClause")
        e = n;
      else if (n.type.is("Statement"))
        e = n;
      else
        break;
    else break;
  }
  return s;
}
function Nc(i, e) {
  let t = i.baseIndentFor(e), r = i.lineAt(i.pos, -1), s = r.from + r.text.length;
  return /^\s*($|#)/.test(r.text) && i.node.to < s + 100 && !/\S/.test(i.state.sliceDoc(s, i.node.to)) && i.lineIndent(i.pos, -1) <= t || /^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(i.textAfter) && i.lineIndent(i.pos, -1) > t ? null : t + i.unit;
}
const Yc = /* @__PURE__ */ Ht.define({
  name: "python",
  parser: /* @__PURE__ */ ZM.configure({
    props: [
      /* @__PURE__ */ bi.add({
        Body: (i) => {
          var e;
          let t = /^\s*(#|$)/.test(i.textAfter) && jc(i) || i.node;
          return (e = Nc(i, t)) !== null && e !== void 0 ? e : i.continue();
        },
        MatchBody: (i) => {
          var e;
          let t = jc(i);
          return (e = Nc(i, t || i.node)) !== null && e !== void 0 ? e : i.continue();
        },
        IfStatement: (i) => /^\s*(else:|elif )/.test(i.textAfter) ? i.baseIndent : i.continue(),
        "ForStatement WhileStatement": (i) => /^\s*else:/.test(i.textAfter) ? i.baseIndent : i.continue(),
        TryStatement: (i) => /^\s*(except[ :]|finally:|else:)/.test(i.textAfter) ? i.baseIndent : i.continue(),
        MatchStatement: (i) => /^\s*case /.test(i.textAfter) ? i.baseIndent + i.unit : i.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ rs({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ rs({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ rs({ closing: "]" }),
        MemberExpression: (i) => i.baseIndent + i.unit,
        "String FormatString": () => null,
        Script: (i) => {
          var e;
          let t = jc(i);
          return (e = t && Nc(i, t)) !== null && e !== void 0 ? e : i.continue();
        }
      }),
      /* @__PURE__ */ ei.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": ho,
        Body: (i, e) => ({ from: i.from + 1, to: i.to - (i.to == e.doc.length ? 0 : 1) }),
        "String FormatString": (i, e) => ({ from: e.doc.lineAt(i.from).to, to: i.to })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    // Indent logic logic are triggered upon below input patterns
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function NM() {
  return new Si(Yc, [
    Yc.data.of({ autocomplete: zM }),
    Yc.data.of({ autocomplete: jM })
  ]);
}
const Yr = 63, im = 64, YM = 1, FM = 2, Oy = 3, HM = 4, py = 5, GM = 6, KM = 7, gy = 65, JM = 66, eB = 8, tB = 9, iB = 10, rB = 11, sB = 12, my = 13, nB = 19, oB = 20, aB = 29, lB = 33, cB = 34, hB = 47, uB = 0, Od = 1, qu = 2, Nn = 3, Xu = 4;
class Sr {
  constructor(e, t, r) {
    this.parent = e, this.depth = t, this.type = r, this.hash = (e ? e.hash + e.hash << 8 : 0) + t + (t << 4) + r;
  }
}
Sr.top = new Sr(null, -1, uB);
function un(i, e) {
  for (let t = 0, r = e - i.pos - 1; ; r--, t++) {
    let s = i.peek(r);
    if (Ii(s) || s == -1) return t;
  }
}
function Iu(i) {
  return i == 32 || i == 9;
}
function Ii(i) {
  return i == 10 || i == 13;
}
function Sy(i) {
  return Iu(i) || Ii(i);
}
function wr(i) {
  return i < 0 || Sy(i);
}
const fB = new go({
  start: Sr.top,
  reduce(i, e) {
    return i.type == Nn && (e == oB || e == cB) ? i.parent : i;
  },
  shift(i, e, t, r) {
    if (e == Oy)
      return new Sr(i, un(r, r.pos), Od);
    if (e == gy || e == py)
      return new Sr(i, un(r, r.pos), qu);
    if (e == Yr)
      return i.parent;
    if (e == nB || e == lB)
      return new Sr(i, 0, Nn);
    if (e == my && i.type == Xu)
      return i.parent;
    if (e == hB) {
      let s = /[1-9]/.exec(r.read(r.pos, t.pos));
      if (s) return new Sr(i, i.depth + +s[0], Xu);
    }
    return i;
  },
  hash(i) {
    return i.hash;
  }
});
function _s(i, e, t = 0) {
  return i.peek(t) == e && i.peek(t + 1) == e && i.peek(t + 2) == e && wr(i.peek(t + 3));
}
const dB = new qe((i, e) => {
  if (i.next == -1 && e.canShift(im))
    return i.acceptToken(im);
  let t = i.peek(-1);
  if ((Ii(t) || t < 0) && e.context.type != Nn) {
    if (_s(
      i,
      45
      /* '-' */
    ))
      if (e.canShift(Yr)) i.acceptToken(Yr);
      else return i.acceptToken(YM, 3);
    if (_s(
      i,
      46
      /* '.' */
    ))
      if (e.canShift(Yr)) i.acceptToken(Yr);
      else return i.acceptToken(FM, 3);
    let r = 0;
    for (; i.next == 32; )
      r++, i.advance();
    (r < e.context.depth || r == e.context.depth && e.context.type == Od && (i.next != 45 || !wr(i.peek(1)))) && // Not blank
    i.next != -1 && !Ii(i.next) && i.next != 35 && i.acceptToken(Yr, -r);
  }
}, { contextual: !0 }), OB = new qe((i, e) => {
  if (e.context.type == Nn) {
    i.next == 63 && (i.advance(), wr(i.next) && i.acceptToken(KM));
    return;
  }
  if (i.next == 45)
    i.advance(), wr(i.next) && i.acceptToken(e.context.type == Od && e.context.depth == un(i, i.pos - 1) ? HM : Oy);
  else if (i.next == 63)
    i.advance(), wr(i.next) && i.acceptToken(e.context.type == qu && e.context.depth == un(i, i.pos - 1) ? GM : py);
  else {
    let t = i.pos;
    for (; ; )
      if (Iu(i.next)) {
        if (i.pos == t) return;
        i.advance();
      } else if (i.next == 33)
        vy(i);
      else if (i.next == 38)
        Zu(i);
      else if (i.next == 42) {
        Zu(i);
        break;
      } else if (i.next == 39 || i.next == 34) {
        if (pd(i, !0)) break;
        return;
      } else if (i.next == 91 || i.next == 123) {
        if (!gB(i)) return;
        break;
      } else {
        _y(i, !0, !1, 0);
        break;
      }
    for (; Iu(i.next); ) i.advance();
    if (i.next == 58) {
      if (i.pos == t && e.canShift(aB)) return;
      let r = i.peek(1);
      wr(r) && i.acceptTokenTo(e.context.type == qu && e.context.depth == un(i, t) ? JM : gy, t);
    }
  }
}, { contextual: !0 });
function pB(i) {
  return i > 32 && i < 127 && i != 34 && i != 37 && i != 44 && i != 60 && i != 62 && i != 92 && i != 94 && i != 96 && i != 123 && i != 124 && i != 125;
}
function rm(i) {
  return i >= 48 && i <= 57 || i >= 97 && i <= 102 || i >= 65 && i <= 70;
}
function sm(i, e) {
  return i.next == 37 ? (i.advance(), rm(i.next) && i.advance(), rm(i.next) && i.advance(), !0) : pB(i.next) || e && i.next == 44 ? (i.advance(), !0) : !1;
}
function vy(i) {
  if (i.advance(), i.next == 60) {
    for (i.advance(); ; )
      if (!sm(i, !0)) {
        i.next == 62 && i.advance();
        break;
      }
  } else
    for (; sm(i, !1); )
      ;
}
function Zu(i) {
  for (i.advance(); !wr(i.next) && dl(i.tag) != "f"; ) i.advance();
}
function pd(i, e) {
  let t = i.next, r = !1, s = i.pos;
  for (i.advance(); ; ) {
    let n = i.next;
    if (n < 0) break;
    if (i.advance(), n == t)
      if (n == 39)
        if (i.next == 39) i.advance();
        else break;
      else
        break;
    else if (n == 92 && t == 34)
      i.next >= 0 && i.advance();
    else if (Ii(n)) {
      if (e) return !1;
      r = !0;
    } else if (e && i.pos >= s + 1024)
      return !1;
  }
  return !r;
}
function gB(i) {
  for (let e = [], t = i.pos + 1024; ; )
    if (i.next == 91 || i.next == 123)
      e.push(i.next), i.advance();
    else if (i.next == 39 || i.next == 34) {
      if (!pd(i, !0)) return !1;
    } else if (i.next == 93 || i.next == 125) {
      if (e[e.length - 1] != i.next - 2) return !1;
      if (e.pop(), i.advance(), !e.length) return !0;
    } else {
      if (i.next < 0 || i.pos > t || Ii(i.next))
        return !1;
      i.advance();
    }
}
const mB = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function dl(i) {
  return i < 33 ? "u" : i > 125 ? "s" : mB[i - 33];
}
function Fc(i, e) {
  let t = dl(i);
  return t != "u" && !(e && t == "f");
}
function _y(i, e, t, r) {
  if (dl(i.next) == "s" || (i.next == 63 || i.next == 58 || i.next == 45) && Fc(i.peek(1), t))
    i.advance();
  else
    return !1;
  let s = i.pos;
  for (; ; ) {
    let n = i.next, o = 0, a = r + 1;
    for (; Sy(n); ) {
      if (Ii(n)) {
        if (e) return !1;
        a = 0;
      } else
        a++;
      n = i.peek(++o);
    }
    if (!(n >= 0 && (n == 58 ? Fc(i.peek(o + 1), t) : n == 35 ? i.peek(o - 1) != 32 : Fc(n, t))) || !t && a <= r || a == 0 && !t && (_s(i, 45, o) || _s(i, 46, o)))
      break;
    if (e && dl(n) == "f") return !1;
    for (let c = o; c >= 0; c--) i.advance();
    if (e && i.pos > s + 1024) return !1;
  }
  return !0;
}
const SB = new qe((i, e) => {
  if (i.next == 33)
    vy(i), i.acceptToken(sB);
  else if (i.next == 38 || i.next == 42) {
    let t = i.next == 38 ? iB : rB;
    Zu(i), i.acceptToken(t);
  } else i.next == 39 || i.next == 34 ? (pd(i, !1), i.acceptToken(tB)) : _y(i, !1, e.context.type == Nn, e.context.depth) && i.acceptToken(eB);
}), vB = new qe((i, e) => {
  let t = e.context.type == Xu ? e.context.depth : -1, r = i.pos;
  e: for (; ; ) {
    let s = 0, n = i.next;
    for (; n == 32; ) n = i.peek(++s);
    if (!s && (_s(i, 45, s) || _s(i, 46, s)) || !Ii(n) && (t < 0 && (t = Math.max(e.context.depth + 1, s)), s < t))
      break;
    for (; ; ) {
      if (i.next < 0) break e;
      let o = Ii(i.next);
      if (i.advance(), o) continue e;
      r = i.pos;
    }
  }
  i.acceptTokenTo(my, r);
}), _B = Jt({
  DirectiveName: C.keyword,
  DirectiveContent: C.attributeValue,
  "DirectiveEnd DocEnd": C.meta,
  QuotedLiteral: C.string,
  BlockLiteralHeader: C.special(C.string),
  BlockLiteralContent: C.content,
  Literal: C.content,
  "Key/Literal Key/QuotedLiteral": C.definition(C.propertyName),
  "Anchor Alias": C.labelName,
  Tag: C.typeName,
  Comment: C.lineComment,
  ": , -": C.separator,
  "?": C.punctuation,
  "[ ]": C.squareBracket,
  "{ }": C.brace
}), bB = Gt.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: " DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: fB,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [_B],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [dB, OB, SB, vB, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), yB = /* @__PURE__ */ Ht.define({
  name: "yaml",
  parser: /* @__PURE__ */ bB.configure({
    props: [
      /* @__PURE__ */ bi.add({
        Stream: (i) => {
          for (let e = i.node.resolve(i.pos, -1); e && e.to >= i.pos; e = e.parent) {
            if (e.name == "BlockLiteralContent" && e.from < e.to)
              return i.baseIndentFor(e);
            if (e.name == "BlockLiteral")
              return i.baseIndentFor(e) + i.unit;
            if (e.name == "BlockSequence" || e.name == "BlockMapping")
              return i.column(e.from, 1);
            if (e.name == "QuotedLiteral")
              return null;
            if (e.name == "Literal") {
              let t = i.column(e.from, 1);
              if (t == i.lineIndent(e.from, 1))
                return t;
              if (e.to > i.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ rs({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ rs({ closing: "]" })
      }),
      /* @__PURE__ */ ei.add({
        "FlowMapping FlowSequence": ho,
        "Item Pair BlockLiteral": (i, e) => ({ from: e.doc.lineAt(i.from).to, to: i.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function wB() {
  return new Si(yB);
}
const Wu = 1, xB = 2, kB = 3, CB = 4, QB = 5, PB = 36, TB = 37, $B = 38, RB = 11, EB = 13;
function AB(i) {
  return i == 45 || i == 46 || i == 58 || i >= 65 && i <= 90 || i == 95 || i >= 97 && i <= 122 || i >= 161;
}
function LB(i) {
  return i == 9 || i == 10 || i == 13 || i == 32;
}
let nm = null, om = null, am = 0;
function zu(i, e) {
  let t = i.pos + e;
  if (om == i && am == t) return nm;
  for (; LB(i.peek(e)); ) e++;
  let r = "";
  for (; ; ) {
    let s = i.peek(e);
    if (!AB(s)) break;
    r += String.fromCharCode(s), e++;
  }
  return om = i, am = t, nm = r || null;
}
function lm(i, e) {
  this.name = i, this.parent = e;
}
const DB = new go({
  start: null,
  shift(i, e, t, r) {
    return e == Wu ? new lm(zu(r, 1) || "", i) : i;
  },
  reduce(i, e) {
    return e == RB && i ? i.parent : i;
  },
  reuse(i, e, t, r) {
    let s = e.type.id;
    return s == Wu || s == EB ? new lm(zu(r, 1) || "", i) : i;
  },
  strict: !1
}), MB = new qe((i, e) => {
  if (i.next == 60) {
    if (i.advance(), i.next == 47) {
      i.advance();
      let t = zu(i, 0);
      if (!t) return i.acceptToken(QB);
      if (e.context && t == e.context.name) return i.acceptToken(xB);
      for (let r = e.context; r; r = r.parent) if (r.name == t) return i.acceptToken(kB, -2);
      i.acceptToken(CB);
    } else if (i.next != 33 && i.next != 63)
      return i.acceptToken(Wu);
  }
}, { contextual: !0 });
function gd(i, e) {
  return new qe((t) => {
    let r = 0, s = e.charCodeAt(0);
    e: for (; !(t.next < 0); t.advance(), r++)
      if (t.next == s) {
        for (let n = 1; n < e.length; n++)
          if (t.peek(n) != e.charCodeAt(n)) continue e;
        break;
      }
    r && t.acceptToken(i);
  });
}
const BB = gd(PB, "-->"), qB = gd(TB, "?>"), XB = gd($B, "]]>"), IB = Jt({
  Text: C.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": C.angleBracket,
  TagName: C.tagName,
  "MismatchedCloseTag/TagName": [C.tagName, C.invalid],
  AttributeName: C.attributeName,
  AttributeValue: C.attributeValue,
  Is: C.definitionOperator,
  "EntityReference CharacterReference": C.character,
  Comment: C.blockComment,
  ProcessingInst: C.processingInstruction,
  DoctypeDecl: C.documentMeta,
  Cdata: C.special(C.string)
}), ZB = Gt.deserialize({
  version: 14,
  states: ",lOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DT'#DTOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C|'#C|O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C}'#C}O$dOrO,59^OOOP,59^,59^OOOS'#DO'#DOO$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6z-E6zOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6{-E6{OOOP1G.x1G.xOOOS-E6|-E6|OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'mO!bO,59eOOOO-E6w-E6wO'{OpO1G.uO'{OpO1G.uOOOP1G.u1G.uO(TOpO7+$fOOOP7+$f7+$fO(]O!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(hO#tO'#CnO(vO&jO'#CnOOOO1G.q1G.qO)UOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO)^O#tO,59YOOOO,59Y,59YOOOO'#C{'#C{O)lO&jO,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.tOOOO-E6y-E6y",
  stateData: ")z~OPQOSVOTWOVWOWWOXWOiXOyPO!QTO!SUO~OvZOx]O~O^`Oz^O~OPQOQcOSVOTWOVWOWWOXWOyPO!QTO!SUO~ORdO~P!SOteO!PgO~OuhO!RjO~O^lOz^O~OvZOxoO~O^qOz^O~O[vO`sOdwOz^O~ORyO~P!SO^{Oz^O~OteO!P}O~OuhO!R!PO~O^!QOz^O~O[!SOz^O~O[!VO`sOd!WOz^O~Oa!YOz^O~Oz^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oz^O~O[!_Oz^O~O[!aOz^O~O[!cO`sOd!dOz^O~O[!cO`sOd!dO~Oa!eOz^O~Oz^O{!gO}!hO~Oz^O[ma`madma~O[!kOz^O~O[!lOz^O~O[!mO`sOd!nO~OW!qOX!qO{!sO|!qO~OW!tOX!tO}!sO!O!tO~O[!vOz^O~OW!qOX!qO{!yO|!qO~OW!tOX!tO}!yO!O!tO~O",
  goto: "%cxPPPPPPPPPPyyP!PP!VPP!`!jP!pyyyP!v!|#S$[$k$q$w$}%TPPPP%ZXWORYbXRORYb_t`qru!T!U!bQ!i!YS!p!e!fR!w!oQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!j!oQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!j!]R!o!eQu`S!UqrU![u!U!bR!b!TQ!r!gR!x!rQ!u!hR!z!uQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: " StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 50,
  context: DB,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"],
    ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]
  ],
  propSources: [IB],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!)v~R!YOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs*vsv$qvw+fwx/ix}$q}!O0[!O!P$q!P!Q2z!Q![$q![!]4n!]!^$q!^!_8U!_!`!#t!`!a!$l!a!b!%d!b!c$q!c!}4n!}#P$q#P#Q!'W#Q#R$q#R#S4n#S#T$q#T#o4n#o%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U$q4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qi$zXVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qa%nVVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%gP&YTVPOv&Tw!^&T!_;'S&T;'S;=`&i<%lO&TP&lP;=`<%l&T`&tS!O`Ov&ox;'S&o;'S;=`'Q<%lO&o`'TP;=`<%l&oa'ZP;=`<%l%gX'eWVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^W(ST|WOr'}sv'}w;'S'};'S;=`(c<%lO'}W(fP;=`<%l'}X(lP;=`<%l'^h(vV|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oh)`P;=`<%l(oi)fP;=`<%l$qo)t`VP|W!O`zUOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk+PV{YVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%g~+iast,n![!]-r!c!}-r#R#S-r#T#o-r%W%o-r%p&a-r&b1p-r4U4d-r4e$IS-r$I`$Ib-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~,qQ!Q![,w#l#m-V~,zQ!Q![,w!]!^-Q~-VOX~~-YR!Q![-c!c!i-c#T#Z-c~-fS!Q![-c!]!^-Q!c!i-c#T#Z-c~-ug}!O-r!O!P-r!Q![-r![!]-r!]!^/^!c!}-r#R#S-r#T#o-r$}%O-r%W%o-r%p&a-r&b1p-r1p4U-r4U4d-r4e$IS-r$I`$Ib-r$Je$Jg-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~/cOW~~/fP;=`<%l-rk/rW}bVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^k0eZVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O1W!O!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk1aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a2S!a;'S$q;'S;=`)c<%lO$qk2_X!PQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qm3TZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a3v!a;'S$q;'S;=`)c<%lO$qm4RXdSVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo4{!P`S^QVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O4n!O!P4n!P!Q$q!Q![4n![!]4n!]!^$q!^!_(o!_!c$q!c!}4n!}#R$q#R#S4n#S#T$q#T#o4n#o$}$q$}%O4n%O%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U4n4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Je$q$Je$Jg4n$Jg$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qo8RP;=`<%l4ni8]Y|W!O`Oq(oqr8{rs&osv(owx'}x!a(o!a!b!#U!b;'S(o;'S;=`)]<%lO(oi9S_|W!O`Or(ors&osv(owx'}x}(o}!O:R!O!f(o!f!g;e!g!}(o!}#ODh#O#W(o#W#XLp#X;'S(o;'S;=`)]<%lO(oi:YX|W!O`Or(ors&osv(owx'}x}(o}!O:u!O;'S(o;'S;=`)]<%lO(oi;OV!QP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oi;lX|W!O`Or(ors&osv(owx'}x!q(o!q!r<X!r;'S(o;'S;=`)]<%lO(oi<`X|W!O`Or(ors&osv(owx'}x!e(o!e!f<{!f;'S(o;'S;=`)]<%lO(oi=SX|W!O`Or(ors&osv(owx'}x!v(o!v!w=o!w;'S(o;'S;=`)]<%lO(oi=vX|W!O`Or(ors&osv(owx'}x!{(o!{!|>c!|;'S(o;'S;=`)]<%lO(oi>jX|W!O`Or(ors&osv(owx'}x!r(o!r!s?V!s;'S(o;'S;=`)]<%lO(oi?^X|W!O`Or(ors&osv(owx'}x!g(o!g!h?y!h;'S(o;'S;=`)]<%lO(oi@QY|W!O`Or?yrs@psv?yvwA[wxBdx!`?y!`!aCr!a;'S?y;'S;=`Db<%lO?ya@uV!O`Ov@pvxA[x!`@p!`!aAy!a;'S@p;'S;=`B^<%lO@pPA_TO!`A[!`!aAn!a;'SA[;'S;=`As<%lOA[PAsOiPPAvP;=`<%lA[aBQSiP!O`Ov&ox;'S&o;'S;=`'Q<%lO&oaBaP;=`<%l@pXBiX|WOrBdrsA[svBdvwA[w!`Bd!`!aCU!a;'SBd;'S;=`Cl<%lOBdXC]TiP|WOr'}sv'}w;'S'};'S;=`(c<%lO'}XCoP;=`<%lBdiC{ViP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiDeP;=`<%l?yiDoZ|W!O`Or(ors&osv(owx'}x!e(o!e!fEb!f#V(o#V#WIr#W;'S(o;'S;=`)]<%lO(oiEiX|W!O`Or(ors&osv(owx'}x!f(o!f!gFU!g;'S(o;'S;=`)]<%lO(oiF]X|W!O`Or(ors&osv(owx'}x!c(o!c!dFx!d;'S(o;'S;=`)]<%lO(oiGPX|W!O`Or(ors&osv(owx'}x!v(o!v!wGl!w;'S(o;'S;=`)]<%lO(oiGsX|W!O`Or(ors&osv(owx'}x!c(o!c!dH`!d;'S(o;'S;=`)]<%lO(oiHgX|W!O`Or(ors&osv(owx'}x!}(o!}#OIS#O;'S(o;'S;=`)]<%lO(oiI]V|W!O`yPOr(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiIyX|W!O`Or(ors&osv(owx'}x#W(o#W#XJf#X;'S(o;'S;=`)]<%lO(oiJmX|W!O`Or(ors&osv(owx'}x#T(o#T#UKY#U;'S(o;'S;=`)]<%lO(oiKaX|W!O`Or(ors&osv(owx'}x#h(o#h#iK|#i;'S(o;'S;=`)]<%lO(oiLTX|W!O`Or(ors&osv(owx'}x#T(o#T#UH`#U;'S(o;'S;=`)]<%lO(oiLwX|W!O`Or(ors&osv(owx'}x#c(o#c#dMd#d;'S(o;'S;=`)]<%lO(oiMkX|W!O`Or(ors&osv(owx'}x#V(o#V#WNW#W;'S(o;'S;=`)]<%lO(oiN_X|W!O`Or(ors&osv(owx'}x#h(o#h#iNz#i;'S(o;'S;=`)]<%lO(oi! RX|W!O`Or(ors&osv(owx'}x#m(o#m#n! n#n;'S(o;'S;=`)]<%lO(oi! uX|W!O`Or(ors&osv(owx'}x#d(o#d#e!!b#e;'S(o;'S;=`)]<%lO(oi!!iX|W!O`Or(ors&osv(owx'}x#X(o#X#Y?y#Y;'S(o;'S;=`)]<%lO(oi!#_V!SP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(ok!$PXaQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo!$wX[UVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!%mZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!&`!a;'S$q;'S;=`)c<%lO$qk!&kX!RQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!'aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_#P$q#P#Q!(S#Q;'S$q;'S;=`)c<%lO$qk!(]ZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!)O!a;'S$q;'S;=`)c<%lO$qk!)ZXxQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$q",
  tokenizers: [MB, BB, qB, XB, 0, 1, 2, 3, 4],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function ma(i, e) {
  let t = e && e.getChild("TagName");
  return t ? i.sliceString(t.from, t.to) : "";
}
function Hc(i, e) {
  let t = e && e.firstChild;
  return !t || t.name != "OpenTag" ? "" : ma(i, t);
}
function WB(i, e, t) {
  let r = e && e.getChildren("Attribute").find((n) => n.from <= t && n.to >= t), s = r && r.getChild("AttributeName");
  return s ? i.sliceString(s.from, s.to) : "";
}
function Gc(i) {
  for (let e = i && i.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function zB(i, e) {
  var t;
  let r = xe(i).resolveInner(e, -1), s = null;
  for (let n = r; !s && n.parent; n = n.parent)
    (n.name == "OpenTag" || n.name == "CloseTag" || n.name == "SelfClosingTag" || n.name == "MismatchedCloseTag") && (s = n);
  if (s && (s.to > e || s.lastChild.type.isError)) {
    let n = s.parent;
    if (r.name == "TagName")
      return s.name == "CloseTag" || s.name == "MismatchedCloseTag" ? { type: "closeTag", from: r.from, context: n } : { type: "openTag", from: r.from, context: Gc(n) };
    if (r.name == "AttributeName")
      return { type: "attrName", from: r.from, context: s };
    if (r.name == "AttributeValue")
      return { type: "attrValue", from: r.from, context: s };
    let o = r == s || r.name == "Attribute" ? r.childBefore(e) : r;
    return o?.name == "StartTag" ? { type: "openTag", from: e, context: Gc(n) } : o?.name == "StartCloseTag" && o.to <= e ? { type: "closeTag", from: e, context: n } : o?.name == "Is" ? { type: "attrValue", from: e, context: s } : o ? { type: "attrName", from: e, context: s } : null;
  } else if (r.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: r.parent };
  for (; r.parent && r.to == e && !(!((t = r.lastChild) === null || t === void 0) && t.type.isError); )
    r = r.parent;
  return r.name == "Element" || r.name == "Text" || r.name == "Document" ? { type: "tag", from: e, context: r.name == "Element" ? r : Gc(r) } : null;
}
class VB {
  constructor(e, t, r) {
    this.attrs = t, this.attrValues = r, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((s) => ({ label: s, type: "text" })) : [];
  }
}
const Kc = /^[:\-\.\w\u00b7-\uffff]*$/;
function cm(i) {
  return Object.assign(Object.assign({ type: "property" }, i.completion || {}), { label: i.name });
}
function hm(i) {
  return typeof i == "string" ? { label: `"${i}"`, type: "constant" } : /^"/.test(i.label) ? i : Object.assign(Object.assign({}, i), { label: `"${i.label}"` });
}
function UB(i, e) {
  let t = [], r = [], s = /* @__PURE__ */ Object.create(null);
  for (let l of e) {
    let c = cm(l);
    t.push(c), l.global && r.push(c), l.values && (s[l.name] = l.values.map(hm));
  }
  let n = [], o = [], a = /* @__PURE__ */ Object.create(null);
  for (let l of i) {
    let c = r, h = s;
    l.attributes && (c = c.concat(l.attributes.map((d) => typeof d == "string" ? t.find((O) => O.label == d) || { label: d, type: "property" } : (d.values && (h == s && (h = Object.create(h)), h[d.name] = d.values.map(hm)), cm(d)))));
    let u = new VB(l, c, h);
    a[u.name] = u, n.push(u), l.top && o.push(u);
  }
  o.length || (o = n);
  for (let l = 0; l < n.length; l++) {
    let c = i[l], h = n[l];
    if (c.children)
      for (let u of c.children)
        a[u] && h.children.push(a[u]);
    else
      h.children = n;
  }
  return (l) => {
    var c;
    let { doc: h } = l.state, u = zB(l.state, l.pos);
    if (!u || u.type == "tag" && !l.explicit)
      return null;
    let { type: d, from: O, context: v } = u;
    if (d == "openTag") {
      let S = o, f = Hc(h, v);
      if (f) {
        let p = a[f];
        S = p?.children || n;
      }
      return {
        from: O,
        options: S.map((p) => p.completion),
        validFor: Kc
      };
    } else if (d == "closeTag") {
      let S = Hc(h, v);
      return S ? {
        from: O,
        to: l.pos + (h.sliceString(l.pos, l.pos + 1) == ">" ? 1 : 0),
        options: [((c = a[S]) === null || c === void 0 ? void 0 : c.closeNameCompletion) || { label: S + ">", type: "type" }],
        validFor: Kc
      } : null;
    } else if (d == "attrName") {
      let S = a[ma(h, v)];
      return {
        from: O,
        options: S?.attrs || r,
        validFor: Kc
      };
    } else if (d == "attrValue") {
      let S = WB(h, v, O);
      if (!S)
        return null;
      let f = a[ma(h, v)], p = (f?.attrValues || s)[S];
      return !p || !p.length ? null : {
        from: O,
        to: l.pos + (h.sliceString(l.pos, l.pos + 1) == '"' ? 1 : 0),
        options: p,
        validFor: /^"[^"]*"?$/
      };
    } else if (d == "tag") {
      let S = Hc(h, v), f = a[S], p = [], g = v && v.lastChild;
      S && (!g || g.name != "CloseTag" || ma(h, g) != S) && p.push(f ? f.closeCompletion : { label: "</" + S + ">", type: "type", boost: 2 });
      let m = p.concat((f?.children || (v ? n : o)).map((_) => _.openCompletion));
      if (v && f?.text.length) {
        let _ = v.firstChild;
        _.to > l.pos - 20 && !/\S/.test(l.state.sliceDoc(_.to, l.pos)) && (m = m.concat(f.text));
      }
      return {
        from: O,
        options: m,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
const Vu = /* @__PURE__ */ Ht.define({
  name: "xml",
  parser: /* @__PURE__ */ ZB.configure({
    props: [
      /* @__PURE__ */ bi.add({
        Element(i) {
          let e = /^\s*<\//.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        }
      }),
      /* @__PURE__ */ ei.add({
        Element(i) {
          let e = i.firstChild, t = i.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : i.to };
        }
      }),
      /* @__PURE__ */ qf.add({
        "OpenTag CloseTag": (i) => i.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function jB(i = {}) {
  let e = [Vu.data.of({
    autocomplete: UB(i.elements || [], i.attributes || [])
  })];
  return i.autoCloseTags !== !1 && e.push(NB), new Si(Vu, e);
}
function um(i, e, t = i.length) {
  if (!e)
    return "";
  let r = e.firstChild, s = r && r.getChild("TagName");
  return s ? i.sliceString(s.from, Math.min(s.to, t)) : "";
}
const NB = /* @__PURE__ */ K.inputHandler.of((i, e, t, r, s) => {
  if (i.composing || i.state.readOnly || e != t || r != ">" && r != "/" || !Vu.isActiveAt(i.state, e, -1))
    return !1;
  let n = s(), { state: o } = n, a = o.changeByRange((l) => {
    var c, h, u;
    let { head: d } = l, O = o.doc.sliceString(d - 1, d) == r, v = xe(o).resolveInner(d, -1), S;
    if (O && r == ">" && v.name == "EndTag") {
      let f = v.parent;
      if (((h = (c = f.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (S = um(o.doc, f.parent, d))) {
        let p = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0), g = `</${S}>`;
        return { range: l, changes: { from: d, to: p, insert: g } };
      }
    } else if (O && r == "/" && v.name == "StartCloseTag") {
      let f = v.parent;
      if (v.from == d - 2 && ((u = f.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (S = um(o.doc, f, d))) {
        let p = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0), g = `${S}>`;
        return {
          range: V.cursor(d + g.length, -1),
          changes: { from: d, to: p, insert: g }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    n,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), YB = Jt({
  String: C.string,
  Number: C.number,
  "True False": C.bool,
  PropertyName: C.propertyName,
  Null: C.null,
  ", :": C.separator,
  "[ ]": C.squareBracket,
  "{ }": C.brace
}), FB = Gt.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [YB],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), HB = /* @__PURE__ */ Ht.define({
  name: "json",
  parser: /* @__PURE__ */ FB.configure({
    props: [
      /* @__PURE__ */ bi.add({
        Object: /* @__PURE__ */ Cr({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ Cr({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ ei.add({
        "Object Array": ho
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function GB() {
  return new Si(HB);
}
function KB(i) {
  switch (i.split(".").pop()?.toLowerCase()) {
    case "js":
    case "ts":
    case "tsx":
    case "jsx":
    case "cjs":
    case "mjs":
    case "ejs":
    case "prisma":
      return K_();
    case "json":
      return GB();
    case "html":
    case "hbs":
      return Ub();
    case "css":
      return Mb();
    case "md":
      return ZL();
    case "xml":
      return jB();
    case "py":
      return NM();
    case "yml":
    case "yaml":
      return wB();
    case "sql":
      return RD();
    //case "hbs":
    //return handlebarsLanguage();
    default:
      return [];
  }
}
const JB = K.theme(
  {
    "&": {
      backgroundColor: "#030712",
      height: "100%",
      color: "#f5f5f5"
    },
    ".cm-content": {
      caretColor: "#f4f4f5"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: "#f4f4f5"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#3f3f46"
    },
    ".cm-gutters": {
      backgroundColor: "#030712",
      color: "#a3a3a3",
      border: "none"
    }
  },
  { dark: !0 }
), eq = K.theme(
  {
    "&": {
      backgroundColor: "#ffffff",
      height: "100%",
      color: "#1f2937"
    },
    ".cm-content": {
      caretColor: "#111827"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: "#111827"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#e5e7eb"
    },
    ".cm-gutters": {
      backgroundColor: "#f9fafb",
      color: "#9ca3af",
      border: "none"
    }
  },
  { dark: !1 }
), tq = xs.define([
  { tag: C.keyword, color: "#22d3ee" },
  { tag: [C.name, C.deleted, C.character, C.propertyName], color: "#f87171" },
  { tag: [C.variableName], color: "#e4e4e7" },
  { tag: [C.string, C.meta], color: "#86efac" },
  { tag: [C.function(C.variableName)], color: "#c4b5fd" },
  { tag: [C.number], color: "#facc15" },
  { tag: [C.comment], color: "#71717a", fontStyle: "italic" }
]), iq = xs.define([
  { tag: C.keyword, color: "#0ea5e9" },
  { tag: [C.name, C.deleted, C.character, C.propertyName], color: "#b91c1c" },
  { tag: [C.variableName], color: "#374151" },
  { tag: [C.string, C.meta], color: "#16a34a" },
  { tag: [C.function(C.variableName)], color: "#7c3aed" },
  { tag: [C.number], color: "#ca8a04" },
  { tag: [C.comment], color: "#6b7280", fontStyle: "italic" }
]);
function rq(i) {
  return [
    i === "dark" ? JB : eq,
    Bv(i === "dark" ? tq : iq)
  ];
}
var sq = /* @__PURE__ */ H('<div class="fixed z-50 inset-0 flex items-center justify-center"><svg class="m-auto h-12 w-12 animate-spin text-sky-800 dark:text-sky-100"xmlns=http://www.w3.org/2000/svg fill=none viewBox="0 0 24 24"><circle class=opacity-25 cx=12 cy=12 r=10 stroke=currentColor stroke-width=4></circle><path class=opacity-75 fill=currentColor d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">');
const md = () => sq(), [nq, fm] = se([]);
let oq = 0;
function dm(i, e = "info", t = 3e3) {
  const r = ++oq;
  fm((s) => [...s, { id: r, message: i, type: e }]), setTimeout(() => {
    fm((s) => s.filter((n) => n.id !== r));
  }, t);
}
var aq = /* @__PURE__ */ H('<div class="bg-gray-950 h-screen flex flex-col overflow-auto relative"><div class="h-full w-full">'), lq = /* @__PURE__ */ H('<p class="text-red-600 p-4">');
const cq = (i) => {
  let e, t = null;
  const [r, s] = se(null), [n, o] = se(""), [a, l] = se(!1), [c, h] = se(!1), [u, d] = se(""), O = (m) => {
    t && (t.destroy(), t = null);
    const _ = i.theme === "light" ? "light" : "dark", b = ve.create({
      doc: m,
      extensions: [z2, KB(i.filePath), ...rq(_), K.lineWrapping, K.updateListener.of((w) => {
        w.docChanged && o(w.state.doc.toString());
      })]
    });
    t = new K({
      state: b,
      parent: e
    });
  }, v = async () => {
    l(!0);
    try {
      const m = new FormData();
      m.append(i.param ? i.param : "filePath", i.filePath);
      const _ = await rr.post("/file/read", m);
      if (!_.data?.data) throw new Error("Failed to load file");
      const b = _.data.data;
      o(b), O(b);
    } catch (m) {
      d(m.message);
    } finally {
      l(!1);
    }
  }, S = async () => {
    h(!0);
    try {
      const m = new FormData();
      if (i.param = i.param ? i.param : "filePath", m.append(i.param ? i.param : "filePath", i.filePath), i.param !== "filePath") throw new Error("Only internal file from the server can be save");
      if (m.append("content", n()), !(await rr.post("/file/write", m)).data.success) throw new Error("Failed to save file");
      dm("File saved successfully.", "success");
    } catch (m) {
      dm("Error saving file: " + m.message, "error");
    } finally {
      h(!1);
    }
  }, f = (m) => {
    e?.contains(m.target) && (m.preventDefault(), s({
      x: m.clientX,
      y: m.clientY
    }));
  }, p = () => s(null), g = (m) => {
    (m.ctrlKey || m.metaKey) && m.key.toLowerCase() === "s" && (m.preventDefault(), S());
  };
  return Di(() => {
    window.addEventListener("contextmenu", f), window.addEventListener("click", p), window.addEventListener("keydown", g);
  }), Di(v), Yn(() => {
    v();
  }), ft(() => {
    t?.destroy(), window.removeEventListener("contextmenu", f), window.removeEventListener("click", p), window.removeEventListener("keydown", g);
  }), (() => {
    var m = aq(), _ = m.firstChild;
    X(m, (() => {
      var w = bt(() => !!a());
      return () => w() && Z(md, {});
    })(), _), X(m, (() => {
      var w = bt(() => !!u());
      return () => w() && (() => {
        var x = lq();
        return X(x, u), x;
      })();
    })(), _);
    var b = e;
    return typeof b == "function" ? Tr(b, _) : e = _, m;
  })();
};
var hq = /* @__PURE__ */ H('<input class="border border-neutral-300 rounded px-1"autofocus>'), uq = /* @__PURE__ */ H('<div class=ml-2><div class=cursor-pointer></div><div class="pl-3 border-l border-gray-300 dark:border-gray-900 transition-all duration-200 origin-top">'), fq = /* @__PURE__ */ H('<div class="inline-flex items-center max-w-[220px] truncate whitespace-nowrap overflow-hidden">&nbsp;<span class=truncate>'), dq = /* @__PURE__ */ H('<div id=context-menu class="fixed min-w-[140px] border shadow-md rounded p-2 z-50"><div class="text-sm font-semibold"></div><div class="text-xs mb-2"></div><div class="text-sm text-yellow-500 hover:underline cursor-pointer">Open</div><div class="text-sm text-red-500 hover:underline cursor-pointer mt-1">Delete'), Oq = /* @__PURE__ */ H("<div class=relative>"), pq = /* @__PURE__ */ H("<div>Loading..."), gq = /* @__PURE__ */ H("<div>No files found.");
const by = (i) => {
  const [e, t] = se(!1), [r, s] = se(!1), [n, o] = se(i.file.name), a = i.file.isDirectory && i.file.children.length > 0, l = () => {
    a && t(!e());
  }, c = async () => {
    n(), i.file.name, s(!1);
  };
  return (() => {
    var h = uq(), u = h.firstChild, d = u.nextSibling;
    return u.$$dblclick = () => s(!0), u.$$contextmenu = (O) => i.onContextMenu(O, i.file), u.$$click = () => a ? l() : i.onSelect(i.file.path), X(u, Z($e, {
      get when() {
        return r();
      },
      get fallback() {
        return (() => {
          var O = fq(), v = O.firstChild, S = v.nextSibling;
          return X(O, () => a ? e() ? "" : "" : "", v), X(S, () => i.file.name), O;
        })();
      },
      get children() {
        var O = hq();
        return O.$$keydown = (v) => {
          v.key === "Enter" && (v.preventDefault(), c());
        }, O.addEventListener("blur", c), O.$$input = (v) => o(v.currentTarget.value), Oe(() => O.value = n()), O;
      }
    })), X(d, Z(_t, {
      get each() {
        return i.file.children;
      },
      children: (O) => Z(by, {
        file: O,
        get onSelect() {
          return i.onSelect;
        },
        get onContextMenu() {
          return i.onContextMenu;
        }
      })
    })), Oe((O) => (O = e() ? "block" : "none") != null ? d.style.setProperty("display", O) : d.style.removeProperty("display")), h;
  })();
};
function mq(i) {
  const [e, t] = se([]), [r, s] = se({
    x: 0,
    y: 0,
    file: null,
    visible: !1
  }), n = async () => {
    const h = await rr.get("file/list?directory=/var/www/webapps/project-board&recursive=false");
    if (!h.data) throw new Error("Failed to load files");
    t(h.data);
  }, o = (c, h) => {
    c.preventDefault();
    const d = c.currentTarget.getBoundingClientRect();
    s({
      x: d.left,
      y: d.bottom,
      file: h,
      visible: !0
    });
  }, a = () => {
    s((c) => ({
      ...c,
      visible: !1
    }));
  }, l = (c) => {
    c.target.closest("#context-menu") || a();
  };
  return Di(() => {
    n(), document.addEventListener("click", l), ft(() => document.removeEventListener("click", l));
  }), Yn(() => {
    n();
  }), (() => {
    var c = Oq();
    return X(c, Z($e, {
      get when() {
        return e();
      },
      get fallback() {
        return pq();
      },
      get children() {
        return Z(_t, {
          get each() {
            return e();
          },
          get fallback() {
            return gq();
          },
          children: (h) => Z(by, {
            file: h,
            get onSelect() {
              return i.onFileSelect;
            },
            onContextMenu: o
          })
        });
      }
    }), null), X(c, Z($e, {
      get when() {
        return bt(() => !!r().visible)() && r().file;
      },
      get children() {
        var h = dq(), u = h.firstChild, d = u.nextSibling, O = d.nextSibling, v = O.nextSibling;
        return X(u, () => r().file?.name), X(d, () => r().file?.type === "folder" ? " Folder" : " File"), O.$$click = () => {
          i.onFileSelect(r().file.path), a();
        }, v.$$click = () => {
          alert(`Delete ${r().file.name} (not implemented)`), a();
        }, Oe((S) => {
          var f = `${r().y}px`, p = `${r().x}px`;
          return f !== S.e && ((S.e = f) != null ? h.style.setProperty("top", f) : h.style.removeProperty("top")), p !== S.t && ((S.t = p) != null ? h.style.setProperty("left", p) : h.style.removeProperty("left")), S;
        }, {
          e: void 0,
          t: void 0
        }), h;
      }
    }), null), c;
  })();
}
dt(["click", "contextmenu", "dblclick", "input", "keydown"]);
const Om = (i, e) => {
  let t = !1, r, s;
  const n = (...a) => {
    s = a, !t && (t = !0, r = setTimeout(() => {
      i(...s), t = !1;
    }, e));
  }, o = () => {
    clearTimeout(r), t = !1;
  };
  return Fn() && ft(o), Object.assign(n, { clear: o });
}, Sa = window, as = Sa.navigator, fn = as.userAgent, pm = /* @__PURE__ */ /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(fn);
Sa.opr && Sa.opr.addons || Sa.opera;
as.vendor && as.vendor.includes("Apple") && fn && !fn.includes("CriOS") && fn.includes("FxiOS");
as.brave && as.brave.isBrave && as.brave.isBrave.name;
var Sq = /* @__PURE__ */ H('<span class="h-1 w-1 rounded-full bg-gray-900 dark:bg-gray-300 dark:group-hover:bg-sky-200">'), vq = /* @__PURE__ */ H('<div class="hover:bg-sky-500 dark:hover:bg-sky-600 flex items-center justify-center gap-2 border-gray-200 dark:border-gray-900"><div>');
const Jc = (i) => (() => {
  var e = Sq();
  return Oe((t) => pn(e, {
    "bg-sky-200": i.isDragging,
    "dark:bg-sky-200": i.isDragging
  }, t)), e;
})(), _q = (i) => {
  const [e, t] = se(!1), r = () => t(!0), s = () => t(!1), n = Om((l) => {
    i.onResize(l.clientX, l.clientY);
  }, 10), o = Om((l) => {
    const c = l.touches[0];
    i.onResize(c.clientX, c.clientY);
  }, 10), a = (l) => {
    i.ref(l), l.addEventListener("mousedown", r, {
      passive: !0
    }), l.addEventListener("touchstart", r, {
      passive: !0
    }), ft(() => {
      l.removeEventListener("mousedown", r), l.removeEventListener("touchstart", r);
    });
  };
  return Yn(() => {
    e() ? (pm && document.querySelectorAll("iframe").forEach((l) => l.style.pointerEvents = "none"), window.addEventListener("mousemove", n), window.addEventListener("mouseup", s), window.addEventListener("touchmove", o), window.addEventListener("touchend", s)) : (pm && document.querySelectorAll("iframe").forEach((l) => l.style.pointerEvents = ""), window.removeEventListener("mousemove", n), window.removeEventListener("mouseup", s), window.removeEventListener("touchmove", o), window.removeEventListener("touchend", s));
  }), (() => {
    var l = vq(), c = l.firstChild;
    return Tr(a, l), X(l, Z(Jc, {
      get isDragging() {
        return e();
      }
    }), null), X(l, Z(Jc, {
      get isDragging() {
        return e();
      }
    }), null), X(l, Z(Jc, {
      get isDragging() {
        return e();
      }
    }), null), Oe((h) => {
      var u = {
        "bg-brand-default dark:bg-brand-default": e(),
        "bg-gray-100 dark:bg-gray-950/50": !e(),
        "flex-col cursor-col-resize border-l-1 border-r-1 w-[12px]": !i.isHorizontal,
        "flex-row cursor-row-resize border-t-1 border-b-1 h-[12px]": i.isHorizontal
      }, d = {
        "fixed inset-0 z-10": e(),
        hidden: !e(),
        "cursor-col-resize": !i.isHorizontal,
        "cursor-row-resize": i.isHorizontal
      };
      return h.e = pn(l, u, h.e), h.t = pn(c, d, h.t), h;
    }, {
      e: void 0,
      t: void 0
    }), l;
  })();
};
var eh = { exports: {} }, gm;
function bq() {
  return gm || (gm = 1, function(i, e) {
    (function(t, r) {
      i.exports = r();
    })(self, () => (() => {
      var t = { 4567: function(o, a, l) {
        var c = this && this.__decorate || function(m, _, b, w) {
          var x, y = arguments.length, k = y < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, b) : w;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(m, _, b, w);
          else for (var $ = m.length - 1; $ >= 0; $--) (x = m[$]) && (k = (y < 3 ? x(k) : y > 3 ? x(_, b, k) : x(_, b)) || k);
          return y > 3 && k && Object.defineProperty(_, b, k), k;
        }, h = this && this.__param || function(m, _) {
          return function(b, w) {
            _(b, w, m);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.AccessibilityManager = void 0;
        const u = l(9042), d = l(6114), O = l(9924), v = l(844), S = l(5596), f = l(4725), p = l(3656);
        let g = a.AccessibilityManager = class extends v.Disposable {
          constructor(m, _) {
            super(), this._terminal = m, this._renderService = _, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
            for (let b = 0; b < this._terminal.rows; b++) this._rowElements[b] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[b]);
            if (this._topBoundaryFocusListener = (b) => this._handleBoundaryFocus(b, 0), this._bottomBoundaryFocusListener = (b) => this._handleBoundaryFocus(b, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new O.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
            this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((b) => this._handleResize(b.rows))), this.register(this._terminal.onRender((b) => this._refreshRows(b.start, b.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((b) => this._handleChar(b))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab((b) => this._handleTab(b))), this.register(this._terminal.onKey((b) => this._handleKey(b.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new S.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, p.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, v.toDisposable)(() => {
              this._accessibilityContainer.remove(), this._rowElements.length = 0;
            }));
          }
          _handleTab(m) {
            for (let _ = 0; _ < m; _++) this._handleChar(" ");
          }
          _handleChar(m) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== m && (this._charsToAnnounce += m) : this._charsToAnnounce += m, m === `
` && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += u.tooMuchOutput)), d.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
              this._accessibilityContainer.appendChild(this._liveRegion);
            }, 0));
          }
          _clearLiveRegion() {
            this._liveRegion.textContent = "", this._liveRegionLineCount = 0, d.isMac && this._liveRegion.remove();
          }
          _handleKey(m) {
            this._clearLiveRegion(), /\p{Control}/u.test(m) || this._charsToConsume.push(m);
          }
          _refreshRows(m, _) {
            this._liveRegionDebouncer.refresh(m, _, this._terminal.rows);
          }
          _renderRows(m, _) {
            const b = this._terminal.buffer, w = b.lines.length.toString();
            for (let x = m; x <= _; x++) {
              const y = b.translateBufferLineToString(b.ydisp + x, !0), k = (b.ydisp + x + 1).toString(), $ = this._rowElements[x];
              $ && (y.length === 0 ? $.innerText = "" : $.textContent = y, $.setAttribute("aria-posinset", k), $.setAttribute("aria-setsize", w));
            }
            this._announceCharacters();
          }
          _announceCharacters() {
            this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
          }
          _handleBoundaryFocus(m, _) {
            const b = m.target, w = this._rowElements[_ === 0 ? 1 : this._rowElements.length - 2];
            if (b.getAttribute("aria-posinset") === (_ === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || m.relatedTarget !== w) return;
            let x, y;
            if (_ === 0 ? (x = b, y = this._rowElements.pop(), this._rowContainer.removeChild(y)) : (x = this._rowElements.shift(), y = b, this._rowContainer.removeChild(x)), x.removeEventListener("focus", this._topBoundaryFocusListener), y.removeEventListener("focus", this._bottomBoundaryFocusListener), _ === 0) {
              const k = this._createAccessibilityTreeNode();
              this._rowElements.unshift(k), this._rowContainer.insertAdjacentElement("afterbegin", k);
            } else {
              const k = this._createAccessibilityTreeNode();
              this._rowElements.push(k), this._rowContainer.appendChild(k);
            }
            this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(_ === 0 ? -1 : 1), this._rowElements[_ === 0 ? 1 : this._rowElements.length - 2].focus(), m.preventDefault(), m.stopImmediatePropagation();
          }
          _handleResize(m) {
            this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
            for (let _ = this._rowContainer.children.length; _ < this._terminal.rows; _++) this._rowElements[_] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[_]);
            for (; this._rowElements.length > m; ) this._rowContainer.removeChild(this._rowElements.pop());
            this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
          }
          _createAccessibilityTreeNode() {
            const m = document.createElement("div");
            return m.setAttribute("role", "listitem"), m.tabIndex = -1, this._refreshRowDimensions(m), m;
          }
          _refreshRowsDimensions() {
            if (this._renderService.dimensions.css.cell.height) {
              this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
              for (let m = 0; m < this._terminal.rows; m++) this._refreshRowDimensions(this._rowElements[m]);
            }
          }
          _refreshRowDimensions(m) {
            m.style.height = `${this._renderService.dimensions.css.cell.height}px`;
          }
        };
        a.AccessibilityManager = g = c([h(1, f.IRenderService)], g);
      }, 3614: (o, a) => {
        function l(d) {
          return d.replace(/\r?\n/g, "\r");
        }
        function c(d, O) {
          return O ? "\x1B[200~" + d + "\x1B[201~" : d;
        }
        function h(d, O, v, S) {
          d = c(d = l(d), v.decPrivateModes.bracketedPasteMode && S.rawOptions.ignoreBracketedPasteMode !== !0), v.triggerDataEvent(d, !0), O.value = "";
        }
        function u(d, O, v) {
          const S = v.getBoundingClientRect(), f = d.clientX - S.left - 10, p = d.clientY - S.top - 10;
          O.style.width = "20px", O.style.height = "20px", O.style.left = `${f}px`, O.style.top = `${p}px`, O.style.zIndex = "1000", O.focus();
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.rightClickHandler = a.moveTextAreaUnderMouseCursor = a.paste = a.handlePasteEvent = a.copyHandler = a.bracketTextForPaste = a.prepareTextForTerminal = void 0, a.prepareTextForTerminal = l, a.bracketTextForPaste = c, a.copyHandler = function(d, O) {
          d.clipboardData && d.clipboardData.setData("text/plain", O.selectionText), d.preventDefault();
        }, a.handlePasteEvent = function(d, O, v, S) {
          d.stopPropagation(), d.clipboardData && h(d.clipboardData.getData("text/plain"), O, v, S);
        }, a.paste = h, a.moveTextAreaUnderMouseCursor = u, a.rightClickHandler = function(d, O, v, S, f) {
          u(d, O, v), f && S.rightClickSelect(d), O.value = S.selectionText, O.select();
        };
      }, 7239: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorContrastCache = void 0;
        const c = l(1505);
        a.ColorContrastCache = class {
          constructor() {
            this._color = new c.TwoKeyMap(), this._css = new c.TwoKeyMap();
          }
          setCss(h, u, d) {
            this._css.set(h, u, d);
          }
          getCss(h, u) {
            return this._css.get(h, u);
          }
          setColor(h, u, d) {
            this._color.set(h, u, d);
          }
          getColor(h, u) {
            return this._color.get(h, u);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 3656: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.addDisposableDomListener = void 0, a.addDisposableDomListener = function(l, c, h, u) {
          l.addEventListener(c, h, u);
          let d = !1;
          return { dispose: () => {
            d || (d = !0, l.removeEventListener(c, h, u));
          } };
        };
      }, 6465: function(o, a, l) {
        var c = this && this.__decorate || function(f, p, g, m) {
          var _, b = arguments.length, w = b < 3 ? p : m === null ? m = Object.getOwnPropertyDescriptor(p, g) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(f, p, g, m);
          else for (var x = f.length - 1; x >= 0; x--) (_ = f[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(p, g, w) : _(p, g)) || w);
          return b > 3 && w && Object.defineProperty(p, g, w), w;
        }, h = this && this.__param || function(f, p) {
          return function(g, m) {
            p(g, m, f);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Linkifier2 = void 0;
        const u = l(3656), d = l(8460), O = l(844), v = l(2585);
        let S = a.Linkifier2 = class extends O.Disposable {
          get currentLink() {
            return this._currentLink;
          }
          constructor(f) {
            super(), this._bufferService = f, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new d.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new d.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, O.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, O.toDisposable)(() => {
              this._lastMouseEvent = void 0;
            })), this.register(this._bufferService.onResize(() => {
              this._clearCurrentLink(), this._wasResized = !0;
            }));
          }
          registerLinkProvider(f) {
            return this._linkProviders.push(f), { dispose: () => {
              const p = this._linkProviders.indexOf(f);
              p !== -1 && this._linkProviders.splice(p, 1);
            } };
          }
          attachToDom(f, p, g) {
            this._element = f, this._mouseService = p, this._renderService = g, this.register((0, u.addDisposableDomListener)(this._element, "mouseleave", () => {
              this._isMouseOut = !0, this._clearCurrentLink();
            })), this.register((0, u.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, u.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, u.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
          }
          _handleMouseMove(f) {
            if (this._lastMouseEvent = f, !this._element || !this._mouseService) return;
            const p = this._positionFromMouseEvent(f, this._element, this._mouseService);
            if (!p) return;
            this._isMouseOut = !1;
            const g = f.composedPath();
            for (let m = 0; m < g.length; m++) {
              const _ = g[m];
              if (_.classList.contains("xterm")) break;
              if (_.classList.contains("xterm-hover")) return;
            }
            this._lastBufferCell && p.x === this._lastBufferCell.x && p.y === this._lastBufferCell.y || (this._handleHover(p), this._lastBufferCell = p);
          }
          _handleHover(f) {
            if (this._activeLine !== f.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(f, !1), void (this._wasResized = !1);
            this._currentLink && this._linkAtPosition(this._currentLink.link, f) || (this._clearCurrentLink(), this._askForLink(f, !0));
          }
          _askForLink(f, p) {
            var g, m;
            this._activeProviderReplies && p || ((g = this._activeProviderReplies) === null || g === void 0 || g.forEach((b) => {
              b?.forEach((w) => {
                w.link.dispose && w.link.dispose();
              });
            }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = f.y);
            let _ = !1;
            for (const [b, w] of this._linkProviders.entries()) p ? !((m = this._activeProviderReplies) === null || m === void 0) && m.get(b) && (_ = this._checkLinkProviderResult(b, f, _)) : w.provideLinks(f.y, (x) => {
              var y, k;
              if (this._isMouseOut) return;
              const $ = x?.map((R) => ({ link: R }));
              (y = this._activeProviderReplies) === null || y === void 0 || y.set(b, $), _ = this._checkLinkProviderResult(b, f, _), ((k = this._activeProviderReplies) === null || k === void 0 ? void 0 : k.size) === this._linkProviders.length && this._removeIntersectingLinks(f.y, this._activeProviderReplies);
            });
          }
          _removeIntersectingLinks(f, p) {
            const g = /* @__PURE__ */ new Set();
            for (let m = 0; m < p.size; m++) {
              const _ = p.get(m);
              if (_) for (let b = 0; b < _.length; b++) {
                const w = _[b], x = w.link.range.start.y < f ? 0 : w.link.range.start.x, y = w.link.range.end.y > f ? this._bufferService.cols : w.link.range.end.x;
                for (let k = x; k <= y; k++) {
                  if (g.has(k)) {
                    _.splice(b--, 1);
                    break;
                  }
                  g.add(k);
                }
              }
            }
          }
          _checkLinkProviderResult(f, p, g) {
            var m;
            if (!this._activeProviderReplies) return g;
            const _ = this._activeProviderReplies.get(f);
            let b = !1;
            for (let w = 0; w < f; w++) this._activeProviderReplies.has(w) && !this._activeProviderReplies.get(w) || (b = !0);
            if (!b && _) {
              const w = _.find((x) => this._linkAtPosition(x.link, p));
              w && (g = !0, this._handleNewLink(w));
            }
            if (this._activeProviderReplies.size === this._linkProviders.length && !g) for (let w = 0; w < this._activeProviderReplies.size; w++) {
              const x = (m = this._activeProviderReplies.get(w)) === null || m === void 0 ? void 0 : m.find((y) => this._linkAtPosition(y.link, p));
              if (x) {
                g = !0, this._handleNewLink(x);
                break;
              }
            }
            return g;
          }
          _handleMouseDown() {
            this._mouseDownLink = this._currentLink;
          }
          _handleMouseUp(f) {
            if (!this._element || !this._mouseService || !this._currentLink) return;
            const p = this._positionFromMouseEvent(f, this._element, this._mouseService);
            p && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, p) && this._currentLink.link.activate(f, this._currentLink.link.text);
          }
          _clearCurrentLink(f, p) {
            this._element && this._currentLink && this._lastMouseEvent && (!f || !p || this._currentLink.link.range.start.y >= f && this._currentLink.link.range.end.y <= p) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, O.disposeArray)(this._linkCacheDisposables));
          }
          _handleNewLink(f) {
            if (!this._element || !this._lastMouseEvent || !this._mouseService) return;
            const p = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
            p && this._linkAtPosition(f.link, p) && (this._currentLink = f, this._currentLink.state = { decorations: { underline: f.link.decorations === void 0 || f.link.decorations.underline, pointerCursor: f.link.decorations === void 0 || f.link.decorations.pointerCursor }, isHovered: !0 }, this._linkHover(this._element, f.link, this._lastMouseEvent), f.link.decorations = {}, Object.defineProperties(f.link.decorations, { pointerCursor: { get: () => {
              var g, m;
              return (m = (g = this._currentLink) === null || g === void 0 ? void 0 : g.state) === null || m === void 0 ? void 0 : m.decorations.pointerCursor;
            }, set: (g) => {
              var m, _;
              !((m = this._currentLink) === null || m === void 0) && m.state && this._currentLink.state.decorations.pointerCursor !== g && (this._currentLink.state.decorations.pointerCursor = g, this._currentLink.state.isHovered && ((_ = this._element) === null || _ === void 0 || _.classList.toggle("xterm-cursor-pointer", g)));
            } }, underline: { get: () => {
              var g, m;
              return (m = (g = this._currentLink) === null || g === void 0 ? void 0 : g.state) === null || m === void 0 ? void 0 : m.decorations.underline;
            }, set: (g) => {
              var m, _, b;
              !((m = this._currentLink) === null || m === void 0) && m.state && ((b = (_ = this._currentLink) === null || _ === void 0 ? void 0 : _.state) === null || b === void 0 ? void 0 : b.decorations.underline) !== g && (this._currentLink.state.decorations.underline = g, this._currentLink.state.isHovered && this._fireUnderlineEvent(f.link, g));
            } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((g) => {
              if (!this._currentLink) return;
              const m = g.start === 0 ? 0 : g.start + 1 + this._bufferService.buffer.ydisp, _ = this._bufferService.buffer.ydisp + 1 + g.end;
              if (this._currentLink.link.range.start.y >= m && this._currentLink.link.range.end.y <= _ && (this._clearCurrentLink(m, _), this._lastMouseEvent && this._element)) {
                const b = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                b && this._askForLink(b, !1);
              }
            })));
          }
          _linkHover(f, p, g) {
            var m;
            !((m = this._currentLink) === null || m === void 0) && m.state && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(p, !0), this._currentLink.state.decorations.pointerCursor && f.classList.add("xterm-cursor-pointer")), p.hover && p.hover(g, p.text);
          }
          _fireUnderlineEvent(f, p) {
            const g = f.range, m = this._bufferService.buffer.ydisp, _ = this._createLinkUnderlineEvent(g.start.x - 1, g.start.y - m - 1, g.end.x, g.end.y - m - 1, void 0);
            (p ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(_);
          }
          _linkLeave(f, p, g) {
            var m;
            !((m = this._currentLink) === null || m === void 0) && m.state && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(p, !1), this._currentLink.state.decorations.pointerCursor && f.classList.remove("xterm-cursor-pointer")), p.leave && p.leave(g, p.text);
          }
          _linkAtPosition(f, p) {
            const g = f.range.start.y * this._bufferService.cols + f.range.start.x, m = f.range.end.y * this._bufferService.cols + f.range.end.x, _ = p.y * this._bufferService.cols + p.x;
            return g <= _ && _ <= m;
          }
          _positionFromMouseEvent(f, p, g) {
            const m = g.getCoords(f, p, this._bufferService.cols, this._bufferService.rows);
            if (m) return { x: m[0], y: m[1] + this._bufferService.buffer.ydisp };
          }
          _createLinkUnderlineEvent(f, p, g, m, _) {
            return { x1: f, y1: p, x2: g, y2: m, cols: this._bufferService.cols, fg: _ };
          }
        };
        a.Linkifier2 = S = c([h(0, v.IBufferService)], S);
      }, 9042: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.tooMuchOutput = a.promptLabel = void 0, a.promptLabel = "Terminal input", a.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
      }, 3730: function(o, a, l) {
        var c = this && this.__decorate || function(S, f, p, g) {
          var m, _ = arguments.length, b = _ < 3 ? f : g === null ? g = Object.getOwnPropertyDescriptor(f, p) : g;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") b = Reflect.decorate(S, f, p, g);
          else for (var w = S.length - 1; w >= 0; w--) (m = S[w]) && (b = (_ < 3 ? m(b) : _ > 3 ? m(f, p, b) : m(f, p)) || b);
          return _ > 3 && b && Object.defineProperty(f, p, b), b;
        }, h = this && this.__param || function(S, f) {
          return function(p, g) {
            f(p, g, S);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkProvider = void 0;
        const u = l(511), d = l(2585);
        let O = a.OscLinkProvider = class {
          constructor(S, f, p) {
            this._bufferService = S, this._optionsService = f, this._oscLinkService = p;
          }
          provideLinks(S, f) {
            var p;
            const g = this._bufferService.buffer.lines.get(S - 1);
            if (!g) return void f(void 0);
            const m = [], _ = this._optionsService.rawOptions.linkHandler, b = new u.CellData(), w = g.getTrimmedLength();
            let x = -1, y = -1, k = !1;
            for (let $ = 0; $ < w; $++) if (y !== -1 || g.hasContent($)) {
              if (g.loadCell($, b), b.hasExtendedAttrs() && b.extended.urlId) {
                if (y === -1) {
                  y = $, x = b.extended.urlId;
                  continue;
                }
                k = b.extended.urlId !== x;
              } else y !== -1 && (k = !0);
              if (k || y !== -1 && $ === w - 1) {
                const R = (p = this._oscLinkService.getLinkData(x)) === null || p === void 0 ? void 0 : p.uri;
                if (R) {
                  const T = { start: { x: y + 1, y: S }, end: { x: $ + (k || $ !== w - 1 ? 0 : 1), y: S } };
                  let A = !1;
                  if (!_?.allowNonHttpProtocols) try {
                    const M = new URL(R);
                    ["http:", "https:"].includes(M.protocol) || (A = !0);
                  } catch {
                    A = !0;
                  }
                  A || m.push({ text: R, range: T, activate: (M, B) => _ ? _.activate(M, B, T) : v(0, B), hover: (M, B) => {
                    var W;
                    return (W = _?.hover) === null || W === void 0 ? void 0 : W.call(_, M, B, T);
                  }, leave: (M, B) => {
                    var W;
                    return (W = _?.leave) === null || W === void 0 ? void 0 : W.call(_, M, B, T);
                  } });
                }
                k = !1, b.hasExtendedAttrs() && b.extended.urlId ? (y = $, x = b.extended.urlId) : (y = -1, x = -1);
              }
            }
            f(m);
          }
        };
        function v(S, f) {
          if (confirm(`Do you want to navigate to ${f}?

WARNING: This link could potentially be dangerous`)) {
            const p = window.open();
            if (p) {
              try {
                p.opener = null;
              } catch {
              }
              p.location.href = f;
            } else console.warn("Opening link blocked as opener could not be cleared");
          }
        }
        a.OscLinkProvider = O = c([h(0, d.IBufferService), h(1, d.IOptionsService), h(2, d.IOscLinkService)], O);
      }, 6193: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderDebouncer = void 0, a.RenderDebouncer = class {
          constructor(l, c) {
            this._parentWindow = l, this._renderCallback = c, this._refreshCallbacks = [];
          }
          dispose() {
            this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
          }
          addRefreshCallback(l) {
            return this._refreshCallbacks.push(l), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
          }
          refresh(l, c, h) {
            this._rowCount = h, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return void this._runRefreshCallbacks();
            const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c), this._runRefreshCallbacks();
          }
          _runRefreshCallbacks() {
            for (const l of this._refreshCallbacks) l(0);
            this._refreshCallbacks = [];
          }
        };
      }, 5596: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ScreenDprMonitor = void 0;
        const c = l(844);
        class h extends c.Disposable {
          constructor(d) {
            super(), this._parentWindow = d, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, c.toDisposable)(() => {
              this.clearListener();
            }));
          }
          setListener(d) {
            this._listener && this.clearListener(), this._listener = d, this._outerListener = () => {
              this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
            }, this._updateDpr();
          }
          _updateDpr() {
            var d;
            this._outerListener && ((d = this._resolutionMediaMatchList) === null || d === void 0 || d.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
          }
          clearListener() {
            this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
          }
        }
        a.ScreenDprMonitor = h;
      }, 3236: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Terminal = void 0;
        const c = l(3614), h = l(3656), u = l(6465), d = l(9042), O = l(3730), v = l(1680), S = l(3107), f = l(5744), p = l(2950), g = l(1296), m = l(428), _ = l(4269), b = l(5114), w = l(8934), x = l(3230), y = l(9312), k = l(4725), $ = l(6731), R = l(8055), T = l(8969), A = l(8460), M = l(844), B = l(6114), W = l(8437), z = l(2584), Q = l(7399), E = l(5941), L = l(9074), D = l(2585), U = l(5435), Y = l(4567), ne = typeof window < "u" ? window.document : null;
        class te extends T.CoreTerminal {
          get onFocus() {
            return this._onFocus.event;
          }
          get onBlur() {
            return this._onBlur.event;
          }
          get onA11yChar() {
            return this._onA11yCharEmitter.event;
          }
          get onA11yTab() {
            return this._onA11yTabEmitter.event;
          }
          get onWillOpen() {
            return this._onWillOpen.event;
          }
          constructor(P = {}) {
            super(P), this.browser = B, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._accessibilityManager = this.register(new M.MutableDisposable()), this._onCursorMove = this.register(new A.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new A.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new A.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new A.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new A.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new A.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new A.EventEmitter()), this._onBlur = this.register(new A.EventEmitter()), this._onA11yCharEmitter = this.register(new A.EventEmitter()), this._onA11yTabEmitter = this.register(new A.EventEmitter()), this._onWillOpen = this.register(new A.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(u.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(O.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(L.DecorationService), this._instantiationService.setService(D.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((q, N) => this.refresh(q, N))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((q) => this._reportWindowsOptions(q))), this.register(this._inputHandler.onColor((q) => this._handleColorEvent(q))), this.register((0, A.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, A.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, A.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, A.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((q) => this._afterResize(q.cols, q.rows))), this.register((0, M.toDisposable)(() => {
              var q, N;
              this._customKeyEventHandler = void 0, (N = (q = this.element) === null || q === void 0 ? void 0 : q.parentNode) === null || N === void 0 || N.removeChild(this.element);
            }));
          }
          _handleColorEvent(P) {
            if (this._themeService) for (const q of P) {
              let N, j = "";
              switch (q.index) {
                case 256:
                  N = "foreground", j = "10";
                  break;
                case 257:
                  N = "background", j = "11";
                  break;
                case 258:
                  N = "cursor", j = "12";
                  break;
                default:
                  N = "ansi", j = "4;" + q.index;
              }
              switch (q.type) {
                case 0:
                  const fe = R.color.toColorRGB(N === "ansi" ? this._themeService.colors.ansi[q.index] : this._themeService.colors[N]);
                  this.coreService.triggerDataEvent(`${z.C0.ESC}]${j};${(0, E.toRgbString)(fe)}${z.C1_ESCAPED.ST}`);
                  break;
                case 1:
                  if (N === "ansi") this._themeService.modifyColors((re) => re.ansi[q.index] = R.rgba.toColor(...q.color));
                  else {
                    const re = N;
                    this._themeService.modifyColors((ke) => ke[re] = R.rgba.toColor(...q.color));
                  }
                  break;
                case 2:
                  this._themeService.restoreColor(q.index);
              }
            }
          }
          _setup() {
            super._setup(), this._customKeyEventHandler = void 0;
          }
          get buffer() {
            return this.buffers.active;
          }
          focus() {
            this.textarea && this.textarea.focus({ preventScroll: !0 });
          }
          _handleScreenReaderModeOptionChange(P) {
            P ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(Y.AccessibilityManager, this)) : this._accessibilityManager.clear();
          }
          _handleTextAreaFocus(P) {
            this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(z.C0.ESC + "[I"), this.updateCursorStyle(P), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
          }
          blur() {
            var P;
            return (P = this.textarea) === null || P === void 0 ? void 0 : P.blur();
          }
          _handleTextAreaBlur() {
            this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(z.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
          }
          _syncTextArea() {
            if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
            const P = this.buffer.ybase + this.buffer.y, q = this.buffer.lines.get(P);
            if (!q) return;
            const N = Math.min(this.buffer.x, this.cols - 1), j = this._renderService.dimensions.css.cell.height, fe = q.getWidth(N), re = this._renderService.dimensions.css.cell.width * fe, ke = this.buffer.y * this._renderService.dimensions.css.cell.height, Fe = N * this._renderService.dimensions.css.cell.width;
            this.textarea.style.left = Fe + "px", this.textarea.style.top = ke + "px", this.textarea.style.width = re + "px", this.textarea.style.height = j + "px", this.textarea.style.lineHeight = j + "px", this.textarea.style.zIndex = "-5";
          }
          _initGlobal() {
            this._bindKeys(), this.register((0, h.addDisposableDomListener)(this.element, "copy", (q) => {
              this.hasSelection() && (0, c.copyHandler)(q, this._selectionService);
            }));
            const P = (q) => (0, c.handlePasteEvent)(q, this.textarea, this.coreService, this.optionsService);
            this.register((0, h.addDisposableDomListener)(this.textarea, "paste", P)), this.register((0, h.addDisposableDomListener)(this.element, "paste", P)), B.isFirefox ? this.register((0, h.addDisposableDomListener)(this.element, "mousedown", (q) => {
              q.button === 2 && (0, c.rightClickHandler)(q, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })) : this.register((0, h.addDisposableDomListener)(this.element, "contextmenu", (q) => {
              (0, c.rightClickHandler)(q, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })), B.isLinux && this.register((0, h.addDisposableDomListener)(this.element, "auxclick", (q) => {
              q.button === 1 && (0, c.moveTextAreaUnderMouseCursor)(q, this.textarea, this.screenElement);
            }));
          }
          _bindKeys() {
            this.register((0, h.addDisposableDomListener)(this.textarea, "keyup", (P) => this._keyUp(P), !0)), this.register((0, h.addDisposableDomListener)(this.textarea, "keydown", (P) => this._keyDown(P), !0)), this.register((0, h.addDisposableDomListener)(this.textarea, "keypress", (P) => this._keyPress(P), !0)), this.register((0, h.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, h.addDisposableDomListener)(this.textarea, "compositionupdate", (P) => this._compositionHelper.compositionupdate(P))), this.register((0, h.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, h.addDisposableDomListener)(this.textarea, "input", (P) => this._inputEvent(P), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
          }
          open(P) {
            var q;
            if (!P) throw new Error("Terminal requires a parent element.");
            P.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = P.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), P.appendChild(this.element);
            const N = ne.createDocumentFragment();
            this._viewportElement = ne.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), N.appendChild(this._viewportElement), this._viewportScrollArea = ne.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = ne.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = ne.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), N.appendChild(this.screenElement), this.textarea = ne.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", d.promptLabel), B.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(b.CoreBrowserService, this.textarea, (q = this._document.defaultView) !== null && q !== void 0 ? q : window), this._instantiationService.setService(k.ICoreBrowserService, this._coreBrowserService), this.register((0, h.addDisposableDomListener)(this.textarea, "focus", (j) => this._handleTextAreaFocus(j))), this.register((0, h.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(m.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(k.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance($.ThemeService), this._instantiationService.setService(k.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(_.CharacterJoinerService), this._instantiationService.setService(k.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(x.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(k.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((j) => this._onRender.fire(j))), this.onResize((j) => this._renderService.resize(j.cols, j.rows)), this._compositionView = ne.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(p.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(N);
            try {
              this._onWillOpen.fire(this.element);
            } catch {
            }
            this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(w.MouseService), this._instantiationService.setService(k.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(v.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((j) => this.scrollLines(j.amount, j.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
              this._renderService.handleCursorMove(), this._syncTextArea();
            })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(y.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(k.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((j) => this.scrollLines(j.amount, j.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((j) => this._renderService.handleSelectionChanged(j.start, j.end, j.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((j) => {
              this.textarea.value = j, this.textarea.focus(), this.textarea.select();
            })), this.register(this._onScroll.event((j) => {
              this.viewport.syncScrollArea(), this._selectionService.refresh();
            })), this.register((0, h.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(S.BufferDecorationRenderer, this.screenElement)), this.register((0, h.addDisposableDomListener)(this.element, "mousedown", (j) => this._selectionService.handleMouseDown(j))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(Y.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (j) => this._handleScreenReaderModeOptionChange(j))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(f.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (j) => {
              !this._overviewRulerRenderer && j && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(f.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
            }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
          }
          _createRenderer() {
            return this._instantiationService.createInstance(g.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
          }
          bindMouse() {
            const P = this, q = this.element;
            function N(re) {
              const ke = P._mouseService.getMouseReportCoords(re, P.screenElement);
              if (!ke) return !1;
              let Fe, Ot;
              switch (re.overrideType || re.type) {
                case "mousemove":
                  Ot = 32, re.buttons === void 0 ? (Fe = 3, re.button !== void 0 && (Fe = re.button < 3 ? re.button : 3)) : Fe = 1 & re.buttons ? 0 : 4 & re.buttons ? 1 : 2 & re.buttons ? 2 : 3;
                  break;
                case "mouseup":
                  Ot = 0, Fe = re.button < 3 ? re.button : 3;
                  break;
                case "mousedown":
                  Ot = 1, Fe = re.button < 3 ? re.button : 3;
                  break;
                case "wheel":
                  if (P.viewport.getLinesScrolled(re) === 0) return !1;
                  Ot = re.deltaY < 0 ? 0 : 1, Fe = 4;
                  break;
                default:
                  return !1;
              }
              return !(Ot === void 0 || Fe === void 0 || Fe > 4) && P.coreMouseService.triggerMouseEvent({ col: ke.col, row: ke.row, x: ke.x, y: ke.y, button: Fe, action: Ot, ctrl: re.ctrlKey, alt: re.altKey, shift: re.shiftKey });
            }
            const j = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, fe = { mouseup: (re) => (N(re), re.buttons || (this._document.removeEventListener("mouseup", j.mouseup), j.mousedrag && this._document.removeEventListener("mousemove", j.mousedrag)), this.cancel(re)), wheel: (re) => (N(re), this.cancel(re, !0)), mousedrag: (re) => {
              re.buttons && N(re);
            }, mousemove: (re) => {
              re.buttons || N(re);
            } };
            this.register(this.coreMouseService.onProtocolChange((re) => {
              re ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(re)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & re ? j.mousemove || (q.addEventListener("mousemove", fe.mousemove), j.mousemove = fe.mousemove) : (q.removeEventListener("mousemove", j.mousemove), j.mousemove = null), 16 & re ? j.wheel || (q.addEventListener("wheel", fe.wheel, { passive: !1 }), j.wheel = fe.wheel) : (q.removeEventListener("wheel", j.wheel), j.wheel = null), 2 & re ? j.mouseup || (q.addEventListener("mouseup", fe.mouseup), j.mouseup = fe.mouseup) : (this._document.removeEventListener("mouseup", j.mouseup), q.removeEventListener("mouseup", j.mouseup), j.mouseup = null), 4 & re ? j.mousedrag || (j.mousedrag = fe.mousedrag) : (this._document.removeEventListener("mousemove", j.mousedrag), j.mousedrag = null);
            })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, h.addDisposableDomListener)(q, "mousedown", (re) => {
              if (re.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(re)) return N(re), j.mouseup && this._document.addEventListener("mouseup", j.mouseup), j.mousedrag && this._document.addEventListener("mousemove", j.mousedrag), this.cancel(re);
            })), this.register((0, h.addDisposableDomListener)(q, "wheel", (re) => {
              if (!j.wheel) {
                if (!this.buffer.hasScrollback) {
                  const ke = this.viewport.getLinesScrolled(re);
                  if (ke === 0) return;
                  const Fe = z.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (re.deltaY < 0 ? "A" : "B");
                  let Ot = "";
                  for (let qr = 0; qr < Math.abs(ke); qr++) Ot += Fe;
                  return this.coreService.triggerDataEvent(Ot, !0), this.cancel(re, !0);
                }
                return this.viewport.handleWheel(re) ? this.cancel(re) : void 0;
              }
            }, { passive: !1 })), this.register((0, h.addDisposableDomListener)(q, "touchstart", (re) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(re), this.cancel(re);
            }, { passive: !0 })), this.register((0, h.addDisposableDomListener)(q, "touchmove", (re) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(re) ? void 0 : this.cancel(re);
            }, { passive: !1 }));
          }
          refresh(P, q) {
            var N;
            (N = this._renderService) === null || N === void 0 || N.refreshRows(P, q);
          }
          updateCursorStyle(P) {
            var q;
            !((q = this._selectionService) === null || q === void 0) && q.shouldColumnSelect(P) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
          }
          _showCursor() {
            this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));
          }
          scrollLines(P, q, N = 0) {
            var j;
            N === 1 ? (super.scrollLines(P, q, N), this.refresh(0, this.rows - 1)) : (j = this.viewport) === null || j === void 0 || j.scrollLines(P);
          }
          paste(P) {
            (0, c.paste)(P, this.textarea, this.coreService, this.optionsService);
          }
          attachCustomKeyEventHandler(P) {
            this._customKeyEventHandler = P;
          }
          registerLinkProvider(P) {
            return this.linkifier2.registerLinkProvider(P);
          }
          registerCharacterJoiner(P) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            const q = this._characterJoinerService.register(P);
            return this.refresh(0, this.rows - 1), q;
          }
          deregisterCharacterJoiner(P) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            this._characterJoinerService.deregister(P) && this.refresh(0, this.rows - 1);
          }
          get markers() {
            return this.buffer.markers;
          }
          registerMarker(P) {
            return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + P);
          }
          registerDecoration(P) {
            return this._decorationService.registerDecoration(P);
          }
          hasSelection() {
            return !!this._selectionService && this._selectionService.hasSelection;
          }
          select(P, q, N) {
            this._selectionService.setSelection(P, q, N);
          }
          getSelection() {
            return this._selectionService ? this._selectionService.selectionText : "";
          }
          getSelectionPosition() {
            if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
          }
          clearSelection() {
            var P;
            (P = this._selectionService) === null || P === void 0 || P.clearSelection();
          }
          selectAll() {
            var P;
            (P = this._selectionService) === null || P === void 0 || P.selectAll();
          }
          selectLines(P, q) {
            var N;
            (N = this._selectionService) === null || N === void 0 || N.selectLines(P, q);
          }
          _keyDown(P) {
            if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && this._customKeyEventHandler(P) === !1) return !1;
            const q = this.browser.isMac && this.options.macOptionIsMeta && P.altKey;
            if (!q && !this._compositionHelper.keydown(P)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), !1;
            q || P.key !== "Dead" && P.key !== "AltGraph" || (this._unprocessedDeadKey = !0);
            const N = (0, Q.evaluateKeyboardEvent)(P, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
            if (this.updateCursorStyle(P), N.type === 3 || N.type === 2) {
              const j = this.rows - 1;
              return this.scrollLines(N.type === 2 ? -j : j), this.cancel(P, !0);
            }
            return N.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, P) || (N.cancel && this.cancel(P, !0), !N.key || !!(P.key && !P.ctrlKey && !P.altKey && !P.metaKey && P.key.length === 1 && P.key.charCodeAt(0) >= 65 && P.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (N.key !== z.C0.ETX && N.key !== z.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: N.key, domEvent: P }), this._showCursor(), this.coreService.triggerDataEvent(N.key, !0), !this.optionsService.rawOptions.screenReaderMode || P.altKey || P.ctrlKey ? this.cancel(P, !0) : void (this._keyDownHandled = !0))));
          }
          _isThirdLevelShift(P, q) {
            const N = P.isMac && !this.options.macOptionIsMeta && q.altKey && !q.ctrlKey && !q.metaKey || P.isWindows && q.altKey && q.ctrlKey && !q.metaKey || P.isWindows && q.getModifierState("AltGraph");
            return q.type === "keypress" ? N : N && (!q.keyCode || q.keyCode > 47);
          }
          _keyUp(P) {
            this._keyDownSeen = !1, this._customKeyEventHandler && this._customKeyEventHandler(P) === !1 || (function(q) {
              return q.keyCode === 16 || q.keyCode === 17 || q.keyCode === 18;
            }(P) || this.focus(), this.updateCursorStyle(P), this._keyPressHandled = !1);
          }
          _keyPress(P) {
            let q;
            if (this._keyPressHandled = !1, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(P) === !1) return !1;
            if (this.cancel(P), P.charCode) q = P.charCode;
            else if (P.which === null || P.which === void 0) q = P.keyCode;
            else {
              if (P.which === 0 || P.charCode === 0) return !1;
              q = P.which;
            }
            return !(!q || (P.altKey || P.ctrlKey || P.metaKey) && !this._isThirdLevelShift(this.browser, P) || (q = String.fromCharCode(q), this._onKey.fire({ key: q, domEvent: P }), this._showCursor(), this.coreService.triggerDataEvent(q, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));
          }
          _inputEvent(P) {
            if (P.data && P.inputType === "insertText" && (!P.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
              if (this._keyPressHandled) return !1;
              this._unprocessedDeadKey = !1;
              const q = P.data;
              return this.coreService.triggerDataEvent(q, !0), this.cancel(P), !0;
            }
            return !1;
          }
          resize(P, q) {
            P !== this.cols || q !== this.rows ? super.resize(P, q) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
          }
          _afterResize(P, q) {
            var N, j;
            (N = this._charSizeService) === null || N === void 0 || N.measure(), (j = this.viewport) === null || j === void 0 || j.syncScrollArea(!0);
          }
          clear() {
            var P;
            if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
              this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let q = 1; q < this.rows; q++) this.buffer.lines.push(this.buffer.getBlankLine(W.DEFAULT_ATTR_DATA));
              this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), (P = this.viewport) === null || P === void 0 || P.reset(), this.refresh(0, this.rows - 1);
            }
          }
          reset() {
            var P, q;
            this.options.rows = this.rows, this.options.cols = this.cols;
            const N = this._customKeyEventHandler;
            this._setup(), super.reset(), (P = this._selectionService) === null || P === void 0 || P.reset(), this._decorationService.reset(), (q = this.viewport) === null || q === void 0 || q.reset(), this._customKeyEventHandler = N, this.refresh(0, this.rows - 1);
          }
          clearTextureAtlas() {
            var P;
            (P = this._renderService) === null || P === void 0 || P.clearTextureAtlas();
          }
          _reportFocus() {
            var P;
            !((P = this.element) === null || P === void 0) && P.classList.contains("focus") ? this.coreService.triggerDataEvent(z.C0.ESC + "[I") : this.coreService.triggerDataEvent(z.C0.ESC + "[O");
          }
          _reportWindowsOptions(P) {
            if (this._renderService) switch (P) {
              case U.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                const q = this._renderService.dimensions.css.canvas.width.toFixed(0), N = this._renderService.dimensions.css.canvas.height.toFixed(0);
                this.coreService.triggerDataEvent(`${z.C0.ESC}[4;${N};${q}t`);
                break;
              case U.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                const j = this._renderService.dimensions.css.cell.width.toFixed(0), fe = this._renderService.dimensions.css.cell.height.toFixed(0);
                this.coreService.triggerDataEvent(`${z.C0.ESC}[6;${fe};${j}t`);
            }
          }
          cancel(P, q) {
            if (this.options.cancelEvents || q) return P.preventDefault(), P.stopPropagation(), !1;
          }
        }
        a.Terminal = te;
      }, 9924: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.TimeBasedDebouncer = void 0, a.TimeBasedDebouncer = class {
          constructor(l, c = 1e3) {
            this._renderCallback = l, this._debounceThresholdMS = c, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;
          }
          dispose() {
            this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
          }
          refresh(l, c, h) {
            this._rowCount = h, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c;
            const u = Date.now();
            if (u - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = u, this._innerRefresh();
            else if (!this._additionalRefreshRequested) {
              const d = u - this._lastRefreshMs, O = this._debounceThresholdMS - d;
              this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => {
                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;
              }, O);
            }
          }
          _innerRefresh() {
            if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return;
            const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c);
          }
        };
      }, 1680: function(o, a, l) {
        var c = this && this.__decorate || function(p, g, m, _) {
          var b, w = arguments.length, x = w < 3 ? g : _ === null ? _ = Object.getOwnPropertyDescriptor(g, m) : _;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(p, g, m, _);
          else for (var y = p.length - 1; y >= 0; y--) (b = p[y]) && (x = (w < 3 ? b(x) : w > 3 ? b(g, m, x) : b(g, m)) || x);
          return w > 3 && x && Object.defineProperty(g, m, x), x;
        }, h = this && this.__param || function(p, g) {
          return function(m, _) {
            g(m, _, p);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Viewport = void 0;
        const u = l(3656), d = l(4725), O = l(8460), v = l(844), S = l(2585);
        let f = a.Viewport = class extends v.Disposable {
          constructor(p, g, m, _, b, w, x, y) {
            super(), this._viewportElement = p, this._scrollArea = g, this._bufferService = m, this._optionsService = _, this._charSizeService = b, this._renderService = w, this._coreBrowserService = x, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new O.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, u.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((k) => this._activeBuffer = k.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((k) => this._renderDimensions = k)), this._handleThemeChange(y.colors), this.register(y.onChangeColors((k) => this._handleThemeChange(k))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
          }
          _handleThemeChange(p) {
            this._viewportElement.style.backgroundColor = p.background.css;
          }
          reset() {
            this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
          }
          _refresh(p) {
            if (p) return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
            this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._charSizeService.height > 0) {
              this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
              const g = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
              this._lastRecordedBufferHeight !== g && (this._lastRecordedBufferHeight = g, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
            }
            const p = this._bufferService.buffer.ydisp * this._currentRowHeight;
            this._viewportElement.scrollTop !== p && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = p), this._refreshAnimationFrame = null;
          }
          syncScrollArea(p = !1) {
            if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(p);
            this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(p);
          }
          _handleScroll(p) {
            if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
            if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: !0 });
            const g = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
            this._onRequestScrollLines.fire({ amount: g, suppressScrollEvent: !0 });
          }
          _smoothScroll() {
            if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1) return;
            const p = this._smoothScrollPercent();
            this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(p * (this._smoothScrollState.target - this._smoothScrollState.origin)), p < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
          }
          _smoothScrollPercent() {
            return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
          }
          _clearSmoothScrollState() {
            this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
          }
          _bubbleScroll(p, g) {
            const m = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
            return !(g < 0 && this._viewportElement.scrollTop !== 0 || g > 0 && m < this._lastRecordedBufferHeight) || (p.cancelable && p.preventDefault(), !1);
          }
          handleWheel(p) {
            const g = this._getPixelsScrolled(p);
            return g !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + g : this._smoothScrollState.target += g, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += g, this._bubbleScroll(p, g));
          }
          scrollLines(p) {
            if (p !== 0) if (this._optionsService.rawOptions.smoothScrollDuration) {
              const g = p * this._currentRowHeight;
              this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + g, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
            } else this._onRequestScrollLines.fire({ amount: p, suppressScrollEvent: !1 });
          }
          _getPixelsScrolled(p) {
            if (p.deltaY === 0 || p.shiftKey) return 0;
            let g = this._applyScrollModifier(p.deltaY, p);
            return p.deltaMode === WheelEvent.DOM_DELTA_LINE ? g *= this._currentRowHeight : p.deltaMode === WheelEvent.DOM_DELTA_PAGE && (g *= this._currentRowHeight * this._bufferService.rows), g;
          }
          getBufferElements(p, g) {
            var m;
            let _, b = "";
            const w = [], x = g ?? this._bufferService.buffer.lines.length, y = this._bufferService.buffer.lines;
            for (let k = p; k < x; k++) {
              const $ = y.get(k);
              if (!$) continue;
              const R = (m = y.get(k + 1)) === null || m === void 0 ? void 0 : m.isWrapped;
              if (b += $.translateToString(!R), !R || k === y.length - 1) {
                const T = document.createElement("div");
                T.textContent = b, w.push(T), b.length > 0 && (_ = T), b = "";
              }
            }
            return { bufferElements: w, cursorElement: _ };
          }
          getLinesScrolled(p) {
            if (p.deltaY === 0 || p.shiftKey) return 0;
            let g = this._applyScrollModifier(p.deltaY, p);
            return p.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (g /= this._currentRowHeight + 0, this._wheelPartialScroll += g, g = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : p.deltaMode === WheelEvent.DOM_DELTA_PAGE && (g *= this._bufferService.rows), g;
          }
          _applyScrollModifier(p, g) {
            const m = this._optionsService.rawOptions.fastScrollModifier;
            return m === "alt" && g.altKey || m === "ctrl" && g.ctrlKey || m === "shift" && g.shiftKey ? p * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : p * this._optionsService.rawOptions.scrollSensitivity;
          }
          handleTouchStart(p) {
            this._lastTouchY = p.touches[0].pageY;
          }
          handleTouchMove(p) {
            const g = this._lastTouchY - p.touches[0].pageY;
            return this._lastTouchY = p.touches[0].pageY, g !== 0 && (this._viewportElement.scrollTop += g, this._bubbleScroll(p, g));
          }
        };
        a.Viewport = f = c([h(2, S.IBufferService), h(3, S.IOptionsService), h(4, d.ICharSizeService), h(5, d.IRenderService), h(6, d.ICoreBrowserService), h(7, d.IThemeService)], f);
      }, 3107: function(o, a, l) {
        var c = this && this.__decorate || function(f, p, g, m) {
          var _, b = arguments.length, w = b < 3 ? p : m === null ? m = Object.getOwnPropertyDescriptor(p, g) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(f, p, g, m);
          else for (var x = f.length - 1; x >= 0; x--) (_ = f[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(p, g, w) : _(p, g)) || w);
          return b > 3 && w && Object.defineProperty(p, g, w), w;
        }, h = this && this.__param || function(f, p) {
          return function(g, m) {
            p(g, m, f);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferDecorationRenderer = void 0;
        const u = l(3656), d = l(4725), O = l(844), v = l(2585);
        let S = a.BufferDecorationRenderer = class extends O.Disposable {
          constructor(f, p, g, m) {
            super(), this._screenElement = f, this._bufferService = p, this._decorationService = g, this._renderService = m, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
              this._dimensionsChanged = !0, this._queueRefresh();
            })), this.register((0, u.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
            })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((_) => this._removeDecoration(_))), this.register((0, O.toDisposable)(() => {
              this._container.remove(), this._decorationElements.clear();
            }));
          }
          _queueRefresh() {
            this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => {
              this._doRefreshDecorations(), this._animationFrame = void 0;
            }));
          }
          _doRefreshDecorations() {
            for (const f of this._decorationService.decorations) this._renderDecoration(f);
            this._dimensionsChanged = !1;
          }
          _renderDecoration(f) {
            this._refreshStyle(f), this._dimensionsChanged && this._refreshXPosition(f);
          }
          _createElement(f) {
            var p, g;
            const m = document.createElement("div");
            m.classList.add("xterm-decoration"), m.classList.toggle("xterm-decoration-top-layer", ((p = f?.options) === null || p === void 0 ? void 0 : p.layer) === "top"), m.style.width = `${Math.round((f.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, m.style.height = (f.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", m.style.top = (f.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", m.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
            const _ = (g = f.options.x) !== null && g !== void 0 ? g : 0;
            return _ && _ > this._bufferService.cols && (m.style.display = "none"), this._refreshXPosition(f, m), m;
          }
          _refreshStyle(f) {
            const p = f.marker.line - this._bufferService.buffers.active.ydisp;
            if (p < 0 || p >= this._bufferService.rows) f.element && (f.element.style.display = "none", f.onRenderEmitter.fire(f.element));
            else {
              let g = this._decorationElements.get(f);
              g || (g = this._createElement(f), f.element = g, this._decorationElements.set(f, g), this._container.appendChild(g), f.onDispose(() => {
                this._decorationElements.delete(f), g.remove();
              })), g.style.top = p * this._renderService.dimensions.css.cell.height + "px", g.style.display = this._altBufferIsActive ? "none" : "block", f.onRenderEmitter.fire(g);
            }
          }
          _refreshXPosition(f, p = f.element) {
            var g;
            if (!p) return;
            const m = (g = f.options.x) !== null && g !== void 0 ? g : 0;
            (f.options.anchor || "left") === "right" ? p.style.right = m ? m * this._renderService.dimensions.css.cell.width + "px" : "" : p.style.left = m ? m * this._renderService.dimensions.css.cell.width + "px" : "";
          }
          _removeDecoration(f) {
            var p;
            (p = this._decorationElements.get(f)) === null || p === void 0 || p.remove(), this._decorationElements.delete(f), f.dispose();
          }
        };
        a.BufferDecorationRenderer = S = c([h(1, v.IBufferService), h(2, v.IDecorationService), h(3, d.IRenderService)], S);
      }, 5871: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorZoneStore = void 0, a.ColorZoneStore = class {
          constructor() {
            this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
          }
          get zones() {
            return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
          }
          clear() {
            this._zones.length = 0, this._zonePoolIndex = 0;
          }
          addDecoration(l) {
            if (l.options.overviewRulerOptions) {
              for (const c of this._zones) if (c.color === l.options.overviewRulerOptions.color && c.position === l.options.overviewRulerOptions.position) {
                if (this._lineIntersectsZone(c, l.marker.line)) return;
                if (this._lineAdjacentToZone(c, l.marker.line, l.options.overviewRulerOptions.position)) return void this._addLineToZone(c, l.marker.line);
              }
              if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = l.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = l.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = l.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = l.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
              this._zones.push({ color: l.options.overviewRulerOptions.color, position: l.options.overviewRulerOptions.position, startBufferLine: l.marker.line, endBufferLine: l.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
            }
          }
          setPadding(l) {
            this._linePadding = l;
          }
          _lineIntersectsZone(l, c) {
            return c >= l.startBufferLine && c <= l.endBufferLine;
          }
          _lineAdjacentToZone(l, c, h) {
            return c >= l.startBufferLine - this._linePadding[h || "full"] && c <= l.endBufferLine + this._linePadding[h || "full"];
          }
          _addLineToZone(l, c) {
            l.startBufferLine = Math.min(l.startBufferLine, c), l.endBufferLine = Math.max(l.endBufferLine, c);
          }
        };
      }, 5744: function(o, a, l) {
        var c = this && this.__decorate || function(_, b, w, x) {
          var y, k = arguments.length, $ = k < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, w) : x;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") $ = Reflect.decorate(_, b, w, x);
          else for (var R = _.length - 1; R >= 0; R--) (y = _[R]) && ($ = (k < 3 ? y($) : k > 3 ? y(b, w, $) : y(b, w)) || $);
          return k > 3 && $ && Object.defineProperty(b, w, $), $;
        }, h = this && this.__param || function(_, b) {
          return function(w, x) {
            b(w, x, _);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OverviewRulerRenderer = void 0;
        const u = l(5871), d = l(3656), O = l(4725), v = l(844), S = l(2585), f = { full: 0, left: 0, center: 0, right: 0 }, p = { full: 0, left: 0, center: 0, right: 0 }, g = { full: 0, left: 0, center: 0, right: 0 };
        let m = a.OverviewRulerRenderer = class extends v.Disposable {
          get _width() {
            return this._optionsService.options.overviewRulerWidth || 0;
          }
          constructor(_, b, w, x, y, k, $) {
            var R;
            super(), this._viewportElement = _, this._screenElement = b, this._bufferService = w, this._decorationService = x, this._renderService = y, this._optionsService = k, this._coreBrowseService = $, this._colorZoneStore = new u.ColorZoneStore(), this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (R = this._viewportElement.parentElement) === null || R === void 0 || R.insertBefore(this._canvas, this._viewportElement);
            const T = this._canvas.getContext("2d");
            if (!T) throw new Error("Ctx cannot be null");
            this._ctx = T, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, v.toDisposable)(() => {
              var A;
              (A = this._canvas) === null || A === void 0 || A.remove();
            }));
          }
          _registerDecorationListeners() {
            this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0)));
          }
          _registerBufferChangeListeners() {
            this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
            })), this.register(this._bufferService.onScroll(() => {
              this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
            }));
          }
          _registerDimensionChangeListeners() {
            this.register(this._renderService.onRender(() => {
              this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);
            })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))), this.register((0, d.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(!0))), this._queueRefresh(!0);
          }
          _refreshDrawConstants() {
            const _ = Math.floor(this._canvas.width / 3), b = Math.ceil(this._canvas.width / 3);
            p.full = this._canvas.width, p.left = _, p.center = b, p.right = _, this._refreshDrawHeightConstants(), g.full = 0, g.left = 0, g.center = p.left, g.right = p.left + p.center;
          }
          _refreshDrawHeightConstants() {
            f.full = Math.round(2 * this._coreBrowseService.dpr);
            const _ = this._canvas.height / this._bufferService.buffer.lines.length, b = Math.round(Math.max(Math.min(_, 12), 6) * this._coreBrowseService.dpr);
            f.left = b, f.center = b, f.right = b;
          }
          _refreshColorZonePadding() {
            this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * f.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * f.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * f.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * f.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
          }
          _refreshCanvasDimensions() {
            this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
          }
          _refreshDecorations() {
            this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
            for (const b of this._decorationService.decorations) this._colorZoneStore.addDecoration(b);
            this._ctx.lineWidth = 1;
            const _ = this._colorZoneStore.zones;
            for (const b of _) b.position !== "full" && this._renderColorZone(b);
            for (const b of _) b.position === "full" && this._renderColorZone(b);
            this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;
          }
          _renderColorZone(_) {
            this._ctx.fillStyle = _.color, this._ctx.fillRect(g[_.position || "full"], Math.round((this._canvas.height - 1) * (_.startBufferLine / this._bufferService.buffers.active.lines.length) - f[_.position || "full"] / 2), p[_.position || "full"], Math.round((this._canvas.height - 1) * ((_.endBufferLine - _.startBufferLine) / this._bufferService.buffers.active.lines.length) + f[_.position || "full"]));
          }
          _queueRefresh(_, b) {
            this._shouldUpdateDimensions = _ || this._shouldUpdateDimensions, this._shouldUpdateAnchor = b || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
              this._refreshDecorations(), this._animationFrame = void 0;
            }));
          }
        };
        a.OverviewRulerRenderer = m = c([h(2, S.IBufferService), h(3, S.IDecorationService), h(4, O.IRenderService), h(5, S.IOptionsService), h(6, O.ICoreBrowserService)], m);
      }, 2950: function(o, a, l) {
        var c = this && this.__decorate || function(S, f, p, g) {
          var m, _ = arguments.length, b = _ < 3 ? f : g === null ? g = Object.getOwnPropertyDescriptor(f, p) : g;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") b = Reflect.decorate(S, f, p, g);
          else for (var w = S.length - 1; w >= 0; w--) (m = S[w]) && (b = (_ < 3 ? m(b) : _ > 3 ? m(f, p, b) : m(f, p)) || b);
          return _ > 3 && b && Object.defineProperty(f, p, b), b;
        }, h = this && this.__param || function(S, f) {
          return function(p, g) {
            f(p, g, S);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CompositionHelper = void 0;
        const u = l(4725), d = l(2585), O = l(2584);
        let v = a.CompositionHelper = class {
          get isComposing() {
            return this._isComposing;
          }
          constructor(S, f, p, g, m, _) {
            this._textarea = S, this._compositionView = f, this._bufferService = p, this._optionsService = g, this._coreService = m, this._renderService = _, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
          }
          compositionstart() {
            this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
          }
          compositionupdate(S) {
            this._compositionView.textContent = S.data, this.updateCompositionElements(), setTimeout(() => {
              this._compositionPosition.end = this._textarea.value.length;
            }, 0);
          }
          compositionend() {
            this._finalizeComposition(!0);
          }
          keydown(S) {
            if (this._isComposing || this._isSendingComposition) {
              if (S.keyCode === 229 || S.keyCode === 16 || S.keyCode === 17 || S.keyCode === 18) return !1;
              this._finalizeComposition(!1);
            }
            return S.keyCode !== 229 || (this._handleAnyTextareaChanges(), !1);
          }
          _finalizeComposition(S) {
            if (this._compositionView.classList.remove("active"), this._isComposing = !1, S) {
              const f = { start: this._compositionPosition.start, end: this._compositionPosition.end };
              this._isSendingComposition = !0, setTimeout(() => {
                if (this._isSendingComposition) {
                  let p;
                  this._isSendingComposition = !1, f.start += this._dataAlreadySent.length, p = this._isComposing ? this._textarea.value.substring(f.start, f.end) : this._textarea.value.substring(f.start), p.length > 0 && this._coreService.triggerDataEvent(p, !0);
                }
              }, 0);
            } else {
              this._isSendingComposition = !1;
              const f = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
              this._coreService.triggerDataEvent(f, !0);
            }
          }
          _handleAnyTextareaChanges() {
            const S = this._textarea.value;
            setTimeout(() => {
              if (!this._isComposing) {
                const f = this._textarea.value, p = f.replace(S, "");
                this._dataAlreadySent = p, f.length > S.length ? this._coreService.triggerDataEvent(p, !0) : f.length < S.length ? this._coreService.triggerDataEvent(`${O.C0.DEL}`, !0) : f.length === S.length && f !== S && this._coreService.triggerDataEvent(f, !0);
              }
            }, 0);
          }
          updateCompositionElements(S) {
            if (this._isComposing) {
              if (this._bufferService.buffer.isCursorInViewport) {
                const f = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), p = this._renderService.dimensions.css.cell.height, g = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, m = f * this._renderService.dimensions.css.cell.width;
                this._compositionView.style.left = m + "px", this._compositionView.style.top = g + "px", this._compositionView.style.height = p + "px", this._compositionView.style.lineHeight = p + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                const _ = this._compositionView.getBoundingClientRect();
                this._textarea.style.left = m + "px", this._textarea.style.top = g + "px", this._textarea.style.width = Math.max(_.width, 1) + "px", this._textarea.style.height = Math.max(_.height, 1) + "px", this._textarea.style.lineHeight = _.height + "px";
              }
              S || setTimeout(() => this.updateCompositionElements(!0), 0);
            }
          }
        };
        a.CompositionHelper = v = c([h(2, d.IBufferService), h(3, d.IOptionsService), h(4, d.ICoreService), h(5, u.IRenderService)], v);
      }, 9806: (o, a) => {
        function l(c, h, u) {
          const d = u.getBoundingClientRect(), O = c.getComputedStyle(u), v = parseInt(O.getPropertyValue("padding-left")), S = parseInt(O.getPropertyValue("padding-top"));
          return [h.clientX - d.left - v, h.clientY - d.top - S];
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getCoords = a.getCoordsRelativeToElement = void 0, a.getCoordsRelativeToElement = l, a.getCoords = function(c, h, u, d, O, v, S, f, p) {
          if (!v) return;
          const g = l(c, h, u);
          return g ? (g[0] = Math.ceil((g[0] + (p ? S / 2 : 0)) / S), g[1] = Math.ceil(g[1] / f), g[0] = Math.min(Math.max(g[0], 1), d + (p ? 1 : 0)), g[1] = Math.min(Math.max(g[1], 1), O), g) : void 0;
        };
      }, 9504: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.moveToCellSequence = void 0;
        const c = l(2584);
        function h(f, p, g, m) {
          const _ = f - u(f, g), b = p - u(p, g), w = Math.abs(_ - b) - function(x, y, k) {
            let $ = 0;
            const R = x - u(x, k), T = y - u(y, k);
            for (let A = 0; A < Math.abs(R - T); A++) {
              const M = d(x, y) === "A" ? -1 : 1, B = k.buffer.lines.get(R + M * A);
              B?.isWrapped && $++;
            }
            return $;
          }(f, p, g);
          return S(w, v(d(f, p), m));
        }
        function u(f, p) {
          let g = 0, m = p.buffer.lines.get(f), _ = m?.isWrapped;
          for (; _ && f >= 0 && f < p.rows; ) g++, m = p.buffer.lines.get(--f), _ = m?.isWrapped;
          return g;
        }
        function d(f, p) {
          return f > p ? "A" : "B";
        }
        function O(f, p, g, m, _, b) {
          let w = f, x = p, y = "";
          for (; w !== g || x !== m; ) w += _ ? 1 : -1, _ && w > b.cols - 1 ? (y += b.buffer.translateBufferLineToString(x, !1, f, w), w = 0, f = 0, x++) : !_ && w < 0 && (y += b.buffer.translateBufferLineToString(x, !1, 0, f + 1), w = b.cols - 1, f = w, x--);
          return y + b.buffer.translateBufferLineToString(x, !1, f, w);
        }
        function v(f, p) {
          const g = p ? "O" : "[";
          return c.C0.ESC + g + f;
        }
        function S(f, p) {
          f = Math.floor(f);
          let g = "";
          for (let m = 0; m < f; m++) g += p;
          return g;
        }
        a.moveToCellSequence = function(f, p, g, m) {
          const _ = g.buffer.x, b = g.buffer.y;
          if (!g.buffer.hasScrollback) return function(y, k, $, R, T, A) {
            return h(k, R, T, A).length === 0 ? "" : S(O(y, k, y, k - u(k, T), !1, T).length, v("D", A));
          }(_, b, 0, p, g, m) + h(b, p, g, m) + function(y, k, $, R, T, A) {
            let M;
            M = h(k, R, T, A).length > 0 ? R - u(R, T) : k;
            const B = R, W = function(z, Q, E, L, D, U) {
              let Y;
              return Y = h(E, L, D, U).length > 0 ? L - u(L, D) : Q, z < E && Y <= L || z >= E && Y < L ? "C" : "D";
            }(y, k, $, R, T, A);
            return S(O(y, M, $, B, W === "C", T).length, v(W, A));
          }(_, b, f, p, g, m);
          let w;
          if (b === p) return w = _ > f ? "D" : "C", S(Math.abs(_ - f), v(w, m));
          w = b > p ? "D" : "C";
          const x = Math.abs(b - p);
          return S(function(y, k) {
            return k.cols - y;
          }(b > p ? f : _, g) + (x - 1) * g.cols + 1 + ((b > p ? _ : f) - 1), v(w, m));
        };
      }, 1296: function(o, a, l) {
        var c = this && this.__decorate || function(T, A, M, B) {
          var W, z = arguments.length, Q = z < 3 ? A : B === null ? B = Object.getOwnPropertyDescriptor(A, M) : B;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Q = Reflect.decorate(T, A, M, B);
          else for (var E = T.length - 1; E >= 0; E--) (W = T[E]) && (Q = (z < 3 ? W(Q) : z > 3 ? W(A, M, Q) : W(A, M)) || Q);
          return z > 3 && Q && Object.defineProperty(A, M, Q), Q;
        }, h = this && this.__param || function(T, A) {
          return function(M, B) {
            A(M, B, T);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRenderer = void 0;
        const u = l(3787), d = l(2550), O = l(2223), v = l(6171), S = l(4725), f = l(8055), p = l(8460), g = l(844), m = l(2585), _ = "xterm-dom-renderer-owner-", b = "xterm-rows", w = "xterm-fg-", x = "xterm-bg-", y = "xterm-focus", k = "xterm-selection";
        let $ = 1, R = a.DomRenderer = class extends g.Disposable {
          constructor(T, A, M, B, W, z, Q, E, L, D) {
            super(), this._element = T, this._screenElement = A, this._viewportElement = M, this._linkifier2 = B, this._charSizeService = z, this._optionsService = Q, this._bufferService = E, this._coreBrowserService = L, this._themeService = D, this._terminalClass = $++, this._rowElements = [], this.onRequestRedraw = this.register(new p.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(b), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(k), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, v.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((U) => this._injectCss(U))), this._injectCss(this._themeService.colors), this._rowFactory = W.createInstance(u.DomRendererRowFactory, document), this._element.classList.add(_ + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((U) => this._handleLinkHover(U))), this.register(this._linkifier2.onHideLinkUnderline((U) => this._handleLinkLeave(U))), this.register((0, g.toDisposable)(() => {
              this._element.classList.remove(_ + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
            })), this._widthCache = new d.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          _updateDimensions() {
            const T = this._coreBrowserService.dpr;
            this.dimensions.device.char.width = this._charSizeService.width * T, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * T), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / T), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / T), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
            for (const M of this._rowElements) M.style.width = `${this.dimensions.css.canvas.width}px`, M.style.height = `${this.dimensions.css.cell.height}px`, M.style.lineHeight = `${this.dimensions.css.cell.height}px`, M.style.overflow = "hidden";
            this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
            const A = `${this._terminalSelector} .${b} span { display: inline-block; height: 100%; vertical-align: top;}`;
            this._dimensionsStyleElement.textContent = A, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
          }
          _injectCss(T) {
            this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
            let A = `${this._terminalSelector} .${b} { color: ${T.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
            A += `${this._terminalSelector} .${b} .xterm-dim { color: ${f.color.multiplyOpacity(T.foreground, 0.5).css};}`, A += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, A += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", A += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${T.cursor.css};  color: ${T.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${T.cursor.css}; }}`, A += `${this._terminalSelector} .${b}.${y} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${b}.${y} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-block { background-color: ${T.cursor.css}; color: ${T.cursorAccent.css};}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${T.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${T.cursor.css} inset;}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${T.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, A += `${this._terminalSelector} .${k} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${k} div { position: absolute; background-color: ${T.selectionBackgroundOpaque.css};}${this._terminalSelector} .${k} div { position: absolute; background-color: ${T.selectionInactiveBackgroundOpaque.css};}`;
            for (const [M, B] of T.ansi.entries()) A += `${this._terminalSelector} .${w}${M} { color: ${B.css}; }${this._terminalSelector} .${w}${M}.xterm-dim { color: ${f.color.multiplyOpacity(B, 0.5).css}; }${this._terminalSelector} .${x}${M} { background-color: ${B.css}; }`;
            A += `${this._terminalSelector} .${w}${O.INVERTED_DEFAULT_COLOR} { color: ${f.color.opaque(T.background).css}; }${this._terminalSelector} .${w}${O.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${f.color.multiplyOpacity(f.color.opaque(T.background), 0.5).css}; }${this._terminalSelector} .${x}${O.INVERTED_DEFAULT_COLOR} { background-color: ${T.foreground.css}; }`, this._themeStyleElement.textContent = A;
          }
          _setDefaultSpacing() {
            const T = this.dimensions.css.cell.width - this._widthCache.get("W", !1, !1);
            this._rowContainer.style.letterSpacing = `${T}px`, this._rowFactory.defaultSpacing = T;
          }
          handleDevicePixelRatioChange() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          _refreshRowElements(T, A) {
            for (let M = this._rowElements.length; M <= A; M++) {
              const B = document.createElement("div");
              this._rowContainer.appendChild(B), this._rowElements.push(B);
            }
            for (; this._rowElements.length > A; ) this._rowContainer.removeChild(this._rowElements.pop());
          }
          handleResize(T, A) {
            this._refreshRowElements(T, A), this._updateDimensions();
          }
          handleCharSizeChanged() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          handleBlur() {
            this._rowContainer.classList.remove(y);
          }
          handleFocus() {
            this._rowContainer.classList.add(y), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
          }
          handleSelectionChanged(T, A, M) {
            if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(T, A, M), this.renderRows(0, this._bufferService.rows - 1), !T || !A) return;
            const B = T[1] - this._bufferService.buffer.ydisp, W = A[1] - this._bufferService.buffer.ydisp, z = Math.max(B, 0), Q = Math.min(W, this._bufferService.rows - 1);
            if (z >= this._bufferService.rows || Q < 0) return;
            const E = document.createDocumentFragment();
            if (M) {
              const L = T[0] > A[0];
              E.appendChild(this._createSelectionElement(z, L ? A[0] : T[0], L ? T[0] : A[0], Q - z + 1));
            } else {
              const L = B === z ? T[0] : 0, D = z === W ? A[0] : this._bufferService.cols;
              E.appendChild(this._createSelectionElement(z, L, D));
              const U = Q - z - 1;
              if (E.appendChild(this._createSelectionElement(z + 1, 0, this._bufferService.cols, U)), z !== Q) {
                const Y = W === Q ? A[0] : this._bufferService.cols;
                E.appendChild(this._createSelectionElement(Q, 0, Y));
              }
            }
            this._selectionContainer.appendChild(E);
          }
          _createSelectionElement(T, A, M, B = 1) {
            const W = document.createElement("div");
            return W.style.height = B * this.dimensions.css.cell.height + "px", W.style.top = T * this.dimensions.css.cell.height + "px", W.style.left = A * this.dimensions.css.cell.width + "px", W.style.width = this.dimensions.css.cell.width * (M - A) + "px", W;
          }
          handleCursorMove() {
          }
          _handleOptionsChanged() {
            this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          clear() {
            for (const T of this._rowElements) T.replaceChildren();
          }
          renderRows(T, A) {
            const M = this._bufferService.buffer, B = M.ybase + M.y, W = Math.min(M.x, this._bufferService.cols - 1), z = this._optionsService.rawOptions.cursorBlink, Q = this._optionsService.rawOptions.cursorStyle, E = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let L = T; L <= A; L++) {
              const D = L + M.ydisp, U = this._rowElements[L], Y = M.lines.get(D);
              if (!U || !Y) break;
              U.replaceChildren(...this._rowFactory.createRow(Y, D, D === B, Q, E, W, z, this.dimensions.css.cell.width, this._widthCache, -1, -1));
            }
          }
          get _terminalSelector() {
            return `.${_}${this._terminalClass}`;
          }
          _handleLinkHover(T) {
            this._setCellUnderline(T.x1, T.x2, T.y1, T.y2, T.cols, !0);
          }
          _handleLinkLeave(T) {
            this._setCellUnderline(T.x1, T.x2, T.y1, T.y2, T.cols, !1);
          }
          _setCellUnderline(T, A, M, B, W, z) {
            M < 0 && (T = 0), B < 0 && (A = 0);
            const Q = this._bufferService.rows - 1;
            M = Math.max(Math.min(M, Q), 0), B = Math.max(Math.min(B, Q), 0), W = Math.min(W, this._bufferService.cols);
            const E = this._bufferService.buffer, L = E.ybase + E.y, D = Math.min(E.x, W - 1), U = this._optionsService.rawOptions.cursorBlink, Y = this._optionsService.rawOptions.cursorStyle, ne = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let te = M; te <= B; ++te) {
              const de = te + E.ydisp, P = this._rowElements[te], q = E.lines.get(de);
              if (!P || !q) break;
              P.replaceChildren(...this._rowFactory.createRow(q, de, de === L, Y, ne, D, U, this.dimensions.css.cell.width, this._widthCache, z ? te === M ? T : 0 : -1, z ? (te === B ? A : W) - 1 : -1));
            }
          }
        };
        a.DomRenderer = R = c([h(4, m.IInstantiationService), h(5, S.ICharSizeService), h(6, m.IOptionsService), h(7, m.IBufferService), h(8, S.ICoreBrowserService), h(9, S.IThemeService)], R);
      }, 3787: function(o, a, l) {
        var c = this && this.__decorate || function(w, x, y, k) {
          var $, R = arguments.length, T = R < 3 ? x : k === null ? k = Object.getOwnPropertyDescriptor(x, y) : k;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(w, x, y, k);
          else for (var A = w.length - 1; A >= 0; A--) ($ = w[A]) && (T = (R < 3 ? $(T) : R > 3 ? $(x, y, T) : $(x, y)) || T);
          return R > 3 && T && Object.defineProperty(x, y, T), T;
        }, h = this && this.__param || function(w, x) {
          return function(y, k) {
            x(y, k, w);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRendererRowFactory = void 0;
        const u = l(2223), d = l(643), O = l(511), v = l(2585), S = l(8055), f = l(4725), p = l(4269), g = l(6171), m = l(3734);
        let _ = a.DomRendererRowFactory = class {
          constructor(w, x, y, k, $, R, T) {
            this._document = w, this._characterJoinerService = x, this._optionsService = y, this._coreBrowserService = k, this._coreService = $, this._decorationService = R, this._themeService = T, this._workCell = new O.CellData(), this._columnSelectMode = !1, this.defaultSpacing = 0;
          }
          handleSelectionChanged(w, x, y) {
            this._selectionStart = w, this._selectionEnd = x, this._columnSelectMode = y;
          }
          createRow(w, x, y, k, $, R, T, A, M, B, W) {
            const z = [], Q = this._characterJoinerService.getJoinedCharacters(x), E = this._themeService.colors;
            let L, D = w.getNoBgTrimmedLength();
            y && D < R + 1 && (D = R + 1);
            let U = 0, Y = "", ne = 0, te = 0, de = 0, P = !1, q = 0, N = !1, j = 0;
            const fe = [], re = B !== -1 && W !== -1;
            for (let ke = 0; ke < D; ke++) {
              w.loadCell(ke, this._workCell);
              let Fe = this._workCell.getWidth();
              if (Fe === 0) continue;
              let Ot = !1, qr = ke, ge = this._workCell;
              if (Q.length > 0 && ke === Q[0][0]) {
                Ot = !0;
                const Me = Q.shift();
                ge = new p.JoinedCellData(this._workCell, w.translateToString(!0, Me[0], Me[1]), Me[1] - Me[0]), qr = Me[1] - 1, Fe = ge.getWidth();
              }
              const Ts = this._isCellInSelection(ke, x), Wl = y && ke === R, zl = re && ke >= B && ke <= W;
              let Vl = !1;
              this._decorationService.forEachDecorationAtCell(ke, x, void 0, (Me) => {
                Vl = !0;
              });
              let mo = ge.getChars() || d.WHITESPACE_CELL_CHAR;
              if (mo === " " && (ge.isUnderline() || ge.isOverline()) && (mo = ""), j = Fe * A - M.get(mo, ge.isBold(), ge.isItalic()), L) {
                if (U && (Ts && N || !Ts && !N && ge.bg === ne) && (Ts && N && E.selectionForeground || ge.fg === te) && ge.extended.ext === de && zl === P && j === q && !Wl && !Ot && !Vl) {
                  Y += mo, U++;
                  continue;
                }
                U && (L.textContent = Y), L = this._document.createElement("span"), U = 0, Y = "";
              } else L = this._document.createElement("span");
              if (ne = ge.bg, te = ge.fg, de = ge.extended.ext, P = zl, q = j, N = Ts, Ot && R >= ke && R <= qr && (R = ke), !this._coreService.isCursorHidden && Wl) {
                if (fe.push("xterm-cursor"), this._coreBrowserService.isFocused) T && fe.push("xterm-cursor-blink"), fe.push(k === "bar" ? "xterm-cursor-bar" : k === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
                else if ($) switch ($) {
                  case "outline":
                    fe.push("xterm-cursor-outline");
                    break;
                  case "block":
                    fe.push("xterm-cursor-block");
                    break;
                  case "bar":
                    fe.push("xterm-cursor-bar");
                    break;
                  case "underline":
                    fe.push("xterm-cursor-underline");
                }
              }
              if (ge.isBold() && fe.push("xterm-bold"), ge.isItalic() && fe.push("xterm-italic"), ge.isDim() && fe.push("xterm-dim"), Y = ge.isInvisible() ? d.WHITESPACE_CELL_CHAR : ge.getChars() || d.WHITESPACE_CELL_CHAR, ge.isUnderline() && (fe.push(`xterm-underline-${ge.extended.underlineStyle}`), Y === " " && (Y = ""), !ge.isUnderlineColorDefault())) if (ge.isUnderlineColorRGB()) L.style.textDecorationColor = `rgb(${m.AttributeData.toColorRGB(ge.getUnderlineColor()).join(",")})`;
              else {
                let Me = ge.getUnderlineColor();
                this._optionsService.rawOptions.drawBoldTextInBrightColors && ge.isBold() && Me < 8 && (Me += 8), L.style.textDecorationColor = E.ansi[Me].css;
              }
              ge.isOverline() && (fe.push("xterm-overline"), Y === " " && (Y = "")), ge.isStrikethrough() && fe.push("xterm-strikethrough"), zl && (L.style.textDecoration = "underline");
              let $t = ge.getFgColor(), $s = ge.getFgColorMode(), ii = ge.getBgColor(), Rs = ge.getBgColorMode();
              const Ul = !!ge.isInverse();
              if (Ul) {
                const Me = $t;
                $t = ii, ii = Me;
                const My = $s;
                $s = Rs, Rs = My;
              }
              let Vi, jl, Ui, Es = !1;
              switch (this._decorationService.forEachDecorationAtCell(ke, x, void 0, (Me) => {
                Me.options.layer !== "top" && Es || (Me.backgroundColorRGB && (Rs = 50331648, ii = Me.backgroundColorRGB.rgba >> 8 & 16777215, Vi = Me.backgroundColorRGB), Me.foregroundColorRGB && ($s = 50331648, $t = Me.foregroundColorRGB.rgba >> 8 & 16777215, jl = Me.foregroundColorRGB), Es = Me.options.layer === "top");
              }), !Es && Ts && (Vi = this._coreBrowserService.isFocused ? E.selectionBackgroundOpaque : E.selectionInactiveBackgroundOpaque, ii = Vi.rgba >> 8 & 16777215, Rs = 50331648, Es = !0, E.selectionForeground && ($s = 50331648, $t = E.selectionForeground.rgba >> 8 & 16777215, jl = E.selectionForeground)), Es && fe.push("xterm-decoration-top"), Rs) {
                case 16777216:
                case 33554432:
                  Ui = E.ansi[ii], fe.push(`xterm-bg-${ii}`);
                  break;
                case 50331648:
                  Ui = S.rgba.toColor(ii >> 16, ii >> 8 & 255, 255 & ii), this._addStyle(L, `background-color:#${b((ii >>> 0).toString(16), "0", 6)}`);
                  break;
                default:
                  Ul ? (Ui = E.foreground, fe.push(`xterm-bg-${u.INVERTED_DEFAULT_COLOR}`)) : Ui = E.background;
              }
              switch (Vi || ge.isDim() && (Vi = S.color.multiplyOpacity(Ui, 0.5)), $s) {
                case 16777216:
                case 33554432:
                  ge.isBold() && $t < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($t += 8), this._applyMinimumContrast(L, Ui, E.ansi[$t], ge, Vi, void 0) || fe.push(`xterm-fg-${$t}`);
                  break;
                case 50331648:
                  const Me = S.rgba.toColor($t >> 16 & 255, $t >> 8 & 255, 255 & $t);
                  this._applyMinimumContrast(L, Ui, Me, ge, Vi, jl) || this._addStyle(L, `color:#${b($t.toString(16), "0", 6)}`);
                  break;
                default:
                  this._applyMinimumContrast(L, Ui, E.foreground, ge, Vi, void 0) || Ul && fe.push(`xterm-fg-${u.INVERTED_DEFAULT_COLOR}`);
              }
              fe.length && (L.className = fe.join(" "), fe.length = 0), Wl || Ot || Vl ? L.textContent = Y : U++, j !== this.defaultSpacing && (L.style.letterSpacing = `${j}px`), z.push(L), ke = qr;
            }
            return L && U && (L.textContent = Y), z;
          }
          _applyMinimumContrast(w, x, y, k, $, R) {
            if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, g.excludeFromContrastRatioDemands)(k.getCode())) return !1;
            const T = this._getContrastCache(k);
            let A;
            if ($ || R || (A = T.getColor(x.rgba, y.rgba)), A === void 0) {
              const M = this._optionsService.rawOptions.minimumContrastRatio / (k.isDim() ? 2 : 1);
              A = S.color.ensureContrastRatio($ || x, R || y, M), T.setColor(($ || x).rgba, (R || y).rgba, A ?? null);
            }
            return !!A && (this._addStyle(w, `color:${A.css}`), !0);
          }
          _getContrastCache(w) {
            return w.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
          }
          _addStyle(w, x) {
            w.setAttribute("style", `${w.getAttribute("style") || ""}${x};`);
          }
          _isCellInSelection(w, x) {
            const y = this._selectionStart, k = this._selectionEnd;
            return !(!y || !k) && (this._columnSelectMode ? y[0] <= k[0] ? w >= y[0] && x >= y[1] && w < k[0] && x <= k[1] : w < y[0] && x >= y[1] && w >= k[0] && x <= k[1] : x > y[1] && x < k[1] || y[1] === k[1] && x === y[1] && w >= y[0] && w < k[0] || y[1] < k[1] && x === k[1] && w < k[0] || y[1] < k[1] && x === y[1] && w >= y[0]);
          }
        };
        function b(w, x, y) {
          for (; w.length < y; ) w = x + w;
          return w;
        }
        a.DomRendererRowFactory = _ = c([h(1, f.ICharacterJoinerService), h(2, v.IOptionsService), h(3, f.ICoreBrowserService), h(4, v.ICoreService), h(5, v.IDecorationService), h(6, f.IThemeService)], _);
      }, 2550: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.WidthCache = void 0, a.WidthCache = class {
          constructor(l) {
            this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = l.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
            const c = l.createElement("span"), h = l.createElement("span");
            h.style.fontWeight = "bold";
            const u = l.createElement("span");
            u.style.fontStyle = "italic";
            const d = l.createElement("span");
            d.style.fontWeight = "bold", d.style.fontStyle = "italic", this._measureElements = [c, h, u, d], this._container.appendChild(c), this._container.appendChild(h), this._container.appendChild(u), this._container.appendChild(d), l.body.appendChild(this._container), this.clear();
          }
          dispose() {
            this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
          }
          clear() {
            this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
          }
          setFont(l, c, h, u) {
            l === this._font && c === this._fontSize && h === this._weight && u === this._weightBold || (this._font = l, this._fontSize = c, this._weight = h, this._weightBold = u, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${h}`, this._measureElements[1].style.fontWeight = `${u}`, this._measureElements[2].style.fontWeight = `${h}`, this._measureElements[3].style.fontWeight = `${u}`, this.clear());
          }
          get(l, c, h) {
            let u = 0;
            if (!c && !h && l.length === 1 && (u = l.charCodeAt(0)) < 256) return this._flat[u] !== -9999 ? this._flat[u] : this._flat[u] = this._measure(l, 0);
            let d = l;
            c && (d += "B"), h && (d += "I");
            let O = this._holey.get(d);
            if (O === void 0) {
              let v = 0;
              c && (v |= 1), h && (v |= 2), O = this._measure(l, v), this._holey.set(d, O);
            }
            return O;
          }
          _measure(l, c) {
            const h = this._measureElements[c];
            return h.textContent = l.repeat(32), h.offsetWidth / 32;
          }
        };
      }, 2223: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.TEXT_BASELINE = a.DIM_OPACITY = a.INVERTED_DEFAULT_COLOR = void 0;
        const c = l(6114);
        a.INVERTED_DEFAULT_COLOR = 257, a.DIM_OPACITY = 0.5, a.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic";
      }, 6171: (o, a) => {
        function l(c) {
          return 57508 <= c && c <= 57558;
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.createRenderDimensions = a.excludeFromContrastRatioDemands = a.isRestrictedPowerlineGlyph = a.isPowerlineGlyph = a.throwIfFalsy = void 0, a.throwIfFalsy = function(c) {
          if (!c) throw new Error("value must not be falsy");
          return c;
        }, a.isPowerlineGlyph = l, a.isRestrictedPowerlineGlyph = function(c) {
          return 57520 <= c && c <= 57527;
        }, a.excludeFromContrastRatioDemands = function(c) {
          return l(c) || function(h) {
            return 9472 <= h && h <= 9631;
          }(c);
        }, a.createRenderDimensions = function() {
          return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
        };
      }, 456: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionModel = void 0, a.SelectionModel = class {
          constructor(l) {
            this._bufferService = l, this.isSelectAllActive = !1, this.selectionStartLength = 0;
          }
          clearSelection() {
            this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;
          }
          get finalSelectionStart() {
            return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
          }
          get finalSelectionEnd() {
            if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
            if (this.selectionStart) {
              if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                const l = this.selectionStart[0] + this.selectionStartLength;
                return l > this._bufferService.cols ? l % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols) - 1] : [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [l, this.selectionStart[1]];
              }
              if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                const l = this.selectionStart[0] + this.selectionStartLength;
                return l > this._bufferService.cols ? [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [Math.max(l, this.selectionEnd[0]), this.selectionEnd[1]];
              }
              return this.selectionEnd;
            }
          }
          areSelectionValuesReversed() {
            const l = this.selectionStart, c = this.selectionEnd;
            return !(!l || !c) && (l[1] > c[1] || l[1] === c[1] && l[0] > c[0]);
          }
          handleTrim(l) {
            return this.selectionStart && (this.selectionStart[1] -= l), this.selectionEnd && (this.selectionEnd[1] -= l), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);
          }
        };
      }, 428: function(o, a, l) {
        var c = this && this.__decorate || function(f, p, g, m) {
          var _, b = arguments.length, w = b < 3 ? p : m === null ? m = Object.getOwnPropertyDescriptor(p, g) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(f, p, g, m);
          else for (var x = f.length - 1; x >= 0; x--) (_ = f[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(p, g, w) : _(p, g)) || w);
          return b > 3 && w && Object.defineProperty(p, g, w), w;
        }, h = this && this.__param || function(f, p) {
          return function(g, m) {
            p(g, m, f);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CharSizeService = void 0;
        const u = l(2585), d = l(8460), O = l(844);
        let v = a.CharSizeService = class extends O.Disposable {
          get hasValidSize() {
            return this.width > 0 && this.height > 0;
          }
          constructor(f, p, g) {
            super(), this._optionsService = g, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new d.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new S(f, p, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
          }
          measure() {
            const f = this._measureStrategy.measure();
            f.width === this.width && f.height === this.height || (this.width = f.width, this.height = f.height, this._onCharSizeChange.fire());
          }
        };
        a.CharSizeService = v = c([h(2, u.IOptionsService)], v);
        class S {
          constructor(p, g, m) {
            this._document = p, this._parentElement = g, this._optionsService = m, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
          }
          measure() {
            this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
            const p = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
            return p.width !== 0 && p.height !== 0 && (this._result.width = p.width / 32, this._result.height = Math.ceil(p.height)), this._result;
          }
        }
      }, 4269: function(o, a, l) {
        var c = this && this.__decorate || function(p, g, m, _) {
          var b, w = arguments.length, x = w < 3 ? g : _ === null ? _ = Object.getOwnPropertyDescriptor(g, m) : _;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(p, g, m, _);
          else for (var y = p.length - 1; y >= 0; y--) (b = p[y]) && (x = (w < 3 ? b(x) : w > 3 ? b(g, m, x) : b(g, m)) || x);
          return w > 3 && x && Object.defineProperty(g, m, x), x;
        }, h = this && this.__param || function(p, g) {
          return function(m, _) {
            g(m, _, p);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CharacterJoinerService = a.JoinedCellData = void 0;
        const u = l(3734), d = l(643), O = l(511), v = l(2585);
        class S extends u.AttributeData {
          constructor(g, m, _) {
            super(), this.content = 0, this.combinedData = "", this.fg = g.fg, this.bg = g.bg, this.combinedData = m, this._width = _;
          }
          isCombined() {
            return 2097152;
          }
          getWidth() {
            return this._width;
          }
          getChars() {
            return this.combinedData;
          }
          getCode() {
            return 2097151;
          }
          setFromCharData(g) {
            throw new Error("not implemented");
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        a.JoinedCellData = S;
        let f = a.CharacterJoinerService = class yy {
          constructor(g) {
            this._bufferService = g, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new O.CellData();
          }
          register(g) {
            const m = { id: this._nextCharacterJoinerId++, handler: g };
            return this._characterJoiners.push(m), m.id;
          }
          deregister(g) {
            for (let m = 0; m < this._characterJoiners.length; m++) if (this._characterJoiners[m].id === g) return this._characterJoiners.splice(m, 1), !0;
            return !1;
          }
          getJoinedCharacters(g) {
            if (this._characterJoiners.length === 0) return [];
            const m = this._bufferService.buffer.lines.get(g);
            if (!m || m.length === 0) return [];
            const _ = [], b = m.translateToString(!0);
            let w = 0, x = 0, y = 0, k = m.getFg(0), $ = m.getBg(0);
            for (let R = 0; R < m.getTrimmedLength(); R++) if (m.loadCell(R, this._workCell), this._workCell.getWidth() !== 0) {
              if (this._workCell.fg !== k || this._workCell.bg !== $) {
                if (R - w > 1) {
                  const T = this._getJoinedRanges(b, y, x, m, w);
                  for (let A = 0; A < T.length; A++) _.push(T[A]);
                }
                w = R, y = x, k = this._workCell.fg, $ = this._workCell.bg;
              }
              x += this._workCell.getChars().length || d.WHITESPACE_CELL_CHAR.length;
            }
            if (this._bufferService.cols - w > 1) {
              const R = this._getJoinedRanges(b, y, x, m, w);
              for (let T = 0; T < R.length; T++) _.push(R[T]);
            }
            return _;
          }
          _getJoinedRanges(g, m, _, b, w) {
            const x = g.substring(m, _);
            let y = [];
            try {
              y = this._characterJoiners[0].handler(x);
            } catch (k) {
              console.error(k);
            }
            for (let k = 1; k < this._characterJoiners.length; k++) try {
              const $ = this._characterJoiners[k].handler(x);
              for (let R = 0; R < $.length; R++) yy._mergeRanges(y, $[R]);
            } catch ($) {
              console.error($);
            }
            return this._stringRangesToCellRanges(y, b, w), y;
          }
          _stringRangesToCellRanges(g, m, _) {
            let b = 0, w = !1, x = 0, y = g[b];
            if (y) {
              for (let k = _; k < this._bufferService.cols; k++) {
                const $ = m.getWidth(k), R = m.getString(k).length || d.WHITESPACE_CELL_CHAR.length;
                if ($ !== 0) {
                  if (!w && y[0] <= x && (y[0] = k, w = !0), y[1] <= x) {
                    if (y[1] = k, y = g[++b], !y) break;
                    y[0] <= x ? (y[0] = k, w = !0) : w = !1;
                  }
                  x += R;
                }
              }
              y && (y[1] = this._bufferService.cols);
            }
          }
          static _mergeRanges(g, m) {
            let _ = !1;
            for (let b = 0; b < g.length; b++) {
              const w = g[b];
              if (_) {
                if (m[1] <= w[0]) return g[b - 1][1] = m[1], g;
                if (m[1] <= w[1]) return g[b - 1][1] = Math.max(m[1], w[1]), g.splice(b, 1), g;
                g.splice(b, 1), b--;
              } else {
                if (m[1] <= w[0]) return g.splice(b, 0, m), g;
                if (m[1] <= w[1]) return w[0] = Math.min(m[0], w[0]), g;
                m[0] < w[1] && (w[0] = Math.min(m[0], w[0]), _ = !0);
              }
            }
            return _ ? g[g.length - 1][1] = m[1] : g.push(m), g;
          }
        };
        a.CharacterJoinerService = f = c([h(0, v.IBufferService)], f);
      }, 5114: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreBrowserService = void 0, a.CoreBrowserService = class {
          constructor(l, c) {
            this._textarea = l, this.window = c, this._isFocused = !1, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = !0), this._textarea.addEventListener("blur", () => this._isFocused = !1);
          }
          get dpr() {
            return this.window.devicePixelRatio;
          }
          get isFocused() {
            return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
          }
        };
      }, 8934: function(o, a, l) {
        var c = this && this.__decorate || function(v, S, f, p) {
          var g, m = arguments.length, _ = m < 3 ? S : p === null ? p = Object.getOwnPropertyDescriptor(S, f) : p;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") _ = Reflect.decorate(v, S, f, p);
          else for (var b = v.length - 1; b >= 0; b--) (g = v[b]) && (_ = (m < 3 ? g(_) : m > 3 ? g(S, f, _) : g(S, f)) || _);
          return m > 3 && _ && Object.defineProperty(S, f, _), _;
        }, h = this && this.__param || function(v, S) {
          return function(f, p) {
            S(f, p, v);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.MouseService = void 0;
        const u = l(4725), d = l(9806);
        let O = a.MouseService = class {
          constructor(v, S) {
            this._renderService = v, this._charSizeService = S;
          }
          getCoords(v, S, f, p, g) {
            return (0, d.getCoords)(window, v, S, f, p, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, g);
          }
          getMouseReportCoords(v, S) {
            const f = (0, d.getCoordsRelativeToElement)(window, v, S);
            if (this._charSizeService.hasValidSize) return f[0] = Math.min(Math.max(f[0], 0), this._renderService.dimensions.css.canvas.width - 1), f[1] = Math.min(Math.max(f[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(f[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(f[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(f[0]), y: Math.floor(f[1]) };
          }
        };
        a.MouseService = O = c([h(0, u.IRenderService), h(1, u.ICharSizeService)], O);
      }, 3230: function(o, a, l) {
        var c = this && this.__decorate || function(_, b, w, x) {
          var y, k = arguments.length, $ = k < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, w) : x;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") $ = Reflect.decorate(_, b, w, x);
          else for (var R = _.length - 1; R >= 0; R--) (y = _[R]) && ($ = (k < 3 ? y($) : k > 3 ? y(b, w, $) : y(b, w)) || $);
          return k > 3 && $ && Object.defineProperty(b, w, $), $;
        }, h = this && this.__param || function(_, b) {
          return function(w, x) {
            b(w, x, _);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderService = void 0;
        const u = l(3656), d = l(6193), O = l(5596), v = l(4725), S = l(8460), f = l(844), p = l(7226), g = l(2585);
        let m = a.RenderService = class extends f.Disposable {
          get dimensions() {
            return this._renderer.value.dimensions;
          }
          constructor(_, b, w, x, y, k, $, R) {
            if (super(), this._rowCount = _, this._charSizeService = x, this._renderer = this.register(new f.MutableDisposable()), this._pausedResizeTask = new p.DebouncedIdleTask(), this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: !1 }, this._onDimensionsChange = this.register(new S.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new S.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new S.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new S.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new d.RenderDebouncer($.window, (T, A) => this._renderRows(T, A)), this.register(this._renderDebouncer), this._screenDprMonitor = new O.ScreenDprMonitor($.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(k.onResize(() => this._fullRefresh())), this.register(k.buffers.onBufferActivate(() => {
              var T;
              return (T = this._renderer.value) === null || T === void 0 ? void 0 : T.clear();
            })), this.register(w.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(y.onDecorationRegistered(() => this._fullRefresh())), this.register(y.onDecorationRemoved(() => this._fullRefresh())), this.register(w.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
              this.clear(), this.handleResize(k.cols, k.rows), this._fullRefresh();
            })), this.register(w.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(k.buffer.y, k.buffer.y, !0))), this.register((0, u.addDisposableDomListener)($.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(R.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in $.window) {
              const T = new $.window.IntersectionObserver((A) => this._handleIntersectionChange(A[A.length - 1]), { threshold: 0 });
              T.observe(b), this.register({ dispose: () => T.disconnect() });
            }
          }
          _handleIntersectionChange(_) {
            this._isPaused = _.isIntersecting === void 0 ? _.intersectionRatio === 0 : !_.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);
          }
          refreshRows(_, b, w = !1) {
            this._isPaused ? this._needsFullRefresh = !0 : (w || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(_, b, this._rowCount));
          }
          _renderRows(_, b) {
            this._renderer.value && (_ = Math.min(_, this._rowCount - 1), b = Math.min(b, this._rowCount - 1), this._renderer.value.renderRows(_, b), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: _, end: b }), this._onRender.fire({ start: _, end: b }), this._isNextRenderRedrawOnly = !0);
          }
          resize(_, b) {
            this._rowCount = b, this._fireOnCanvasResize();
          }
          _handleOptionsChanged() {
            this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
          }
          _fireOnCanvasResize() {
            this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
          }
          hasRenderer() {
            return !!this._renderer.value;
          }
          setRenderer(_) {
            this._renderer.value = _, this._renderer.value.onRequestRedraw((b) => this.refreshRows(b.start, b.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh();
          }
          addRefreshCallback(_) {
            return this._renderDebouncer.addRefreshCallback(_);
          }
          _fullRefresh() {
            this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);
          }
          clearTextureAtlas() {
            var _, b;
            this._renderer.value && ((b = (_ = this._renderer.value).clearTextureAtlas) === null || b === void 0 || b.call(_), this._fullRefresh());
          }
          handleDevicePixelRatioChange() {
            this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
          }
          handleResize(_, b) {
            this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(_, b)) : this._renderer.value.handleResize(_, b), this._fullRefresh());
          }
          handleCharSizeChanged() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleCharSizeChanged();
          }
          handleBlur() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleBlur();
          }
          handleFocus() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleFocus();
          }
          handleSelectionChanged(_, b, w) {
            var x;
            this._selectionState.start = _, this._selectionState.end = b, this._selectionState.columnSelectMode = w, (x = this._renderer.value) === null || x === void 0 || x.handleSelectionChanged(_, b, w);
          }
          handleCursorMove() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleCursorMove();
          }
          clear() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.clear();
          }
        };
        a.RenderService = m = c([h(2, g.IOptionsService), h(3, v.ICharSizeService), h(4, g.IDecorationService), h(5, g.IBufferService), h(6, v.ICoreBrowserService), h(7, v.IThemeService)], m);
      }, 9312: function(o, a, l) {
        var c = this && this.__decorate || function(y, k, $, R) {
          var T, A = arguments.length, M = A < 3 ? k : R === null ? R = Object.getOwnPropertyDescriptor(k, $) : R;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") M = Reflect.decorate(y, k, $, R);
          else for (var B = y.length - 1; B >= 0; B--) (T = y[B]) && (M = (A < 3 ? T(M) : A > 3 ? T(k, $, M) : T(k, $)) || M);
          return A > 3 && M && Object.defineProperty(k, $, M), M;
        }, h = this && this.__param || function(y, k) {
          return function($, R) {
            k($, R, y);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionService = void 0;
        const u = l(9806), d = l(9504), O = l(456), v = l(4725), S = l(8460), f = l(844), p = l(6114), g = l(4841), m = l(511), _ = l(2585), b = "", w = new RegExp(b, "g");
        let x = a.SelectionService = class extends f.Disposable {
          constructor(y, k, $, R, T, A, M, B, W) {
            super(), this._element = y, this._screenElement = k, this._linkifier = $, this._bufferService = R, this._coreService = T, this._mouseService = A, this._optionsService = M, this._renderService = B, this._coreBrowserService = W, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new m.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new S.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new S.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new S.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new S.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (z) => this._handleMouseMove(z), this._mouseUpListener = (z) => this._handleMouseUp(z), this._coreService.onUserInput(() => {
              this.hasSelection && this.clearSelection();
            }), this._trimListener = this._bufferService.buffer.lines.onTrim((z) => this._handleTrim(z)), this.register(this._bufferService.buffers.onBufferActivate((z) => this._handleBufferActivate(z))), this.enable(), this._model = new O.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, f.toDisposable)(() => {
              this._removeMouseDownListeners();
            }));
          }
          reset() {
            this.clearSelection();
          }
          disable() {
            this.clearSelection(), this._enabled = !1;
          }
          enable() {
            this._enabled = !0;
          }
          get selectionStart() {
            return this._model.finalSelectionStart;
          }
          get selectionEnd() {
            return this._model.finalSelectionEnd;
          }
          get hasSelection() {
            const y = this._model.finalSelectionStart, k = this._model.finalSelectionEnd;
            return !(!y || !k || y[0] === k[0] && y[1] === k[1]);
          }
          get selectionText() {
            const y = this._model.finalSelectionStart, k = this._model.finalSelectionEnd;
            if (!y || !k) return "";
            const $ = this._bufferService.buffer, R = [];
            if (this._activeSelectionMode === 3) {
              if (y[0] === k[0]) return "";
              const T = y[0] < k[0] ? y[0] : k[0], A = y[0] < k[0] ? k[0] : y[0];
              for (let M = y[1]; M <= k[1]; M++) {
                const B = $.translateBufferLineToString(M, !0, T, A);
                R.push(B);
              }
            } else {
              const T = y[1] === k[1] ? k[0] : void 0;
              R.push($.translateBufferLineToString(y[1], !0, y[0], T));
              for (let A = y[1] + 1; A <= k[1] - 1; A++) {
                const M = $.lines.get(A), B = $.translateBufferLineToString(A, !0);
                M?.isWrapped ? R[R.length - 1] += B : R.push(B);
              }
              if (y[1] !== k[1]) {
                const A = $.lines.get(k[1]), M = $.translateBufferLineToString(k[1], !0, 0, k[0]);
                A && A.isWrapped ? R[R.length - 1] += M : R.push(M);
              }
            }
            return R.map((T) => T.replace(w, " ")).join(p.isWindows ? `\r
` : `
`);
          }
          clearSelection() {
            this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
          }
          refresh(y) {
            this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), p.isLinux && y && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
          }
          _refresh() {
            this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
          }
          _isClickInSelection(y) {
            const k = this._getMouseBufferCoords(y), $ = this._model.finalSelectionStart, R = this._model.finalSelectionEnd;
            return !!($ && R && k) && this._areCoordsInSelection(k, $, R);
          }
          isCellInSelection(y, k) {
            const $ = this._model.finalSelectionStart, R = this._model.finalSelectionEnd;
            return !(!$ || !R) && this._areCoordsInSelection([y, k], $, R);
          }
          _areCoordsInSelection(y, k, $) {
            return y[1] > k[1] && y[1] < $[1] || k[1] === $[1] && y[1] === k[1] && y[0] >= k[0] && y[0] < $[0] || k[1] < $[1] && y[1] === $[1] && y[0] < $[0] || k[1] < $[1] && y[1] === k[1] && y[0] >= k[0];
          }
          _selectWordAtCursor(y, k) {
            var $, R;
            const T = (R = ($ = this._linkifier.currentLink) === null || $ === void 0 ? void 0 : $.link) === null || R === void 0 ? void 0 : R.range;
            if (T) return this._model.selectionStart = [T.start.x - 1, T.start.y - 1], this._model.selectionStartLength = (0, g.getRangeLength)(T, this._bufferService.cols), this._model.selectionEnd = void 0, !0;
            const A = this._getMouseBufferCoords(y);
            return !!A && (this._selectWordAt(A, k), this._model.selectionEnd = void 0, !0);
          }
          selectAll() {
            this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();
          }
          selectLines(y, k) {
            this._model.clearSelection(), y = Math.max(y, 0), k = Math.min(k, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, y], this._model.selectionEnd = [this._bufferService.cols, k], this.refresh(), this._onSelectionChange.fire();
          }
          _handleTrim(y) {
            this._model.handleTrim(y) && this.refresh();
          }
          _getMouseBufferCoords(y) {
            const k = this._mouseService.getCoords(y, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
            if (k) return k[0]--, k[1]--, k[1] += this._bufferService.buffer.ydisp, k;
          }
          _getMouseEventScrollAmount(y) {
            let k = (0, u.getCoordsRelativeToElement)(this._coreBrowserService.window, y, this._screenElement)[1];
            const $ = this._renderService.dimensions.css.canvas.height;
            return k >= 0 && k <= $ ? 0 : (k > $ && (k -= $), k = Math.min(Math.max(k, -50), 50), k /= 50, k / Math.abs(k) + Math.round(14 * k));
          }
          shouldForceSelection(y) {
            return p.isMac ? y.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : y.shiftKey;
          }
          handleMouseDown(y) {
            if (this._mouseDownTimeStamp = y.timeStamp, (y.button !== 2 || !this.hasSelection) && y.button === 0) {
              if (!this._enabled) {
                if (!this.shouldForceSelection(y)) return;
                y.stopPropagation();
              }
              y.preventDefault(), this._dragScrollAmount = 0, this._enabled && y.shiftKey ? this._handleIncrementalClick(y) : y.detail === 1 ? this._handleSingleClick(y) : y.detail === 2 ? this._handleDoubleClick(y) : y.detail === 3 && this._handleTripleClick(y), this._addMouseDownListeners(), this.refresh(!0);
            }
          }
          _addMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
          }
          _removeMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
          }
          _handleIncrementalClick(y) {
            this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(y));
          }
          _handleSingleClick(y) {
            if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(y) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(y), !this._model.selectionStart) return;
            this._model.selectionEnd = void 0;
            const k = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
            k && k.length !== this._model.selectionStart[0] && k.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
          }
          _handleDoubleClick(y) {
            this._selectWordAtCursor(y, !0) && (this._activeSelectionMode = 1);
          }
          _handleTripleClick(y) {
            const k = this._getMouseBufferCoords(y);
            k && (this._activeSelectionMode = 2, this._selectLineAt(k[1]));
          }
          shouldColumnSelect(y) {
            return y.altKey && !(p.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
          }
          _handleMouseMove(y) {
            if (y.stopImmediatePropagation(), !this._model.selectionStart) return;
            const k = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
            if (this._model.selectionEnd = this._getMouseBufferCoords(y), !this._model.selectionEnd) return void this.refresh(!0);
            this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(y), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
            const $ = this._bufferService.buffer;
            if (this._model.selectionEnd[1] < $.lines.length) {
              const R = $.lines.get(this._model.selectionEnd[1]);
              R && R.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0]++;
            }
            k && k[0] === this._model.selectionEnd[0] && k[1] === this._model.selectionEnd[1] || this.refresh(!0);
          }
          _dragScroll() {
            if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
              this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: !1 });
              const y = this._bufferService.buffer;
              this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(y.ydisp + this._bufferService.rows, y.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = y.ydisp), this.refresh();
            }
          }
          _handleMouseUp(y) {
            const k = y.timeStamp - this._mouseDownTimeStamp;
            if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && k < 500 && y.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
              if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                const $ = this._mouseService.getCoords(y, this._element, this._bufferService.cols, this._bufferService.rows, !1);
                if ($ && $[0] !== void 0 && $[1] !== void 0) {
                  const R = (0, d.moveToCellSequence)($[0] - 1, $[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                  this._coreService.triggerDataEvent(R, !0);
                }
              }
            } else this._fireEventIfSelectionChanged();
          }
          _fireEventIfSelectionChanged() {
            const y = this._model.finalSelectionStart, k = this._model.finalSelectionEnd, $ = !(!y || !k || y[0] === k[0] && y[1] === k[1]);
            $ ? y && k && (this._oldSelectionStart && this._oldSelectionEnd && y[0] === this._oldSelectionStart[0] && y[1] === this._oldSelectionStart[1] && k[0] === this._oldSelectionEnd[0] && k[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(y, k, $)) : this._oldHasSelection && this._fireOnSelectionChange(y, k, $);
          }
          _fireOnSelectionChange(y, k, $) {
            this._oldSelectionStart = y, this._oldSelectionEnd = k, this._oldHasSelection = $, this._onSelectionChange.fire();
          }
          _handleBufferActivate(y) {
            this.clearSelection(), this._trimListener.dispose(), this._trimListener = y.activeBuffer.lines.onTrim((k) => this._handleTrim(k));
          }
          _convertViewportColToCharacterIndex(y, k) {
            let $ = k;
            for (let R = 0; k >= R; R++) {
              const T = y.loadCell(R, this._workCell).getChars().length;
              this._workCell.getWidth() === 0 ? $-- : T > 1 && k !== R && ($ += T - 1);
            }
            return $;
          }
          setSelection(y, k, $) {
            this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [y, k], this._model.selectionStartLength = $, this.refresh(), this._fireEventIfSelectionChanged();
          }
          rightClickSelect(y) {
            this._isClickInSelection(y) || (this._selectWordAtCursor(y, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());
          }
          _getWordAt(y, k, $ = !0, R = !0) {
            if (y[0] >= this._bufferService.cols) return;
            const T = this._bufferService.buffer, A = T.lines.get(y[1]);
            if (!A) return;
            const M = T.translateBufferLineToString(y[1], !1);
            let B = this._convertViewportColToCharacterIndex(A, y[0]), W = B;
            const z = y[0] - B;
            let Q = 0, E = 0, L = 0, D = 0;
            if (M.charAt(B) === " ") {
              for (; B > 0 && M.charAt(B - 1) === " "; ) B--;
              for (; W < M.length && M.charAt(W + 1) === " "; ) W++;
            } else {
              let ne = y[0], te = y[0];
              A.getWidth(ne) === 0 && (Q++, ne--), A.getWidth(te) === 2 && (E++, te++);
              const de = A.getString(te).length;
              for (de > 1 && (D += de - 1, W += de - 1); ne > 0 && B > 0 && !this._isCharWordSeparator(A.loadCell(ne - 1, this._workCell)); ) {
                A.loadCell(ne - 1, this._workCell);
                const P = this._workCell.getChars().length;
                this._workCell.getWidth() === 0 ? (Q++, ne--) : P > 1 && (L += P - 1, B -= P - 1), B--, ne--;
              }
              for (; te < A.length && W + 1 < M.length && !this._isCharWordSeparator(A.loadCell(te + 1, this._workCell)); ) {
                A.loadCell(te + 1, this._workCell);
                const P = this._workCell.getChars().length;
                this._workCell.getWidth() === 2 ? (E++, te++) : P > 1 && (D += P - 1, W += P - 1), W++, te++;
              }
            }
            W++;
            let U = B + z - Q + L, Y = Math.min(this._bufferService.cols, W - B + Q + E - L - D);
            if (k || M.slice(B, W).trim() !== "") {
              if ($ && U === 0 && A.getCodePoint(0) !== 32) {
                const ne = T.lines.get(y[1] - 1);
                if (ne && A.isWrapped && ne.getCodePoint(this._bufferService.cols - 1) !== 32) {
                  const te = this._getWordAt([this._bufferService.cols - 1, y[1] - 1], !1, !0, !1);
                  if (te) {
                    const de = this._bufferService.cols - te.start;
                    U -= de, Y += de;
                  }
                }
              }
              if (R && U + Y === this._bufferService.cols && A.getCodePoint(this._bufferService.cols - 1) !== 32) {
                const ne = T.lines.get(y[1] + 1);
                if (ne?.isWrapped && ne.getCodePoint(0) !== 32) {
                  const te = this._getWordAt([0, y[1] + 1], !1, !1, !0);
                  te && (Y += te.length);
                }
              }
              return { start: U, length: Y };
            }
          }
          _selectWordAt(y, k) {
            const $ = this._getWordAt(y, k);
            if ($) {
              for (; $.start < 0; ) $.start += this._bufferService.cols, y[1]--;
              this._model.selectionStart = [$.start, y[1]], this._model.selectionStartLength = $.length;
            }
          }
          _selectToWordAt(y) {
            const k = this._getWordAt(y, !0);
            if (k) {
              let $ = y[1];
              for (; k.start < 0; ) k.start += this._bufferService.cols, $--;
              if (!this._model.areSelectionValuesReversed()) for (; k.start + k.length > this._bufferService.cols; ) k.length -= this._bufferService.cols, $++;
              this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? k.start : k.start + k.length, $];
            }
          }
          _isCharWordSeparator(y) {
            return y.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(y.getChars()) >= 0;
          }
          _selectLineAt(y) {
            const k = this._bufferService.buffer.getWrappedRangeForLine(y), $ = { start: { x: 0, y: k.first }, end: { x: this._bufferService.cols - 1, y: k.last } };
            this._model.selectionStart = [0, k.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, g.getRangeLength)($, this._bufferService.cols);
          }
        };
        a.SelectionService = x = c([h(3, _.IBufferService), h(4, _.ICoreService), h(5, v.IMouseService), h(6, _.IOptionsService), h(7, v.IRenderService), h(8, v.ICoreBrowserService)], x);
      }, 4725: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.IThemeService = a.ICharacterJoinerService = a.ISelectionService = a.IRenderService = a.IMouseService = a.ICoreBrowserService = a.ICharSizeService = void 0;
        const c = l(8343);
        a.ICharSizeService = (0, c.createDecorator)("CharSizeService"), a.ICoreBrowserService = (0, c.createDecorator)("CoreBrowserService"), a.IMouseService = (0, c.createDecorator)("MouseService"), a.IRenderService = (0, c.createDecorator)("RenderService"), a.ISelectionService = (0, c.createDecorator)("SelectionService"), a.ICharacterJoinerService = (0, c.createDecorator)("CharacterJoinerService"), a.IThemeService = (0, c.createDecorator)("ThemeService");
      }, 6731: function(o, a, l) {
        var c = this && this.__decorate || function(x, y, k, $) {
          var R, T = arguments.length, A = T < 3 ? y : $ === null ? $ = Object.getOwnPropertyDescriptor(y, k) : $;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") A = Reflect.decorate(x, y, k, $);
          else for (var M = x.length - 1; M >= 0; M--) (R = x[M]) && (A = (T < 3 ? R(A) : T > 3 ? R(y, k, A) : R(y, k)) || A);
          return T > 3 && A && Object.defineProperty(y, k, A), A;
        }, h = this && this.__param || function(x, y) {
          return function(k, $) {
            y(k, $, x);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ThemeService = a.DEFAULT_ANSI_COLORS = void 0;
        const u = l(7239), d = l(8055), O = l(8460), v = l(844), S = l(2585), f = d.css.toColor("#ffffff"), p = d.css.toColor("#000000"), g = d.css.toColor("#ffffff"), m = d.css.toColor("#000000"), _ = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        a.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const x = [d.css.toColor("#2e3436"), d.css.toColor("#cc0000"), d.css.toColor("#4e9a06"), d.css.toColor("#c4a000"), d.css.toColor("#3465a4"), d.css.toColor("#75507b"), d.css.toColor("#06989a"), d.css.toColor("#d3d7cf"), d.css.toColor("#555753"), d.css.toColor("#ef2929"), d.css.toColor("#8ae234"), d.css.toColor("#fce94f"), d.css.toColor("#729fcf"), d.css.toColor("#ad7fa8"), d.css.toColor("#34e2e2"), d.css.toColor("#eeeeec")], y = [0, 95, 135, 175, 215, 255];
          for (let k = 0; k < 216; k++) {
            const $ = y[k / 36 % 6 | 0], R = y[k / 6 % 6 | 0], T = y[k % 6];
            x.push({ css: d.channels.toCss($, R, T), rgba: d.channels.toRgba($, R, T) });
          }
          for (let k = 0; k < 24; k++) {
            const $ = 8 + 10 * k;
            x.push({ css: d.channels.toCss($, $, $), rgba: d.channels.toRgba($, $, $) });
          }
          return x;
        })());
        let b = a.ThemeService = class extends v.Disposable {
          get colors() {
            return this._colors;
          }
          constructor(x) {
            super(), this._optionsService = x, this._contrastCache = new u.ColorContrastCache(), this._halfContrastCache = new u.ColorContrastCache(), this._onChangeColors = this.register(new O.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: f, background: p, cursor: g, cursorAccent: m, selectionForeground: void 0, selectionBackgroundTransparent: _, selectionBackgroundOpaque: d.color.blend(p, _), selectionInactiveBackgroundTransparent: _, selectionInactiveBackgroundOpaque: d.color.blend(p, _), ansi: a.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
          }
          _setTheme(x = {}) {
            const y = this._colors;
            if (y.foreground = w(x.foreground, f), y.background = w(x.background, p), y.cursor = w(x.cursor, g), y.cursorAccent = w(x.cursorAccent, m), y.selectionBackgroundTransparent = w(x.selectionBackground, _), y.selectionBackgroundOpaque = d.color.blend(y.background, y.selectionBackgroundTransparent), y.selectionInactiveBackgroundTransparent = w(x.selectionInactiveBackground, y.selectionBackgroundTransparent), y.selectionInactiveBackgroundOpaque = d.color.blend(y.background, y.selectionInactiveBackgroundTransparent), y.selectionForeground = x.selectionForeground ? w(x.selectionForeground, d.NULL_COLOR) : void 0, y.selectionForeground === d.NULL_COLOR && (y.selectionForeground = void 0), d.color.isOpaque(y.selectionBackgroundTransparent) && (y.selectionBackgroundTransparent = d.color.opacity(y.selectionBackgroundTransparent, 0.3)), d.color.isOpaque(y.selectionInactiveBackgroundTransparent) && (y.selectionInactiveBackgroundTransparent = d.color.opacity(y.selectionInactiveBackgroundTransparent, 0.3)), y.ansi = a.DEFAULT_ANSI_COLORS.slice(), y.ansi[0] = w(x.black, a.DEFAULT_ANSI_COLORS[0]), y.ansi[1] = w(x.red, a.DEFAULT_ANSI_COLORS[1]), y.ansi[2] = w(x.green, a.DEFAULT_ANSI_COLORS[2]), y.ansi[3] = w(x.yellow, a.DEFAULT_ANSI_COLORS[3]), y.ansi[4] = w(x.blue, a.DEFAULT_ANSI_COLORS[4]), y.ansi[5] = w(x.magenta, a.DEFAULT_ANSI_COLORS[5]), y.ansi[6] = w(x.cyan, a.DEFAULT_ANSI_COLORS[6]), y.ansi[7] = w(x.white, a.DEFAULT_ANSI_COLORS[7]), y.ansi[8] = w(x.brightBlack, a.DEFAULT_ANSI_COLORS[8]), y.ansi[9] = w(x.brightRed, a.DEFAULT_ANSI_COLORS[9]), y.ansi[10] = w(x.brightGreen, a.DEFAULT_ANSI_COLORS[10]), y.ansi[11] = w(x.brightYellow, a.DEFAULT_ANSI_COLORS[11]), y.ansi[12] = w(x.brightBlue, a.DEFAULT_ANSI_COLORS[12]), y.ansi[13] = w(x.brightMagenta, a.DEFAULT_ANSI_COLORS[13]), y.ansi[14] = w(x.brightCyan, a.DEFAULT_ANSI_COLORS[14]), y.ansi[15] = w(x.brightWhite, a.DEFAULT_ANSI_COLORS[15]), x.extendedAnsi) {
              const k = Math.min(y.ansi.length - 16, x.extendedAnsi.length);
              for (let $ = 0; $ < k; $++) y.ansi[$ + 16] = w(x.extendedAnsi[$], a.DEFAULT_ANSI_COLORS[$ + 16]);
            }
            this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(x) {
            this._restoreColor(x), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(x) {
            if (x !== void 0) switch (x) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[x] = this._restoreColors.ansi[x];
            }
            else for (let y = 0; y < this._restoreColors.ansi.length; ++y) this._colors.ansi[y] = this._restoreColors.ansi[y];
          }
          modifyColors(x) {
            x(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function w(x, y) {
          if (x !== void 0) try {
            return d.css.toColor(x);
          } catch {
          }
          return y;
        }
        a.ThemeService = b = c([h(0, S.IOptionsService)], b);
      }, 6349: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CircularList = void 0;
        const c = l(8460), h = l(844);
        class u extends h.Disposable {
          constructor(O) {
            super(), this._maxLength = O, this.onDeleteEmitter = this.register(new c.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new c.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new c.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(O) {
            if (this._maxLength === O) return;
            const v = new Array(O);
            for (let S = 0; S < Math.min(O, this.length); S++) v[S] = this._array[this._getCyclicIndex(S)];
            this._array = v, this._maxLength = O, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(O) {
            if (O > this._length) for (let v = this._length; v < O; v++) this._array[v] = void 0;
            this._length = O;
          }
          get(O) {
            return this._array[this._getCyclicIndex(O)];
          }
          set(O, v) {
            this._array[this._getCyclicIndex(O)] = v;
          }
          push(O) {
            this._array[this._getCyclicIndex(this._length)] = O, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(O, v, ...S) {
            if (v) {
              for (let f = O; f < this._length - v; f++) this._array[this._getCyclicIndex(f)] = this._array[this._getCyclicIndex(f + v)];
              this._length -= v, this.onDeleteEmitter.fire({ index: O, amount: v });
            }
            for (let f = this._length - 1; f >= O; f--) this._array[this._getCyclicIndex(f + S.length)] = this._array[this._getCyclicIndex(f)];
            for (let f = 0; f < S.length; f++) this._array[this._getCyclicIndex(O + f)] = S[f];
            if (S.length && this.onInsertEmitter.fire({ index: O, amount: S.length }), this._length + S.length > this._maxLength) {
              const f = this._length + S.length - this._maxLength;
              this._startIndex += f, this._length = this._maxLength, this.onTrimEmitter.fire(f);
            } else this._length += S.length;
          }
          trimStart(O) {
            O > this._length && (O = this._length), this._startIndex += O, this._length -= O, this.onTrimEmitter.fire(O);
          }
          shiftElements(O, v, S) {
            if (!(v <= 0)) {
              if (O < 0 || O >= this._length) throw new Error("start argument out of range");
              if (O + S < 0) throw new Error("Cannot shift elements in list beyond index 0");
              if (S > 0) {
                for (let p = v - 1; p >= 0; p--) this.set(O + p + S, this.get(O + p));
                const f = O + v + S - this._length;
                if (f > 0) for (this._length += f; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else for (let f = 0; f < v; f++) this.set(O + f + S, this.get(O + f));
            }
          }
          _getCyclicIndex(O) {
            return (this._startIndex + O) % this._maxLength;
          }
        }
        a.CircularList = u;
      }, 1439: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.clone = void 0, a.clone = function l(c, h = 5) {
          if (typeof c != "object") return c;
          const u = Array.isArray(c) ? [] : {};
          for (const d in c) u[d] = h <= 1 ? c[d] : c[d] && l(c[d], h - 1);
          return u;
        };
      }, 8055: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.contrastRatio = a.toPaddedHex = a.rgba = a.rgb = a.css = a.color = a.channels = a.NULL_COLOR = void 0;
        const c = l(6114);
        let h = 0, u = 0, d = 0, O = 0;
        var v, S, f, p, g;
        function m(b) {
          const w = b.toString(16);
          return w.length < 2 ? "0" + w : w;
        }
        function _(b, w) {
          return b < w ? (w + 0.05) / (b + 0.05) : (b + 0.05) / (w + 0.05);
        }
        a.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(b) {
          b.toCss = function(w, x, y, k) {
            return k !== void 0 ? `#${m(w)}${m(x)}${m(y)}${m(k)}` : `#${m(w)}${m(x)}${m(y)}`;
          }, b.toRgba = function(w, x, y, k = 255) {
            return (w << 24 | x << 16 | y << 8 | k) >>> 0;
          };
        }(v || (a.channels = v = {})), function(b) {
          function w(x, y) {
            return O = Math.round(255 * y), [h, u, d] = g.toChannels(x.rgba), { css: v.toCss(h, u, d, O), rgba: v.toRgba(h, u, d, O) };
          }
          b.blend = function(x, y) {
            if (O = (255 & y.rgba) / 255, O === 1) return { css: y.css, rgba: y.rgba };
            const k = y.rgba >> 24 & 255, $ = y.rgba >> 16 & 255, R = y.rgba >> 8 & 255, T = x.rgba >> 24 & 255, A = x.rgba >> 16 & 255, M = x.rgba >> 8 & 255;
            return h = T + Math.round((k - T) * O), u = A + Math.round(($ - A) * O), d = M + Math.round((R - M) * O), { css: v.toCss(h, u, d), rgba: v.toRgba(h, u, d) };
          }, b.isOpaque = function(x) {
            return (255 & x.rgba) == 255;
          }, b.ensureContrastRatio = function(x, y, k) {
            const $ = g.ensureContrastRatio(x.rgba, y.rgba, k);
            if ($) return g.toColor($ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255);
          }, b.opaque = function(x) {
            const y = (255 | x.rgba) >>> 0;
            return [h, u, d] = g.toChannels(y), { css: v.toCss(h, u, d), rgba: y };
          }, b.opacity = w, b.multiplyOpacity = function(x, y) {
            return O = 255 & x.rgba, w(x, O * y / 255);
          }, b.toColorRGB = function(x) {
            return [x.rgba >> 24 & 255, x.rgba >> 16 & 255, x.rgba >> 8 & 255];
          };
        }(S || (a.color = S = {})), function(b) {
          let w, x;
          if (!c.isNode) {
            const y = document.createElement("canvas");
            y.width = 1, y.height = 1;
            const k = y.getContext("2d", { willReadFrequently: !0 });
            k && (w = k, w.globalCompositeOperation = "copy", x = w.createLinearGradient(0, 0, 1, 1));
          }
          b.toColor = function(y) {
            if (y.match(/#[\da-f]{3,8}/i)) switch (y.length) {
              case 4:
                return h = parseInt(y.slice(1, 2).repeat(2), 16), u = parseInt(y.slice(2, 3).repeat(2), 16), d = parseInt(y.slice(3, 4).repeat(2), 16), g.toColor(h, u, d);
              case 5:
                return h = parseInt(y.slice(1, 2).repeat(2), 16), u = parseInt(y.slice(2, 3).repeat(2), 16), d = parseInt(y.slice(3, 4).repeat(2), 16), O = parseInt(y.slice(4, 5).repeat(2), 16), g.toColor(h, u, d, O);
              case 7:
                return { css: y, rgba: (parseInt(y.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: y, rgba: parseInt(y.slice(1), 16) >>> 0 };
            }
            const k = y.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (k) return h = parseInt(k[1]), u = parseInt(k[2]), d = parseInt(k[3]), O = Math.round(255 * (k[5] === void 0 ? 1 : parseFloat(k[5]))), g.toColor(h, u, d, O);
            if (!w || !x) throw new Error("css.toColor: Unsupported css format");
            if (w.fillStyle = x, w.fillStyle = y, typeof w.fillStyle != "string") throw new Error("css.toColor: Unsupported css format");
            if (w.fillRect(0, 0, 1, 1), [h, u, d, O] = w.getImageData(0, 0, 1, 1).data, O !== 255) throw new Error("css.toColor: Unsupported css format");
            return { rgba: v.toRgba(h, u, d, O), css: y };
          };
        }(f || (a.css = f = {})), function(b) {
          function w(x, y, k) {
            const $ = x / 255, R = y / 255, T = k / 255;
            return 0.2126 * ($ <= 0.03928 ? $ / 12.92 : Math.pow(($ + 0.055) / 1.055, 2.4)) + 0.7152 * (R <= 0.03928 ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4)) + 0.0722 * (T <= 0.03928 ? T / 12.92 : Math.pow((T + 0.055) / 1.055, 2.4));
          }
          b.relativeLuminance = function(x) {
            return w(x >> 16 & 255, x >> 8 & 255, 255 & x);
          }, b.relativeLuminance2 = w;
        }(p || (a.rgb = p = {})), function(b) {
          function w(y, k, $) {
            const R = y >> 24 & 255, T = y >> 16 & 255, A = y >> 8 & 255;
            let M = k >> 24 & 255, B = k >> 16 & 255, W = k >> 8 & 255, z = _(p.relativeLuminance2(M, B, W), p.relativeLuminance2(R, T, A));
            for (; z < $ && (M > 0 || B > 0 || W > 0); ) M -= Math.max(0, Math.ceil(0.1 * M)), B -= Math.max(0, Math.ceil(0.1 * B)), W -= Math.max(0, Math.ceil(0.1 * W)), z = _(p.relativeLuminance2(M, B, W), p.relativeLuminance2(R, T, A));
            return (M << 24 | B << 16 | W << 8 | 255) >>> 0;
          }
          function x(y, k, $) {
            const R = y >> 24 & 255, T = y >> 16 & 255, A = y >> 8 & 255;
            let M = k >> 24 & 255, B = k >> 16 & 255, W = k >> 8 & 255, z = _(p.relativeLuminance2(M, B, W), p.relativeLuminance2(R, T, A));
            for (; z < $ && (M < 255 || B < 255 || W < 255); ) M = Math.min(255, M + Math.ceil(0.1 * (255 - M))), B = Math.min(255, B + Math.ceil(0.1 * (255 - B))), W = Math.min(255, W + Math.ceil(0.1 * (255 - W))), z = _(p.relativeLuminance2(M, B, W), p.relativeLuminance2(R, T, A));
            return (M << 24 | B << 16 | W << 8 | 255) >>> 0;
          }
          b.ensureContrastRatio = function(y, k, $) {
            const R = p.relativeLuminance(y >> 8), T = p.relativeLuminance(k >> 8);
            if (_(R, T) < $) {
              if (T < R) {
                const B = w(y, k, $), W = _(R, p.relativeLuminance(B >> 8));
                if (W < $) {
                  const z = x(y, k, $);
                  return W > _(R, p.relativeLuminance(z >> 8)) ? B : z;
                }
                return B;
              }
              const A = x(y, k, $), M = _(R, p.relativeLuminance(A >> 8));
              if (M < $) {
                const B = w(y, k, $);
                return M > _(R, p.relativeLuminance(B >> 8)) ? A : B;
              }
              return A;
            }
          }, b.reduceLuminance = w, b.increaseLuminance = x, b.toChannels = function(y) {
            return [y >> 24 & 255, y >> 16 & 255, y >> 8 & 255, 255 & y];
          }, b.toColor = function(y, k, $, R) {
            return { css: v.toCss(y, k, $, R), rgba: v.toRgba(y, k, $, R) };
          };
        }(g || (a.rgba = g = {})), a.toPaddedHex = m, a.contrastRatio = _;
      }, 8969: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreTerminal = void 0;
        const c = l(844), h = l(2585), u = l(4348), d = l(7866), O = l(744), v = l(7302), S = l(6975), f = l(8460), p = l(1753), g = l(1480), m = l(7994), _ = l(9282), b = l(5435), w = l(5981), x = l(2660);
        let y = !1;
        class k extends c.Disposable {
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new f.EventEmitter()), this._onScroll.event((R) => {
              var T;
              (T = this._onScrollApi) === null || T === void 0 || T.fire(R.position);
            })), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(R) {
            for (const T in R) this.optionsService.options[T] = R[T];
          }
          constructor(R) {
            super(), this._windowsWrappingHeuristics = this.register(new c.MutableDisposable()), this._onBinary = this.register(new f.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new f.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new f.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new f.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new f.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new f.EventEmitter()), this._instantiationService = new u.InstantiationService(), this.optionsService = this.register(new v.OptionsService(R)), this._instantiationService.setService(h.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(O.BufferService)), this._instantiationService.setService(h.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(d.LogService)), this._instantiationService.setService(h.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(S.CoreService)), this._instantiationService.setService(h.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(p.CoreMouseService)), this._instantiationService.setService(h.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(g.UnicodeService)), this._instantiationService.setService(h.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(m.CharsetService), this._instantiationService.setService(h.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(x.OscLinkService), this._instantiationService.setService(h.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new b.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, f.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, f.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, f.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, f.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((T) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this.register(this._inputHandler.onScroll((T) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this._writeBuffer = this.register(new w.WriteBuffer((T, A) => this._inputHandler.parse(T, A))), this.register((0, f.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
          }
          write(R, T) {
            this._writeBuffer.write(R, T);
          }
          writeSync(R, T) {
            this._logService.logLevel <= h.LogLevelEnum.WARN && !y && (this._logService.warn("writeSync is unreliable and will be removed soon."), y = !0), this._writeBuffer.writeSync(R, T);
          }
          resize(R, T) {
            isNaN(R) || isNaN(T) || (R = Math.max(R, O.MINIMUM_COLS), T = Math.max(T, O.MINIMUM_ROWS), this._bufferService.resize(R, T));
          }
          scroll(R, T = !1) {
            this._bufferService.scroll(R, T);
          }
          scrollLines(R, T, A) {
            this._bufferService.scrollLines(R, T, A);
          }
          scrollPages(R) {
            this.scrollLines(R * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this._bufferService.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          }
          scrollToLine(R) {
            const T = R - this._bufferService.buffer.ydisp;
            T !== 0 && this.scrollLines(T);
          }
          registerEscHandler(R, T) {
            return this._inputHandler.registerEscHandler(R, T);
          }
          registerDcsHandler(R, T) {
            return this._inputHandler.registerDcsHandler(R, T);
          }
          registerCsiHandler(R, T) {
            return this._inputHandler.registerCsiHandler(R, T);
          }
          registerOscHandler(R, T) {
            return this._inputHandler.registerOscHandler(R, T);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            let R = !1;
            const T = this.optionsService.rawOptions.windowsPty;
            T && T.buildNumber !== void 0 && T.buildNumber !== void 0 ? R = T.backend === "conpty" && T.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (R = !0), R ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics.value) {
              const R = [];
              R.push(this.onLineFeed(_.updateWindowsModeWrappedState.bind(null, this._bufferService))), R.push(this.registerCsiHandler({ final: "H" }, () => ((0, _.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics.value = (0, c.toDisposable)(() => {
                for (const T of R) T.dispose();
              });
            }
          }
        }
        a.CoreTerminal = k;
      }, 8460: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.forwardEvent = a.EventEmitter = void 0, a.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = !1;
          }
          get event() {
            return this._event || (this._event = (l) => (this._listeners.push(l), { dispose: () => {
              if (!this._disposed) {
                for (let c = 0; c < this._listeners.length; c++) if (this._listeners[c] === l) return void this._listeners.splice(c, 1);
              }
            } })), this._event;
          }
          fire(l, c) {
            const h = [];
            for (let u = 0; u < this._listeners.length; u++) h.push(this._listeners[u]);
            for (let u = 0; u < h.length; u++) h[u].call(void 0, l, c);
          }
          dispose() {
            this.clearListeners(), this._disposed = !0;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, a.forwardEvent = function(l, c) {
          return l((h) => c.fire(h));
        };
      }, 5435: function(o, a, l) {
        var c = this && this.__decorate || function(z, Q, E, L) {
          var D, U = arguments.length, Y = U < 3 ? Q : L === null ? L = Object.getOwnPropertyDescriptor(Q, E) : L;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Y = Reflect.decorate(z, Q, E, L);
          else for (var ne = z.length - 1; ne >= 0; ne--) (D = z[ne]) && (Y = (U < 3 ? D(Y) : U > 3 ? D(Q, E, Y) : D(Q, E)) || Y);
          return U > 3 && Y && Object.defineProperty(Q, E, Y), Y;
        }, h = this && this.__param || function(z, Q) {
          return function(E, L) {
            Q(E, L, z);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.InputHandler = a.WindowsOptionsReportType = void 0;
        const u = l(2584), d = l(7116), O = l(2015), v = l(844), S = l(482), f = l(8437), p = l(8460), g = l(643), m = l(511), _ = l(3734), b = l(2585), w = l(6242), x = l(6351), y = l(5941), k = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, $ = 131072;
        function R(z, Q) {
          if (z > 24) return Q.setWinLines || !1;
          switch (z) {
            case 1:
              return !!Q.restoreWin;
            case 2:
              return !!Q.minimizeWin;
            case 3:
              return !!Q.setWinPosition;
            case 4:
              return !!Q.setWinSizePixels;
            case 5:
              return !!Q.raiseWin;
            case 6:
              return !!Q.lowerWin;
            case 7:
              return !!Q.refreshWin;
            case 8:
              return !!Q.setWinSizeChars;
            case 9:
              return !!Q.maximizeWin;
            case 10:
              return !!Q.fullscreenWin;
            case 11:
              return !!Q.getWinState;
            case 13:
              return !!Q.getWinPosition;
            case 14:
              return !!Q.getWinSizePixels;
            case 15:
              return !!Q.getScreenSizePixels;
            case 16:
              return !!Q.getCellSizePixels;
            case 18:
              return !!Q.getWinSizeChars;
            case 19:
              return !!Q.getScreenSizeChars;
            case 20:
              return !!Q.getIconTitle;
            case 21:
              return !!Q.getWinTitle;
            case 22:
              return !!Q.pushTitle;
            case 23:
              return !!Q.popTitle;
            case 24:
              return !!Q.setWinLines;
          }
          return !1;
        }
        var T;
        (function(z) {
          z[z.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", z[z.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        })(T || (a.WindowsOptionsReportType = T = {}));
        let A = 0;
        class M extends v.Disposable {
          getAttrData() {
            return this._curAttrData;
          }
          constructor(Q, E, L, D, U, Y, ne, te, de = new O.EscapeSequenceParser()) {
            super(), this._bufferService = Q, this._charsetService = E, this._coreService = L, this._logService = D, this._optionsService = U, this._oscLinkService = Y, this._coreMouseService = ne, this._unicodeService = te, this._parser = de, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new S.StringToUtf32(), this._utf8Decoder = new S.Utf8ToUtf32(), this._workCell = new m.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = f.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = f.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new p.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new p.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new p.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new p.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new p.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new p.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new p.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new p.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new p.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new p.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new p.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new p.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new p.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new B(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((P) => this._activeBuffer = P.activeBuffer)), this._parser.setCsiHandlerFallback((P, q) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(P), params: q.toArray() });
            }), this._parser.setEscHandlerFallback((P) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(P) });
            }), this._parser.setExecuteHandlerFallback((P) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: P });
            }), this._parser.setOscHandlerFallback((P, q, N) => {
              this._logService.debug("Unknown OSC code: ", { identifier: P, action: q, data: N });
            }), this._parser.setDcsHandlerFallback((P, q, N) => {
              q === "HOOK" && (N = N.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(P), action: q, payload: N });
            }), this._parser.setPrintHandler((P, q, N) => this.print(P, q, N)), this._parser.registerCsiHandler({ final: "@" }, (P) => this.insertChars(P)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (P) => this.scrollLeft(P)), this._parser.registerCsiHandler({ final: "A" }, (P) => this.cursorUp(P)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (P) => this.scrollRight(P)), this._parser.registerCsiHandler({ final: "B" }, (P) => this.cursorDown(P)), this._parser.registerCsiHandler({ final: "C" }, (P) => this.cursorForward(P)), this._parser.registerCsiHandler({ final: "D" }, (P) => this.cursorBackward(P)), this._parser.registerCsiHandler({ final: "E" }, (P) => this.cursorNextLine(P)), this._parser.registerCsiHandler({ final: "F" }, (P) => this.cursorPrecedingLine(P)), this._parser.registerCsiHandler({ final: "G" }, (P) => this.cursorCharAbsolute(P)), this._parser.registerCsiHandler({ final: "H" }, (P) => this.cursorPosition(P)), this._parser.registerCsiHandler({ final: "I" }, (P) => this.cursorForwardTab(P)), this._parser.registerCsiHandler({ final: "J" }, (P) => this.eraseInDisplay(P, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (P) => this.eraseInDisplay(P, !0)), this._parser.registerCsiHandler({ final: "K" }, (P) => this.eraseInLine(P, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (P) => this.eraseInLine(P, !0)), this._parser.registerCsiHandler({ final: "L" }, (P) => this.insertLines(P)), this._parser.registerCsiHandler({ final: "M" }, (P) => this.deleteLines(P)), this._parser.registerCsiHandler({ final: "P" }, (P) => this.deleteChars(P)), this._parser.registerCsiHandler({ final: "S" }, (P) => this.scrollUp(P)), this._parser.registerCsiHandler({ final: "T" }, (P) => this.scrollDown(P)), this._parser.registerCsiHandler({ final: "X" }, (P) => this.eraseChars(P)), this._parser.registerCsiHandler({ final: "Z" }, (P) => this.cursorBackwardTab(P)), this._parser.registerCsiHandler({ final: "`" }, (P) => this.charPosAbsolute(P)), this._parser.registerCsiHandler({ final: "a" }, (P) => this.hPositionRelative(P)), this._parser.registerCsiHandler({ final: "b" }, (P) => this.repeatPrecedingCharacter(P)), this._parser.registerCsiHandler({ final: "c" }, (P) => this.sendDeviceAttributesPrimary(P)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (P) => this.sendDeviceAttributesSecondary(P)), this._parser.registerCsiHandler({ final: "d" }, (P) => this.linePosAbsolute(P)), this._parser.registerCsiHandler({ final: "e" }, (P) => this.vPositionRelative(P)), this._parser.registerCsiHandler({ final: "f" }, (P) => this.hVPosition(P)), this._parser.registerCsiHandler({ final: "g" }, (P) => this.tabClear(P)), this._parser.registerCsiHandler({ final: "h" }, (P) => this.setMode(P)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (P) => this.setModePrivate(P)), this._parser.registerCsiHandler({ final: "l" }, (P) => this.resetMode(P)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (P) => this.resetModePrivate(P)), this._parser.registerCsiHandler({ final: "m" }, (P) => this.charAttributes(P)), this._parser.registerCsiHandler({ final: "n" }, (P) => this.deviceStatus(P)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (P) => this.deviceStatusPrivate(P)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (P) => this.softReset(P)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (P) => this.setCursorStyle(P)), this._parser.registerCsiHandler({ final: "r" }, (P) => this.setScrollRegion(P)), this._parser.registerCsiHandler({ final: "s" }, (P) => this.saveCursor(P)), this._parser.registerCsiHandler({ final: "t" }, (P) => this.windowOptions(P)), this._parser.registerCsiHandler({ final: "u" }, (P) => this.restoreCursor(P)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (P) => this.insertColumns(P)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (P) => this.deleteColumns(P)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (P) => this.selectProtected(P)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (P) => this.requestMode(P, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (P) => this.requestMode(P, !1)), this._parser.setExecuteHandler(u.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(u.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(u.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(u.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(u.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(u.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(u.C0.HT, () => this.tab()), this._parser.setExecuteHandler(u.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(u.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(u.C1.IND, () => this.index()), this._parser.setExecuteHandler(u.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(u.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new w.OscHandler((P) => (this.setTitle(P), this.setIconName(P), !0))), this._parser.registerOscHandler(1, new w.OscHandler((P) => this.setIconName(P))), this._parser.registerOscHandler(2, new w.OscHandler((P) => this.setTitle(P))), this._parser.registerOscHandler(4, new w.OscHandler((P) => this.setOrReportIndexedColor(P))), this._parser.registerOscHandler(8, new w.OscHandler((P) => this.setHyperlink(P))), this._parser.registerOscHandler(10, new w.OscHandler((P) => this.setOrReportFgColor(P))), this._parser.registerOscHandler(11, new w.OscHandler((P) => this.setOrReportBgColor(P))), this._parser.registerOscHandler(12, new w.OscHandler((P) => this.setOrReportCursorColor(P))), this._parser.registerOscHandler(104, new w.OscHandler((P) => this.restoreIndexedColor(P))), this._parser.registerOscHandler(110, new w.OscHandler((P) => this.restoreFgColor(P))), this._parser.registerOscHandler(111, new w.OscHandler((P) => this.restoreBgColor(P))), this._parser.registerOscHandler(112, new w.OscHandler((P) => this.restoreCursorColor(P))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
            for (const P in d.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: P }, () => this.selectCharset("(" + P)), this._parser.registerEscHandler({ intermediates: ")", final: P }, () => this.selectCharset(")" + P)), this._parser.registerEscHandler({ intermediates: "*", final: P }, () => this.selectCharset("*" + P)), this._parser.registerEscHandler({ intermediates: "+", final: P }, () => this.selectCharset("+" + P)), this._parser.registerEscHandler({ intermediates: "-", final: P }, () => this.selectCharset("-" + P)), this._parser.registerEscHandler({ intermediates: ".", final: P }, () => this.selectCharset("." + P)), this._parser.registerEscHandler({ intermediates: "/", final: P }, () => this.selectCharset("/" + P));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((P) => (this._logService.error("Parsing error: ", P), P)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new x.DcsHandler((P, q) => this.requestStatusString(P, q)));
          }
          _preserveStack(Q, E, L, D) {
            this._parseStack.paused = !0, this._parseStack.cursorStartX = Q, this._parseStack.cursorStartY = E, this._parseStack.decodedLength = L, this._parseStack.position = D;
          }
          _logSlowResolvingAsync(Q) {
            this._logService.logLevel <= b.LogLevelEnum.WARN && Promise.race([Q, new Promise((E, L) => setTimeout(() => L("#SLOW_TIMEOUT"), 5e3))]).catch((E) => {
              if (E !== "#SLOW_TIMEOUT") throw E;
              console.warn("async parser handler taking longer than 5000 ms");
            });
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(Q, E) {
            let L, D = this._activeBuffer.x, U = this._activeBuffer.y, Y = 0;
            const ne = this._parseStack.paused;
            if (ne) {
              if (L = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, E)) return this._logSlowResolvingAsync(L), L;
              D = this._parseStack.cursorStartX, U = this._parseStack.cursorStartY, this._parseStack.paused = !1, Q.length > $ && (Y = this._parseStack.position + $);
            }
            if (this._logService.logLevel <= b.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof Q == "string" ? ` "${Q}"` : ` "${Array.prototype.map.call(Q, (te) => String.fromCharCode(te)).join("")}"`), typeof Q == "string" ? Q.split("").map((te) => te.charCodeAt(0)) : Q), this._parseBuffer.length < Q.length && this._parseBuffer.length < $ && (this._parseBuffer = new Uint32Array(Math.min(Q.length, $))), ne || this._dirtyRowTracker.clearRange(), Q.length > $) for (let te = Y; te < Q.length; te += $) {
              const de = te + $ < Q.length ? te + $ : Q.length, P = typeof Q == "string" ? this._stringDecoder.decode(Q.substring(te, de), this._parseBuffer) : this._utf8Decoder.decode(Q.subarray(te, de), this._parseBuffer);
              if (L = this._parser.parse(this._parseBuffer, P)) return this._preserveStack(D, U, P, te), this._logSlowResolvingAsync(L), L;
            }
            else if (!ne) {
              const te = typeof Q == "string" ? this._stringDecoder.decode(Q, this._parseBuffer) : this._utf8Decoder.decode(Q, this._parseBuffer);
              if (L = this._parser.parse(this._parseBuffer, te)) return this._preserveStack(D, U, te, 0), this._logSlowResolvingAsync(L), L;
            }
            this._activeBuffer.x === D && this._activeBuffer.y === U || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
          }
          print(Q, E, L) {
            let D, U;
            const Y = this._charsetService.charset, ne = this._optionsService.rawOptions.screenReaderMode, te = this._bufferService.cols, de = this._coreService.decPrivateModes.wraparound, P = this._coreService.modes.insertMode, q = this._curAttrData;
            let N = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && L - E > 0 && N.getWidth(this._activeBuffer.x - 1) === 2 && N.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, q.fg, q.bg, q.extended);
            for (let j = E; j < L; ++j) {
              if (D = Q[j], U = this._unicodeService.wcwidth(D), D < 127 && Y) {
                const fe = Y[String.fromCharCode(D)];
                fe && (D = fe.charCodeAt(0));
              }
              if (ne && this._onA11yChar.fire((0, S.stringFromCodePoint)(D)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), U || !this._activeBuffer.x) {
                if (this._activeBuffer.x + U - 1 >= te) {
                  if (de) {
                    for (; this._activeBuffer.x < te; ) N.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, q.fg, q.bg, q.extended);
                    this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), N = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                  } else if (this._activeBuffer.x = te - 1, U === 2) continue;
                }
                if (P && (N.insertCells(this._activeBuffer.x, U, this._activeBuffer.getNullCell(q), q), N.getWidth(te - 1) === 2 && N.setCellFromCodePoint(te - 1, g.NULL_CELL_CODE, g.NULL_CELL_WIDTH, q.fg, q.bg, q.extended)), N.setCellFromCodePoint(this._activeBuffer.x++, D, U, q.fg, q.bg, q.extended), U > 0) for (; --U; ) N.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, q.fg, q.bg, q.extended);
              } else N.getWidth(this._activeBuffer.x - 1) ? N.addCodepointToCell(this._activeBuffer.x - 1, D) : N.addCodepointToCell(this._activeBuffer.x - 2, D);
            }
            L - E > 0 && (N.loadCell(this._activeBuffer.x - 1, this._workCell), this._workCell.getWidth() === 2 || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < te && L - E > 0 && N.getWidth(this._activeBuffer.x) === 0 && !N.hasContent(this._activeBuffer.x) && N.setCellFromCodePoint(this._activeBuffer.x, 0, 1, q.fg, q.bg, q.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(Q, E) {
            return Q.final !== "t" || Q.prefix || Q.intermediates ? this._parser.registerCsiHandler(Q, E) : this._parser.registerCsiHandler(Q, (L) => !R(L.params[0], this._optionsService.rawOptions.windowOptions) || E(L));
          }
          registerDcsHandler(Q, E) {
            return this._parser.registerDcsHandler(Q, new x.DcsHandler(E));
          }
          registerEscHandler(Q, E) {
            return this._parser.registerEscHandler(Q, E);
          }
          registerOscHandler(Q, E) {
            return this._parser.registerOscHandler(Q, new w.OscHandler(E));
          }
          bell() {
            return this._onRequestBell.fire(), !0;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, !0;
          }
          backspace() {
            var Q;
            if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
            else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (!((Q = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) === null || Q === void 0) && Q.isWrapped)) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              E.hasWidth(this._activeBuffer.x) && !E.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), !0;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            const Q = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - Q), !0;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), !0;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), !0;
          }
          _restrictCursor(Q = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(Q, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(Q, E) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = Q, this._activeBuffer.y = this._activeBuffer.scrollTop + E) : (this._activeBuffer.x = Q, this._activeBuffer.y = E), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(Q, E) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + Q, this._activeBuffer.y + E);
          }
          cursorUp(Q) {
            const E = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return E >= 0 ? this._moveCursor(0, -Math.min(E, Q.params[0] || 1)) : this._moveCursor(0, -(Q.params[0] || 1)), !0;
          }
          cursorDown(Q) {
            const E = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return E >= 0 ? this._moveCursor(0, Math.min(E, Q.params[0] || 1)) : this._moveCursor(0, Q.params[0] || 1), !0;
          }
          cursorForward(Q) {
            return this._moveCursor(Q.params[0] || 1, 0), !0;
          }
          cursorBackward(Q) {
            return this._moveCursor(-(Q.params[0] || 1), 0), !0;
          }
          cursorNextLine(Q) {
            return this.cursorDown(Q), this._activeBuffer.x = 0, !0;
          }
          cursorPrecedingLine(Q) {
            return this.cursorUp(Q), this._activeBuffer.x = 0, !0;
          }
          cursorCharAbsolute(Q) {
            return this._setCursor((Q.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          cursorPosition(Q) {
            return this._setCursor(Q.length >= 2 ? (Q.params[1] || 1) - 1 : 0, (Q.params[0] || 1) - 1), !0;
          }
          charPosAbsolute(Q) {
            return this._setCursor((Q.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          hPositionRelative(Q) {
            return this._moveCursor(Q.params[0] || 1, 0), !0;
          }
          linePosAbsolute(Q) {
            return this._setCursor(this._activeBuffer.x, (Q.params[0] || 1) - 1), !0;
          }
          vPositionRelative(Q) {
            return this._moveCursor(0, Q.params[0] || 1), !0;
          }
          hVPosition(Q) {
            return this.cursorPosition(Q), !0;
          }
          tabClear(Q) {
            const E = Q.params[0];
            return E === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : E === 3 && (this._activeBuffer.tabs = {}), !0;
          }
          cursorForwardTab(Q) {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            let E = Q.params[0] || 1;
            for (; E--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
            return !0;
          }
          cursorBackwardTab(Q) {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            let E = Q.params[0] || 1;
            for (; E--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
            return !0;
          }
          selectProtected(Q) {
            const E = Q.params[0];
            return E === 1 && (this._curAttrData.bg |= 536870912), E !== 2 && E !== 0 || (this._curAttrData.bg &= -536870913), !0;
          }
          _eraseInBufferLine(Q, E, L, D = !1, U = !1) {
            const Y = this._activeBuffer.lines.get(this._activeBuffer.ybase + Q);
            Y.replaceCells(E, L, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), U), D && (Y.isWrapped = !1);
          }
          _resetBufferLine(Q, E = !1) {
            const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + Q);
            L && (L.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), E), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + Q), L.isWrapped = !1);
          }
          eraseInDisplay(Q, E = !1) {
            let L;
            switch (this._restrictCursor(this._bufferService.cols), Q.params[0]) {
              case 0:
                for (L = this._activeBuffer.y, this._dirtyRowTracker.markDirty(L), this._eraseInBufferLine(L++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, E); L < this._bufferService.rows; L++) this._resetBufferLine(L, E);
                this._dirtyRowTracker.markDirty(L);
                break;
              case 1:
                for (L = this._activeBuffer.y, this._dirtyRowTracker.markDirty(L), this._eraseInBufferLine(L, 0, this._activeBuffer.x + 1, !0, E), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(L + 1).isWrapped = !1); L--; ) this._resetBufferLine(L, E);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (L = this._bufferService.rows, this._dirtyRowTracker.markDirty(L - 1); L--; ) this._resetBufferLine(L, E);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const D = this._activeBuffer.lines.length - this._bufferService.rows;
                D > 0 && (this._activeBuffer.lines.trimStart(D), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - D, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - D, 0), this._onScroll.fire(0));
            }
            return !0;
          }
          eraseInLine(Q, E = !1) {
            switch (this._restrictCursor(this._bufferService.cols), Q.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, E);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, E);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, E);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
          }
          insertLines(Q) {
            this._restrictCursor();
            let E = Q.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const L = this._activeBuffer.ybase + this._activeBuffer.y, D = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, U = this._bufferService.rows - 1 + this._activeBuffer.ybase - D + 1;
            for (; E--; ) this._activeBuffer.lines.splice(U - 1, 1), this._activeBuffer.lines.splice(L, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          deleteLines(Q) {
            this._restrictCursor();
            let E = Q.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const L = this._activeBuffer.ybase + this._activeBuffer.y;
            let D;
            for (D = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, D = this._bufferService.rows - 1 + this._activeBuffer.ybase - D; E--; ) this._activeBuffer.lines.splice(L, 1), this._activeBuffer.lines.splice(D, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          insertChars(Q) {
            this._restrictCursor();
            const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return E && (E.insertCells(this._activeBuffer.x, Q.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          deleteChars(Q) {
            this._restrictCursor();
            const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return E && (E.deleteCells(this._activeBuffer.x, Q.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          scrollUp(Q) {
            let E = Q.params[0] || 1;
            for (; E--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollDown(Q) {
            let E = Q.params[0] || 1;
            for (; E--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(f.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollLeft(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const E = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const D = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              D.deleteCells(0, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollRight(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const E = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const D = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              D.insertCells(0, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          insertColumns(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const E = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const D = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              D.insertCells(this._activeBuffer.x, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          deleteColumns(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const E = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const D = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              D.deleteCells(this._activeBuffer.x, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          eraseChars(Q) {
            this._restrictCursor();
            const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return E && (E.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (Q.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          repeatPrecedingCharacter(Q) {
            if (!this._parser.precedingCodepoint) return !0;
            const E = Q.params[0] || 1, L = new Uint32Array(E);
            for (let D = 0; D < E; ++D) L[D] = this._parser.precedingCodepoint;
            return this.print(L, 0, L.length), !0;
          }
          sendDeviceAttributesPrimary(Q) {
            return Q.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(u.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(u.C0.ESC + "[?6c")), !0;
          }
          sendDeviceAttributesSecondary(Q) {
            return Q.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(u.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(u.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(Q.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(u.C0.ESC + "[>83;40003;0c")), !0;
          }
          _is(Q) {
            return (this._optionsService.rawOptions.termName + "").indexOf(Q) === 0;
          }
          setMode(Q) {
            for (let E = 0; E < Q.length; E++) switch (Q.params[E]) {
              case 4:
                this._coreService.modes.insertMode = !0;
                break;
              case 20:
                this._optionsService.options.convertEol = !0;
            }
            return !0;
          }
          setModePrivate(Q) {
            for (let E = 0; E < Q.length; E++) switch (Q.params[E]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = !0;
                break;
              case 2:
                this._charsetService.setgCharset(0, d.DEFAULT_CHARSET), this._charsetService.setgCharset(1, d.DEFAULT_CHARSET), this._charsetService.setgCharset(2, d.DEFAULT_CHARSET), this._charsetService.setgCharset(3, d.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = !0;
                break;
              case 12:
                this._optionsService.options.cursorBlink = !0;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = !0;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1e3:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = !1;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = !0;
            }
            return !0;
          }
          resetMode(Q) {
            for (let E = 0; E < Q.length; E++) switch (Q.params[E]) {
              case 4:
                this._coreService.modes.insertMode = !1;
                break;
              case 20:
                this._optionsService.options.convertEol = !1;
            }
            return !0;
          }
          resetModePrivate(Q) {
            for (let E = 0; E < Q.length; E++) switch (Q.params[E]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = !1;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = !1;
                break;
              case 12:
                this._optionsService.options.cursorBlink = !1;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = !1;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1e3:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = !1;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = !0;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), Q.params[E] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = !1;
            }
            return !0;
          }
          requestMode(Q, E) {
            const L = this._coreService.decPrivateModes, { activeProtocol: D, activeEncoding: U } = this._coreMouseService, Y = this._coreService, { buffers: ne, cols: te } = this._bufferService, { active: de, alt: P } = ne, q = this._optionsService.rawOptions, N = (ke) => ke ? 1 : 2, j = Q.params[0];
            return fe = j, re = E ? j === 2 ? 4 : j === 4 ? N(Y.modes.insertMode) : j === 12 ? 3 : j === 20 ? N(q.convertEol) : 0 : j === 1 ? N(L.applicationCursorKeys) : j === 3 ? q.windowOptions.setWinLines ? te === 80 ? 2 : te === 132 ? 1 : 0 : 0 : j === 6 ? N(L.origin) : j === 7 ? N(L.wraparound) : j === 8 ? 3 : j === 9 ? N(D === "X10") : j === 12 ? N(q.cursorBlink) : j === 25 ? N(!Y.isCursorHidden) : j === 45 ? N(L.reverseWraparound) : j === 66 ? N(L.applicationKeypad) : j === 67 ? 4 : j === 1e3 ? N(D === "VT200") : j === 1002 ? N(D === "DRAG") : j === 1003 ? N(D === "ANY") : j === 1004 ? N(L.sendFocus) : j === 1005 ? 4 : j === 1006 ? N(U === "SGR") : j === 1015 ? 4 : j === 1016 ? N(U === "SGR_PIXELS") : j === 1048 ? 1 : j === 47 || j === 1047 || j === 1049 ? N(de === P) : j === 2004 ? N(L.bracketedPasteMode) : 0, Y.triggerDataEvent(`${u.C0.ESC}[${E ? "" : "?"}${fe};${re}$y`), !0;
            var fe, re;
          }
          _updateAttrColor(Q, E, L, D, U) {
            return E === 2 ? (Q |= 50331648, Q &= -16777216, Q |= _.AttributeData.fromColorRGB([L, D, U])) : E === 5 && (Q &= -50331904, Q |= 33554432 | 255 & L), Q;
          }
          _extractColor(Q, E, L) {
            const D = [0, 0, -1, 0, 0, 0];
            let U = 0, Y = 0;
            do {
              if (D[Y + U] = Q.params[E + Y], Q.hasSubParams(E + Y)) {
                const ne = Q.getSubParams(E + Y);
                let te = 0;
                do
                  D[1] === 5 && (U = 1), D[Y + te + 1 + U] = ne[te];
                while (++te < ne.length && te + Y + 1 + U < D.length);
                break;
              }
              if (D[1] === 5 && Y + U >= 2 || D[1] === 2 && Y + U >= 5) break;
              D[1] && (U = 1);
            } while (++Y + E < Q.length && Y + U < D.length);
            for (let ne = 2; ne < D.length; ++ne) D[ne] === -1 && (D[ne] = 0);
            switch (D[0]) {
              case 38:
                L.fg = this._updateAttrColor(L.fg, D[1], D[3], D[4], D[5]);
                break;
              case 48:
                L.bg = this._updateAttrColor(L.bg, D[1], D[3], D[4], D[5]);
                break;
              case 58:
                L.extended = L.extended.clone(), L.extended.underlineColor = this._updateAttrColor(L.extended.underlineColor, D[1], D[3], D[4], D[5]);
            }
            return Y;
          }
          _processUnderline(Q, E) {
            E.extended = E.extended.clone(), (!~Q || Q > 5) && (Q = 1), E.extended.underlineStyle = Q, E.fg |= 268435456, Q === 0 && (E.fg &= -268435457), E.updateExtended();
          }
          _processSGR0(Q) {
            Q.fg = f.DEFAULT_ATTR_DATA.fg, Q.bg = f.DEFAULT_ATTR_DATA.bg, Q.extended = Q.extended.clone(), Q.extended.underlineStyle = 0, Q.extended.underlineColor &= -67108864, Q.updateExtended();
          }
          charAttributes(Q) {
            if (Q.length === 1 && Q.params[0] === 0) return this._processSGR0(this._curAttrData), !0;
            const E = Q.length;
            let L;
            const D = this._curAttrData;
            for (let U = 0; U < E; U++) L = Q.params[U], L >= 30 && L <= 37 ? (D.fg &= -50331904, D.fg |= 16777216 | L - 30) : L >= 40 && L <= 47 ? (D.bg &= -50331904, D.bg |= 16777216 | L - 40) : L >= 90 && L <= 97 ? (D.fg &= -50331904, D.fg |= 16777224 | L - 90) : L >= 100 && L <= 107 ? (D.bg &= -50331904, D.bg |= 16777224 | L - 100) : L === 0 ? this._processSGR0(D) : L === 1 ? D.fg |= 134217728 : L === 3 ? D.bg |= 67108864 : L === 4 ? (D.fg |= 268435456, this._processUnderline(Q.hasSubParams(U) ? Q.getSubParams(U)[0] : 1, D)) : L === 5 ? D.fg |= 536870912 : L === 7 ? D.fg |= 67108864 : L === 8 ? D.fg |= 1073741824 : L === 9 ? D.fg |= 2147483648 : L === 2 ? D.bg |= 134217728 : L === 21 ? this._processUnderline(2, D) : L === 22 ? (D.fg &= -134217729, D.bg &= -134217729) : L === 23 ? D.bg &= -67108865 : L === 24 ? (D.fg &= -268435457, this._processUnderline(0, D)) : L === 25 ? D.fg &= -536870913 : L === 27 ? D.fg &= -67108865 : L === 28 ? D.fg &= -1073741825 : L === 29 ? D.fg &= 2147483647 : L === 39 ? (D.fg &= -67108864, D.fg |= 16777215 & f.DEFAULT_ATTR_DATA.fg) : L === 49 ? (D.bg &= -67108864, D.bg |= 16777215 & f.DEFAULT_ATTR_DATA.bg) : L === 38 || L === 48 || L === 58 ? U += this._extractColor(Q, U, D) : L === 53 ? D.bg |= 1073741824 : L === 55 ? D.bg &= -1073741825 : L === 59 ? (D.extended = D.extended.clone(), D.extended.underlineColor = -1, D.updateExtended()) : L === 100 ? (D.fg &= -67108864, D.fg |= 16777215 & f.DEFAULT_ATTR_DATA.fg, D.bg &= -67108864, D.bg |= 16777215 & f.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", L);
            return !0;
          }
          deviceStatus(Q) {
            switch (Q.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${u.C0.ESC}[0n`);
                break;
              case 6:
                const E = this._activeBuffer.y + 1, L = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${u.C0.ESC}[${E};${L}R`);
            }
            return !0;
          }
          deviceStatusPrivate(Q) {
            if (Q.params[0] === 6) {
              const E = this._activeBuffer.y + 1, L = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${u.C0.ESC}[?${E};${L}R`);
            }
            return !0;
          }
          softReset(Q) {
            return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = f.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
          }
          setCursorStyle(Q) {
            const E = Q.params[0] || 1;
            switch (E) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const L = E % 2 == 1;
            return this._optionsService.options.cursorBlink = L, !0;
          }
          setScrollRegion(Q) {
            const E = Q.params[0] || 1;
            let L;
            return (Q.length < 2 || (L = Q.params[1]) > this._bufferService.rows || L === 0) && (L = this._bufferService.rows), L > E && (this._activeBuffer.scrollTop = E - 1, this._activeBuffer.scrollBottom = L - 1, this._setCursor(0, 0)), !0;
          }
          windowOptions(Q) {
            if (!R(Q.params[0], this._optionsService.rawOptions.windowOptions)) return !0;
            const E = Q.length > 1 ? Q.params[1] : 0;
            switch (Q.params[0]) {
              case 14:
                E !== 2 && this._onRequestWindowsOptionsReport.fire(T.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire(T.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${u.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                E !== 0 && E !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), E !== 0 && E !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                E !== 0 && E !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), E !== 0 && E !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return !0;
          }
          saveCursor(Q) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
          }
          restoreCursor(Q) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
          }
          setTitle(Q) {
            return this._windowTitle = Q, this._onTitleChange.fire(Q), !0;
          }
          setIconName(Q) {
            return this._iconName = Q, !0;
          }
          setOrReportIndexedColor(Q) {
            const E = [], L = Q.split(";");
            for (; L.length > 1; ) {
              const D = L.shift(), U = L.shift();
              if (/^\d+$/.exec(D)) {
                const Y = parseInt(D);
                if (W(Y)) if (U === "?") E.push({ type: 0, index: Y });
                else {
                  const ne = (0, y.parseColor)(U);
                  ne && E.push({ type: 1, index: Y, color: ne });
                }
              }
            }
            return E.length && this._onColor.fire(E), !0;
          }
          setHyperlink(Q) {
            const E = Q.split(";");
            return !(E.length < 2) && (E[1] ? this._createHyperlink(E[0], E[1]) : !E[0] && this._finishHyperlink());
          }
          _createHyperlink(Q, E) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const L = Q.split(":");
            let D;
            const U = L.findIndex((Y) => Y.startsWith("id="));
            return U !== -1 && (D = L[U].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: D, uri: E }), this._curAttrData.updateExtended(), !0;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
          }
          _setOrReportSpecialColor(Q, E) {
            const L = Q.split(";");
            for (let D = 0; D < L.length && !(E >= this._specialColors.length); ++D, ++E) if (L[D] === "?") this._onColor.fire([{ type: 0, index: this._specialColors[E] }]);
            else {
              const U = (0, y.parseColor)(L[D]);
              U && this._onColor.fire([{ type: 1, index: this._specialColors[E], color: U }]);
            }
            return !0;
          }
          setOrReportFgColor(Q) {
            return this._setOrReportSpecialColor(Q, 0);
          }
          setOrReportBgColor(Q) {
            return this._setOrReportSpecialColor(Q, 1);
          }
          setOrReportCursorColor(Q) {
            return this._setOrReportSpecialColor(Q, 2);
          }
          restoreIndexedColor(Q) {
            if (!Q) return this._onColor.fire([{ type: 2 }]), !0;
            const E = [], L = Q.split(";");
            for (let D = 0; D < L.length; ++D) if (/^\d+$/.exec(L[D])) {
              const U = parseInt(L[D]);
              W(U) && E.push({ type: 2, index: U });
            }
            return E.length && this._onColor.fire(E), !0;
          }
          restoreFgColor(Q) {
            return this._onColor.fire([{ type: 2, index: 256 }]), !0;
          }
          restoreBgColor(Q) {
            return this._onColor.fire([{ type: 2, index: 257 }]), !0;
          }
          restoreCursorColor(Q) {
            return this._onColor.fire([{ type: 2, index: 258 }]), !0;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), !0;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, d.DEFAULT_CHARSET), !0;
          }
          selectCharset(Q) {
            return Q.length !== 2 ? (this.selectDefaultCharset(), !0) : (Q[0] === "/" || this._charsetService.setgCharset(k[Q[0]], d.CHARSETS[Q[1]] || d.DEFAULT_CHARSET), !0);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const Q = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, Q, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else this._activeBuffer.y--, this._restrictCursor();
            return !0;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), !0;
          }
          reset() {
            this._curAttrData = f.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = f.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(Q) {
            return this._charsetService.setgLevel(Q), !0;
          }
          screenAlignmentPattern() {
            const Q = new m.CellData();
            Q.content = 4194373, Q.fg = this._curAttrData.fg, Q.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let E = 0; E < this._bufferService.rows; ++E) {
              const L = this._activeBuffer.ybase + this._activeBuffer.y + E, D = this._activeBuffer.lines.get(L);
              D && (D.fill(Q), D.isWrapped = !1);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
          }
          requestStatusString(Q, E) {
            const L = this._bufferService.buffer, D = this._optionsService.rawOptions;
            return ((U) => (this._coreService.triggerDataEvent(`${u.C0.ESC}${U}${u.C0.ESC}\\`), !0))(Q === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : Q === '"p' ? 'P1$r61;1"p' : Q === "r" ? `P1$r${L.scrollTop + 1};${L.scrollBottom + 1}r` : Q === "m" ? "P1$r0m" : Q === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[D.cursorStyle] - (D.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(Q, E) {
            this._dirtyRowTracker.markRangeDirty(Q, E);
          }
        }
        a.InputHandler = M;
        let B = class {
          constructor(z) {
            this._bufferService = z, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(z) {
            z < this.start ? this.start = z : z > this.end && (this.end = z);
          }
          markRangeDirty(z, Q) {
            z > Q && (A = z, z = Q, Q = A), z < this.start && (this.start = z), Q > this.end && (this.end = Q);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        };
        function W(z) {
          return 0 <= z && z < 256;
        }
        B = c([h(0, b.IBufferService)], B);
      }, 844: (o, a) => {
        function l(c) {
          for (const h of c) h.dispose();
          c.length = 0;
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getDisposeArrayDisposable = a.disposeArray = a.toDisposable = a.MutableDisposable = a.Disposable = void 0, a.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = !1;
          }
          dispose() {
            this._isDisposed = !0;
            for (const c of this._disposables) c.dispose();
            this._disposables.length = 0;
          }
          register(c) {
            return this._disposables.push(c), c;
          }
          unregister(c) {
            const h = this._disposables.indexOf(c);
            h !== -1 && this._disposables.splice(h, 1);
          }
        }, a.MutableDisposable = class {
          constructor() {
            this._isDisposed = !1;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(c) {
            var h;
            this._isDisposed || c === this._value || ((h = this._value) === null || h === void 0 || h.dispose(), this._value = c);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            var c;
            this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0;
          }
        }, a.toDisposable = function(c) {
          return { dispose: c };
        }, a.disposeArray = l, a.getDisposeArrayDisposable = function(c) {
          return { dispose: () => l(c) };
        };
      }, 1505: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.FourKeyMap = a.TwoKeyMap = void 0;
        class l {
          constructor() {
            this._data = {};
          }
          set(h, u, d) {
            this._data[h] || (this._data[h] = {}), this._data[h][u] = d;
          }
          get(h, u) {
            return this._data[h] ? this._data[h][u] : void 0;
          }
          clear() {
            this._data = {};
          }
        }
        a.TwoKeyMap = l, a.FourKeyMap = class {
          constructor() {
            this._data = new l();
          }
          set(c, h, u, d, O) {
            this._data.get(c, h) || this._data.set(c, h, new l()), this._data.get(c, h).set(u, d, O);
          }
          get(c, h, u, d) {
            var O;
            return (O = this._data.get(c, h)) === null || O === void 0 ? void 0 : O.get(u, d);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 6114: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.isChromeOS = a.isLinux = a.isWindows = a.isIphone = a.isIpad = a.isMac = a.getSafariVersion = a.isSafari = a.isLegacyEdge = a.isFirefox = a.isNode = void 0, a.isNode = typeof navigator > "u";
        const l = a.isNode ? "node" : navigator.userAgent, c = a.isNode ? "node" : navigator.platform;
        a.isFirefox = l.includes("Firefox"), a.isLegacyEdge = l.includes("Edge"), a.isSafari = /^((?!chrome|android).)*safari/i.test(l), a.getSafariVersion = function() {
          if (!a.isSafari) return 0;
          const h = l.match(/Version\/(\d+)/);
          return h === null || h.length < 2 ? 0 : parseInt(h[1]);
        }, a.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c), a.isIpad = c === "iPad", a.isIphone = c === "iPhone", a.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c), a.isLinux = c.indexOf("Linux") >= 0, a.isChromeOS = /\bCrOS\b/.test(l);
      }, 6106: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.SortedList = void 0;
        let l = 0;
        a.SortedList = class {
          constructor(c) {
            this._getKey = c, this._array = [];
          }
          clear() {
            this._array.length = 0;
          }
          insert(c) {
            this._array.length !== 0 ? (l = this._search(this._getKey(c)), this._array.splice(l, 0, c)) : this._array.push(c);
          }
          delete(c) {
            if (this._array.length === 0) return !1;
            const h = this._getKey(c);
            if (h === void 0 || (l = this._search(h), l === -1) || this._getKey(this._array[l]) !== h) return !1;
            do
              if (this._array[l] === c) return this._array.splice(l, 1), !0;
            while (++l < this._array.length && this._getKey(this._array[l]) === h);
            return !1;
          }
          *getKeyIterator(c) {
            if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
              yield this._array[l];
            while (++l < this._array.length && this._getKey(this._array[l]) === c);
          }
          forEachByKey(c, h) {
            if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
              h(this._array[l]);
            while (++l < this._array.length && this._getKey(this._array[l]) === c);
          }
          values() {
            return [...this._array].values();
          }
          _search(c) {
            let h = 0, u = this._array.length - 1;
            for (; u >= h; ) {
              let d = h + u >> 1;
              const O = this._getKey(this._array[d]);
              if (O > c) u = d - 1;
              else {
                if (!(O < c)) {
                  for (; d > 0 && this._getKey(this._array[d - 1]) === c; ) d--;
                  return d;
                }
                h = d + 1;
              }
            }
            return h;
          }
        };
      }, 7226: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DebouncedIdleTask = a.IdleTaskQueue = a.PriorityTaskQueue = void 0;
        const c = l(6114);
        class h {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(O) {
            this._tasks.push(O), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(O) {
            this._idleCallback = void 0;
            let v = 0, S = 0, f = O.timeRemaining(), p = 0;
            for (; this._i < this._tasks.length; ) {
              if (v = Date.now(), this._tasks[this._i]() || this._i++, v = Math.max(1, Date.now() - v), S = Math.max(v, S), p = O.timeRemaining(), 1.5 * S > p) return f - v < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(f - v))}ms`), void this._start();
              f = p;
            }
            this.clear();
          }
        }
        class u extends h {
          _requestCallback(O) {
            return setTimeout(() => O(this._createDeadline(16)));
          }
          _cancelCallback(O) {
            clearTimeout(O);
          }
          _createDeadline(O) {
            const v = Date.now() + O;
            return { timeRemaining: () => Math.max(0, v - Date.now()) };
          }
        }
        a.PriorityTaskQueue = u, a.IdleTaskQueue = !c.isNode && "requestIdleCallback" in window ? class extends h {
          _requestCallback(d) {
            return requestIdleCallback(d);
          }
          _cancelCallback(d) {
            cancelIdleCallback(d);
          }
        } : u, a.DebouncedIdleTask = class {
          constructor() {
            this._queue = new a.IdleTaskQueue();
          }
          set(d) {
            this._queue.clear(), this._queue.enqueue(d);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 9282: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.updateWindowsModeWrappedState = void 0;
        const c = l(643);
        a.updateWindowsModeWrappedState = function(h) {
          const u = h.buffer.lines.get(h.buffer.ybase + h.buffer.y - 1), d = u?.get(h.cols - 1), O = h.buffer.lines.get(h.buffer.ybase + h.buffer.y);
          O && d && (O.isWrapped = d[c.CHAR_DATA_CODE_INDEX] !== c.NULL_CELL_CODE && d[c.CHAR_DATA_CODE_INDEX] !== c.WHITESPACE_CELL_CODE);
        };
      }, 3734: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ExtendedAttrs = a.AttributeData = void 0;
        class l {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new c();
          }
          static toColorRGB(u) {
            return [u >>> 16 & 255, u >>> 8 & 255, 255 & u];
          }
          static fromColorRGB(u) {
            return (255 & u[0]) << 16 | (255 & u[1]) << 8 | 255 & u[2];
          }
          clone() {
            const u = new l();
            return u.fg = this.fg, u.bg = this.bg, u.extended = this.extended.clone(), u;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return (50331648 & this.fg) == 50331648;
          }
          isBgRGB() {
            return (50331648 & this.bg) == 50331648;
          }
          isFgPalette() {
            return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
          }
          isBgPalette() {
            return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
          }
          isFgDefault() {
            return (50331648 & this.fg) == 0;
          }
          isBgDefault() {
            return (50331648 & this.bg) == 0;
          }
          isAttributeDefault() {
            return this.fg === 0 && this.bg === 0;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
        }
        a.AttributeData = l;
        class c {
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(u) {
            this._ext = u;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(u) {
            this._ext &= -469762049, this._ext |= u << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(u) {
            this._ext &= -67108864, this._ext |= 67108863 & u;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(u) {
            this._urlId = u;
          }
          constructor(u = 0, d = 0) {
            this._ext = 0, this._urlId = 0, this._ext = u, this._urlId = d;
          }
          clone() {
            return new c(this._ext, this._urlId);
          }
          isEmpty() {
            return this.underlineStyle === 0 && this._urlId === 0;
          }
        }
        a.ExtendedAttrs = c;
      }, 9092: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Buffer = a.MAX_BUFFER_SIZE = void 0;
        const c = l(6349), h = l(7226), u = l(3734), d = l(8437), O = l(4634), v = l(511), S = l(643), f = l(4863), p = l(7116);
        a.MAX_BUFFER_SIZE = 4294967295, a.Buffer = class {
          constructor(g, m, _) {
            this._hasScrollback = g, this._optionsService = m, this._bufferService = _, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = d.DEFAULT_ATTR_DATA.clone(), this.savedCharset = p.DEFAULT_CHARSET, this.markers = [], this._nullCell = v.CellData.fromCharData([0, S.NULL_CELL_CHAR, S.NULL_CELL_WIDTH, S.NULL_CELL_CODE]), this._whitespaceCell = v.CellData.fromCharData([0, S.WHITESPACE_CELL_CHAR, S.WHITESPACE_CELL_WIDTH, S.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new h.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(g) {
            return g ? (this._nullCell.fg = g.fg, this._nullCell.bg = g.bg, this._nullCell.extended = g.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new u.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(g) {
            return g ? (this._whitespaceCell.fg = g.fg, this._whitespaceCell.bg = g.bg, this._whitespaceCell.extended = g.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new u.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(g, m) {
            return new d.BufferLine(this._bufferService.cols, this.getNullCell(g), m);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const g = this.ybase + this.y - this.ydisp;
            return g >= 0 && g < this._rows;
          }
          _getCorrectBufferLength(g) {
            if (!this._hasScrollback) return g;
            const m = g + this._optionsService.rawOptions.scrollback;
            return m > a.MAX_BUFFER_SIZE ? a.MAX_BUFFER_SIZE : m;
          }
          fillViewportRows(g) {
            if (this.lines.length === 0) {
              g === void 0 && (g = d.DEFAULT_ATTR_DATA);
              let m = this._rows;
              for (; m--; ) this.lines.push(this.getBlankLine(g));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(g, m) {
            const _ = this.getNullCell(d.DEFAULT_ATTR_DATA);
            let b = 0;
            const w = this._getCorrectBufferLength(m);
            if (w > this.lines.maxLength && (this.lines.maxLength = w), this.lines.length > 0) {
              if (this._cols < g) for (let y = 0; y < this.lines.length; y++) b += +this.lines.get(y).resize(g, _);
              let x = 0;
              if (this._rows < m) for (let y = this._rows; y < m; y++) this.lines.length < m + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new d.BufferLine(g, _)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + x + 1 ? (this.ybase--, x++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new d.BufferLine(g, _)));
              else for (let y = this._rows; y > m; y--) this.lines.length > m + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (w < this.lines.maxLength) {
                const y = this.lines.length - w;
                y > 0 && (this.lines.trimStart(y), this.ybase = Math.max(this.ybase - y, 0), this.ydisp = Math.max(this.ydisp - y, 0), this.savedY = Math.max(this.savedY - y, 0)), this.lines.maxLength = w;
              }
              this.x = Math.min(this.x, g - 1), this.y = Math.min(this.y, m - 1), x && (this.y += x), this.savedX = Math.min(this.savedX, g - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = m - 1, this._isReflowEnabled && (this._reflow(g, m), this._cols > g)) for (let x = 0; x < this.lines.length; x++) b += +this.lines.get(x).resize(g, _);
            this._cols = g, this._rows = m, this._memoryCleanupQueue.clear(), b > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
          }
          _batchedMemoryCleanup() {
            let g = !0;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, g = !1);
            let m = 0;
            for (; this._memoryCleanupPosition < this.lines.length; ) if (m += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), m > 100) return !0;
            return g;
          }
          get _isReflowEnabled() {
            const g = this._optionsService.rawOptions.windowsPty;
            return g && g.buildNumber ? this._hasScrollback && g.backend === "conpty" && g.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(g, m) {
            this._cols !== g && (g > this._cols ? this._reflowLarger(g, m) : this._reflowSmaller(g, m));
          }
          _reflowLarger(g, m) {
            const _ = (0, O.reflowLargerGetLinesToRemove)(this.lines, this._cols, g, this.ybase + this.y, this.getNullCell(d.DEFAULT_ATTR_DATA));
            if (_.length > 0) {
              const b = (0, O.reflowLargerCreateNewLayout)(this.lines, _);
              (0, O.reflowLargerApplyNewLayout)(this.lines, b.layout), this._reflowLargerAdjustViewport(g, m, b.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(g, m, _) {
            const b = this.getNullCell(d.DEFAULT_ATTR_DATA);
            let w = _;
            for (; w-- > 0; ) this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < m && this.lines.push(new d.BufferLine(g, b))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - _, 0);
          }
          _reflowSmaller(g, m) {
            const _ = this.getNullCell(d.DEFAULT_ATTR_DATA), b = [];
            let w = 0;
            for (let x = this.lines.length - 1; x >= 0; x--) {
              let y = this.lines.get(x);
              if (!y || !y.isWrapped && y.getTrimmedLength() <= g) continue;
              const k = [y];
              for (; y.isWrapped && x > 0; ) y = this.lines.get(--x), k.unshift(y);
              const $ = this.ybase + this.y;
              if ($ >= x && $ < x + k.length) continue;
              const R = k[k.length - 1].getTrimmedLength(), T = (0, O.reflowSmallerGetNewLineLengths)(k, this._cols, g), A = T.length - k.length;
              let M;
              M = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + A) : Math.max(0, this.lines.length - this.lines.maxLength + A);
              const B = [];
              for (let D = 0; D < A; D++) {
                const U = this.getBlankLine(d.DEFAULT_ATTR_DATA, !0);
                B.push(U);
              }
              B.length > 0 && (b.push({ start: x + k.length + w, newLines: B }), w += B.length), k.push(...B);
              let W = T.length - 1, z = T[W];
              z === 0 && (W--, z = T[W]);
              let Q = k.length - A - 1, E = R;
              for (; Q >= 0; ) {
                const D = Math.min(E, z);
                if (k[W] === void 0) break;
                if (k[W].copyCellsFrom(k[Q], E - D, z - D, D, !0), z -= D, z === 0 && (W--, z = T[W]), E -= D, E === 0) {
                  Q--;
                  const U = Math.max(Q, 0);
                  E = (0, O.getWrappedLineTrimmedLength)(k, U, this._cols);
                }
              }
              for (let D = 0; D < k.length; D++) T[D] < g && k[D].setCell(T[D], _);
              let L = A - M;
              for (; L-- > 0; ) this.ybase === 0 ? this.y < m - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + w) - m && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + A, this.ybase + m - 1);
            }
            if (b.length > 0) {
              const x = [], y = [];
              for (let W = 0; W < this.lines.length; W++) y.push(this.lines.get(W));
              const k = this.lines.length;
              let $ = k - 1, R = 0, T = b[R];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + w);
              let A = 0;
              for (let W = Math.min(this.lines.maxLength - 1, k + w - 1); W >= 0; W--) if (T && T.start > $ + A) {
                for (let z = T.newLines.length - 1; z >= 0; z--) this.lines.set(W--, T.newLines[z]);
                W++, x.push({ index: $ + 1, amount: T.newLines.length }), A += T.newLines.length, T = b[++R];
              } else this.lines.set(W, y[$--]);
              let M = 0;
              for (let W = x.length - 1; W >= 0; W--) x[W].index += M, this.lines.onInsertEmitter.fire(x[W]), M += x[W].amount;
              const B = Math.max(0, k + w - this.lines.maxLength);
              B > 0 && this.lines.onTrimEmitter.fire(B);
            }
          }
          translateBufferLineToString(g, m, _ = 0, b) {
            const w = this.lines.get(g);
            return w ? w.translateToString(m, _, b) : "";
          }
          getWrappedRangeForLine(g) {
            let m = g, _ = g;
            for (; m > 0 && this.lines.get(m).isWrapped; ) m--;
            for (; _ + 1 < this.lines.length && this.lines.get(_ + 1).isWrapped; ) _++;
            return { first: m, last: _ };
          }
          setupTabStops(g) {
            for (g != null ? this.tabs[g] || (g = this.prevStop(g)) : (this.tabs = {}, g = 0); g < this._cols; g += this._optionsService.rawOptions.tabStopWidth) this.tabs[g] = !0;
          }
          prevStop(g) {
            for (g == null && (g = this.x); !this.tabs[--g] && g > 0; ) ;
            return g >= this._cols ? this._cols - 1 : g < 0 ? 0 : g;
          }
          nextStop(g) {
            for (g == null && (g = this.x); !this.tabs[++g] && g < this._cols; ) ;
            return g >= this._cols ? this._cols - 1 : g < 0 ? 0 : g;
          }
          clearMarkers(g) {
            this._isClearing = !0;
            for (let m = 0; m < this.markers.length; m++) this.markers[m].line === g && (this.markers[m].dispose(), this.markers.splice(m--, 1));
            this._isClearing = !1;
          }
          clearAllMarkers() {
            this._isClearing = !0;
            for (let g = 0; g < this.markers.length; g++) this.markers[g].dispose(), this.markers.splice(g--, 1);
            this._isClearing = !1;
          }
          addMarker(g) {
            const m = new f.Marker(g);
            return this.markers.push(m), m.register(this.lines.onTrim((_) => {
              m.line -= _, m.line < 0 && m.dispose();
            })), m.register(this.lines.onInsert((_) => {
              m.line >= _.index && (m.line += _.amount);
            })), m.register(this.lines.onDelete((_) => {
              m.line >= _.index && m.line < _.index + _.amount && m.dispose(), m.line > _.index && (m.line -= _.amount);
            })), m.register(m.onDispose(() => this._removeMarker(m))), m;
          }
          _removeMarker(g) {
            this._isClearing || this.markers.splice(this.markers.indexOf(g), 1);
          }
        };
      }, 8437: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLine = a.DEFAULT_ATTR_DATA = void 0;
        const c = l(3734), h = l(511), u = l(643), d = l(482);
        a.DEFAULT_ATTR_DATA = Object.freeze(new c.AttributeData());
        let O = 0;
        class v {
          constructor(f, p, g = !1) {
            this.isWrapped = g, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * f);
            const m = p || h.CellData.fromCharData([0, u.NULL_CELL_CHAR, u.NULL_CELL_WIDTH, u.NULL_CELL_CODE]);
            for (let _ = 0; _ < f; ++_) this.setCell(_, m);
            this.length = f;
          }
          get(f) {
            const p = this._data[3 * f + 0], g = 2097151 & p;
            return [this._data[3 * f + 1], 2097152 & p ? this._combined[f] : g ? (0, d.stringFromCodePoint)(g) : "", p >> 22, 2097152 & p ? this._combined[f].charCodeAt(this._combined[f].length - 1) : g];
          }
          set(f, p) {
            this._data[3 * f + 1] = p[u.CHAR_DATA_ATTR_INDEX], p[u.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[f] = p[1], this._data[3 * f + 0] = 2097152 | f | p[u.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * f + 0] = p[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | p[u.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(f) {
            return this._data[3 * f + 0] >> 22;
          }
          hasWidth(f) {
            return 12582912 & this._data[3 * f + 0];
          }
          getFg(f) {
            return this._data[3 * f + 1];
          }
          getBg(f) {
            return this._data[3 * f + 2];
          }
          hasContent(f) {
            return 4194303 & this._data[3 * f + 0];
          }
          getCodePoint(f) {
            const p = this._data[3 * f + 0];
            return 2097152 & p ? this._combined[f].charCodeAt(this._combined[f].length - 1) : 2097151 & p;
          }
          isCombined(f) {
            return 2097152 & this._data[3 * f + 0];
          }
          getString(f) {
            const p = this._data[3 * f + 0];
            return 2097152 & p ? this._combined[f] : 2097151 & p ? (0, d.stringFromCodePoint)(2097151 & p) : "";
          }
          isProtected(f) {
            return 536870912 & this._data[3 * f + 2];
          }
          loadCell(f, p) {
            return O = 3 * f, p.content = this._data[O + 0], p.fg = this._data[O + 1], p.bg = this._data[O + 2], 2097152 & p.content && (p.combinedData = this._combined[f]), 268435456 & p.bg && (p.extended = this._extendedAttrs[f]), p;
          }
          setCell(f, p) {
            2097152 & p.content && (this._combined[f] = p.combinedData), 268435456 & p.bg && (this._extendedAttrs[f] = p.extended), this._data[3 * f + 0] = p.content, this._data[3 * f + 1] = p.fg, this._data[3 * f + 2] = p.bg;
          }
          setCellFromCodePoint(f, p, g, m, _, b) {
            268435456 & _ && (this._extendedAttrs[f] = b), this._data[3 * f + 0] = p | g << 22, this._data[3 * f + 1] = m, this._data[3 * f + 2] = _;
          }
          addCodepointToCell(f, p) {
            let g = this._data[3 * f + 0];
            2097152 & g ? this._combined[f] += (0, d.stringFromCodePoint)(p) : (2097151 & g ? (this._combined[f] = (0, d.stringFromCodePoint)(2097151 & g) + (0, d.stringFromCodePoint)(p), g &= -2097152, g |= 2097152) : g = p | 4194304, this._data[3 * f + 0] = g);
          }
          insertCells(f, p, g, m) {
            if ((f %= this.length) && this.getWidth(f - 1) === 2 && this.setCellFromCodePoint(f - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), p < this.length - f) {
              const _ = new h.CellData();
              for (let b = this.length - f - p - 1; b >= 0; --b) this.setCell(f + p + b, this.loadCell(f + b, _));
              for (let b = 0; b < p; ++b) this.setCell(f + b, g);
            } else for (let _ = f; _ < this.length; ++_) this.setCell(_, g);
            this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs());
          }
          deleteCells(f, p, g, m) {
            if (f %= this.length, p < this.length - f) {
              const _ = new h.CellData();
              for (let b = 0; b < this.length - f - p; ++b) this.setCell(f + b, this.loadCell(f + p + b, _));
              for (let b = this.length - p; b < this.length; ++b) this.setCell(b, g);
            } else for (let _ = f; _ < this.length; ++_) this.setCell(_, g);
            f && this.getWidth(f - 1) === 2 && this.setCellFromCodePoint(f - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), this.getWidth(f) !== 0 || this.hasContent(f) || this.setCellFromCodePoint(f, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs());
          }
          replaceCells(f, p, g, m, _ = !1) {
            if (_) for (f && this.getWidth(f - 1) === 2 && !this.isProtected(f - 1) && this.setCellFromCodePoint(f - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), p < this.length && this.getWidth(p - 1) === 2 && !this.isProtected(p) && this.setCellFromCodePoint(p, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()); f < p && f < this.length; ) this.isProtected(f) || this.setCell(f, g), f++;
            else for (f && this.getWidth(f - 1) === 2 && this.setCellFromCodePoint(f - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), p < this.length && this.getWidth(p - 1) === 2 && this.setCellFromCodePoint(p, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()); f < p && f < this.length; ) this.setCell(f++, g);
          }
          resize(f, p) {
            if (f === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const g = 3 * f;
            if (f > this.length) {
              if (this._data.buffer.byteLength >= 4 * g) this._data = new Uint32Array(this._data.buffer, 0, g);
              else {
                const m = new Uint32Array(g);
                m.set(this._data), this._data = m;
              }
              for (let m = this.length; m < f; ++m) this.setCell(m, p);
            } else {
              this._data = this._data.subarray(0, g);
              const m = Object.keys(this._combined);
              for (let b = 0; b < m.length; b++) {
                const w = parseInt(m[b], 10);
                w >= f && delete this._combined[w];
              }
              const _ = Object.keys(this._extendedAttrs);
              for (let b = 0; b < _.length; b++) {
                const w = parseInt(_[b], 10);
                w >= f && delete this._extendedAttrs[w];
              }
            }
            return this.length = f, 4 * g * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const f = new Uint32Array(this._data.length);
              return f.set(this._data), this._data = f, 1;
            }
            return 0;
          }
          fill(f, p = !1) {
            if (p) for (let g = 0; g < this.length; ++g) this.isProtected(g) || this.setCell(g, f);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let g = 0; g < this.length; ++g) this.setCell(g, f);
            }
          }
          copyFrom(f) {
            this.length !== f.length ? this._data = new Uint32Array(f._data) : this._data.set(f._data), this.length = f.length, this._combined = {};
            for (const p in f._combined) this._combined[p] = f._combined[p];
            this._extendedAttrs = {};
            for (const p in f._extendedAttrs) this._extendedAttrs[p] = f._extendedAttrs[p];
            this.isWrapped = f.isWrapped;
          }
          clone() {
            const f = new v(0);
            f._data = new Uint32Array(this._data), f.length = this.length;
            for (const p in this._combined) f._combined[p] = this._combined[p];
            for (const p in this._extendedAttrs) f._extendedAttrs[p] = this._extendedAttrs[p];
            return f.isWrapped = this.isWrapped, f;
          }
          getTrimmedLength() {
            for (let f = this.length - 1; f >= 0; --f) if (4194303 & this._data[3 * f + 0]) return f + (this._data[3 * f + 0] >> 22);
            return 0;
          }
          getNoBgTrimmedLength() {
            for (let f = this.length - 1; f >= 0; --f) if (4194303 & this._data[3 * f + 0] || 50331648 & this._data[3 * f + 2]) return f + (this._data[3 * f + 0] >> 22);
            return 0;
          }
          copyCellsFrom(f, p, g, m, _) {
            const b = f._data;
            if (_) for (let x = m - 1; x >= 0; x--) {
              for (let y = 0; y < 3; y++) this._data[3 * (g + x) + y] = b[3 * (p + x) + y];
              268435456 & b[3 * (p + x) + 2] && (this._extendedAttrs[g + x] = f._extendedAttrs[p + x]);
            }
            else for (let x = 0; x < m; x++) {
              for (let y = 0; y < 3; y++) this._data[3 * (g + x) + y] = b[3 * (p + x) + y];
              268435456 & b[3 * (p + x) + 2] && (this._extendedAttrs[g + x] = f._extendedAttrs[p + x]);
            }
            const w = Object.keys(f._combined);
            for (let x = 0; x < w.length; x++) {
              const y = parseInt(w[x], 10);
              y >= p && (this._combined[y - p + g] = f._combined[y]);
            }
          }
          translateToString(f = !1, p = 0, g = this.length) {
            f && (g = Math.min(g, this.getTrimmedLength()));
            let m = "";
            for (; p < g; ) {
              const _ = this._data[3 * p + 0], b = 2097151 & _;
              m += 2097152 & _ ? this._combined[p] : b ? (0, d.stringFromCodePoint)(b) : u.WHITESPACE_CELL_CHAR, p += _ >> 22 || 1;
            }
            return m;
          }
        }
        a.BufferLine = v;
      }, 4841: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getRangeLength = void 0, a.getRangeLength = function(l, c) {
          if (l.start.y > l.end.y) throw new Error(`Buffer range end (${l.end.x}, ${l.end.y}) cannot be before start (${l.start.x}, ${l.start.y})`);
          return c * (l.end.y - l.start.y) + (l.end.x - l.start.x + 1);
        };
      }, 4634: (o, a) => {
        function l(c, h, u) {
          if (h === c.length - 1) return c[h].getTrimmedLength();
          const d = !c[h].hasContent(u - 1) && c[h].getWidth(u - 1) === 1, O = c[h + 1].getWidth(0) === 2;
          return d && O ? u - 1 : u;
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getWrappedLineTrimmedLength = a.reflowSmallerGetNewLineLengths = a.reflowLargerApplyNewLayout = a.reflowLargerCreateNewLayout = a.reflowLargerGetLinesToRemove = void 0, a.reflowLargerGetLinesToRemove = function(c, h, u, d, O) {
          const v = [];
          for (let S = 0; S < c.length - 1; S++) {
            let f = S, p = c.get(++f);
            if (!p.isWrapped) continue;
            const g = [c.get(S)];
            for (; f < c.length && p.isWrapped; ) g.push(p), p = c.get(++f);
            if (d >= S && d < f) {
              S += g.length - 1;
              continue;
            }
            let m = 0, _ = l(g, m, h), b = 1, w = 0;
            for (; b < g.length; ) {
              const y = l(g, b, h), k = y - w, $ = u - _, R = Math.min(k, $);
              g[m].copyCellsFrom(g[b], w, _, R, !1), _ += R, _ === u && (m++, _ = 0), w += R, w === y && (b++, w = 0), _ === 0 && m !== 0 && g[m - 1].getWidth(u - 1) === 2 && (g[m].copyCellsFrom(g[m - 1], u - 1, _++, 1, !1), g[m - 1].setCell(u - 1, O));
            }
            g[m].replaceCells(_, u, O);
            let x = 0;
            for (let y = g.length - 1; y > 0 && (y > m || g[y].getTrimmedLength() === 0); y--) x++;
            x > 0 && (v.push(S + g.length - x), v.push(x)), S += g.length - 1;
          }
          return v;
        }, a.reflowLargerCreateNewLayout = function(c, h) {
          const u = [];
          let d = 0, O = h[d], v = 0;
          for (let S = 0; S < c.length; S++) if (O === S) {
            const f = h[++d];
            c.onDeleteEmitter.fire({ index: S - v, amount: f }), S += f - 1, v += f, O = h[++d];
          } else u.push(S);
          return { layout: u, countRemoved: v };
        }, a.reflowLargerApplyNewLayout = function(c, h) {
          const u = [];
          for (let d = 0; d < h.length; d++) u.push(c.get(h[d]));
          for (let d = 0; d < u.length; d++) c.set(d, u[d]);
          c.length = h.length;
        }, a.reflowSmallerGetNewLineLengths = function(c, h, u) {
          const d = [], O = c.map((p, g) => l(c, g, h)).reduce((p, g) => p + g);
          let v = 0, S = 0, f = 0;
          for (; f < O; ) {
            if (O - f < u) {
              d.push(O - f);
              break;
            }
            v += u;
            const p = l(c, S, h);
            v > p && (v -= p, S++);
            const g = c[S].getWidth(v - 1) === 2;
            g && v--;
            const m = g ? u - 1 : u;
            d.push(m), f += m;
          }
          return d;
        }, a.getWrappedLineTrimmedLength = l;
      }, 5295: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferSet = void 0;
        const c = l(8460), h = l(844), u = l(9092);
        class d extends h.Disposable {
          constructor(v, S) {
            super(), this._optionsService = v, this._bufferService = S, this._onBufferActivate = this.register(new c.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
          }
          reset() {
            this._normal = new u.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new u.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(v) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(v), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(v, S) {
            this._normal.resize(v, S), this._alt.resize(v, S), this.setupTabStops(v);
          }
          setupTabStops(v) {
            this._normal.setupTabStops(v), this._alt.setupTabStops(v);
          }
        }
        a.BufferSet = d;
      }, 511: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CellData = void 0;
        const c = l(482), h = l(643), u = l(3734);
        class d extends u.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new u.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(v) {
            const S = new d();
            return S.setFromCharData(v), S;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, c.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(v) {
            this.fg = v[h.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let S = !1;
            if (v[h.CHAR_DATA_CHAR_INDEX].length > 2) S = !0;
            else if (v[h.CHAR_DATA_CHAR_INDEX].length === 2) {
              const f = v[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= f && f <= 56319) {
                const p = v[h.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= p && p <= 57343 ? this.content = 1024 * (f - 55296) + p - 56320 + 65536 | v[h.CHAR_DATA_WIDTH_INDEX] << 22 : S = !0;
              } else S = !0;
            } else this.content = v[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | v[h.CHAR_DATA_WIDTH_INDEX] << 22;
            S && (this.combinedData = v[h.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | v[h.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        a.CellData = d;
      }, 643: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.WHITESPACE_CELL_CODE = a.WHITESPACE_CELL_WIDTH = a.WHITESPACE_CELL_CHAR = a.NULL_CELL_CODE = a.NULL_CELL_WIDTH = a.NULL_CELL_CHAR = a.CHAR_DATA_CODE_INDEX = a.CHAR_DATA_WIDTH_INDEX = a.CHAR_DATA_CHAR_INDEX = a.CHAR_DATA_ATTR_INDEX = a.DEFAULT_EXT = a.DEFAULT_ATTR = a.DEFAULT_COLOR = void 0, a.DEFAULT_COLOR = 0, a.DEFAULT_ATTR = 256 | a.DEFAULT_COLOR << 9, a.DEFAULT_EXT = 0, a.CHAR_DATA_ATTR_INDEX = 0, a.CHAR_DATA_CHAR_INDEX = 1, a.CHAR_DATA_WIDTH_INDEX = 2, a.CHAR_DATA_CODE_INDEX = 3, a.NULL_CELL_CHAR = "", a.NULL_CELL_WIDTH = 1, a.NULL_CELL_CODE = 0, a.WHITESPACE_CELL_CHAR = " ", a.WHITESPACE_CELL_WIDTH = 1, a.WHITESPACE_CELL_CODE = 32;
      }, 4863: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Marker = void 0;
        const c = l(8460), h = l(844);
        class u {
          get id() {
            return this._id;
          }
          constructor(O) {
            this.line = O, this.isDisposed = !1, this._disposables = [], this._id = u._nextId++, this._onDispose = this.register(new c.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, h.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(O) {
            return this._disposables.push(O), O;
          }
        }
        a.Marker = u, u._nextId = 1;
      }, 7116: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DEFAULT_CHARSET = a.CHARSETS = void 0, a.CHARSETS = {}, a.DEFAULT_CHARSET = a.CHARSETS.B, a.CHARSETS[0] = { "`": "", a: "", b: "", c: "", d: "", e: "", f: "", g: "", h: "", i: "", j: "", k: "", l: "", m: "", n: "", o: "", p: "", q: "", r: "", s: "", t: "", u: "", v: "", w: "", x: "", y: "", z: "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.A = { "#": "" }, a.CHARSETS.B = void 0, a.CHARSETS[4] = { "#": "", "@": "", "[": "ij", "\\": "", "]": "|", "{": "", "|": "f", "}": "", "~": "" }, a.CHARSETS.C = a.CHARSETS[5] = { "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.R = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Q = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.K = { "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Y = { "#": "", "@": "", "[": "", "\\": "", "]": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.E = a.CHARSETS[6] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Z = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "" }, a.CHARSETS.H = a.CHARSETS[7] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS["="] = { "#": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "" };
      }, 2584: (o, a) => {
        var l, c, h;
        Object.defineProperty(a, "__esModule", { value: !0 }), a.C1_ESCAPED = a.C1 = a.C0 = void 0, function(u) {
          u.NUL = "\0", u.SOH = "", u.STX = "", u.ETX = "", u.EOT = "", u.ENQ = "", u.ACK = "", u.BEL = "\x07", u.BS = "\b", u.HT = "	", u.LF = `
`, u.VT = "\v", u.FF = "\f", u.CR = "\r", u.SO = "", u.SI = "", u.DLE = "", u.DC1 = "", u.DC2 = "", u.DC3 = "", u.DC4 = "", u.NAK = "", u.SYN = "", u.ETB = "", u.CAN = "", u.EM = "", u.SUB = "", u.ESC = "\x1B", u.FS = "", u.GS = "", u.RS = "", u.US = "", u.SP = " ", u.DEL = "";
        }(l || (a.C0 = l = {})), function(u) {
          u.PAD = "", u.HOP = "", u.BPH = "", u.NBH = "", u.IND = "", u.NEL = "", u.SSA = "", u.ESA = "", u.HTS = "", u.HTJ = "", u.VTS = "", u.PLD = "", u.PLU = "", u.RI = "", u.SS2 = "", u.SS3 = "", u.DCS = "", u.PU1 = "", u.PU2 = "", u.STS = "", u.CCH = "", u.MW = "", u.SPA = "", u.EPA = "", u.SOS = "", u.SGCI = "", u.SCI = "", u.CSI = "", u.ST = "", u.OSC = "", u.PM = "", u.APC = "";
        }(c || (a.C1 = c = {})), function(u) {
          u.ST = `${l.ESC}\\`;
        }(h || (a.C1_ESCAPED = h = {}));
      }, 7399: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.evaluateKeyboardEvent = void 0;
        const c = l(2584), h = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
        a.evaluateKeyboardEvent = function(u, d, O, v) {
          const S = { type: 0, cancel: !1, key: void 0 }, f = (u.shiftKey ? 1 : 0) | (u.altKey ? 2 : 0) | (u.ctrlKey ? 4 : 0) | (u.metaKey ? 8 : 0);
          switch (u.keyCode) {
            case 0:
              u.key === "UIKeyInputUpArrow" ? S.key = d ? c.C0.ESC + "OA" : c.C0.ESC + "[A" : u.key === "UIKeyInputLeftArrow" ? S.key = d ? c.C0.ESC + "OD" : c.C0.ESC + "[D" : u.key === "UIKeyInputRightArrow" ? S.key = d ? c.C0.ESC + "OC" : c.C0.ESC + "[C" : u.key === "UIKeyInputDownArrow" && (S.key = d ? c.C0.ESC + "OB" : c.C0.ESC + "[B");
              break;
            case 8:
              if (u.altKey) {
                S.key = c.C0.ESC + c.C0.DEL;
                break;
              }
              S.key = c.C0.DEL;
              break;
            case 9:
              if (u.shiftKey) {
                S.key = c.C0.ESC + "[Z";
                break;
              }
              S.key = c.C0.HT, S.cancel = !0;
              break;
            case 13:
              S.key = u.altKey ? c.C0.ESC + c.C0.CR : c.C0.CR, S.cancel = !0;
              break;
            case 27:
              S.key = c.C0.ESC, u.altKey && (S.key = c.C0.ESC + c.C0.ESC), S.cancel = !0;
              break;
            case 37:
              if (u.metaKey) break;
              f ? (S.key = c.C0.ESC + "[1;" + (f + 1) + "D", S.key === c.C0.ESC + "[1;3D" && (S.key = c.C0.ESC + (O ? "b" : "[1;5D"))) : S.key = d ? c.C0.ESC + "OD" : c.C0.ESC + "[D";
              break;
            case 39:
              if (u.metaKey) break;
              f ? (S.key = c.C0.ESC + "[1;" + (f + 1) + "C", S.key === c.C0.ESC + "[1;3C" && (S.key = c.C0.ESC + (O ? "f" : "[1;5C"))) : S.key = d ? c.C0.ESC + "OC" : c.C0.ESC + "[C";
              break;
            case 38:
              if (u.metaKey) break;
              f ? (S.key = c.C0.ESC + "[1;" + (f + 1) + "A", O || S.key !== c.C0.ESC + "[1;3A" || (S.key = c.C0.ESC + "[1;5A")) : S.key = d ? c.C0.ESC + "OA" : c.C0.ESC + "[A";
              break;
            case 40:
              if (u.metaKey) break;
              f ? (S.key = c.C0.ESC + "[1;" + (f + 1) + "B", O || S.key !== c.C0.ESC + "[1;3B" || (S.key = c.C0.ESC + "[1;5B")) : S.key = d ? c.C0.ESC + "OB" : c.C0.ESC + "[B";
              break;
            case 45:
              u.shiftKey || u.ctrlKey || (S.key = c.C0.ESC + "[2~");
              break;
            case 46:
              S.key = f ? c.C0.ESC + "[3;" + (f + 1) + "~" : c.C0.ESC + "[3~";
              break;
            case 36:
              S.key = f ? c.C0.ESC + "[1;" + (f + 1) + "H" : d ? c.C0.ESC + "OH" : c.C0.ESC + "[H";
              break;
            case 35:
              S.key = f ? c.C0.ESC + "[1;" + (f + 1) + "F" : d ? c.C0.ESC + "OF" : c.C0.ESC + "[F";
              break;
            case 33:
              u.shiftKey ? S.type = 2 : u.ctrlKey ? S.key = c.C0.ESC + "[5;" + (f + 1) + "~" : S.key = c.C0.ESC + "[5~";
              break;
            case 34:
              u.shiftKey ? S.type = 3 : u.ctrlKey ? S.key = c.C0.ESC + "[6;" + (f + 1) + "~" : S.key = c.C0.ESC + "[6~";
              break;
            case 112:
              S.key = f ? c.C0.ESC + "[1;" + (f + 1) + "P" : c.C0.ESC + "OP";
              break;
            case 113:
              S.key = f ? c.C0.ESC + "[1;" + (f + 1) + "Q" : c.C0.ESC + "OQ";
              break;
            case 114:
              S.key = f ? c.C0.ESC + "[1;" + (f + 1) + "R" : c.C0.ESC + "OR";
              break;
            case 115:
              S.key = f ? c.C0.ESC + "[1;" + (f + 1) + "S" : c.C0.ESC + "OS";
              break;
            case 116:
              S.key = f ? c.C0.ESC + "[15;" + (f + 1) + "~" : c.C0.ESC + "[15~";
              break;
            case 117:
              S.key = f ? c.C0.ESC + "[17;" + (f + 1) + "~" : c.C0.ESC + "[17~";
              break;
            case 118:
              S.key = f ? c.C0.ESC + "[18;" + (f + 1) + "~" : c.C0.ESC + "[18~";
              break;
            case 119:
              S.key = f ? c.C0.ESC + "[19;" + (f + 1) + "~" : c.C0.ESC + "[19~";
              break;
            case 120:
              S.key = f ? c.C0.ESC + "[20;" + (f + 1) + "~" : c.C0.ESC + "[20~";
              break;
            case 121:
              S.key = f ? c.C0.ESC + "[21;" + (f + 1) + "~" : c.C0.ESC + "[21~";
              break;
            case 122:
              S.key = f ? c.C0.ESC + "[23;" + (f + 1) + "~" : c.C0.ESC + "[23~";
              break;
            case 123:
              S.key = f ? c.C0.ESC + "[24;" + (f + 1) + "~" : c.C0.ESC + "[24~";
              break;
            default:
              if (!u.ctrlKey || u.shiftKey || u.altKey || u.metaKey) if (O && !v || !u.altKey || u.metaKey) !O || u.altKey || u.ctrlKey || u.shiftKey || !u.metaKey ? u.key && !u.ctrlKey && !u.altKey && !u.metaKey && u.keyCode >= 48 && u.key.length === 1 ? S.key = u.key : u.key && u.ctrlKey && (u.key === "_" && (S.key = c.C0.US), u.key === "@" && (S.key = c.C0.NUL)) : u.keyCode === 65 && (S.type = 1);
              else {
                const p = h[u.keyCode], g = p?.[u.shiftKey ? 1 : 0];
                if (g) S.key = c.C0.ESC + g;
                else if (u.keyCode >= 65 && u.keyCode <= 90) {
                  const m = u.ctrlKey ? u.keyCode - 64 : u.keyCode + 32;
                  let _ = String.fromCharCode(m);
                  u.shiftKey && (_ = _.toUpperCase()), S.key = c.C0.ESC + _;
                } else if (u.keyCode === 32) S.key = c.C0.ESC + (u.ctrlKey ? c.C0.NUL : " ");
                else if (u.key === "Dead" && u.code.startsWith("Key")) {
                  let m = u.code.slice(3, 4);
                  u.shiftKey || (m = m.toLowerCase()), S.key = c.C0.ESC + m, S.cancel = !0;
                }
              }
              else u.keyCode >= 65 && u.keyCode <= 90 ? S.key = String.fromCharCode(u.keyCode - 64) : u.keyCode === 32 ? S.key = c.C0.NUL : u.keyCode >= 51 && u.keyCode <= 55 ? S.key = String.fromCharCode(u.keyCode - 51 + 27) : u.keyCode === 56 ? S.key = c.C0.DEL : u.keyCode === 219 ? S.key = c.C0.ESC : u.keyCode === 220 ? S.key = c.C0.FS : u.keyCode === 221 && (S.key = c.C0.GS);
          }
          return S;
        };
      }, 482: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Utf8ToUtf32 = a.StringToUtf32 = a.utf32ToString = a.stringFromCodePoint = void 0, a.stringFromCodePoint = function(l) {
          return l > 65535 ? (l -= 65536, String.fromCharCode(55296 + (l >> 10)) + String.fromCharCode(l % 1024 + 56320)) : String.fromCharCode(l);
        }, a.utf32ToString = function(l, c = 0, h = l.length) {
          let u = "";
          for (let d = c; d < h; ++d) {
            let O = l[d];
            O > 65535 ? (O -= 65536, u += String.fromCharCode(55296 + (O >> 10)) + String.fromCharCode(O % 1024 + 56320)) : u += String.fromCharCode(O);
          }
          return u;
        }, a.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(l, c) {
            const h = l.length;
            if (!h) return 0;
            let u = 0, d = 0;
            if (this._interim) {
              const O = l.charCodeAt(d++);
              56320 <= O && O <= 57343 ? c[u++] = 1024 * (this._interim - 55296) + O - 56320 + 65536 : (c[u++] = this._interim, c[u++] = O), this._interim = 0;
            }
            for (let O = d; O < h; ++O) {
              const v = l.charCodeAt(O);
              if (55296 <= v && v <= 56319) {
                if (++O >= h) return this._interim = v, u;
                const S = l.charCodeAt(O);
                56320 <= S && S <= 57343 ? c[u++] = 1024 * (v - 55296) + S - 56320 + 65536 : (c[u++] = v, c[u++] = S);
              } else v !== 65279 && (c[u++] = v);
            }
            return u;
          }
        }, a.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(l, c) {
            const h = l.length;
            if (!h) return 0;
            let u, d, O, v, S = 0, f = 0, p = 0;
            if (this.interim[0]) {
              let _ = !1, b = this.interim[0];
              b &= (224 & b) == 192 ? 31 : (240 & b) == 224 ? 15 : 7;
              let w, x = 0;
              for (; (w = 63 & this.interim[++x]) && x < 4; ) b <<= 6, b |= w;
              const y = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, k = y - x;
              for (; p < k; ) {
                if (p >= h) return 0;
                if (w = l[p++], (192 & w) != 128) {
                  p--, _ = !0;
                  break;
                }
                this.interim[x++] = w, b <<= 6, b |= 63 & w;
              }
              _ || (y === 2 ? b < 128 ? p-- : c[S++] = b : y === 3 ? b < 2048 || b >= 55296 && b <= 57343 || b === 65279 || (c[S++] = b) : b < 65536 || b > 1114111 || (c[S++] = b)), this.interim.fill(0);
            }
            const g = h - 4;
            let m = p;
            for (; m < h; ) {
              for (; !(!(m < g) || 128 & (u = l[m]) || 128 & (d = l[m + 1]) || 128 & (O = l[m + 2]) || 128 & (v = l[m + 3])); ) c[S++] = u, c[S++] = d, c[S++] = O, c[S++] = v, m += 4;
              if (u = l[m++], u < 128) c[S++] = u;
              else if ((224 & u) == 192) {
                if (m >= h) return this.interim[0] = u, S;
                if (d = l[m++], (192 & d) != 128) {
                  m--;
                  continue;
                }
                if (f = (31 & u) << 6 | 63 & d, f < 128) {
                  m--;
                  continue;
                }
                c[S++] = f;
              } else if ((240 & u) == 224) {
                if (m >= h) return this.interim[0] = u, S;
                if (d = l[m++], (192 & d) != 128) {
                  m--;
                  continue;
                }
                if (m >= h) return this.interim[0] = u, this.interim[1] = d, S;
                if (O = l[m++], (192 & O) != 128) {
                  m--;
                  continue;
                }
                if (f = (15 & u) << 12 | (63 & d) << 6 | 63 & O, f < 2048 || f >= 55296 && f <= 57343 || f === 65279) continue;
                c[S++] = f;
              } else if ((248 & u) == 240) {
                if (m >= h) return this.interim[0] = u, S;
                if (d = l[m++], (192 & d) != 128) {
                  m--;
                  continue;
                }
                if (m >= h) return this.interim[0] = u, this.interim[1] = d, S;
                if (O = l[m++], (192 & O) != 128) {
                  m--;
                  continue;
                }
                if (m >= h) return this.interim[0] = u, this.interim[1] = d, this.interim[2] = O, S;
                if (v = l[m++], (192 & v) != 128) {
                  m--;
                  continue;
                }
                if (f = (7 & u) << 18 | (63 & d) << 12 | (63 & O) << 6 | 63 & v, f < 65536 || f > 1114111) continue;
                c[S++] = f;
              }
            }
            return S;
          }
        };
      }, 225: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeV6 = void 0;
        const l = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], c = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let h;
        a.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !h) {
              h = new Uint8Array(65536), h.fill(1), h[0] = 0, h.fill(0, 1, 32), h.fill(0, 127, 160), h.fill(2, 4352, 4448), h[9001] = 2, h[9002] = 2, h.fill(2, 11904, 42192), h[12351] = 1, h.fill(2, 44032, 55204), h.fill(2, 63744, 64256), h.fill(2, 65040, 65050), h.fill(2, 65072, 65136), h.fill(2, 65280, 65377), h.fill(2, 65504, 65511);
              for (let u = 0; u < l.length; ++u) h.fill(0, l[u][0], l[u][1] + 1);
            }
          }
          wcwidth(u) {
            return u < 32 ? 0 : u < 127 ? 1 : u < 65536 ? h[u] : function(d, O) {
              let v, S = 0, f = O.length - 1;
              if (d < O[0][0] || d > O[f][1]) return !1;
              for (; f >= S; ) if (v = S + f >> 1, d > O[v][1]) S = v + 1;
              else {
                if (!(d < O[v][0])) return !0;
                f = v - 1;
              }
              return !1;
            }(u, c) ? 0 : u >= 131072 && u <= 196605 || u >= 196608 && u <= 262141 ? 2 : 1;
          }
        };
      }, 5981: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.WriteBuffer = void 0;
        const c = l(8460), h = l(844);
        class u extends h.Disposable {
          constructor(O) {
            super(), this._action = O, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new c.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = !0;
          }
          writeSync(O, v) {
            if (v !== void 0 && this._syncCalls > v) return void (this._syncCalls = 0);
            if (this._pendingData += O.length, this._writeBuffer.push(O), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
            let S;
            for (this._isSyncWriting = !0; S = this._writeBuffer.shift(); ) {
              this._action(S);
              const f = this._callbacks.shift();
              f && f();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
          }
          write(O, v) {
            if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += O.length, this._writeBuffer.push(O), this._callbacks.push(v), void this._innerWrite();
              setTimeout(() => this._innerWrite());
            }
            this._pendingData += O.length, this._writeBuffer.push(O), this._callbacks.push(v);
          }
          _innerWrite(O = 0, v = !0) {
            const S = O || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const f = this._writeBuffer[this._bufferOffset], p = this._action(f, v);
              if (p) {
                const m = (_) => Date.now() - S >= 12 ? setTimeout(() => this._innerWrite(0, _)) : this._innerWrite(S, _);
                return void p.catch((_) => (queueMicrotask(() => {
                  throw _;
                }), Promise.resolve(!1))).then(m);
              }
              const g = this._callbacks[this._bufferOffset];
              if (g && g(), this._bufferOffset++, this._pendingData -= f.length, Date.now() - S >= 12) break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        }
        a.WriteBuffer = u;
      }, 5941: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.toRgbString = a.parseColor = void 0;
        const l = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, c = /^[\da-f]+$/;
        function h(u, d) {
          const O = u.toString(16), v = O.length < 2 ? "0" + O : O;
          switch (d) {
            case 4:
              return O[0];
            case 8:
              return v;
            case 12:
              return (v + v).slice(0, 3);
            default:
              return v + v;
          }
        }
        a.parseColor = function(u) {
          if (!u) return;
          let d = u.toLowerCase();
          if (d.indexOf("rgb:") === 0) {
            d = d.slice(4);
            const O = l.exec(d);
            if (O) {
              const v = O[1] ? 15 : O[4] ? 255 : O[7] ? 4095 : 65535;
              return [Math.round(parseInt(O[1] || O[4] || O[7] || O[10], 16) / v * 255), Math.round(parseInt(O[2] || O[5] || O[8] || O[11], 16) / v * 255), Math.round(parseInt(O[3] || O[6] || O[9] || O[12], 16) / v * 255)];
            }
          } else if (d.indexOf("#") === 0 && (d = d.slice(1), c.exec(d) && [3, 6, 9, 12].includes(d.length))) {
            const O = d.length / 3, v = [0, 0, 0];
            for (let S = 0; S < 3; ++S) {
              const f = parseInt(d.slice(O * S, O * S + O), 16);
              v[S] = O === 1 ? f << 4 : O === 2 ? f : O === 3 ? f >> 4 : f >> 8;
            }
            return v;
          }
        }, a.toRgbString = function(u, d = 16) {
          const [O, v, S] = u;
          return `rgb:${h(O, d)}/${h(v, d)}/${h(S, d)}`;
        };
      }, 5770: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.PAYLOAD_LIMIT = void 0, a.PAYLOAD_LIMIT = 1e7;
      }, 6351: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DcsHandler = a.DcsParser = void 0;
        const c = l(482), h = l(8742), u = l(5770), d = [];
        a.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = d, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = d;
          }
          registerHandler(v, S) {
            this._handlers[v] === void 0 && (this._handlers[v] = []);
            const f = this._handlers[v];
            return f.push(S), { dispose: () => {
              const p = f.indexOf(S);
              p !== -1 && f.splice(p, 1);
            } };
          }
          clearHandler(v) {
            this._handlers[v] && delete this._handlers[v];
          }
          setHandlerFallback(v) {
            this._handlerFb = v;
          }
          reset() {
            if (this._active.length) for (let v = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; v >= 0; --v) this._active[v].unhook(!1);
            this._stack.paused = !1, this._active = d, this._ident = 0;
          }
          hook(v, S) {
            if (this.reset(), this._ident = v, this._active = this._handlers[v] || d, this._active.length) for (let f = this._active.length - 1; f >= 0; f--) this._active[f].hook(S);
            else this._handlerFb(this._ident, "HOOK", S);
          }
          put(v, S, f) {
            if (this._active.length) for (let p = this._active.length - 1; p >= 0; p--) this._active[p].put(v, S, f);
            else this._handlerFb(this._ident, "PUT", (0, c.utf32ToString)(v, S, f));
          }
          unhook(v, S = !0) {
            if (this._active.length) {
              let f = !1, p = this._active.length - 1, g = !1;
              if (this._stack.paused && (p = this._stack.loopPosition - 1, f = S, g = this._stack.fallThrough, this._stack.paused = !1), !g && f === !1) {
                for (; p >= 0 && (f = this._active[p].unhook(v), f !== !0); p--) if (f instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = p, this._stack.fallThrough = !1, f;
                p--;
              }
              for (; p >= 0; p--) if (f = this._active[p].unhook(!1), f instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = p, this._stack.fallThrough = !0, f;
            } else this._handlerFb(this._ident, "UNHOOK", v);
            this._active = d, this._ident = 0;
          }
        };
        const O = new h.Params();
        O.addParam(0), a.DcsHandler = class {
          constructor(v) {
            this._handler = v, this._data = "", this._params = O, this._hitLimit = !1;
          }
          hook(v) {
            this._params = v.length > 1 || v.params[0] ? v.clone() : O, this._data = "", this._hitLimit = !1;
          }
          put(v, S, f) {
            this._hitLimit || (this._data += (0, c.utf32ToString)(v, S, f), this._data.length > u.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          unhook(v) {
            let S = !1;
            if (this._hitLimit) S = !1;
            else if (v && (S = this._handler(this._data, this._params), S instanceof Promise)) return S.then((f) => (this._params = O, this._data = "", this._hitLimit = !1, f));
            return this._params = O, this._data = "", this._hitLimit = !1, S;
          }
        };
      }, 2015: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.EscapeSequenceParser = a.VT500_TRANSITION_TABLE = a.TransitionTable = void 0;
        const c = l(844), h = l(8742), u = l(6242), d = l(6351);
        class O {
          constructor(p) {
            this.table = new Uint8Array(p);
          }
          setDefault(p, g) {
            this.table.fill(p << 4 | g);
          }
          add(p, g, m, _) {
            this.table[g << 8 | p] = m << 4 | _;
          }
          addMany(p, g, m, _) {
            for (let b = 0; b < p.length; b++) this.table[g << 8 | p[b]] = m << 4 | _;
          }
        }
        a.TransitionTable = O;
        const v = 160;
        a.VT500_TRANSITION_TABLE = function() {
          const f = new O(4095), p = Array.apply(null, Array(256)).map((x, y) => y), g = (x, y) => p.slice(x, y), m = g(32, 127), _ = g(0, 24);
          _.push(25), _.push.apply(_, g(28, 32));
          const b = g(0, 14);
          let w;
          for (w in f.setDefault(1, 0), f.addMany(m, 0, 2, 0), b) f.addMany([24, 26, 153, 154], w, 3, 0), f.addMany(g(128, 144), w, 3, 0), f.addMany(g(144, 152), w, 3, 0), f.add(156, w, 0, 0), f.add(27, w, 11, 1), f.add(157, w, 4, 8), f.addMany([152, 158, 159], w, 0, 7), f.add(155, w, 11, 3), f.add(144, w, 11, 9);
          return f.addMany(_, 0, 3, 0), f.addMany(_, 1, 3, 1), f.add(127, 1, 0, 1), f.addMany(_, 8, 0, 8), f.addMany(_, 3, 3, 3), f.add(127, 3, 0, 3), f.addMany(_, 4, 3, 4), f.add(127, 4, 0, 4), f.addMany(_, 6, 3, 6), f.addMany(_, 5, 3, 5), f.add(127, 5, 0, 5), f.addMany(_, 2, 3, 2), f.add(127, 2, 0, 2), f.add(93, 1, 4, 8), f.addMany(m, 8, 5, 8), f.add(127, 8, 5, 8), f.addMany([156, 27, 24, 26, 7], 8, 6, 0), f.addMany(g(28, 32), 8, 0, 8), f.addMany([88, 94, 95], 1, 0, 7), f.addMany(m, 7, 0, 7), f.addMany(_, 7, 0, 7), f.add(156, 7, 0, 0), f.add(127, 7, 0, 7), f.add(91, 1, 11, 3), f.addMany(g(64, 127), 3, 7, 0), f.addMany(g(48, 60), 3, 8, 4), f.addMany([60, 61, 62, 63], 3, 9, 4), f.addMany(g(48, 60), 4, 8, 4), f.addMany(g(64, 127), 4, 7, 0), f.addMany([60, 61, 62, 63], 4, 0, 6), f.addMany(g(32, 64), 6, 0, 6), f.add(127, 6, 0, 6), f.addMany(g(64, 127), 6, 0, 0), f.addMany(g(32, 48), 3, 9, 5), f.addMany(g(32, 48), 5, 9, 5), f.addMany(g(48, 64), 5, 0, 6), f.addMany(g(64, 127), 5, 7, 0), f.addMany(g(32, 48), 4, 9, 5), f.addMany(g(32, 48), 1, 9, 2), f.addMany(g(32, 48), 2, 9, 2), f.addMany(g(48, 127), 2, 10, 0), f.addMany(g(48, 80), 1, 10, 0), f.addMany(g(81, 88), 1, 10, 0), f.addMany([89, 90, 92], 1, 10, 0), f.addMany(g(96, 127), 1, 10, 0), f.add(80, 1, 11, 9), f.addMany(_, 9, 0, 9), f.add(127, 9, 0, 9), f.addMany(g(28, 32), 9, 0, 9), f.addMany(g(32, 48), 9, 9, 12), f.addMany(g(48, 60), 9, 8, 10), f.addMany([60, 61, 62, 63], 9, 9, 10), f.addMany(_, 11, 0, 11), f.addMany(g(32, 128), 11, 0, 11), f.addMany(g(28, 32), 11, 0, 11), f.addMany(_, 10, 0, 10), f.add(127, 10, 0, 10), f.addMany(g(28, 32), 10, 0, 10), f.addMany(g(48, 60), 10, 8, 10), f.addMany([60, 61, 62, 63], 10, 0, 11), f.addMany(g(32, 48), 10, 9, 12), f.addMany(_, 12, 0, 12), f.add(127, 12, 0, 12), f.addMany(g(28, 32), 12, 0, 12), f.addMany(g(32, 48), 12, 9, 12), f.addMany(g(48, 64), 12, 0, 11), f.addMany(g(64, 127), 12, 12, 13), f.addMany(g(64, 127), 10, 12, 13), f.addMany(g(64, 127), 9, 12, 13), f.addMany(_, 13, 13, 13), f.addMany(m, 13, 13, 13), f.add(127, 13, 0, 13), f.addMany([27, 156, 24, 26], 13, 14, 0), f.add(v, 0, 2, 0), f.add(v, 8, 5, 8), f.add(v, 6, 0, 6), f.add(v, 11, 0, 11), f.add(v, 13, 13, 13), f;
        }();
        class S extends c.Disposable {
          constructor(p = a.VT500_TRANSITION_TABLE) {
            super(), this._transitions = p, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new h.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (g, m, _) => {
            }, this._executeHandlerFb = (g) => {
            }, this._csiHandlerFb = (g, m) => {
            }, this._escHandlerFb = (g) => {
            }, this._errorHandlerFb = (g) => g, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, c.toDisposable)(() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            })), this._oscParser = this.register(new u.OscParser()), this._dcsParser = this.register(new d.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0);
          }
          _identifier(p, g = [64, 126]) {
            let m = 0;
            if (p.prefix) {
              if (p.prefix.length > 1) throw new Error("only one byte as prefix supported");
              if (m = p.prefix.charCodeAt(0), m && 60 > m || m > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (p.intermediates) {
              if (p.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
              for (let b = 0; b < p.intermediates.length; ++b) {
                const w = p.intermediates.charCodeAt(b);
                if (32 > w || w > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                m <<= 8, m |= w;
              }
            }
            if (p.final.length !== 1) throw new Error("final must be a single byte");
            const _ = p.final.charCodeAt(0);
            if (g[0] > _ || _ > g[1]) throw new Error(`final must be in range ${g[0]} .. ${g[1]}`);
            return m <<= 8, m |= _, m;
          }
          identToString(p) {
            const g = [];
            for (; p; ) g.push(String.fromCharCode(255 & p)), p >>= 8;
            return g.reverse().join("");
          }
          setPrintHandler(p) {
            this._printHandler = p;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(p, g) {
            const m = this._identifier(p, [48, 126]);
            this._escHandlers[m] === void 0 && (this._escHandlers[m] = []);
            const _ = this._escHandlers[m];
            return _.push(g), { dispose: () => {
              const b = _.indexOf(g);
              b !== -1 && _.splice(b, 1);
            } };
          }
          clearEscHandler(p) {
            this._escHandlers[this._identifier(p, [48, 126])] && delete this._escHandlers[this._identifier(p, [48, 126])];
          }
          setEscHandlerFallback(p) {
            this._escHandlerFb = p;
          }
          setExecuteHandler(p, g) {
            this._executeHandlers[p.charCodeAt(0)] = g;
          }
          clearExecuteHandler(p) {
            this._executeHandlers[p.charCodeAt(0)] && delete this._executeHandlers[p.charCodeAt(0)];
          }
          setExecuteHandlerFallback(p) {
            this._executeHandlerFb = p;
          }
          registerCsiHandler(p, g) {
            const m = this._identifier(p);
            this._csiHandlers[m] === void 0 && (this._csiHandlers[m] = []);
            const _ = this._csiHandlers[m];
            return _.push(g), { dispose: () => {
              const b = _.indexOf(g);
              b !== -1 && _.splice(b, 1);
            } };
          }
          clearCsiHandler(p) {
            this._csiHandlers[this._identifier(p)] && delete this._csiHandlers[this._identifier(p)];
          }
          setCsiHandlerFallback(p) {
            this._csiHandlerFb = p;
          }
          registerDcsHandler(p, g) {
            return this._dcsParser.registerHandler(this._identifier(p), g);
          }
          clearDcsHandler(p) {
            this._dcsParser.clearHandler(this._identifier(p));
          }
          setDcsHandlerFallback(p) {
            this._dcsParser.setHandlerFallback(p);
          }
          registerOscHandler(p, g) {
            return this._oscParser.registerHandler(p, g);
          }
          clearOscHandler(p) {
            this._oscParser.clearHandler(p);
          }
          setOscHandlerFallback(p) {
            this._oscParser.setHandlerFallback(p);
          }
          setErrorHandler(p) {
            this._errorHandler = p;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(p, g, m, _, b) {
            this._parseStack.state = p, this._parseStack.handlers = g, this._parseStack.handlerPos = m, this._parseStack.transition = _, this._parseStack.chunkPos = b;
          }
          parse(p, g, m) {
            let _, b = 0, w = 0, x = 0;
            if (this._parseStack.state) if (this._parseStack.state === 2) this._parseStack.state = 0, x = this._parseStack.chunkPos + 1;
            else {
              if (m === void 0 || this._parseStack.state === 1) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              const y = this._parseStack.handlers;
              let k = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (m === !1 && k > -1) {
                    for (; k >= 0 && (_ = y[k](this._params), _ !== !0); k--) if (_ instanceof Promise) return this._parseStack.handlerPos = k, _;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (m === !1 && k > -1) {
                    for (; k >= 0 && (_ = y[k](), _ !== !0); k--) if (_ instanceof Promise) return this._parseStack.handlerPos = k, _;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (b = p[this._parseStack.chunkPos], _ = this._dcsParser.unhook(b !== 24 && b !== 26, m), _) return _;
                  b === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (b = p[this._parseStack.chunkPos], _ = this._oscParser.end(b !== 24 && b !== 26, m), _) return _;
                  b === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, x = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
            }
            for (let y = x; y < g; ++y) {
              switch (b = p[y], w = this._transitions.table[this.currentState << 8 | (b < 160 ? b : v)], w >> 4) {
                case 2:
                  for (let A = y + 1; ; ++A) {
                    if (A >= g || (b = p[A]) < 32 || b > 126 && b < v) {
                      this._printHandler(p, y, A), y = A - 1;
                      break;
                    }
                    if (++A >= g || (b = p[A]) < 32 || b > 126 && b < v) {
                      this._printHandler(p, y, A), y = A - 1;
                      break;
                    }
                    if (++A >= g || (b = p[A]) < 32 || b > 126 && b < v) {
                      this._printHandler(p, y, A), y = A - 1;
                      break;
                    }
                    if (++A >= g || (b = p[A]) < 32 || b > 126 && b < v) {
                      this._printHandler(p, y, A), y = A - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[b] ? this._executeHandlers[b]() : this._executeHandlerFb(b), this.precedingCodepoint = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: y, code: b, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort) return;
                  break;
                case 7:
                  const k = this._csiHandlers[this._collect << 8 | b];
                  let $ = k ? k.length - 1 : -1;
                  for (; $ >= 0 && (_ = k[$](this._params), _ !== !0); $--) if (_ instanceof Promise) return this._preserveStack(3, k, $, w, y), _;
                  $ < 0 && this._csiHandlerFb(this._collect << 8 | b, this._params), this.precedingCodepoint = 0;
                  break;
                case 8:
                  do
                    switch (b) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(b - 48);
                    }
                  while (++y < g && (b = p[y]) > 47 && b < 60);
                  y--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= b;
                  break;
                case 10:
                  const R = this._escHandlers[this._collect << 8 | b];
                  let T = R ? R.length - 1 : -1;
                  for (; T >= 0 && (_ = R[T](), _ !== !0); T--) if (_ instanceof Promise) return this._preserveStack(4, R, T, w, y), _;
                  T < 0 && this._escHandlerFb(this._collect << 8 | b), this.precedingCodepoint = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | b, this._params);
                  break;
                case 13:
                  for (let A = y + 1; ; ++A) if (A >= g || (b = p[A]) === 24 || b === 26 || b === 27 || b > 127 && b < v) {
                    this._dcsParser.put(p, y, A), y = A - 1;
                    break;
                  }
                  break;
                case 14:
                  if (_ = this._dcsParser.unhook(b !== 24 && b !== 26), _) return this._preserveStack(6, [], 0, w, y), _;
                  b === 27 && (w |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let A = y + 1; ; A++) if (A >= g || (b = p[A]) < 32 || b > 127 && b < v) {
                    this._oscParser.put(p, y, A), y = A - 1;
                    break;
                  }
                  break;
                case 6:
                  if (_ = this._oscParser.end(b !== 24 && b !== 26), _) return this._preserveStack(5, [], 0, w, y), _;
                  b === 27 && (w |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
              }
              this.currentState = 15 & w;
            }
          }
        }
        a.EscapeSequenceParser = S;
      }, 6242: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OscHandler = a.OscParser = void 0;
        const c = l(5770), h = l(482), u = [];
        a.OscParser = class {
          constructor() {
            this._state = 0, this._active = u, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          registerHandler(d, O) {
            this._handlers[d] === void 0 && (this._handlers[d] = []);
            const v = this._handlers[d];
            return v.push(O), { dispose: () => {
              const S = v.indexOf(O);
              S !== -1 && v.splice(S, 1);
            } };
          }
          clearHandler(d) {
            this._handlers[d] && delete this._handlers[d];
          }
          setHandlerFallback(d) {
            this._handlerFb = d;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = u;
          }
          reset() {
            if (this._state === 2) for (let d = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; d >= 0; --d) this._active[d].end(!1);
            this._stack.paused = !1, this._active = u, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || u, this._active.length) for (let d = this._active.length - 1; d >= 0; d--) this._active[d].start();
            else this._handlerFb(this._id, "START");
          }
          _put(d, O, v) {
            if (this._active.length) for (let S = this._active.length - 1; S >= 0; S--) this._active[S].put(d, O, v);
            else this._handlerFb(this._id, "PUT", (0, h.utf32ToString)(d, O, v));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(d, O, v) {
            if (this._state !== 3) {
              if (this._state === 1) for (; O < v; ) {
                const S = d[O++];
                if (S === 59) {
                  this._state = 2, this._start();
                  break;
                }
                if (S < 48 || 57 < S) return void (this._state = 3);
                this._id === -1 && (this._id = 0), this._id = 10 * this._id + S - 48;
              }
              this._state === 2 && v - O > 0 && this._put(d, O, v);
            }
          }
          end(d, O = !0) {
            if (this._state !== 0) {
              if (this._state !== 3) if (this._state === 1 && this._start(), this._active.length) {
                let v = !1, S = this._active.length - 1, f = !1;
                if (this._stack.paused && (S = this._stack.loopPosition - 1, v = O, f = this._stack.fallThrough, this._stack.paused = !1), !f && v === !1) {
                  for (; S >= 0 && (v = this._active[S].end(d), v !== !0); S--) if (v instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = S, this._stack.fallThrough = !1, v;
                  S--;
                }
                for (; S >= 0; S--) if (v = this._active[S].end(!1), v instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = S, this._stack.fallThrough = !0, v;
              } else this._handlerFb(this._id, "END", d);
              this._active = u, this._id = -1, this._state = 0;
            }
          }
        }, a.OscHandler = class {
          constructor(d) {
            this._handler = d, this._data = "", this._hitLimit = !1;
          }
          start() {
            this._data = "", this._hitLimit = !1;
          }
          put(d, O, v) {
            this._hitLimit || (this._data += (0, h.utf32ToString)(d, O, v), this._data.length > c.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          end(d) {
            let O = !1;
            if (this._hitLimit) O = !1;
            else if (d && (O = this._handler(this._data), O instanceof Promise)) return O.then((v) => (this._data = "", this._hitLimit = !1, v));
            return this._data = "", this._hitLimit = !1, O;
          }
        };
      }, 8742: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Params = void 0;
        const l = 2147483647;
        class c {
          static fromArray(u) {
            const d = new c();
            if (!u.length) return d;
            for (let O = Array.isArray(u[0]) ? 1 : 0; O < u.length; ++O) {
              const v = u[O];
              if (Array.isArray(v)) for (let S = 0; S < v.length; ++S) d.addSubParam(v[S]);
              else d.addParam(v);
            }
            return d;
          }
          constructor(u = 32, d = 32) {
            if (this.maxLength = u, this.maxSubParamsLength = d, d > 256) throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(u), this.length = 0, this._subParams = new Int32Array(d), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(u), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          clone() {
            const u = new c(this.maxLength, this.maxSubParamsLength);
            return u.params.set(this.params), u.length = this.length, u._subParams.set(this._subParams), u._subParamsLength = this._subParamsLength, u._subParamsIdx.set(this._subParamsIdx), u._rejectDigits = this._rejectDigits, u._rejectSubDigits = this._rejectSubDigits, u._digitIsSub = this._digitIsSub, u;
          }
          toArray() {
            const u = [];
            for (let d = 0; d < this.length; ++d) {
              u.push(this.params[d]);
              const O = this._subParamsIdx[d] >> 8, v = 255 & this._subParamsIdx[d];
              v - O > 0 && u.push(Array.prototype.slice.call(this._subParams, O, v));
            }
            return u;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          addParam(u) {
            if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;
            else {
              if (u < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = u > l ? l : u;
            }
          }
          addSubParam(u) {
            if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;
            else {
              if (u < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = u > l ? l : u, this._subParamsIdx[this.length - 1]++;
            }
          }
          hasSubParams(u) {
            return (255 & this._subParamsIdx[u]) - (this._subParamsIdx[u] >> 8) > 0;
          }
          getSubParams(u) {
            const d = this._subParamsIdx[u] >> 8, O = 255 & this._subParamsIdx[u];
            return O - d > 0 ? this._subParams.subarray(d, O) : null;
          }
          getSubParamsAll() {
            const u = {};
            for (let d = 0; d < this.length; ++d) {
              const O = this._subParamsIdx[d] >> 8, v = 255 & this._subParamsIdx[d];
              v - O > 0 && (u[d] = this._subParams.slice(O, v));
            }
            return u;
          }
          addDigit(u) {
            let d;
            if (this._rejectDigits || !(d = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
            const O = this._digitIsSub ? this._subParams : this.params, v = O[d - 1];
            O[d - 1] = ~v ? Math.min(10 * v + u, l) : u;
          }
        }
        a.Params = c;
      }, 5741: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.AddonManager = void 0, a.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let l = this._addons.length - 1; l >= 0; l--) this._addons[l].instance.dispose();
          }
          loadAddon(l, c) {
            const h = { instance: c, dispose: c.dispose, isDisposed: !1 };
            this._addons.push(h), c.dispose = () => this._wrappedAddonDispose(h), c.activate(l);
          }
          _wrappedAddonDispose(l) {
            if (l.isDisposed) return;
            let c = -1;
            for (let h = 0; h < this._addons.length; h++) if (this._addons[h] === l) {
              c = h;
              break;
            }
            if (c === -1) throw new Error("Could not dispose an addon that has not been loaded");
            l.isDisposed = !0, l.dispose.apply(l.instance), this._addons.splice(c, 1);
          }
        };
      }, 8771: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferApiView = void 0;
        const c = l(3785), h = l(511);
        a.BufferApiView = class {
          constructor(u, d) {
            this._buffer = u, this.type = d;
          }
          init(u) {
            return this._buffer = u, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(u) {
            const d = this._buffer.lines.get(u);
            if (d) return new c.BufferLineApiView(d);
          }
          getNullCell() {
            return new h.CellData();
          }
        };
      }, 3785: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLineApiView = void 0;
        const c = l(511);
        a.BufferLineApiView = class {
          constructor(h) {
            this._line = h;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(h, u) {
            if (!(h < 0 || h >= this._line.length)) return u ? (this._line.loadCell(h, u), u) : this._line.loadCell(h, new c.CellData());
          }
          translateToString(h, u, d) {
            return this._line.translateToString(h, u, d);
          }
        };
      }, 8285: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferNamespaceApi = void 0;
        const c = l(8771), h = l(8460), u = l(844);
        class d extends u.Disposable {
          constructor(v) {
            super(), this._core = v, this._onBufferChange = this.register(new h.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new c.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new c.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        }
        a.BufferNamespaceApi = d;
      }, 7975: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ParserApi = void 0, a.ParserApi = class {
          constructor(l) {
            this._core = l;
          }
          registerCsiHandler(l, c) {
            return this._core.registerCsiHandler(l, (h) => c(h.toArray()));
          }
          addCsiHandler(l, c) {
            return this.registerCsiHandler(l, c);
          }
          registerDcsHandler(l, c) {
            return this._core.registerDcsHandler(l, (h, u) => c(h, u.toArray()));
          }
          addDcsHandler(l, c) {
            return this.registerDcsHandler(l, c);
          }
          registerEscHandler(l, c) {
            return this._core.registerEscHandler(l, c);
          }
          addEscHandler(l, c) {
            return this.registerEscHandler(l, c);
          }
          registerOscHandler(l, c) {
            return this._core.registerOscHandler(l, c);
          }
          addOscHandler(l, c) {
            return this.registerOscHandler(l, c);
          }
        };
      }, 7090: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeApi = void 0, a.UnicodeApi = class {
          constructor(l) {
            this._core = l;
          }
          register(l) {
            this._core.unicodeService.register(l);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(l) {
            this._core.unicodeService.activeVersion = l;
          }
        };
      }, 744: function(o, a, l) {
        var c = this && this.__decorate || function(f, p, g, m) {
          var _, b = arguments.length, w = b < 3 ? p : m === null ? m = Object.getOwnPropertyDescriptor(p, g) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(f, p, g, m);
          else for (var x = f.length - 1; x >= 0; x--) (_ = f[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(p, g, w) : _(p, g)) || w);
          return b > 3 && w && Object.defineProperty(p, g, w), w;
        }, h = this && this.__param || function(f, p) {
          return function(g, m) {
            p(g, m, f);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferService = a.MINIMUM_ROWS = a.MINIMUM_COLS = void 0;
        const u = l(8460), d = l(844), O = l(5295), v = l(2585);
        a.MINIMUM_COLS = 2, a.MINIMUM_ROWS = 1;
        let S = a.BufferService = class extends d.Disposable {
          get buffer() {
            return this.buffers.active;
          }
          constructor(f) {
            super(), this.isUserScrolling = !1, this._onResize = this.register(new u.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new u.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(f.rawOptions.cols || 0, a.MINIMUM_COLS), this.rows = Math.max(f.rawOptions.rows || 0, a.MINIMUM_ROWS), this.buffers = this.register(new O.BufferSet(f, this));
          }
          resize(f, p) {
            this.cols = f, this.rows = p, this.buffers.resize(f, p), this._onResize.fire({ cols: f, rows: p });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = !1;
          }
          scroll(f, p = !1) {
            const g = this.buffer;
            let m;
            m = this._cachedBlankLine, m && m.length === this.cols && m.getFg(0) === f.fg && m.getBg(0) === f.bg || (m = g.getBlankLine(f, p), this._cachedBlankLine = m), m.isWrapped = p;
            const _ = g.ybase + g.scrollTop, b = g.ybase + g.scrollBottom;
            if (g.scrollTop === 0) {
              const w = g.lines.isFull;
              b === g.lines.length - 1 ? w ? g.lines.recycle().copyFrom(m) : g.lines.push(m.clone()) : g.lines.splice(b + 1, 0, m.clone()), w ? this.isUserScrolling && (g.ydisp = Math.max(g.ydisp - 1, 0)) : (g.ybase++, this.isUserScrolling || g.ydisp++);
            } else {
              const w = b - _ + 1;
              g.lines.shiftElements(_ + 1, w - 1, -1), g.lines.set(b, m.clone());
            }
            this.isUserScrolling || (g.ydisp = g.ybase), this._onScroll.fire(g.ydisp);
          }
          scrollLines(f, p, g) {
            const m = this.buffer;
            if (f < 0) {
              if (m.ydisp === 0) return;
              this.isUserScrolling = !0;
            } else f + m.ydisp >= m.ybase && (this.isUserScrolling = !1);
            const _ = m.ydisp;
            m.ydisp = Math.max(Math.min(m.ydisp + f, m.ybase), 0), _ !== m.ydisp && (p || this._onScroll.fire(m.ydisp));
          }
        };
        a.BufferService = S = c([h(0, v.IOptionsService)], S);
      }, 7994: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CharsetService = void 0, a.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(l) {
            this.glevel = l, this.charset = this._charsets[l];
          }
          setgCharset(l, c) {
            this._charsets[l] = c, this.glevel === l && (this.charset = c);
          }
        };
      }, 1753: function(o, a, l) {
        var c = this && this.__decorate || function(m, _, b, w) {
          var x, y = arguments.length, k = y < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, b) : w;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(m, _, b, w);
          else for (var $ = m.length - 1; $ >= 0; $--) (x = m[$]) && (k = (y < 3 ? x(k) : y > 3 ? x(_, b, k) : x(_, b)) || k);
          return y > 3 && k && Object.defineProperty(_, b, k), k;
        }, h = this && this.__param || function(m, _) {
          return function(b, w) {
            _(b, w, m);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreMouseService = void 0;
        const u = l(2585), d = l(8460), O = l(844), v = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: (m) => m.button !== 4 && m.action === 1 && (m.ctrl = !1, m.alt = !1, m.shift = !1, !0) }, VT200: { events: 19, restrict: (m) => m.action !== 32 }, DRAG: { events: 23, restrict: (m) => m.action !== 32 || m.button !== 3 }, ANY: { events: 31, restrict: (m) => !0 } };
        function S(m, _) {
          let b = (m.ctrl ? 16 : 0) | (m.shift ? 4 : 0) | (m.alt ? 8 : 0);
          return m.button === 4 ? (b |= 64, b |= m.action) : (b |= 3 & m.button, 4 & m.button && (b |= 64), 8 & m.button && (b |= 128), m.action === 32 ? b |= 32 : m.action !== 0 || _ || (b |= 3)), b;
        }
        const f = String.fromCharCode, p = { DEFAULT: (m) => {
          const _ = [S(m, !1) + 32, m.col + 32, m.row + 32];
          return _[0] > 255 || _[1] > 255 || _[2] > 255 ? "" : `\x1B[M${f(_[0])}${f(_[1])}${f(_[2])}`;
        }, SGR: (m) => {
          const _ = m.action === 0 && m.button !== 4 ? "m" : "M";
          return `\x1B[<${S(m, !0)};${m.col};${m.row}${_}`;
        }, SGR_PIXELS: (m) => {
          const _ = m.action === 0 && m.button !== 4 ? "m" : "M";
          return `\x1B[<${S(m, !0)};${m.x};${m.y}${_}`;
        } };
        let g = a.CoreMouseService = class extends O.Disposable {
          constructor(m, _) {
            super(), this._bufferService = m, this._coreService = _, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new d.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const b of Object.keys(v)) this.addProtocol(b, v[b]);
            for (const b of Object.keys(p)) this.addEncoding(b, p[b]);
            this.reset();
          }
          addProtocol(m, _) {
            this._protocols[m] = _;
          }
          addEncoding(m, _) {
            this._encodings[m] = _;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return this._protocols[this._activeProtocol].events !== 0;
          }
          set activeProtocol(m) {
            if (!this._protocols[m]) throw new Error(`unknown protocol "${m}"`);
            this._activeProtocol = m, this._onProtocolChange.fire(this._protocols[m].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(m) {
            if (!this._encodings[m]) throw new Error(`unknown encoding "${m}"`);
            this._activeEncoding = m;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(m) {
            if (m.col < 0 || m.col >= this._bufferService.cols || m.row < 0 || m.row >= this._bufferService.rows || m.button === 4 && m.action === 32 || m.button === 3 && m.action !== 32 || m.button !== 4 && (m.action === 2 || m.action === 3) || (m.col++, m.row++, m.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, m, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(m)) return !1;
            const _ = this._encodings[this._activeEncoding](m);
            return _ && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(_) : this._coreService.triggerDataEvent(_, !0)), this._lastEvent = m, !0;
          }
          explainEvents(m) {
            return { down: !!(1 & m), up: !!(2 & m), drag: !!(4 & m), move: !!(8 & m), wheel: !!(16 & m) };
          }
          _equalEvents(m, _, b) {
            if (b) {
              if (m.x !== _.x || m.y !== _.y) return !1;
            } else if (m.col !== _.col || m.row !== _.row) return !1;
            return m.button === _.button && m.action === _.action && m.ctrl === _.ctrl && m.alt === _.alt && m.shift === _.shift;
          }
        };
        a.CoreMouseService = g = c([h(0, u.IBufferService), h(1, u.ICoreService)], g);
      }, 6975: function(o, a, l) {
        var c = this && this.__decorate || function(g, m, _, b) {
          var w, x = arguments.length, y = x < 3 ? m : b === null ? b = Object.getOwnPropertyDescriptor(m, _) : b;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") y = Reflect.decorate(g, m, _, b);
          else for (var k = g.length - 1; k >= 0; k--) (w = g[k]) && (y = (x < 3 ? w(y) : x > 3 ? w(m, _, y) : w(m, _)) || y);
          return x > 3 && y && Object.defineProperty(m, _, y), y;
        }, h = this && this.__param || function(g, m) {
          return function(_, b) {
            m(_, b, g);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreService = void 0;
        const u = l(1439), d = l(8460), O = l(844), v = l(2585), S = Object.freeze({ insertMode: !1 }), f = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 });
        let p = a.CoreService = class extends O.Disposable {
          constructor(g, m, _) {
            super(), this._bufferService = g, this._logService = m, this._optionsService = _, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new d.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new d.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new d.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new d.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, u.clone)(S), this.decPrivateModes = (0, u.clone)(f);
          }
          reset() {
            this.modes = (0, u.clone)(S), this.decPrivateModes = (0, u.clone)(f);
          }
          triggerDataEvent(g, m = !1) {
            if (this._optionsService.rawOptions.disableStdin) return;
            const _ = this._bufferService.buffer;
            m && this._optionsService.rawOptions.scrollOnUserInput && _.ybase !== _.ydisp && this._onRequestScrollToBottom.fire(), m && this._onUserInput.fire(), this._logService.debug(`sending data "${g}"`, () => g.split("").map((b) => b.charCodeAt(0))), this._onData.fire(g);
          }
          triggerBinaryEvent(g) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${g}"`, () => g.split("").map((m) => m.charCodeAt(0))), this._onBinary.fire(g));
          }
        };
        a.CoreService = p = c([h(0, v.IBufferService), h(1, v.ILogService), h(2, v.IOptionsService)], p);
      }, 9074: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DecorationService = void 0;
        const c = l(8055), h = l(8460), u = l(844), d = l(6106);
        let O = 0, v = 0;
        class S extends u.Disposable {
          get decorations() {
            return this._decorations.values();
          }
          constructor() {
            super(), this._decorations = new d.SortedList((g) => g?.marker.line), this._onDecorationRegistered = this.register(new h.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new h.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, u.toDisposable)(() => this.reset()));
          }
          registerDecoration(g) {
            if (g.marker.isDisposed) return;
            const m = new f(g);
            if (m) {
              const _ = m.marker.onDispose(() => m.dispose());
              m.onDispose(() => {
                m && (this._decorations.delete(m) && this._onDecorationRemoved.fire(m), _.dispose());
              }), this._decorations.insert(m), this._onDecorationRegistered.fire(m);
            }
            return m;
          }
          reset() {
            for (const g of this._decorations.values()) g.dispose();
            this._decorations.clear();
          }
          *getDecorationsAtCell(g, m, _) {
            var b, w, x;
            let y = 0, k = 0;
            for (const $ of this._decorations.getKeyIterator(m)) y = (b = $.options.x) !== null && b !== void 0 ? b : 0, k = y + ((w = $.options.width) !== null && w !== void 0 ? w : 1), g >= y && g < k && (!_ || ((x = $.options.layer) !== null && x !== void 0 ? x : "bottom") === _) && (yield $);
          }
          forEachDecorationAtCell(g, m, _, b) {
            this._decorations.forEachByKey(m, (w) => {
              var x, y, k;
              O = (x = w.options.x) !== null && x !== void 0 ? x : 0, v = O + ((y = w.options.width) !== null && y !== void 0 ? y : 1), g >= O && g < v && (!_ || ((k = w.options.layer) !== null && k !== void 0 ? k : "bottom") === _) && b(w);
            });
          }
        }
        a.DecorationService = S;
        class f extends u.Disposable {
          get isDisposed() {
            return this._isDisposed;
          }
          get backgroundColorRGB() {
            return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = c.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
          }
          get foregroundColorRGB() {
            return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = c.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
          }
          constructor(g) {
            super(), this.options = g, this.onRenderEmitter = this.register(new h.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new h.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = g.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
          }
          dispose() {
            this._onDispose.fire(), super.dispose();
          }
        }
      }, 4348: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.InstantiationService = a.ServiceCollection = void 0;
        const c = l(2585), h = l(8343);
        class u {
          constructor(...O) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [v, S] of O) this.set(v, S);
          }
          set(O, v) {
            const S = this._entries.get(O);
            return this._entries.set(O, v), S;
          }
          forEach(O) {
            for (const [v, S] of this._entries.entries()) O(v, S);
          }
          has(O) {
            return this._entries.has(O);
          }
          get(O) {
            return this._entries.get(O);
          }
        }
        a.ServiceCollection = u, a.InstantiationService = class {
          constructor() {
            this._services = new u(), this._services.set(c.IInstantiationService, this);
          }
          setService(d, O) {
            this._services.set(d, O);
          }
          getService(d) {
            return this._services.get(d);
          }
          createInstance(d, ...O) {
            const v = (0, h.getServiceDependencies)(d).sort((p, g) => p.index - g.index), S = [];
            for (const p of v) {
              const g = this._services.get(p.id);
              if (!g) throw new Error(`[createInstance] ${d.name} depends on UNKNOWN service ${p.id}.`);
              S.push(g);
            }
            const f = v.length > 0 ? v[0].index : O.length;
            if (O.length !== f) throw new Error(`[createInstance] First service dependency of ${d.name} at position ${f + 1} conflicts with ${O.length} static arguments`);
            return new d(...O, ...S);
          }
        };
      }, 7866: function(o, a, l) {
        var c = this && this.__decorate || function(f, p, g, m) {
          var _, b = arguments.length, w = b < 3 ? p : m === null ? m = Object.getOwnPropertyDescriptor(p, g) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(f, p, g, m);
          else for (var x = f.length - 1; x >= 0; x--) (_ = f[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(p, g, w) : _(p, g)) || w);
          return b > 3 && w && Object.defineProperty(p, g, w), w;
        }, h = this && this.__param || function(f, p) {
          return function(g, m) {
            p(g, m, f);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.traceCall = a.setTraceLogger = a.LogService = void 0;
        const u = l(844), d = l(2585), O = { trace: d.LogLevelEnum.TRACE, debug: d.LogLevelEnum.DEBUG, info: d.LogLevelEnum.INFO, warn: d.LogLevelEnum.WARN, error: d.LogLevelEnum.ERROR, off: d.LogLevelEnum.OFF };
        let v, S = a.LogService = class extends u.Disposable {
          get logLevel() {
            return this._logLevel;
          }
          constructor(f) {
            super(), this._optionsService = f, this._logLevel = d.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), v = this;
          }
          _updateLogLevel() {
            this._logLevel = O[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(f) {
            for (let p = 0; p < f.length; p++) typeof f[p] == "function" && (f[p] = f[p]());
          }
          _log(f, p, g) {
            this._evalLazyOptionalParams(g), f.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + p, ...g);
          }
          trace(f, ...p) {
            var g, m;
            this._logLevel <= d.LogLevelEnum.TRACE && this._log((m = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.trace.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.log, f, p);
          }
          debug(f, ...p) {
            var g, m;
            this._logLevel <= d.LogLevelEnum.DEBUG && this._log((m = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.debug.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.log, f, p);
          }
          info(f, ...p) {
            var g, m;
            this._logLevel <= d.LogLevelEnum.INFO && this._log((m = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.info.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.info, f, p);
          }
          warn(f, ...p) {
            var g, m;
            this._logLevel <= d.LogLevelEnum.WARN && this._log((m = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.warn.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.warn, f, p);
          }
          error(f, ...p) {
            var g, m;
            this._logLevel <= d.LogLevelEnum.ERROR && this._log((m = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.error.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.error, f, p);
          }
        };
        a.LogService = S = c([h(0, d.IOptionsService)], S), a.setTraceLogger = function(f) {
          v = f;
        }, a.traceCall = function(f, p, g) {
          if (typeof g.value != "function") throw new Error("not supported");
          const m = g.value;
          g.value = function(..._) {
            if (v.logLevel !== d.LogLevelEnum.TRACE) return m.apply(this, _);
            v.trace(`GlyphRenderer#${m.name}(${_.map((w) => JSON.stringify(w)).join(", ")})`);
            const b = m.apply(this, _);
            return v.trace(`GlyphRenderer#${m.name} return`, b), b;
          };
        };
      }, 7302: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OptionsService = a.DEFAULT_OPTIONS = void 0;
        const c = l(8460), h = l(844), u = l(6114);
        a.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: !0, drawBoldTextInBrightColors: !0, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: !1, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rightClickSelectsWord: u.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 };
        const d = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        class O extends h.Disposable {
          constructor(S) {
            super(), this._onOptionChange = this.register(new c.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const f = Object.assign({}, a.DEFAULT_OPTIONS);
            for (const p in S) if (p in f) try {
              const g = S[p];
              f[p] = this._sanitizeAndValidateOption(p, g);
            } catch (g) {
              console.error(g);
            }
            this.rawOptions = f, this.options = Object.assign({}, f), this._setupOptions();
          }
          onSpecificOptionChange(S, f) {
            return this.onOptionChange((p) => {
              p === S && f(this.rawOptions[S]);
            });
          }
          onMultipleOptionChange(S, f) {
            return this.onOptionChange((p) => {
              S.indexOf(p) !== -1 && f();
            });
          }
          _setupOptions() {
            const S = (p) => {
              if (!(p in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${p}"`);
              return this.rawOptions[p];
            }, f = (p, g) => {
              if (!(p in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${p}"`);
              g = this._sanitizeAndValidateOption(p, g), this.rawOptions[p] !== g && (this.rawOptions[p] = g, this._onOptionChange.fire(p));
            };
            for (const p in this.rawOptions) {
              const g = { get: S.bind(this, p), set: f.bind(this, p) };
              Object.defineProperty(this.options, p, g);
            }
          }
          _sanitizeAndValidateOption(S, f) {
            switch (S) {
              case "cursorStyle":
                if (f || (f = a.DEFAULT_OPTIONS[S]), !/* @__PURE__ */ function(p) {
                  return p === "block" || p === "underline" || p === "bar";
                }(f)) throw new Error(`"${f}" is not a valid value for ${S}`);
                break;
              case "wordSeparator":
                f || (f = a.DEFAULT_OPTIONS[S]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if (typeof f == "number" && 1 <= f && f <= 1e3) break;
                f = d.includes(f) ? f : a.DEFAULT_OPTIONS[S];
                break;
              case "cursorWidth":
                f = Math.floor(f);
              case "lineHeight":
              case "tabStopWidth":
                if (f < 1) throw new Error(`${S} cannot be less than 1, value: ${f}`);
                break;
              case "minimumContrastRatio":
                f = Math.max(1, Math.min(21, Math.round(10 * f) / 10));
                break;
              case "scrollback":
                if ((f = Math.min(f, 4294967295)) < 0) throw new Error(`${S} cannot be less than 0, value: ${f}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (f <= 0) throw new Error(`${S} cannot be less than or equal to 0, value: ${f}`);
                break;
              case "rows":
              case "cols":
                if (!f && f !== 0) throw new Error(`${S} must be numeric, value: ${f}`);
                break;
              case "windowsPty":
                f = f ?? {};
            }
            return f;
          }
        }
        a.OptionsService = O;
      }, 2660: function(o, a, l) {
        var c = this && this.__decorate || function(O, v, S, f) {
          var p, g = arguments.length, m = g < 3 ? v : f === null ? f = Object.getOwnPropertyDescriptor(v, S) : f;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") m = Reflect.decorate(O, v, S, f);
          else for (var _ = O.length - 1; _ >= 0; _--) (p = O[_]) && (m = (g < 3 ? p(m) : g > 3 ? p(v, S, m) : p(v, S)) || m);
          return g > 3 && m && Object.defineProperty(v, S, m), m;
        }, h = this && this.__param || function(O, v) {
          return function(S, f) {
            v(S, f, O);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkService = void 0;
        const u = l(2585);
        let d = a.OscLinkService = class {
          constructor(O) {
            this._bufferService = O, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(O) {
            const v = this._bufferService.buffer;
            if (O.id === void 0) {
              const _ = v.addMarker(v.ybase + v.y), b = { data: O, id: this._nextId++, lines: [_] };
              return _.onDispose(() => this._removeMarkerFromLink(b, _)), this._dataByLinkId.set(b.id, b), b.id;
            }
            const S = O, f = this._getEntryIdKey(S), p = this._entriesWithId.get(f);
            if (p) return this.addLineToLink(p.id, v.ybase + v.y), p.id;
            const g = v.addMarker(v.ybase + v.y), m = { id: this._nextId++, key: this._getEntryIdKey(S), data: S, lines: [g] };
            return g.onDispose(() => this._removeMarkerFromLink(m, g)), this._entriesWithId.set(m.key, m), this._dataByLinkId.set(m.id, m), m.id;
          }
          addLineToLink(O, v) {
            const S = this._dataByLinkId.get(O);
            if (S && S.lines.every((f) => f.line !== v)) {
              const f = this._bufferService.buffer.addMarker(v);
              S.lines.push(f), f.onDispose(() => this._removeMarkerFromLink(S, f));
            }
          }
          getLinkData(O) {
            var v;
            return (v = this._dataByLinkId.get(O)) === null || v === void 0 ? void 0 : v.data;
          }
          _getEntryIdKey(O) {
            return `${O.id};;${O.uri}`;
          }
          _removeMarkerFromLink(O, v) {
            const S = O.lines.indexOf(v);
            S !== -1 && (O.lines.splice(S, 1), O.lines.length === 0 && (O.data.id !== void 0 && this._entriesWithId.delete(O.key), this._dataByLinkId.delete(O.id)));
          }
        };
        a.OscLinkService = d = c([h(0, u.IBufferService)], d);
      }, 8343: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.createDecorator = a.getServiceDependencies = a.serviceRegistry = void 0;
        const l = "di$target", c = "di$dependencies";
        a.serviceRegistry = /* @__PURE__ */ new Map(), a.getServiceDependencies = function(h) {
          return h[c] || [];
        }, a.createDecorator = function(h) {
          if (a.serviceRegistry.has(h)) return a.serviceRegistry.get(h);
          const u = function(d, O, v) {
            if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            (function(S, f, p) {
              f[l] === f ? f[c].push({ id: S, index: p }) : (f[c] = [{ id: S, index: p }], f[l] = f);
            })(u, d, v);
          };
          return u.toString = () => h, a.serviceRegistry.set(h, u), u;
        };
      }, 2585: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.IDecorationService = a.IUnicodeService = a.IOscLinkService = a.IOptionsService = a.ILogService = a.LogLevelEnum = a.IInstantiationService = a.ICharsetService = a.ICoreService = a.ICoreMouseService = a.IBufferService = void 0;
        const c = l(8343);
        var h;
        a.IBufferService = (0, c.createDecorator)("BufferService"), a.ICoreMouseService = (0, c.createDecorator)("CoreMouseService"), a.ICoreService = (0, c.createDecorator)("CoreService"), a.ICharsetService = (0, c.createDecorator)("CharsetService"), a.IInstantiationService = (0, c.createDecorator)("InstantiationService"), function(u) {
          u[u.TRACE = 0] = "TRACE", u[u.DEBUG = 1] = "DEBUG", u[u.INFO = 2] = "INFO", u[u.WARN = 3] = "WARN", u[u.ERROR = 4] = "ERROR", u[u.OFF = 5] = "OFF";
        }(h || (a.LogLevelEnum = h = {})), a.ILogService = (0, c.createDecorator)("LogService"), a.IOptionsService = (0, c.createDecorator)("OptionsService"), a.IOscLinkService = (0, c.createDecorator)("OscLinkService"), a.IUnicodeService = (0, c.createDecorator)("UnicodeService"), a.IDecorationService = (0, c.createDecorator)("DecorationService");
      }, 1480: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeService = void 0;
        const c = l(8460), h = l(225);
        a.UnicodeService = class {
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new c.EventEmitter(), this.onChange = this._onChange.event;
            const u = new h.UnicodeV6();
            this.register(u), this._active = u.version, this._activeProvider = u;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(u) {
            if (!this._providers[u]) throw new Error(`unknown Unicode version "${u}"`);
            this._active = u, this._activeProvider = this._providers[u], this._onChange.fire(u);
          }
          register(u) {
            this._providers[u.version] = u;
          }
          wcwidth(u) {
            return this._activeProvider.wcwidth(u);
          }
          getStringCellWidth(u) {
            let d = 0;
            const O = u.length;
            for (let v = 0; v < O; ++v) {
              let S = u.charCodeAt(v);
              if (55296 <= S && S <= 56319) {
                if (++v >= O) return d + this.wcwidth(S);
                const f = u.charCodeAt(v);
                56320 <= f && f <= 57343 ? S = 1024 * (S - 55296) + f - 56320 + 65536 : d += this.wcwidth(f);
              }
              d += this.wcwidth(S);
            }
            return d;
          }
        };
      } }, r = {};
      function s(o) {
        var a = r[o];
        if (a !== void 0) return a.exports;
        var l = r[o] = { exports: {} };
        return t[o].call(l.exports, l, l.exports, s), l.exports;
      }
      var n = {};
      return (() => {
        var o = n;
        Object.defineProperty(o, "__esModule", { value: !0 }), o.Terminal = void 0;
        const a = s(9042), l = s(3236), c = s(844), h = s(5741), u = s(8285), d = s(7975), O = s(7090), v = ["cols", "rows"];
        class S extends c.Disposable {
          constructor(p) {
            super(), this._core = this.register(new l.Terminal(p)), this._addonManager = this.register(new h.AddonManager()), this._publicOptions = Object.assign({}, this._core.options);
            const g = (_) => this._core.options[_], m = (_, b) => {
              this._checkReadonlyOptions(_), this._core.options[_] = b;
            };
            for (const _ in this._core.options) {
              const b = { get: g.bind(this, _), set: m.bind(this, _) };
              Object.defineProperty(this._publicOptions, _, b);
            }
          }
          _checkReadonlyOptions(p) {
            if (v.includes(p)) throw new Error(`Option "${p}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new d.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new O.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = this.register(new u.BufferNamespaceApi(this._core))), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const p = this._core.coreService.decPrivateModes;
            let g = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                g = "x10";
                break;
              case "VT200":
                g = "vt200";
                break;
              case "DRAG":
                g = "drag";
                break;
              case "ANY":
                g = "any";
            }
            return { applicationCursorKeysMode: p.applicationCursorKeys, applicationKeypadMode: p.applicationKeypad, bracketedPasteMode: p.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: g, originMode: p.origin, reverseWraparoundMode: p.reverseWraparound, sendFocusMode: p.sendFocus, wraparoundMode: p.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(p) {
            for (const g in p) this._publicOptions[g] = p[g];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          resize(p, g) {
            this._verifyIntegers(p, g), this._core.resize(p, g);
          }
          open(p) {
            this._core.open(p);
          }
          attachCustomKeyEventHandler(p) {
            this._core.attachCustomKeyEventHandler(p);
          }
          registerLinkProvider(p) {
            return this._core.registerLinkProvider(p);
          }
          registerCharacterJoiner(p) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(p);
          }
          deregisterCharacterJoiner(p) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(p);
          }
          registerMarker(p = 0) {
            return this._verifyIntegers(p), this._core.registerMarker(p);
          }
          registerDecoration(p) {
            var g, m, _;
            return this._checkProposedApi(), this._verifyPositiveIntegers((g = p.x) !== null && g !== void 0 ? g : 0, (m = p.width) !== null && m !== void 0 ? m : 0, (_ = p.height) !== null && _ !== void 0 ? _ : 0), this._core.registerDecoration(p);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(p, g, m) {
            this._verifyIntegers(p, g, m), this._core.select(p, g, m);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(p, g) {
            this._verifyIntegers(p, g), this._core.selectLines(p, g);
          }
          dispose() {
            super.dispose();
          }
          scrollLines(p) {
            this._verifyIntegers(p), this._core.scrollLines(p);
          }
          scrollPages(p) {
            this._verifyIntegers(p), this._core.scrollPages(p);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(p) {
            this._verifyIntegers(p), this._core.scrollToLine(p);
          }
          clear() {
            this._core.clear();
          }
          write(p, g) {
            this._core.write(p, g);
          }
          writeln(p, g) {
            this._core.write(p), this._core.write(`\r
`, g);
          }
          paste(p) {
            this._core.paste(p);
          }
          refresh(p, g) {
            this._verifyIntegers(p, g), this._core.refresh(p, g);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(p) {
            this._addonManager.loadAddon(this, p);
          }
          static get strings() {
            return a;
          }
          _verifyIntegers(...p) {
            for (const g of p) if (g === 1 / 0 || isNaN(g) || g % 1 != 0) throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...p) {
            for (const g of p) if (g && (g === 1 / 0 || isNaN(g) || g % 1 != 0 || g < 0)) throw new Error("This API only accepts positive integers");
          }
        }
        o.Terminal = S;
      })(), n;
    })());
  }(eh)), eh.exports;
}
var yq = bq(), th = { exports: {} }, mm;
function wq() {
  return mm || (mm = 1, function(i, e) {
    (function(t, r) {
      i.exports = r();
    })(self, () => (() => {
      var t = {};
      return (() => {
        var r = t;
        Object.defineProperty(r, "__esModule", { value: !0 }), r.FitAddon = void 0, r.FitAddon = class {
          activate(s) {
            this._terminal = s;
          }
          dispose() {
          }
          fit() {
            const s = this.proposeDimensions();
            if (!s || !this._terminal || isNaN(s.cols) || isNaN(s.rows)) return;
            const n = this._terminal._core;
            this._terminal.rows === s.rows && this._terminal.cols === s.cols || (n._renderService.clear(), this._terminal.resize(s.cols, s.rows));
          }
          proposeDimensions() {
            if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement) return;
            const s = this._terminal._core, n = s._renderService.dimensions;
            if (n.css.cell.width === 0 || n.css.cell.height === 0) return;
            const o = this._terminal.options.scrollback === 0 ? 0 : s.viewport.scrollBarWidth, a = window.getComputedStyle(this._terminal.element.parentElement), l = parseInt(a.getPropertyValue("height")), c = Math.max(0, parseInt(a.getPropertyValue("width"))), h = window.getComputedStyle(this._terminal.element), u = l - (parseInt(h.getPropertyValue("padding-top")) + parseInt(h.getPropertyValue("padding-bottom"))), d = c - (parseInt(h.getPropertyValue("padding-right")) + parseInt(h.getPropertyValue("padding-left"))) - o;
            return { cols: Math.max(2, Math.floor(d / n.css.cell.width)), rows: Math.max(1, Math.floor(u / n.css.cell.height)) };
          }
        };
      })(), t;
    })());
  }(th)), th.exports;
}
var xq = wq();
const vi = /* @__PURE__ */ Object.create(null);
vi.open = "0";
vi.close = "1";
vi.ping = "2";
vi.pong = "3";
vi.message = "4";
vi.upgrade = "5";
vi.noop = "6";
const va = /* @__PURE__ */ Object.create(null);
Object.keys(vi).forEach((i) => {
  va[vi[i]] = i;
});
const Uu = { type: "error", data: "parser error" }, wy = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", xy = typeof ArrayBuffer == "function", ky = (i) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer, Sd = ({ type: i, data: e }, t, r) => wy && e instanceof Blob ? t ? r(e) : Sm(e, r) : xy && (e instanceof ArrayBuffer || ky(e)) ? t ? r(e) : Sm(new Blob([e]), r) : r(vi[i] + (e || "")), Sm = (i, e) => {
  const t = new FileReader();
  return t.onload = function() {
    const r = t.result.split(",")[1];
    e("b" + (r || ""));
  }, t.readAsDataURL(i);
};
function vm(i) {
  return i instanceof Uint8Array ? i : i instanceof ArrayBuffer ? new Uint8Array(i) : new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
}
let ih;
function kq(i, e) {
  if (wy && i.data instanceof Blob)
    return i.data.arrayBuffer().then(vm).then(e);
  if (xy && (i.data instanceof ArrayBuffer || ky(i.data)))
    return e(vm(i.data));
  Sd(i, !1, (t) => {
    ih || (ih = new TextEncoder()), e(ih.encode(t));
  });
}
const _m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Js = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let i = 0; i < _m.length; i++)
  Js[_m.charCodeAt(i)] = i;
const Cq = (i) => {
  let e = i.length * 0.75, t = i.length, r, s = 0, n, o, a, l;
  i[i.length - 1] === "=" && (e--, i[i.length - 2] === "=" && e--);
  const c = new ArrayBuffer(e), h = new Uint8Array(c);
  for (r = 0; r < t; r += 4)
    n = Js[i.charCodeAt(r)], o = Js[i.charCodeAt(r + 1)], a = Js[i.charCodeAt(r + 2)], l = Js[i.charCodeAt(r + 3)], h[s++] = n << 2 | o >> 4, h[s++] = (o & 15) << 4 | a >> 2, h[s++] = (a & 3) << 6 | l & 63;
  return c;
}, Qq = typeof ArrayBuffer == "function", vd = (i, e) => {
  if (typeof i != "string")
    return {
      type: "message",
      data: Cy(i, e)
    };
  const t = i.charAt(0);
  return t === "b" ? {
    type: "message",
    data: Pq(i.substring(1), e)
  } : va[t] ? i.length > 1 ? {
    type: va[t],
    data: i.substring(1)
  } : {
    type: va[t]
  } : Uu;
}, Pq = (i, e) => {
  if (Qq) {
    const t = Cq(i);
    return Cy(t, e);
  } else
    return { base64: !0, data: i };
}, Cy = (i, e) => {
  switch (e) {
    case "blob":
      return i instanceof Blob ? i : new Blob([i]);
    case "arraybuffer":
    default:
      return i instanceof ArrayBuffer ? i : i.buffer;
  }
}, Qy = "", Tq = (i, e) => {
  const t = i.length, r = new Array(t);
  let s = 0;
  i.forEach((n, o) => {
    Sd(n, !1, (a) => {
      r[o] = a, ++s === t && e(r.join(Qy));
    });
  });
}, $q = (i, e) => {
  const t = i.split(Qy), r = [];
  for (let s = 0; s < t.length; s++) {
    const n = vd(t[s], e);
    if (r.push(n), n.type === "error")
      break;
  }
  return r;
};
function Rq() {
  return new TransformStream({
    transform(i, e) {
      kq(i, (t) => {
        const r = t.length;
        let s;
        if (r < 126)
          s = new Uint8Array(1), new DataView(s.buffer).setUint8(0, r);
        else if (r < 65536) {
          s = new Uint8Array(3);
          const n = new DataView(s.buffer);
          n.setUint8(0, 126), n.setUint16(1, r);
        } else {
          s = new Uint8Array(9);
          const n = new DataView(s.buffer);
          n.setUint8(0, 127), n.setBigUint64(1, BigInt(r));
        }
        i.data && typeof i.data != "string" && (s[0] |= 128), e.enqueue(s), e.enqueue(t);
      });
    }
  });
}
let rh;
function No(i) {
  return i.reduce((e, t) => e + t.length, 0);
}
function Yo(i, e) {
  if (i[0].length === e)
    return i.shift();
  const t = new Uint8Array(e);
  let r = 0;
  for (let s = 0; s < e; s++)
    t[s] = i[0][r++], r === i[0].length && (i.shift(), r = 0);
  return i.length && r < i[0].length && (i[0] = i[0].slice(r)), t;
}
function Eq(i, e) {
  rh || (rh = new TextDecoder());
  const t = [];
  let r = 0, s = -1, n = !1;
  return new TransformStream({
    transform(o, a) {
      for (t.push(o); ; ) {
        if (r === 0) {
          if (No(t) < 1)
            break;
          const l = Yo(t, 1);
          n = (l[0] & 128) === 128, s = l[0] & 127, s < 126 ? r = 3 : s === 126 ? r = 1 : r = 2;
        } else if (r === 1) {
          if (No(t) < 2)
            break;
          const l = Yo(t, 2);
          s = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), r = 3;
        } else if (r === 2) {
          if (No(t) < 8)
            break;
          const l = Yo(t, 8), c = new DataView(l.buffer, l.byteOffset, l.length), h = c.getUint32(0);
          if (h > Math.pow(2, 21) - 1) {
            a.enqueue(Uu);
            break;
          }
          s = h * Math.pow(2, 32) + c.getUint32(4), r = 3;
        } else {
          if (No(t) < s)
            break;
          const l = Yo(t, s);
          a.enqueue(vd(n ? l : rh.decode(l), e)), r = 0;
        }
        if (s === 0 || s > i) {
          a.enqueue(Uu);
          break;
        }
      }
    }
  });
}
const Py = 4;
function ze(i) {
  if (i) return Aq(i);
}
function Aq(i) {
  for (var e in ze.prototype)
    i[e] = ze.prototype[e];
  return i;
}
ze.prototype.on = ze.prototype.addEventListener = function(i, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(e), this;
};
ze.prototype.once = function(i, e) {
  function t() {
    this.off(i, t), e.apply(this, arguments);
  }
  return t.fn = e, this.on(i, t), this;
};
ze.prototype.off = ze.prototype.removeListener = ze.prototype.removeAllListeners = ze.prototype.removeEventListener = function(i, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var t = this._callbacks["$" + i];
  if (!t) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + i], this;
  for (var r, s = 0; s < t.length; s++)
    if (r = t[s], r === e || r.fn === e) {
      t.splice(s, 1);
      break;
    }
  return t.length === 0 && delete this._callbacks["$" + i], this;
};
ze.prototype.emit = function(i) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + i], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (t) {
    t = t.slice(0);
    for (var r = 0, s = t.length; r < s; ++r)
      t[r].apply(this, e);
  }
  return this;
};
ze.prototype.emitReserved = ze.prototype.emit;
ze.prototype.listeners = function(i) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + i] || [];
};
ze.prototype.hasListeners = function(i) {
  return !!this.listeners(i).length;
};
const Il = typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0), At = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), Lq = "arraybuffer";
function Ty(i, ...e) {
  return e.reduce((t, r) => (i.hasOwnProperty(r) && (t[r] = i[r]), t), {});
}
const Dq = At.setTimeout, Mq = At.clearTimeout;
function Zl(i, e) {
  e.useNativeTimers ? (i.setTimeoutFn = Dq.bind(At), i.clearTimeoutFn = Mq.bind(At)) : (i.setTimeoutFn = At.setTimeout.bind(At), i.clearTimeoutFn = At.clearTimeout.bind(At));
}
const Bq = 1.33;
function qq(i) {
  return typeof i == "string" ? Xq(i) : Math.ceil((i.byteLength || i.size) * Bq);
}
function Xq(i) {
  let e = 0, t = 0;
  for (let r = 0, s = i.length; r < s; r++)
    e = i.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4);
  return t;
}
function $y() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function Iq(i) {
  let e = "";
  for (let t in i)
    i.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(i[t]));
  return e;
}
function Zq(i) {
  let e = {}, t = i.split("&");
  for (let r = 0, s = t.length; r < s; r++) {
    let n = t[r].split("=");
    e[decodeURIComponent(n[0])] = decodeURIComponent(n[1]);
  }
  return e;
}
class Wq extends Error {
  constructor(e, t, r) {
    super(e), this.description = t, this.context = r, this.type = "TransportError";
  }
}
class _d extends ze {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(e) {
    super(), this.writable = !1, Zl(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(e, t, r) {
    return super.emitReserved("error", new Wq(e, t, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(e) {
    const t = vd(e, this.socket.binaryType);
    this.onPacket(t);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(e) {
  }
  createUri(e, t = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const t = Iq(e);
    return t.length ? "?" + t : "";
  }
}
class zq extends _d {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      this.readyState = "paused", e();
    };
    if (this._polling || !this.writable) {
      let r = 0;
      this._polling && (r++, this.once("pollComplete", function() {
        --r || t();
      })), this.writable || (r++, this.once("drain", function() {
        --r || t();
      }));
    } else
      t();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(e) {
    const t = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    $q(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(e) {
    this.writable = !1, Tq(e, (t) => {
      this.doWrite(t, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "https" : "http", t = this.query || {};
    return this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = $y()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t);
  }
}
let Ry = !1;
try {
  Ry = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Vq = Ry;
function Uq() {
}
class jq extends zq {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(e) {
    if (super(e), typeof location < "u") {
      const t = location.protocol === "https:";
      let r = location.port;
      r || (r = t ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || r !== e.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(e, t) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", t), r.on("error", (s, n) => {
      this.onError("xhr post error", s, n);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (t, r) => {
      this.onError("xhr poll error", t, r);
    }), this.pollXhr = e;
  }
}
let ls = class _a extends ze {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(e, t, r) {
    super(), this.createRequest = e, Zl(this, r), this._opts = r, this._method = r.method || "GET", this._uri = t, this._data = r.data !== void 0 ? r.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var e;
    const t = Ty(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this._opts.xd;
    const r = this._xhr = this.createRequest(t);
    try {
      r.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
          for (let s in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(s) && r.setRequestHeader(s, this._opts.extraHeaders[s]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(r), "withCredentials" in r && (r.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (r.timeout = this._opts.requestTimeout), r.onreadystatechange = () => {
        var s;
        r.readyState === 3 && ((s = this._opts.cookieJar) === null || s === void 0 || s.parseCookies(
          // @ts-ignore
          r.getResponseHeader("set-cookie")
        )), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, r.send(this._data);
    } catch (s) {
      this.setTimeoutFn(() => {
        this._onError(s);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = _a.requestsCount++, _a.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(e) {
    this.emitReserved("error", e, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(e) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = Uq, e)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete _a.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const e = this._xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
ls.requestsCount = 0;
ls.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", bm);
  else if (typeof addEventListener == "function") {
    const i = "onpagehide" in At ? "pagehide" : "unload";
    addEventListener(i, bm, !1);
  }
}
function bm() {
  for (let i in ls.requests)
    ls.requests.hasOwnProperty(i) && ls.requests[i].abort();
}
const Nq = function() {
  const i = Ey({
    xdomain: !1
  });
  return i && i.responseType !== null;
}();
class Yq extends jq {
  constructor(e) {
    super(e);
    const t = e && e.forceBase64;
    this.supportsBinary = Nq && !t;
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd }, this.opts), new ls(Ey, this.uri(), e);
  }
}
function Ey(i) {
  const e = i.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || Vq))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new At[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Ay = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Fq extends _d {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e = this.uri(), t = this.opts.protocols, r = Ay ? {} : Ty(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e, t, r);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      Sd(r, this.supportsBinary, (n) => {
        try {
          this.doWrite(r, n);
        } catch {
        }
        s && Il(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "wss" : "ws", t = this.query || {};
    return this.opts.timestampRequests && (t[this.opts.timestampParam] = $y()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t);
  }
}
const sh = At.WebSocket || At.MozWebSocket;
class Hq extends Fq {
  createSocket(e, t, r) {
    return Ay ? new sh(e, t, r) : t ? new sh(e, t) : new sh(e);
  }
  doWrite(e, t) {
    this.ws.send(t);
  }
}
class Gq extends _d {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (e) {
      return this.emitReserved("error", e);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((e) => {
        const t = Eq(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(t).getReader(), s = Rq();
        s.readable.pipeTo(e.writable), this._writer = s.writable.getWriter();
        const n = () => {
          r.read().then(({ done: a, value: l }) => {
            a || (this.onPacket(l), n());
          }).catch((a) => {
          });
        };
        n();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      this._writer.write(r).then(() => {
        s && Il(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this._transport) === null || e === void 0 || e.close();
  }
}
const Kq = {
  websocket: Hq,
  webtransport: Gq,
  polling: Yq
}, Jq = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, eX = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function ju(i) {
  if (i.length > 8e3)
    throw "URI too long";
  const e = i, t = i.indexOf("["), r = i.indexOf("]");
  t != -1 && r != -1 && (i = i.substring(0, t) + i.substring(t, r).replace(/:/g, ";") + i.substring(r, i.length));
  let s = Jq.exec(i || ""), n = {}, o = 14;
  for (; o--; )
    n[eX[o]] = s[o] || "";
  return t != -1 && r != -1 && (n.source = e, n.host = n.host.substring(1, n.host.length - 1).replace(/;/g, ":"), n.authority = n.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), n.ipv6uri = !0), n.pathNames = tX(n, n.path), n.queryKey = iX(n, n.query), n;
}
function tX(i, e) {
  const t = /\/{2,9}/g, r = e.replace(t, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function iX(i, e) {
  const t = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, n) {
    s && (t[s] = n);
  }), t;
}
const Nu = typeof addEventListener == "function" && typeof removeEventListener == "function", ba = [];
Nu && addEventListener("offline", () => {
  ba.forEach((i) => i());
}, !1);
class er extends ze {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(e, t) {
    if (super(), this.binaryType = Lq, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (t = e, e = null), e) {
      const r = ju(e);
      t.hostname = r.host, t.secure = r.protocol === "https" || r.protocol === "wss", t.port = r.port, r.query && (t.query = r.query);
    } else t.host && (t.hostname = ju(t.host).host);
    Zl(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, t.transports.forEach((r) => {
      const s = r.prototype.name;
      this.transports.push(s), this._transportsByName[s] = r;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = Zq(this.opts.query)), Nu && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, ba.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    t.EIO = Py, t.transport = e, this.id && (t.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: t,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e]);
    return new this._transportsByName[e](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e = this.opts.rememberUpgrade && er.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const t = this.createTransport(e);
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (t) => this._onClose("transport close", t));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", er.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this._onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this._getWritablePackets();
      this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let t = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const s = this.writeBuffer[r].data;
      if (s && (t += qq(s)), r > 0 && t > this._maxPayload)
        return this.writeBuffer.slice(0, r);
      t += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const e = Date.now() > this._pingTimeoutTime;
    return e && (this._pingTimeoutTime = 0, Il(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), e;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(e, t, r) {
    return this._sendPacket("message", e, t, r), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(e, t, r) {
    return this._sendPacket("message", e, t, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(e, t, r, s) {
    if (typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const n = {
      type: e,
      data: t,
      options: r
    };
    this.emitReserved("packetCreate", n), this.writeBuffer.push(n), s && this.once("flush", s), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const e = () => {
      this._onClose("forced close"), this.transport.close();
    }, t = () => {
      this.off("upgrade", t), this.off("upgradeError", t), e();
    }, r = () => {
      this.once("upgrade", t), this.once("upgradeError", t);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(e) {
    if (er.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", e), this._onClose("transport error", e);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(e, t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), Nu && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const r = ba.indexOf(this._offlineEventListener);
        r !== -1 && ba.splice(r, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
er.protocol = Py;
class rX extends er {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let e = 0; e < this._upgrades.length; e++)
        this._probe(this._upgrades[e]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(e) {
    let t = this.createTransport(e), r = !1;
    er.priorWebsocketSuccess = !1;
    const s = () => {
      r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", (u) => {
        if (!r)
          if (u.type === "pong" && u.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", t), !t)
              return;
            er.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (h(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush());
            });
          } else {
            const d = new Error("probe error");
            d.transport = t.name, this.emitReserved("upgradeError", d);
          }
      }));
    };
    function n() {
      r || (r = !0, h(), t.close(), t = null);
    }
    const o = (u) => {
      const d = new Error("probe error: " + u);
      d.transport = t.name, n(), this.emitReserved("upgradeError", d);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function c(u) {
      t && u.name !== t.name && n();
    }
    const h = () => {
      t.removeListener("open", s), t.removeListener("error", o), t.removeListener("close", a), this.off("close", l), this.off("upgrading", c);
    };
    t.once("open", s), t.once("error", o), t.once("close", a), this.once("close", l), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      r || t.open();
    }, 200) : t.open();
  }
  onHandshake(e) {
    this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(e) {
    const t = [];
    for (let r = 0; r < e.length; r++)
      ~this.transports.indexOf(e[r]) && t.push(e[r]);
    return t;
  }
}
let sX = class extends rX {
  constructor(e, t = {}) {
    const r = typeof e == "object" ? e : t;
    (!r.transports || r.transports && typeof r.transports[0] == "string") && (r.transports = (r.transports || ["polling", "websocket", "webtransport"]).map((s) => Kq[s]).filter((s) => !!s)), super(e, r);
  }
};
function nX(i, e = "", t) {
  let r = i;
  t = t || typeof location < "u" && location, i == null && (i = t.protocol + "//" + t.host), typeof i == "string" && (i.charAt(0) === "/" && (i.charAt(1) === "/" ? i = t.protocol + i : i = t.host + i), /^(https?|wss?):\/\//.test(i) || (typeof t < "u" ? i = t.protocol + "//" + i : i = "https://" + i), r = ju(i)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const n = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + n + ":" + r.port + e, r.href = r.protocol + "://" + n + (t && t.port === r.port ? "" : ":" + r.port), r;
}
const oX = typeof ArrayBuffer == "function", aX = (i) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i.buffer instanceof ArrayBuffer, Ly = Object.prototype.toString, lX = typeof Blob == "function" || typeof Blob < "u" && Ly.call(Blob) === "[object BlobConstructor]", cX = typeof File == "function" || typeof File < "u" && Ly.call(File) === "[object FileConstructor]";
function bd(i) {
  return oX && (i instanceof ArrayBuffer || aX(i)) || lX && i instanceof Blob || cX && i instanceof File;
}
function ya(i, e) {
  if (!i || typeof i != "object")
    return !1;
  if (Array.isArray(i)) {
    for (let t = 0, r = i.length; t < r; t++)
      if (ya(i[t]))
        return !0;
    return !1;
  }
  if (bd(i))
    return !0;
  if (i.toJSON && typeof i.toJSON == "function" && arguments.length === 1)
    return ya(i.toJSON(), !0);
  for (const t in i)
    if (Object.prototype.hasOwnProperty.call(i, t) && ya(i[t]))
      return !0;
  return !1;
}
function hX(i) {
  const e = [], t = i.data, r = i;
  return r.data = Yu(t, e), r.attachments = e.length, { packet: r, buffers: e };
}
function Yu(i, e) {
  if (!i)
    return i;
  if (bd(i)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(i), t;
  } else if (Array.isArray(i)) {
    const t = new Array(i.length);
    for (let r = 0; r < i.length; r++)
      t[r] = Yu(i[r], e);
    return t;
  } else if (typeof i == "object" && !(i instanceof Date)) {
    const t = {};
    for (const r in i)
      Object.prototype.hasOwnProperty.call(i, r) && (t[r] = Yu(i[r], e));
    return t;
  }
  return i;
}
function uX(i, e) {
  return i.data = Fu(i.data, e), delete i.attachments, i;
}
function Fu(i, e) {
  if (!i)
    return i;
  if (i && i._placeholder === !0) {
    if (typeof i.num == "number" && i.num >= 0 && i.num < e.length)
      return e[i.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(i))
    for (let t = 0; t < i.length; t++)
      i[t] = Fu(i[t], e);
  else if (typeof i == "object")
    for (const t in i)
      Object.prototype.hasOwnProperty.call(i, t) && (i[t] = Fu(i[t], e));
  return i;
}
const fX = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], dX = 5;
var me;
(function(i) {
  i[i.CONNECT = 0] = "CONNECT", i[i.DISCONNECT = 1] = "DISCONNECT", i[i.EVENT = 2] = "EVENT", i[i.ACK = 3] = "ACK", i[i.CONNECT_ERROR = 4] = "CONNECT_ERROR", i[i.BINARY_EVENT = 5] = "BINARY_EVENT", i[i.BINARY_ACK = 6] = "BINARY_ACK";
})(me || (me = {}));
class OX {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(e) {
    this.replacer = e;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(e) {
    return (e.type === me.EVENT || e.type === me.ACK) && ya(e) ? this.encodeAsBinary({
      type: e.type === me.EVENT ? me.BINARY_EVENT : me.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(e) {
    let t = "" + e.type;
    return (e.type === me.BINARY_EVENT || e.type === me.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(e) {
    const t = hX(e), r = this.encodeAsString(t.packet), s = t.buffers;
    return s.unshift(r), s;
  }
}
function ym(i) {
  return Object.prototype.toString.call(i) === "[object Object]";
}
class yd extends ze {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(e) {
    super(), this.reviver = e;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const r = t.type === me.BINARY_EVENT;
      r || t.type === me.BINARY_ACK ? (t.type = r ? me.EVENT : me.ACK, this.reconstructor = new pX(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
    } else if (bd(e) || e.base64)
      if (this.reconstructor)
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(e) {
    let t = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (me[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === me.BINARY_EVENT || r.type === me.BINARY_ACK) {
      const n = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; )
        ;
      const o = e.substring(n, t);
      if (o != Number(o) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(o);
    }
    if (e.charAt(t + 1) === "/") {
      const n = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); )
        ;
      r.nsp = e.substring(n, t);
    } else
      r.nsp = "/";
    const s = e.charAt(t + 1);
    if (s !== "" && Number(s) == s) {
      const n = t + 1;
      for (; ++t; ) {
        const o = e.charAt(t);
        if (o == null || Number(o) != o) {
          --t;
          break;
        }
        if (t === e.length)
          break;
      }
      r.id = Number(e.substring(n, t + 1));
    }
    if (e.charAt(++t)) {
      const n = this.tryParse(e.substr(t));
      if (yd.isPayloadValid(r.type, n))
        r.data = n;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case me.CONNECT:
        return ym(t);
      case me.DISCONNECT:
        return t === void 0;
      case me.CONNECT_ERROR:
        return typeof t == "string" || ym(t);
      case me.EVENT:
      case me.BINARY_EVENT:
        return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && fX.indexOf(t[0]) === -1);
      case me.ACK:
      case me.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class pX {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const t = uX(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const gX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: yd,
  Encoder: OX,
  get PacketType() {
    return me;
  },
  protocol: dX
}, Symbol.toStringTag, { value: "Module" }));
function zt(i, e, t) {
  return i.on(e, t), function() {
    i.off(e, t);
  };
}
const mX = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Dy extends ze {
  /**
   * `Socket` constructor.
   */
  constructor(e, t, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      zt(e, "open", this.onopen.bind(this)),
      zt(e, "packet", this.onpacket.bind(this)),
      zt(e, "error", this.onerror.bind(this)),
      zt(e, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(e, ...t) {
    var r, s, n;
    if (mX.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(t), this;
    const o = {
      type: me.EVENT,
      data: t
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") {
      const h = this.ids++, u = t.pop();
      this._registerAckCallback(h, u), o.id = h;
    }
    const a = (s = (r = this.io.engine) === null || r === void 0 ? void 0 : r.transport) === null || s === void 0 ? void 0 : s.writable, l = this.connected && !(!((n = this.io.engine) === null || n === void 0) && n._hasPingExpired());
    return this.flags.volatile && !a || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(e, t) {
    var r;
    const s = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (s === void 0) {
      this.acks[e] = t;
      return;
    }
    const n = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === e && this.sendBuffer.splice(a, 1);
      t.call(this, new Error("operation has timed out"));
    }, s), o = (...a) => {
      this.io.clearTimeoutFn(n), t.apply(this, a);
    };
    o.withError = !0, this.acks[e] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(e, ...t) {
    return new Promise((r, s) => {
      const n = (o, a) => o ? s(o) : r(a);
      n.withError = !0, t.push(n), this.emit(e, ...t);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == "function" && (t = e.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((s, ...n) => r !== this._queue[0] ? void 0 : (s !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), t && t(s)) : (this._queue.shift(), t && t(null, ...n)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const t = this._queue[0];
    t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(e) {
    this.packet({
      type: me.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(e, t) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((e) => {
      if (!this.sendBuffer.some((r) => String(r.id) === e)) {
        const r = this.acks[e];
        delete this.acks[e], r.withError && r.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case me.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case me.EVENT:
        case me.BINARY_EVENT:
          this.onevent(e);
          break;
        case me.ACK:
        case me.BINARY_ACK:
          this.onack(e);
          break;
        case me.DISCONNECT:
          this.ondisconnect();
          break;
        case me.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const r of t)
        r.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(e) {
    const t = this;
    let r = !1;
    return function(...s) {
      r || (r = !0, t.packet({
        type: me.ACK,
        id: e,
        data: s
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" && (delete this.acks[e.id], t.withError && e.data.unshift(null), t.apply(this, e.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(e, t) {
    this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: me.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(e) {
    return this.flags.compress = e, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const t = this._anyListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const r of t)
        r.apply(this, e.data);
    }
  }
}
function Ps(i) {
  i = i || {}, this.ms = i.min || 100, this.max = i.max || 1e4, this.factor = i.factor || 2, this.jitter = i.jitter > 0 && i.jitter <= 1 ? i.jitter : 0, this.attempts = 0;
}
Ps.prototype.duration = function() {
  var i = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), t = Math.floor(e * this.jitter * i);
    i = (Math.floor(e * 10) & 1) == 0 ? i - t : i + t;
  }
  return Math.min(i, this.max) | 0;
};
Ps.prototype.reset = function() {
  this.attempts = 0;
};
Ps.prototype.setMin = function(i) {
  this.ms = i;
};
Ps.prototype.setMax = function(i) {
  this.max = i;
};
Ps.prototype.setJitter = function(i) {
  this.jitter = i;
};
class Hu extends ze {
  constructor(e, t) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, Zl(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Ps({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
    const s = t.parser || gX;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new sX(this.uri, this.opts);
    const t = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const s = zt(t, "open", function() {
      r.onopen(), e && e();
    }), n = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), e ? e(a) : this.maybeReconnectOnOpen();
    }, o = zt(t, "error", n);
    if (this._timeout !== !1) {
      const a = this._timeout, l = this.setTimeoutFn(() => {
        s(), n(new Error("timeout")), t.close();
      }, a);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(s), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(e) {
    return this.open(e);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(
      zt(e, "ping", this.onping.bind(this)),
      zt(e, "data", this.ondata.bind(this)),
      zt(e, "error", this.onerror.bind(this)),
      zt(e, "close", this.onclose.bind(this)),
      // @ts-ignore
      zt(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose("parse error", t);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(e) {
    Il(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(e) {
    this.emitReserved("error", e);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(e, t) {
    let r = this.nsps[e];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new Dy(this, e, t), this.nsps[e] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const r of t)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let r = 0; r < t.length; r++)
      this.engine.write(t[r], e.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(e, t) {
    var r;
    this.cleanup(), (r = this.engine) === null || r === void 0 || r.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, t);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const js = {};
function dn(i, e) {
  typeof i == "object" && (e = i, i = void 0), e = e || {};
  const t = nX(i, e.path || "/socket.io"), r = t.source, s = t.id, n = t.path, o = js[s] && n in js[s].nsps, a = e.forceNew || e["force new connection"] || e.multiplex === !1 || o;
  let l;
  return a ? l = new Hu(r, e) : (js[s] || (js[s] = new Hu(r, e)), l = js[s]), t.query && !e.query && (e.query = t.queryKey), l.socket(t.path, e);
}
Object.assign(dn, {
  Manager: Hu,
  Socket: Dy,
  io: dn,
  connect: dn
});
var SX = /* @__PURE__ */ H('<div class="p-2 h-full"><div class="h-full focus:outline-none"tabindex=0>');
function vX(i) {
  let e;
  const [t, r] = se(), [s, n] = se(), [o, a] = se("~"), l = [];
  let c = -1, h = "";
  const u = () => {
    s()?.write(`\x1B[1;32m${o()}\x1B[0m $ `);
  }, d = (v) => {
    t()?.emit("exec", v);
  }, O = (v) => {
    const S = s();
    if (S)
      switch (v) {
        case "\r":
          S.write(`\r
`), d(h), l.push(h), c = l.length, h = "";
          break;
        case "":
          h.length > 0 && (S.write("\b \b"), h = h.slice(0, -1));
          break;
        case "\x1B[A":
          if (c > 0) {
            c--;
            const f = l[c];
            S.write("\x1B[2K\r"), u(), S.write(f), h = f;
          }
          break;
        case "\x1B[B":
          if (c < l.length - 1) {
            c++;
            const f = l[c];
            S.write("\x1B[2K\r"), u(), S.write(f), h = f;
          } else
            c = l.length, S.write("\x1B[2K\r"), u(), h = "";
          break;
        default:
          S.write(v), h += v;
      }
  };
  return Di(() => {
    const v = new yq.Terminal({
      cursorBlink: !0,
      fontFamily: "monospace",
      convertEol: !0,
      fontSize: i.fontSize ?? 12,
      theme: {
        background: "#030712"
      }
    }), S = new xq.FitAddon();
    v.loadAddon(S), n(v), v.open(e), S.fit(), window.addEventListener("resize", () => S.fit()), v.onData(O), u(), e.focus(), e.addEventListener("paste", (g) => {
      g.preventDefault();
      const m = g.clipboardData?.getData("text");
      m && v.write(m);
    }), e.addEventListener("copy", (g) => {
      const m = v.getSelection();
      m && (g.preventDefault(), g.clipboardData?.setData("text/plain", m));
    });
    const f = localStorage.getItem("token"), p = dn("http://localhost:5000/terminal", {
      auth: {
        token: `Bearer ${f}`
      }
      //withCredentials: true,
    });
    r(p), p.on("connect", () => {
      console.log("[] Terminal connected");
    }), p.on("output", (g) => {
      v.writeln(g), u();
    }), p.on("prompt", ({
      cwd: g
    }) => {
      a(g);
    }), p.on("error", (g) => {
      v.writeln(`\x1B[1;31mError:\x1B[0m ${g}`), u();
    }), ft(() => {
      window.removeEventListener("resize", () => S.fit()), p.disconnect(), v.dispose();
    });
  }), (() => {
    var v = SX(), S = v.firstChild;
    return Tr((f) => e = f, S), v;
  })();
}
var _X = /* @__PURE__ */ H('<div><button aria-label="Close Drawer"class="absolute -top-8 right-2 rounded-md p-1 cursor-alias focus:ring-2 focus:ring-indigo-500 focus:outline-none dark:focus:ring-indigo-400"><svg class="h-5 w-5"viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><path d="M6 18L18 6M6 6l12 12">'), bX = /* @__PURE__ */ H('<button class="fixed -bottom-2 right-2 p-2 z-60 shadow-lg cursor-pointer">');
function yX(i) {
  const [e, t] = se(!1), r = () => {
    switch (i.position) {
      case "left":
        return "left-0 top-0 bottom-0 h-full";
      case "right":
        return "right-0 top-0 bottom-0 h-full";
      case "bottom":
      default:
        return "bottom-0 left-0 right-0 w-full";
    }
  }, s = () => {
    switch (i.position) {
      case "left":
      case "right":
        return `width: ${i.size ?? "400px"};`;
      case "bottom":
      default:
        return `height: ${i.size ?? "300px"};`;
    }
  }, n = () => {
    switch (i.position) {
      case "left":
        return "transition-transform duration-300 transform translate-x-0";
      case "right":
        return "transition-transform duration-300 transform translate-x-0";
      case "bottom":
      default:
        return "transition-transform duration-300 transform translate-y-0";
    }
  };
  return [Z($e, {
    get when() {
      return e();
    },
    get children() {
      var o = _X(), a = o.firstChild;
      return a.$$click = () => t(!1), X(o, Z(vX, {
        get fontSize() {
          return i.fontSize;
        }
      }), null), Oe((l) => {
        var c = `fixed z-50 bg-gray-950 text-white shadow-lg mb-8 border ${r()} ${n()}`, h = `${s()}; font-size: ${i.fontSize ?? "14px"};`;
        return c !== l.e && Vt(o, l.e = c), l.t = Qa(o, h, l.t), l;
      }, {
        e: void 0,
        t: void 0
      }), o;
    }
  }), (() => {
    var o = bX();
    return o.$$click = () => t(!e()), X(o, Z(ct, {
      icon: "mdi:code-greater-than-or-equal",
      width: "1.4em",
      height: "1.4em"
    })), o;
  })()];
}
dt(["click"]);
var wX = /* @__PURE__ */ H('<div class="flex h-[calc(100vh-5rem)] min-h-0 flex-1 flex-col font-sans"><div class="flex min-h-0 min-w-0 flex-col overflow-auto relative"><div class="fixed top-12 left-0 right-0 z-10 w-full border-b border-gray-900 bg-gray-950 "><div class="flex justify-between align-center"><div><button class="flex cursor-alias items-center gap-2 px-2 py-1 text-left text-neutral-800 dark:text-neutral-200 dark:hover:text-yellow-500 text-sm uppercase tracking-widest"> File Explorer</button></div></div></div><div class="pb-4 pt-12"></div></div><div class="flex min-h-0 min-w-0 flex-col overflow-auto pt-9">');
function xX() {
  const {
    user: i,
    isAuthenticated: e
  } = to(), [t, r] = se(!1), [s, n] = se("README.md"), [o, a] = se(""), [l, c] = se(400), [h, u] = se(0), [d, O] = se(0.325), v = () => !1;
  let S, f;
  const p = () => {
  }, g = (_, b) => {
    const w = S.getBoundingClientRect();
    let x, y;
    x = _ - w.left - f.offsetWidth / 2, y = S.offsetWidth - f.offsetWidth;
    const k = x / y, $ = Math.min(Math.max(k, 0.25), 0.75);
    O($);
  }, m = async (_) => {
    try {
      r(!0);
      const b = new FormData();
      b.append("filePath", _);
      const w = await rr.post("/file/read", b);
      if (!w.data) throw new Error("Failed to load file");
      const {
        data: x
      } = w.data;
      n(_), a(x.data);
    } catch (b) {
      throw console.error(`Error loading file "${_}":`, b), new Error(`Error loading file "${_}": ${b}`);
    } finally {
      r(!1);
    }
  };
  return Di(() => {
    m(s()), ft(() => {
      window.removeEventListener("resize", p);
    });
  }), (() => {
    var _ = wX(), b = _.firstChild, w = b.firstChild, x = w.firstChild, y = x.firstChild, k = y.firstChild, $ = k.firstChild, R = w.nextSibling, T = b.nextSibling, A = S;
    return typeof A == "function" ? Tr(A, _) : S = _, X(k, Z(ct, {
      icon: "mdi:file",
      width: "22",
      height: "22"
    }), $), X(R, Z(mq, {
      onFileSelect: m
    })), X(_, Z(_q, {
      ref(M) {
        var B = f;
        typeof B == "function" ? B(M) : f = M;
      },
      get isHorizontal() {
        return v();
      },
      onResize: g
    }), T), X(T, Z(cq, {
      theme: "dark",
      get filePath() {
        return s();
      },
      get content() {
        return o();
      }
    })), X(_, Z(yX, {
      position: "bottom",
      size: "200px",
      fontSize: 12,
      resizable: !0,
      draggable: !1
    }), null), Oe((M) => {
      var B = {
        "md:flex-row": !0,
        dark: !0
      }, W = `flex: ${d()}`, z = `flex: ${1 - d()}`;
      return M.e = pn(_, B, M.e), M.t = Qa(b, W, M.t), M.a = Qa(T, z, M.a), M;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    }), _;
  })();
}
var kX = /* @__PURE__ */ H("<button>");
function en(i) {
  const [e, t] = Dm(i, ["class", "disabled", "children"]);
  return (() => {
    var r = kX();
    return rf(r, Ca({
      get class() {
        return `inline-flex items-center justify-center px-4 py-2 rounded-md text-white font-medium transition-colors
        bg-sky-600 hover:bg-sky-700 disabled:opacity-50 disabled:cursor-not-allowed
        focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2
        ${e.class || ""}`;
      },
      get disabled() {
        return e.disabled;
      }
    }, t), !1, !0), X(r, () => e.children), r;
  })();
}
var CX = /* @__PURE__ */ H('<label class="flex items-center cursor-pointer gap-2"><div class=relative><input type=checkbox class="sr-only peer"><div class="w-11 h-6 border rounded-full peer-checked:bg-gray-200 transition-colors"></div><div class="absolute top-0.5 left-0.5 w-5 h-5 bg-sky-600 rounded-full transition-transform peer-checked:translate-x-5">'), QX = /* @__PURE__ */ H("<span class=text-sm>");
function PX(i) {
  return (() => {
    var e = CX(), t = e.firstChild, r = t.firstChild;
    return X(e, (() => {
      var s = bt(() => !!i.label);
      return () => s() && (() => {
        var n = QX();
        return X(n, () => i.label), n;
      })();
    })(), t), r.addEventListener("change", (s) => i.onChange(s.currentTarget.checked)), Oe(() => r.checked = i.checked), e;
  })();
}
var TX = /* @__PURE__ */ H('<audio controls class="w-full rounded-lg shadow-lg"><source type=audio/wav>Your browser does not support the audio element.'), $X = /* @__PURE__ */ H('<div class=py-6><div class="flex justify-center"><div class="flex flex-col md:flex-row gap-6 w-full max-w-6xl p-6 "><div class="w-full md:w-2/3 space-y-4 border rounded-lg p-6"><div class="flex items-center justify-between"><h2 class="text-2xl font-bold">Generate TTS Audio</h2></div><textarea rows=4 class="w-full p-3 min-h-[160px] border rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500"placeholder="Enter your prompt here..."></textarea><div><label class="block mb-1 text-sm font-medium">Language</label><select class="w-full p-2 border rounded-md"></select></div><div class=space-y-2><label class="block font-medium">Speakers</label><div class="flex item-center justify-between"></div></div><div class="flex flex-col sm:flex-row items-center justify-between gap-2"></div></div><div class="w-full md:w-1/3 space-y-4 p-4 border rounded-lg"><h3 class="text-xl font-semibold"> About Text-to-Speech</h3><p class=text-gray-600>This interactive TTS generator transforms written prompts into human-like speech using the Google Cloud Text-to-Speech API. Customize the language, assign unique voices to multiple speakers, and preview or download the resulting audio.</p><h4 class="font-medium text-gray-800 mt-4"> Key Features</h4><ul class="list-disc pl-5 text-gray-700 space-y-1"><li>Supports over 20 languages and dialects</li><li>Custom speaker and voice assignment</li><li>Real-time playback of synthesized speech</li><li>Downloadable `.wav` audio files</li><li>Clean and responsive UI with SolidJS</li></ul><h4 class="font-medium text-gray-800 mt-4"> Language Support</h4><p class=text-gray-600>Includes locales such as English (US, IN), Japanese, Hindi, Arabic, French, and more.</p><h4 class="font-medium text-gray-800 mt-4"> Voice Profiles</h4><p class=text-gray-600>Choose from curated tones like <em>Bright</em>, <em>Smooth</em>, or enter custom voice names for more control.'), wm = /* @__PURE__ */ H("<option>"), RX = /* @__PURE__ */ H('<input type=text class="w-full p-2 border rounded-md"placeholder="Enter custom voice name">'), EX = /* @__PURE__ */ H('<div class="flex flex-col gap-2"><div class="flex items-center gap-2"><input type=text class="w-1/2 p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500"placeholder="Speaker name"><select class="w-1/2 p-2 border rounded-md">'), AX = /* @__PURE__ */ H("<p class=text-red-500>");
const LX = [{
  label: "Arabic (Egyptian)",
  code: "ar-EG"
}, {
  label: "German (Germany)",
  code: "de-DE"
}, {
  label: "English (US)",
  code: "en-US"
}, {
  label: "Spanish (US)",
  code: "es-US"
}, {
  label: "French (France)",
  code: "fr-FR"
}, {
  label: "Hindi (India)",
  code: "hi-IN"
}, {
  label: "Indonesian (Indonesia)",
  code: "id-ID"
}, {
  label: "Italian (Italy)",
  code: "it-IT"
}, {
  label: "Japanese (Japan)",
  code: "ja-JP"
}, {
  label: "Korean (Korea)",
  code: "ko-KR"
}, {
  label: "Portuguese (Brazil)",
  code: "pt-BR"
}, {
  label: "Russian (Russia)",
  code: "ru-RU"
}, {
  label: "Dutch (Netherlands)",
  code: "nl-NL"
}, {
  label: "Polish (Poland)",
  code: "pl-PL"
}, {
  label: "Thai (Thailand)",
  code: "th-TH"
}, {
  label: "Turkish (Turkey)",
  code: "tr-TR"
}, {
  label: "Vietnamese (Vietnam)",
  code: "vi-VN"
}, {
  label: "Romanian (Romania)",
  code: "ro-RO"
}, {
  label: "Ukrainian (Ukraine)",
  code: "uk-UA"
}, {
  label: "Bengali (Bangladesh)",
  code: "bn-BD"
}, {
  label: "English (India)",
  code: "en-IN"
}, {
  label: "Marathi (India)",
  code: "mr-IN"
}, {
  label: "Tamil (India)",
  code: "ta-IN"
}, {
  label: "Telugu (India)",
  code: "te-IN"
}], xm = [{
  name: "Zephyr",
  tone: "Bright"
}, {
  name: "Puck",
  tone: "Upbeat"
}, {
  name: "Charon",
  tone: "Informative"
}, {
  name: "Kore",
  tone: "Firm"
}, {
  name: "Fenrir",
  tone: "Excitable"
}, {
  name: "Leda",
  tone: "Youthful"
}, {
  name: "Orus",
  tone: "Firm"
}, {
  name: "Aoede",
  tone: "Breezy"
}, {
  name: "Callirrhoe",
  tone: "Easy-going"
}, {
  name: "Autonoe",
  tone: "Bright"
}, {
  name: "Enceladus",
  tone: "Breathy"
}, {
  name: "Iapetus",
  tone: "Clear"
}, {
  name: "Umbriel",
  tone: "Easy-going"
}, {
  name: "Algieba",
  tone: "Smooth"
}, {
  name: "Despina",
  tone: "Smooth"
}, {
  name: "Erinome",
  tone: "Clear"
}, {
  name: "Algenib",
  tone: "Gravelly"
}, {
  name: "Rasalgethi",
  tone: "Informative"
}, {
  name: "Laomedeia",
  tone: "Upbeat"
}, {
  name: "Achernar",
  tone: "Soft"
}, {
  name: "Alnilam",
  tone: "Firm"
}, {
  name: "Schedar",
  tone: "Even"
}, {
  name: "Gacrux",
  tone: "Mature"
}, {
  name: "Pulcherrima",
  tone: "Forward"
}, {
  name: "Achird",
  tone: "Friendly"
}, {
  name: "Zubenelgenubi",
  tone: "Casual"
}, {
  name: "Vindemiatrix",
  tone: "Gentle"
}, {
  name: "Sadachbia",
  tone: "Lively"
}, {
  name: "Sadaltager",
  tone: "Knowledgeable"
}, {
  name: "Sulafat",
  tone: "Warm"
}];
function DX() {
  const [i, e] = se(""), [t, r] = se("en-US"), [s, n] = se("en-US"), [o, a] = se([{
    speaker: "Eddie",
    voiceName: "Kore"
  }, {
    speaker: "Marionette",
    voiceName: "Puck"
  }]), [l, c] = se(!1), [h, u] = se(), [d, O] = se(), [v, S] = se(!1), [f, p] = se(""), g = (x, y, k) => {
    const $ = [...o()];
    $[x][y] = k, a($);
  }, m = () => a([...o(), {
    speaker: "",
    voiceName: xm[0].name
  }]), _ = (x) => {
    const y = [...o()];
    y.splice(x, 1), a(y);
  }, b = async () => {
    S(!0), p(""), u(void 0), O(void 0);
    try {
      const x = await rr.post("/google-tts/generate", {
        prompt: i(),
        languageCode: s(),
        speakers: o()
      }, {
        responseType: "blob"
      });
      if (!x.data) throw new Error("Failed to generate audio");
      const y = x.data, k = URL.createObjectURL(y);
      u(k), O(y), l() && new Audio(k).play();
    } catch (x) {
      p(x.message || "Unexpected error");
    } finally {
      S(!1);
    }
  }, w = () => {
    const x = d();
    if (!x) return;
    const y = URL.createObjectURL(x), k = document.createElement("a");
    k.href = y, k.download = "tts-audio.mp3", document.body.appendChild(k), k.click(), k.remove(), URL.revokeObjectURL(y);
  };
  return (() => {
    var x = $X(), y = x.firstChild, k = y.firstChild, $ = k.firstChild, R = $.firstChild;
    R.firstChild;
    var T = R.nextSibling, A = T.nextSibling, M = A.firstChild, B = M.nextSibling, W = A.nextSibling, z = W.firstChild, Q = z.nextSibling, E = W.nextSibling;
    return X(R, Z(ct, {
      icon: "mdi:tts",
      width: "2.2em",
      height: "2.2em"
    }), null), T.$$input = (L) => e(L.currentTarget.value), B.addEventListener("change", (L) => n(L.currentTarget.value)), X(B, Z(_t, {
      each: LX,
      children: (L) => (() => {
        var D = wm();
        return X(D, () => L.label), Oe(() => D.value = L.code), D;
      })()
    })), X(W, Z(_t, {
      get each() {
        return o();
      },
      children: (L, D) => (() => {
        var U = EX(), Y = U.firstChild, ne = Y.firstChild, te = ne.nextSibling;
        return ne.$$input = (de) => g(D(), "speaker", de.currentTarget.value), te.addEventListener("change", (de) => g(D(), "voiceName", de.currentTarget.value)), X(te, Z(_t, {
          each: xm,
          children: (de) => (() => {
            var P = wm();
            return X(P, () => de.name === "Custom" ? "Custom (manual)" : `${de.name} (${de.tone})`), Oe(() => P.value = de.name), P;
          })()
        })), X(Y, Z(en, {
          onClick: () => _(D()),
          class: "px-2 py-1 text-sm",
          children: ""
        }), null), X(U, Z($e, {
          get when() {
            return L.voiceName === "Custom";
          },
          get children() {
            var de = RX();
            return de.$$input = (P) => g(D(), "voiceName", P.currentTarget.value), de;
          }
        }), null), Oe(() => ne.value = L.speaker), Oe(() => te.value = L.voiceName), U;
      })()
    }), Q), X(Q, Z(en, {
      onClick: m,
      class: "text-sm",
      children: "+ Add Speaker"
    }), null), X(Q, Z(PX, {
      label: "Autoplay",
      get checked() {
        return l();
      },
      onChange: c
    }), null), X($, Z(en, {
      class: "w-full flex items-center gap-2 px-2 py-2 uppercase tracking-widest",
      onClick: b,
      get disabled() {
        return v();
      },
      get children() {
        return [Z(ct, {
          icon: "mdi:tts",
          width: "2.2em",
          height: "2.2em"
        }), bt(() => v() ? "Generating..." : "Generate Audio")];
      }
    }), E), X($, (() => {
      var L = bt(() => !!f());
      return () => L() && (() => {
        var D = AX();
        return X(D, f), D;
      })();
    })(), E), X(E, Z($e, {
      get when() {
        return h();
      },
      get children() {
        var L = TX(), D = L.firstChild;
        return Oe(() => Ae(D, "src", h())), L;
      }
    }), null), X(E, Z($e, {
      get when() {
        return d();
      },
      get children() {
        return Z(en, {
          class: "w-full flex items-center gap-2 px-2 py-2 uppercase tracking-widest",
          onClick: w,
          get children() {
            return [Z(ct, {
              icon: "mdi:download",
              width: "2em",
              height: "2em"
            }), "Download Audio"];
          }
        });
      }
    }), null), Oe(() => T.value = i()), Oe(() => B.value = s()), x;
  })();
}
dt(["input"]);
var MX = /* @__PURE__ */ H('<div class="p-4 max-w-md mx-auto rounded shadow"><h2 class="text-xl font-bold mb-4">YouTube Audio Downloader</h2><input type=text class="w-full border p-2 mb-2"placeholder="Enter YouTube URL">'), BX = /* @__PURE__ */ H('<div class=mt-4><p>Progress: <!>%</p><div class="h-2 bg-gray-300 rounded overflow-hidden"><div class="h-full bg-blue-500">'), qX = /* @__PURE__ */ H('<div class="mt-4 text-green-600"> Download complete: <code>'), XX = /* @__PURE__ */ H('<div class="mt-4 text-red-600"> Error: ');
const dr = dn("https://board-api.duckdns.org");
function IX() {
  const [i, e] = se(""), [t, r] = se(0), [s, n] = se(""), [o, a] = se("");
  Di(() => {
    dr.on("download_progress", (c) => {
      r(c.progress);
    }), dr.on("download_complete", (c) => {
      n(c.filePath);
    }), dr.on("download_error", (c) => {
      a(c.message);
    }), ft(() => {
      dr.off("download_progress"), dr.off("download_complete"), dr.off("download_error");
    });
  });
  const l = () => {
    r(0), n(""), a(""), dr.emit("extract_audio", {
      url: i(),
      format: "mp3"
    });
  };
  return (() => {
    var c = MX(), h = c.firstChild, u = h.nextSibling;
    return u.$$input = (d) => e(d.currentTarget.value), X(c, Z(en, {
      class: "w-full flex items-center gap-2 px-2 py-2 uppercase tracking-widest",
      onClick: l,
      get children() {
        return [Z(ct, {
          icon: "mdi:download",
          width: "2.2em",
          height: "2.2em"
        }), "Download"];
      }
    }), null), X(c, (() => {
      var d = bt(() => t() > 0);
      return () => d() && (() => {
        var O = BX(), v = O.firstChild, S = v.firstChild, f = S.nextSibling;
        f.nextSibling;
        var p = v.nextSibling, g = p.firstChild;
        return X(v, () => t().toFixed(2), f), Oe((m) => (m = `${t()}%`) != null ? g.style.setProperty("width", m) : g.style.removeProperty("width")), O;
      })();
    })(), null), X(c, (() => {
      var d = bt(() => !!s());
      return () => d() && (() => {
        var O = qX(), v = O.firstChild, S = v.nextSibling;
        return X(S, s), O;
      })();
    })(), null), X(c, (() => {
      var d = bt(() => !!o());
      return () => d() && (() => {
        var O = XX();
        return O.firstChild, X(O, o, null), O;
      })();
    })(), null), Oe(() => u.value = i()), c;
  })();
}
dt(["input"]);
var ZX = /* @__PURE__ */ H('<div class="grid grid-cols-1 gap-4">'), WX = /* @__PURE__ */ H('<div class=p-4><h2 class="text-xl font-semibold mb-4">Media Gallery'), zX = /* @__PURE__ */ H('<video class="w-full h-auto rounded"controls muted><source>Your browser does not support the video tag.'), VX = /* @__PURE__ */ H("<audio class=w-full controls><source>Your browser does not support the audio tag."), UX = /* @__PURE__ */ H('<img class="w-full h-auto rounded">'), jX = /* @__PURE__ */ H("<p class=text-red-500>Unsupported file type"), NX = /* @__PURE__ */ H('<div class=p-2><p class="text-sm font-medium break-words mb-2">');
const YX = (i) => {
  const e = i.split(".").pop()?.toLowerCase();
  return e ? ["mp4", "webm", "ogg"].includes(e) ? "video" : ["mp3", "wav", "webm", "m4a"].includes(e) ? "audio" : ["jpg", "jpeg", "png", "gif", "bmp", "webp"].includes(e) ? "image" : "unknown" : "unknown";
}, FX = () => {
  const [i] = se("/file/list?directory=./downloads&recursive=true"), [e, t] = se(null);
  let r = null;
  const [s] = Gu(async () => {
    const a = (await rr.get(i())).data.map((c) => ({
      name: c.name,
      type: YX(c.name),
      url: `http://localhost:5000/api/media/${encodeURIComponent(c.name)}`
    })), l = a.map((c, h) => c.type === "video" || c.type === "audio" ? h : null).filter((c) => c !== null);
    if (l.length > 0) {
      const c = l[Math.floor(Math.random() * l.length)];
      t(c);
    }
    return a;
  }), n = () => {
    const o = s()?.map((a, l) => a.type === "video" || a.type === "audio" ? l : null).filter((a) => a !== null);
    if (o.length > 1) {
      let a;
      do
        a = o[Math.floor(Math.random() * o.length)];
      while (a === e());
      t(a);
    }
  };
  return ft(() => {
    r && r.removeEventListener("ended", n);
  }), (() => {
    var o = WX();
    return o.firstChild, X(o, Z($e, {
      get when() {
        return !s.loading;
      },
      get fallback() {
        return Z(md, {});
      },
      get children() {
        var a = ZX();
        return X(a, Z(_t, {
          get each() {
            return s();
          },
          children: (l, c) => (() => {
            var h = NX(), u = h.firstChild;
            return X(u, () => l.name), X(h, Z($e, {
              get when() {
                return l.type === "video";
              },
              get children() {
                var d = zX(), O = d.firstChild;
                return Tr((v) => {
                  c() === e() && (r = v, v.addEventListener("ended", n));
                }, d), Oe((v) => {
                  var S = c() === e(), f = l.url;
                  return S !== v.e && (d.autoplay = v.e = S), f !== v.t && Ae(O, "src", v.t = f), v;
                }, {
                  e: void 0,
                  t: void 0
                }), d;
              }
            }), null), X(h, Z($e, {
              get when() {
                return l.type === "audio";
              },
              get children() {
                var d = VX(), O = d.firstChild;
                return Tr((v) => {
                  c() === e() && (r = v, v.addEventListener("ended", n));
                }, d), Oe((v) => {
                  var S = c() === e(), f = l.url;
                  return S !== v.e && (d.autoplay = v.e = S), f !== v.t && Ae(O, "src", v.t = f), v;
                }, {
                  e: void 0,
                  t: void 0
                }), d;
              }
            }), null), X(h, Z($e, {
              get when() {
                return l.type === "image";
              },
              get children() {
                var d = UX();
                return Oe((O) => {
                  var v = l.url, S = l.name;
                  return v !== O.e && Ae(d, "src", O.e = v), S !== O.t && Ae(d, "alt", O.t = S), O;
                }, {
                  e: void 0,
                  t: void 0
                }), d;
              }
            }), null), X(h, Z($e, {
              get when() {
                return l.type === "unknown";
              },
              get children() {
                return jX();
              }
            }), null), h;
          })()
        })), a;
      }
    }), null), o;
  })();
};
var HX = /* @__PURE__ */ H('<div class=py-6><div class="flex justify-center"><div class="flex flex-col md:flex-row gap-6 w-full max-w-6xl p-6"><div class="w-full md:w-2/3 space-y-4 border rounded-lg p-6"><div class="flex items-center justify-between"><h2 class="text-2xl font-bold">Download and Extract YouTube Audio</h2></div></div><div class="w-full md:w-1/3 space-y-4 p-4 border rounded-lg"><h3 class="text-xl font-semibold"> About Audio Downloader</h3><p class=text-gray-600>This tool allows you to extract audio from YouTube videos using a custom backend powered by <code>yt-dlp</code>. Simply paste the video URL and track download progress in real-time.</p><h4 class="font-medium text-gray-800 mt-4"> Features</h4><ul class="list-disc pl-5 text-gray-700 space-y-1"><li>Supports direct YouTube audio extraction</li><li>Real-time download progress updates</li><li>MP3 format with automatic file generation</li><li>Cancelable download process</li><li>One-click download of result</li></ul><h4 class="font-medium text-gray-800 mt-4"> Privacy</h4><p class=text-gray-600>Downloads are processed server-side and stored temporarily for access. No login required.</p><h4 class="font-medium text-gray-800 mt-4"> Tech Stack</h4><p class=text-gray-600>Built with <strong>SolidJS</strong>, <strong>NestJS</strong>, <code>yt-dlp</code>, and <strong>WebSockets</strong> for fast, reactive updates.');
function GX() {
  return (() => {
    var i = HX(), e = i.firstChild, t = e.firstChild, r = t.firstChild, s = r.firstChild;
    return s.firstChild, X(s, Z(ct, {
      icon: "mdi:download",
      width: "2.2em",
      height: "2.2em"
    }), null), X(r, Z(IX, {}), null), X(r, Z(FX, {}), null), i;
  })();
}
var KX = /* @__PURE__ */ H('<button class="w-full flex items-center gap-2 justify-center p-3 text-white bg-neutral-900 rounded-md hover:bg-neutral-800 mt-4"> Sign in with Google');
const JX = "http://localhost:5000/api/auth/google/callback";
function e3() {
  const [i, e] = se("");
  return Di(() => {
    e(`${JX}`);
  }), (() => {
    var t = KX(), r = t.firstChild;
    return t.$$click = () => i() && (window.location.href = i()), X(t, Z(ct, {
      icon: "flat-color-icons:google",
      width: "20",
      height: "20"
    }), r), t;
  })();
}
dt(["click"]);
var t3 = /* @__PURE__ */ H('<button class="w-full flex gap-2 items-center justify-center p-3 text-white bg-gray-700 rounded-md hover:bg-gray-600 mt-4"> Sign in with Github');
const i3 = "https://board-api.duckdns.org/api/auth/github/callback";
function r3() {
  const [i, e] = se("");
  return Di(() => {
    e(`${i3}`);
  }), (() => {
    var t = t3(), r = t.firstChild;
    return t.$$click = () => i() && (window.location.href = i()), X(t, Z(ct, {
      icon: "mdi:github",
      width: "24",
      class: "text-gray-900",
      height: "24"
    }), r), t;
  })();
}
dt(["click"]);
var s3 = /* @__PURE__ */ H('<div class=py-16><div class="flex items-center justify-center"><div class="w-full max-w-md rounded-lg p-8 border shadow-lg"><h2 class="text-center text-2xl font-bold">Welcome Back </h2><form class="space-y-4 mt-4"><div><label class=block>Email</label><input type=email placeholder="Enter email"class="mt-1 w-full rounded-md border p-3 focus:ring-2 focus:ring-blue-500"required></div><div><label class=block>Password</label><input type=password placeholder= class="mt-1 w-full rounded-md border p-3 focus:ring-2 focus:ring-blue-500"required></div><button type=submit class="w-full rounded-md bg-sky-500 p-3 hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400">Sign In'), n3 = /* @__PURE__ */ H('<p class="text-center text-sm text-red-400">');
const o3 = () => {
  const {
    login: i
  } = to(), e = zm(), [t, r] = se(""), [s, n] = se(""), [o, a] = se(null), [l, c] = se(!1), h = async (u) => {
    u.preventDefault(), a(null), c(!0);
    try {
      await i({
        email: t(),
        password: s()
      }), e("/dashboard");
    } catch (d) {
      a(d.message || "Login failed");
    } finally {
      c(!1);
    }
  };
  return Z($e, {
    get when() {
      return !l();
    },
    get fallback() {
      return Z(md, {});
    },
    get children() {
      var u = s3(), d = u.firstChild, O = d.firstChild, v = O.firstChild, S = v.nextSibling, f = S.firstChild, p = f.firstChild, g = p.nextSibling, m = f.nextSibling, _ = m.firstChild, b = _.nextSibling;
      return X(O, (() => {
        var w = bt(() => !!o());
        return () => w() && (() => {
          var x = n3();
          return X(x, o), x;
        })();
      })(), S), S.addEventListener("submit", h), g.$$input = (w) => r(w.currentTarget.value), b.$$input = (w) => n(w.currentTarget.value), X(O, Z(e3, {}), null), X(O, Z(r3, {}), null), Oe(() => g.value = t()), Oe(() => b.value = s()), u;
    }
  });
};
dt(["input"]);
var a3 = /* @__PURE__ */ H('<div class="fixed top-10 right-10 space-y-2 z-50">'), l3 = /* @__PURE__ */ H("<div>");
function c3() {
  return (() => {
    var i = a3();
    return X(i, Z(_t, {
      get each() {
        return nq();
      },
      children: (e) => (() => {
        var t = l3();
        return X(t, () => e.message), Oe(() => Vt(t, `px-4 py-3 rounded shadow text-white animate-fade-in-out
              ${e.type === "success" && "bg-green-600"}
              ${e.type === "error" && "bg-red-600"}
              ${e.type === "info" && "bg-blue-600"}`)), t;
      })()
    })), i;
  })();
}
var h3 = /* @__PURE__ */ H("<div class=p-4>404 Not Found");
const u3 = async () => [];
function f3() {
  const i = Fy(() => import("./_...slug_-REtw2RhC.js"));
  Gu(u3);
  const e = U0();
  return Z(Jm, {
    get children() {
      return [Z(c3, {}), Z(Mx, {
        get children() {
          return [" ", Z(I1, {
            root: (t) => Z(SC, {
              get title() {
                return bn.name;
              },
              menus: cf,
              get content() {
                return Z(Ky, {
                  get children() {
                    return t.children;
                  }
                });
              }
            }),
            get children() {
              return [Z(wi, {
                path: "/",
                component: MC
              }), Z(wi, {
                path: "/docs",
                component: CC
              }), Z(wi, {
                path: "/dashboard",
                component: ZC
              }), Z(wi, {
                path: "/editor",
                component: xX
              }), Z(wi, {
                path: "/tts",
                component: DX
              }), Z(wi, {
                path: "/downloader",
                component: GX
              }), Z($e, {
                when: e,
                get children() {
                  return Z(_t, {
                    each: e,
                    children: (t) => Z(wi, {
                      path: `/docs/${t}`,
                      component: i
                    })
                  });
                }
              }), Z(wi, {
                path: "/login",
                component: () => Z(o3, {})
              }), Z(wi, {
                path: "*",
                component: () => h3()
              })];
            }
          })];
        }
      })];
    }
  });
}
const d3 = document.getElementById("app");
a1(() => Z(Jm, {
  get children() {
    return Z(f3, {});
  }
}), d3);
export {
  $e as S,
  Z as a,
  Oe as b,
  Gu as c,
  F3 as g,
  X as i,
  H as t,
  p3 as u
};
