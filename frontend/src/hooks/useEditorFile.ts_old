import { createSignal, createEffect, onCleanup } from 'solid-js';
import api from '../services/api';
import { showToast } from '../stores/toast';
import type { FileItem } from '../types/types';
import {
  editorContent,
  editorFilePath,
  editorLanguage,
  editorOriginalContent,
  editorHistory,
  editorFuture,
  editorOpenTabs,
} from '../stores/editorContent';

export function useEditorFile(
  initialPath: string = '',
  onLoadContent?: (content: string) => void,
  onSave?: () => void,
) {
  const [content, setContent] = createSignal('');
  const [currentFilePath, setCurrentFilePath] = createSignal<string>('');
  const [language, setLanguage] = createSignal('');
  const [loading, setLoading] = createSignal(false);
  const [loadingMessage, setLoadingMessage] = createSignal('');
  const [saving, setSaving] = createSignal(false);
  const [error, setError] = createSignal('');
  const [directoryFiles, setDirectoryFiles] = createSignal<FileItem[]>([]);
  const [currentDirectory, setCurrentDirectory] = createSignal<string>('');

  let activePath = '';

  const fetchFile = async (path: string): Promise<void> => {
    if (!path) return;
    setLoading(true);
    setLoadingMessage(`Loading ${path}...`);
    showToast(`Loading ${path}...`, 'info');
    activePath = path;

    try {
      const formData = new FormData();
      formData.append('filePath', path);

      const response = await api.post('/file/read', formData);
      const code = response.data?.content;
      if (!code) throw new Error('Empty file content');

      if (activePath !== path) return; // Ignore stale request

      setContent(code);
      editorContent.set(code);
      editorOriginalContent.set(code);
      editorHistory.set([]);
      editorFuture.set([]);
      setCurrentFilePath(path);
      editorFilePath.set(path);

      const lang = response.data?.language || '';
      setLanguage(lang);
      editorLanguage.set(lang);

      editorOpenTabs.set((prev) => (
        prev.includes(path) ? prev : [...prev, path]
      ));

      onLoadContent?.(code);
      showToast(`Loaded ${path}`, 'success');
    } catch (err) {
      const msg = (err as any).response?.data?.message || (err as Error).message;
      setError(msg);
      showToast(`Error: ${msg}`, 'error');
    } finally {
      setLoading(false);
      setLoadingMessage('');
    }
  };

  const fetchDirectory = async (dirPath: string) => {
    setLoading(true);
    setLoadingMessage(`Loading directory ${dirPath}...`);
    showToast(`Loading directory ${dirPath}...`, 'info');

    try {
      const query = `?directory=${encodeURIComponent(dirPath || './')}&recursive=true`;
      const response = await api.get(`/file/list${query}`);
      if (!Array.isArray(response.data)) {
        throw new Error('Invalid data format: expected array of files.');
      }

      setDirectoryFiles(response.data as FileItem[]);
      setCurrentDirectory(dirPath);
    } catch (err) {
      const msg = (err as any).response?.data?.message || (err as Error).message;
      setError(msg);
      showToast(`Error: ${msg}`, 'error');
    } finally {
      setLoading(false);
      setLoadingMessage('');
    }
  };

  const saveFile = async () => {
    setSaving(true);
    try {
      const formData = new FormData();
      formData.append('filePath', editorFilePath.get());
      formData.append('content', content());

      const response = await api.post('/file/write', formData);
      if (!response.data.success) throw new Error('Failed to save file');

      editorOriginalContent.set(content());
      showToast('File saved successfully.', 'success');
      onSave?.();
    } catch (err) {
      const msg = (err as any).response?.data?.message || (err as Error).message;
      showToast(`Error saving file: ${msg}`, 'error');
    } finally {
      setSaving(false);
    }
  };

  createEffect(() => {
    const path = initialPath || './README.md';
    fetchFile(path);
  });

  createEffect(() => {
    const val = content();
    if (editorHistory.get().at(-1) !== val) {
      editorHistory.set([...editorHistory.get(), val]);
      editorFuture.set([]);
    }
    editorContent.set(val);
  });

  onCleanup(() => {
    // Future: abort controller / cancel requests if needed
  });

  return {
    currentFilePath,
    content,
    setContent,
    language,
    loading,
    loadingMessage,
    saving,
    error,
    directoryFiles,
    currentDirectory,
    fetchFile,
    fetchDirectory,
    saveFile,
  };
}

